1
14:15:29,116 --> 14:15:32,880
对于这一章，所以这也是一个快速的章节，这完全是

2
14:15:32,880 --> 14:15:37,040
好吧，我也有这些简短的章节，真的很令人耳目一新

3
14:15:37,040 --> 14:15:41,276
嗯，现在我们已经完成了错误处理

4
14:15:41,276 --> 14:15:44,956
我们的登录视图我们还需要清理我们的注册表

5
14:15:44,956 --> 14:15:48,480
查看你可以看到我们的注册表有同样的问题

6
14:15:48,480 --> 14:15:52,640
正如本章开头的登录视图那样，我们有很多

7
14:15:52,640 --> 14:15:58,080
像开发工具这样的错误在这里记录了一些不太有用的东西，所以对于下一个

8
14:15:58,080 --> 14:16:01,916
章嗯，我们需要做的是确保

9
14:16:01,916 --> 14:16:07,596
我们已经退出了应用程序，我们可以进入注册视图

10
14:16:07,596 --> 14:16:13,040
我们可以在这里做，所以这是下一章和我们之前你需要的地方

11
14:16:13,040 --> 14:16:17,276
可以继续学习下一章的课程，所以我

12
14:16:17,276 --> 14:16:21,680
希望你喜欢这一章，我们下一章再见

13
14:16:21,680 --> 14:16:25,916
大家好，欢迎来到 Flutter 课程的第 22 章

14
14:16:25,916 --> 14:16:28,640
在前面的章节中，我们已经谈论了很多关于登录和

15
14:16:28,640 --> 14:16:33,116
注册和电子邮件验证，正如您在上一章中看到的，我们

16
14:16:33,116 --> 14:16:37,596
在我们的注册视图中仍然存在一些问题，因为当我们来到

17
14:16:37,596 --> 14:16:40,400
我们仍在做日志的错误处理

18
14:16:40,400 --> 14:16:44,000
基本上不是使用我们称为 show error 的新函数

19
14:16:44,000 --> 14:16:48,400
对话框和我们的注册视图基本上

20
14:16:48,400 --> 14:16:52,800
成功后真的不能把我们送到正确的地方

21
14:16:52,800 --> 14:16:56,956
注册您会看到我们在每个用户中都设置了电子邮件验证

22
14:16:56,956 --> 14:17:01,520
注册的人还需要在进入之前验证他或她的电子邮件

23
14:17:01,520 --> 14:17:07,116
应用程序的主用户界面，所以如果这是该应用程序的默认行为

24
14:17:07,116 --> 14:17:11,520
新注册的用户需要验证他们的电子邮件，也许这是最好的

25
14:17:11,520 --> 14:17:15,520
我们在注册后立即发送给用户

26
14:17:15,520 --> 14:17:19,200
到电子邮件验证视图，这些是我们基本上要做的事情

27
14:17:19,200 --> 14:17:23,680
将在本章中解决在寄存器视图中修复我们的日志语句

28
14:17:23,680 --> 14:17:28,080
并将用户发送到电子邮件验证视图

29
14:17:28,080 --> 14:17:31,276
之后立即将注册用户发送到电子邮件验证视图

30
14:17:31,276 --> 14:17:35,276
注册好的，这就是本章的目标

31
14:17:35,276 --> 14:17:38,560
所以你知道，我会把我的视觉工作室代码带到屏幕上，所以你

32
14:17:38,560 --> 14:17:43,116
也可以看到它 我要在右侧调出 scr cpy 让你看到

33
14:17:43,116 --> 14:17:47,360
你看到这些窗口的位置也好一点

34
14:17:47,360 --> 14:17:50,480
好吧，我们需要做的第一个任务

35
14:17:50,480 --> 14:17:55,596
这是为了确保我们在我们的

36
14:17:55,596 --> 14:17:58,720
注册视图，如果您还没有看过以前的

37
14:17:58,720 --> 14:18:02,000
这就是我们在之前讨论过的章节中所做的

38
14:18:02,000 --> 14:18:06,080
实用程序中的这个 uh 文件显示错误对话框，该对话框会增加

39
14:18:06,080 --> 14:18:09,916
窗口，以便您看得更清楚，因此此显示错误对话框是通用的

40
14:18:09,916 --> 14:18:13,596
标题显示发生错误的对话

41
14:18:13,596 --> 14:18:18,800
还有您选择的文本，让我们进入我们的注册表视图

42
14:18:18,800 --> 14:18:22,640
标题说在这里我要最小化这里的终端并摆脱

43
14:18:22,640 --> 14:18:26,400
explorer，让我们去这个弱密码和

44
14:18:26,400 --> 14:18:30,400
然后开始输入显示错误对话框，你可以看到它

45
14:18:30,400 --> 14:18:33,520
会自动导入，对不起

46
14:18:33,520 --> 14:18:37,680
它将为我们自动导入它所以让我们说显示空气对话

47
14:18:37,680 --> 14:18:40,720
上下文，我只是要在这个

48
14:18:40,720 --> 14:18:43,436
弱密码的情况 um

49
14:18:43,436 --> 14:18:50,000
我们只需要说弱密码就可以了，这样部分就完成了，你也可以

50
14:18:50,000 --> 14:18:54,320
在第二个参数的末尾加一个逗号只是为了确保它是

51
14:18:54,320 --> 14:18:58,320
干净，但请记住，显示错误对话是

52
14:18:58,320 --> 14:19:02,320
是一个异步函数，所以如果你将鼠标移到它上面，你会看到

53
14:19:02,320 --> 14:19:05,916
它说未来无效，所以只需像你没有显示一样调用显示空气拨号

54
14:19:05,916 --> 14:19:09,436
您基本上只是在告诉简短的错误对话，我喜欢返回

55
14:19:09,436 --> 14:19:14,880
如果你等待它，那么你可以显示错误对话框

56
14:19:14,880 --> 14:19:19,840
完成后不要忘记等待让我们删除我们的开发

57
14:19:19,840 --> 14:19:25,360
devtools 从弱密码和 if 语句中记录

58
14:19:25,360 --> 14:19:29,276
现在我们要做的是复制

59
14:19:29,276 --> 14:19:34,240
我们在此处编写的这段代码并转到已在使用的电子邮件并显示另一个

60
14:19:34,240 --> 14:19:39,276
错误对话框在这里使用相同的确切代码，我只想说

61
14:19:39,276 --> 14:19:46,160
电子邮件已经在使用中，好吧，所以这是用于电子邮件 rna 新闻以及

62
14:19:46,160 --> 14:19:51,436
对于无效的电子邮件，我们会说无效

63
14:19:51,436 --> 14:19:54,880
如果你应该说，让我看看无效的电子邮件

64
14:19:54,880 --> 14:20:01,756
嗯，这是一个无效的电子邮件地址，对吧

65
14:20:01,756 --> 14:20:07,840
我可以看到我们还没有真正处理其他可能的异常

66
14:20:07,840 --> 14:20:11,840
发生是因为您记得在登录视图中

67
14:20:11,840 --> 14:20:17,596
我们看看处理例如其他呃

68
14:20:17,596 --> 14:20:21,756
其他可能发生的异常，例如我们在

69
14:20:21,756 --> 14:20:25,840
那里有一个 else 语句，我们还做了一个通用的 catch 语句来捕获

70
14:20:25,840 --> 14:20:29,756
任何其他不是 Firebase 身份验证异常的异常，我可以看到

71
14:20:29,756 --> 14:20:32,880
现在我们还没有在注册视图中这样做，所以让我们去处理它

72
14:20:32,880 --> 14:20:37,116
所以让我们说 else 所以在这个 else 语句中我们正在捕捉

73
14:20:37,116 --> 14:20:41,360
任何其他可能发生的firebase off异常都可以，所以我只是去

74
14:20:41,360 --> 14:20:44,320
在这里说，我只想说

75
14:20:44,320 --> 14:20:48,956
错误和美元 e 代码没关系，所以这非常

76
14:20:48,956 --> 14:20:52,720
类似于我们在登录视图中所做的

77
14:20:52,720 --> 14:20:55,276
所以我很抱歉我只能看到

78
14:20:55,276 --> 14:20:59,360
你看不到代码，因为它隐藏在标题后面，但现在你

79
14:20:59,360 --> 14:21:02,640
可以看到，所以我在这里放了一个 else 声明，然后我说

80
14:21:02,640 --> 14:21:06,720
基本上是一个重量更短的对话和电子代码所以

81
14:21:06,720 --> 14:21:11,200
如果你看的话，那就看看这个

82
14:21:11,200 --> 14:21:16,956
花括号就在这里，你现在可以看到它开始的这个紫色的

83
14:21:16,956 --> 14:21:20,640
在这里，因为这是我们开始赶上火力基地的开始

84
14:21:20,640 --> 14:21:22,880
例外和

85
14:21:22,880 --> 14:21:27,520
我们还需要做的是在这里放另一个 l 另一个 catch 语句

86
14:21:27,520 --> 14:21:33,840
捕获不是 Firebase 身份验证异常的任何其他异常

87
14:21:33,840 --> 14:21:37,360
所以我们在上一章讨论异常时已经讨论过了

88
14:21:37,360 --> 14:21:43,276
在登录视图中处理，所以我认为我不需要再次解释

89
14:21:43,276 --> 14:21:46,560
好的，所以我们在这里要做的，我们也将显示错误

90
14:21:46,560 --> 14:21:50,560
在这种情况下也可以使用对话框，但对于消息，我们只会说 e2

91
14:21:50,560 --> 14:21:54,480
字符串 好吧 类似的事情 我们在

92
14:21:54,480 --> 14:21:59,040
我们的登录视图实际上完全一样

93
14:21:59,040 --> 14:22:02,800
好的，那太好了，所以现在我们使用简短的错误对话框而不是登录

94
14:22:02,800 --> 14:22:06,160
注册视图，现在基本上我不认为我们正在使用开发

95
14:22:06,160 --> 14:22:10,320
使用 devtools 登录的工具我不在这里

96
14:22:10,320 --> 14:22:13,200
认为我们需要再这样做，这样我们才能摆脱它

97
14:22:13,200 --> 14:22:17,436
然后我们也可以摆脱devtools um

98
14:22:17,436 --> 14:22:23,040
在这里导入好的，它会看看我的笔记

99
14:22:23,040 --> 14:22:25,596
一点点只是为了确保我告诉你你所有的信息

100
14:22:25,596 --> 14:22:28,800
需要知道这很好

101
14:22:28,800 --> 14:22:32,560
嗯，既然我们已经完成了所有这些，我们还需要

102
14:22:32,560 --> 14:22:35,276
确保您可以看到后面的缓存

103
14:22:35,276 --> 14:22:40,480
每次注册我们都需要确认用户的电子邮件，就像嗯

104
14:22:40,480 --> 14:22:44,720
应用中每个新注册用户的模式

105
14:22:44,720 --> 14:22:49,916
新注册的用户不能拥有

106
14:22:49,916 --> 14:22:53,596
已经确认了他们的电子邮件，因为他们两个不去是不可能的

107
14:22:53,596 --> 14:22:57,756
一个新用户 一个新注册的用户没有他们的电子邮件地址

108
14:22:57,756 --> 14:23:02,720
在我们的系统中注册，因此在此期间未收到验证电子邮件

109
14:23:02,720 --> 14:23:05,680
这个会话所以这是我们需要的模式

110
14:23:05,680 --> 14:23:09,916
基本上可以帮助我们的用户，所以在每次成功注册后，我们就可以

111
14:23:09,916 --> 14:23:15,276
将自动将用户发送到验证电子邮件视图，如果您

112
14:23:15,276 --> 14:23:18,880
记得在前面的章节中，我们在这里有这个验证电子邮件视图

113
14:23:18,880 --> 14:23:22,800
这是它自己的有状态小部件和

114
14:23:22,800 --> 14:23:26,400
我的意思是它不一定是有状态的小部件我可以看到它不是

115
14:23:26,400 --> 14:23:30,560
做任何有状态的事情，但我们刚刚离开它，状态将保持完整的小部件

116
14:23:30,560 --> 14:23:34,880
它现在可以是这样，但我们也可以把它变成一个

117
14:23:34,880 --> 14:23:39,436
无状态小部件，如果你想，好吧

118
14:23:39,436 --> 14:23:44,320
这就是我们的用户使用注册视图所做的模式

119
14:23:44,320 --> 14:23:48,400
所以如果我们去这里注册，呃，糟糕，不，我们实际上是在

120
14:23:48,400 --> 14:23:52,640
对此感到抱歉，嗯，好吧，所以我们现在需要做的是

121
14:23:52,640 --> 14:23:56,640
因为我们要从注册视图发送用户，所以我们要发送到

122
14:23:56,640 --> 14:24:00,160
验证电子邮件视图，我们需要一个路由，如果你记得

123
14:24:00,160 --> 14:24:03,756
之前的章节我们现在在这个文件 lib 中定义我们的路由

124
14:24:03,756 --> 14:24:06,640
常量路线点镖

125
14:24:06,640 --> 14:24:11,436
我们现在已经定义了登录路由注册路由和节点路由

126
14:24:11,436 --> 14:24:15,596
那么我们需要一个新的路由来验证电子邮件视图，所以让我们继续

127
14:24:15,596 --> 14:24:19,520
标题在这里说，只需输入，然后说 cons verify

128
14:24:19,520 --> 14:24:22,956
发送电子邮件是

129
14:24:22,956 --> 14:24:28,320
斜线验证电子邮件，最后也有一个斜线

130
14:24:28,320 --> 14:24:33,276
既然我们已经定义了我们需要的路线那么请原谅我们需要

131
14:24:33,276 --> 14:24:38,000
进入我们的主要飞镖文件所以我要关闭这个文件关闭这个文件并

132
14:24:38,000 --> 14:24:44,160
然后在 Visual Studio 中的 mac 上命令 p 或在 linux 和 windows 中控制 p 和

133
14:24:44,160 --> 14:24:47,596
去 main.dart 好吧

134
14:24:47,596 --> 14:24:52,480
在您的 main.dart 中，您记得所有路线都在路线内注册

135
14:24:52,480 --> 14:24:58,080
您的材料应用程序的参数，所以让我们继续注册 um

136
14:24:58,080 --> 14:25:03,916
电子邮件验证电子邮件在这里换行，我们说上下文，我们只说 const

137
14:25:03,916 --> 14:25:08,560
验证电子邮件视图，然后注册

138
14:25:08,560 --> 14:25:12,640
在 main 函数中，好的，记住你正在做的任何事情

139
14:25:12,640 --> 14:25:17,756
当你做热时，主函数内部不会重新加载

140
14:25:17,756 --> 14:25:23,436
热重载，所以你需要在这里做一个热重启，以便那些

141
14:25:23,436 --> 14:25:26,560
为了使主要功能中的这些更改生效，所以我只是

142
14:25:26,560 --> 14:25:30,560
在这里做一个热重启好吗

143
14:25:30,560 --> 14:25:33,520
所以现在我们已经注册了

144
14:25:33,520 --> 14:25:37,680
让我们去我们的注册，现在我们已经注册了，有这么多

145
14:25:37,680 --> 14:25:40,320
注册的话我扔在那里所以我现在只想澄清一下，我们已经

146
14:25:40,320 --> 14:25:45,520
注册以验证我们在主要飞镖路线中的电子邮件路线，我们需要去

147
14:25:45,520 --> 14:25:51,116
成功后注册视图并在其中使用此验证电子邮件路由

148
14:25:51,116 --> 14:25:54,720
注册好的所以嗯

149
14:25:54,720 --> 14:25:58,800
然后让我们去我们的我要关闭这个，我要

150
14:25:58,800 --> 14:26:02,000
去注册查看

151
14:26:02,000 --> 14:26:05,276
就在这里好吧

152
14:26:05,276 --> 14:26:09,520
在这里我可以看到我们正在获取用户凭据，然后

153
14:26:09,520 --> 14:26:12,720
将其分配给此用户凭据，我们不必再这样做了，所以让我们

154
14:26:12,720 --> 14:26:15,916
只需删除我们不会实际使用的

155
14:26:15,916 --> 14:26:19,596
使用电子邮件成功创建用户后返回用户凭据和

156
14:26:19,596 --> 14:26:24,640
密码我们将自动转到下一行，因为我们有一个尝试

157
14:26:24,640 --> 14:26:28,800
并在这里捕获声明

158
14:26:28,800 --> 14:26:33,756
现在我们需要做的是，呃，我们要显示验证电子邮件

159
14:26:33,756 --> 14:26:36,720
路线可以哦

160
14:26:36,720 --> 14:26:40,720
所以让我们去我们的

161
14:26:40,720 --> 14:26:45,436
呃验证这里的电子邮件，我们要说的是导航器

162
14:26:45,436 --> 14:26:48,240
和点推

163
14:26:48,240 --> 14:26:52,800
上下文导航器，然后我们要说 push named

164
14:26:52,800 --> 14:26:56,880
你看在这种情况下我们实际上会说 push name 而不是使用

165
14:26:56,880 --> 14:27:00,080
显示推送名称的其他功能和

166
14:27:00,080 --> 14:27:03,756
删除直到，这背后的原因是

167
14:27:03,756 --> 14:27:06,800
嗯

168
14:27:06,800 --> 14:27:11,200
当用户在此处的注册页面内时

169
14:27:11,200 --> 14:27:16,000
当我们想去的时候，假设你输入了一些电子邮件

170
14:27:16,000 --> 14:27:20,320
在这里然后你输入一些密码然后你点击注册按钮或者你

171
14:27:20,320 --> 14:27:25,520
点击注册按钮，我们会将您发送到验证电子邮件页面

172
14:27:25,520 --> 14:27:28,000
我们说哦，嗯

173
14:27:28,000 --> 14:27:32,320
如果您意识到这一点，您可以在此处验证您的电子邮件等

174
14:27:32,320 --> 14:27:37,200
哦，我注册时使用了错误的电子邮件，您需要能够返回

175
14:27:37,200 --> 14:27:41,360
注册页面，以便避免发送所有这些按钮

176
14:27:41,360 --> 14:27:45,436
一个用户从一个页面到另一个页面，如果他从

177
14:27:45,436 --> 14:27:50,480
注册视图可以只推送新的呃电子邮件验证路线，所以我们

178
14:27:50,480 --> 14:27:56,160
不要用新路由替换整个路由，比如注册页面，所以

179
14:27:56,160 --> 14:27:59,200
基本上这里想要的效果是我们的注册页面会保留

180
14:27:59,200 --> 14:28:03,116
就在这里，然后我们将在上面推送验证电子邮件路由，如果

181
14:28:03,116 --> 14:28:06,400
验证电子邮件路由中的用户意识到他们做错了什么

182
14:28:06,400 --> 14:28:11,520
电子邮件地址，然后他们只需按顶部栏上的后退按钮，然后

183
14:28:11,520 --> 14:28:15,360
回到注册页面，这样就很自然了

184
14:28:15,360 --> 14:28:19,520
在屏幕之间导航的方式，这就是为什么我们使用 push named in

185
14:28:19,520 --> 14:28:23,116
这种情况没关系，所以我要说推送名称并推送

186
14:28:23,116 --> 14:28:28,000
名称，然后在名称中，我们只会说验证

187
14:28:28,000 --> 14:28:33,680
电子邮件路由哎呀，像这样验证电子邮件路由

188
14:28:33,680 --> 14:28:38,160
我会在那里做一个命令，嗯

189
14:28:38,160 --> 14:28:43,436
那么让我们确保我们可以把所有这些都付诸行动，所以我要

190
14:28:43,436 --> 14:28:47,200
热重启只是为了确保你记得我们做了

191
14:28:47,200 --> 14:28:50,560
更改我们的主要功能，因此如果您忘记进行热重启，请这样做

192
14:28:50,560 --> 14:28:55,200
现在嗯，这样您的更改实际上可以从登录视图生效，即

193
14:28:55,200 --> 14:28:59,520
用户看到的第一个视图我们将进入注册页面

194
14:28:59,520 --> 14:29:05,360
在这个注册页面中，我将注册一个新用户，所以因为

195
14:29:05,360 --> 14:29:11,040
我已经注册了我的用户，我实际上可以去 firebase 控制台所以

196
14:29:11,040 --> 14:29:16,400
让我们去控制台 firebase 我通常使用的用户已经是

197
14:29:16,400 --> 14:29:20,800
注册了这个应用程序，所以我的笔记颤动项目还可以

198
14:29:20,800 --> 14:29:25,596
让我们进行身份验证，我可以看到 pixelityab gmail.com 已经存在

199
14:29:25,596 --> 14:29:29,040
注册所以我要在这里注册一个新用户我要说

200
14:29:29,040 --> 14:29:33,436
van.mp 和密码是 foobarbaz 我只是

201
14:29:33,436 --> 14:29:37,916
将选择这里，请不要在生产中使用此密码

202
14:29:37,916 --> 14:29:42,640
你的帐户在任何地方这只是一个坏主意，我正在使用 fubar bass

203
14:29:42,640 --> 14:29:47,360
共识一致性，并且为了这个项目的简单性，所以

204
14:29:47,360 --> 14:29:51,840
因为对我来说，输入和写下所有密码要容易得多

205
14:29:51,840 --> 14:29:54,720
一遍又一遍地使用fullbarbass，但这不是一个好

206
14:29:54,720 --> 14:29:58,160
密码，所以我想只是为了说明这一点

207
14:29:58,160 --> 14:30:02,800
嗯，现在我要注册这个用户，现在你可以看到

208
14:30:02,800 --> 14:30:06,560
成功注册后，现在我们将在此验证电子邮件中结束

209
14:30:06,560 --> 14:30:11,360
屏幕，这真的很好，但是

210
14:30:11,360 --> 14:30:15,200
有一种方法可以让这件事变得更好，让我们去这里的火力基地

211
14:30:15,200 --> 14:30:19,596
我现在可以看到用户已经在这里注册了，你看，它有一个

212
14:30:19,596 --> 14:30:23,916
用户 ID，这是最后一次登录日期

213
14:30:23,916 --> 14:30:27,756
所以我们怎样才能让这变得更好你看

214
14:30:27,756 --> 14:30:32,800
如果这是用户在注册时的自然流程

215
14:30:32,800 --> 14:30:38,640
页面或注册视图，它们总是出现在验证电子邮件页面中

216
14:30:38,640 --> 14:30:42,640
我们可以让它变得更好的方法是嗯

217
14:30:42,640 --> 14:30:47,840
在我们推送之前成功注册

218
14:30:47,840 --> 14:30:51,916
验证屏幕上的电子邮件视图

219
14:30:51,916 --> 14:30:56,800
是我们实际上向该用户发送了一封验证电子邮件，否则

220
14:30:56,800 --> 14:30:59,916
你正在创建什么你正在为用户创建一个他们必须做的逻辑

221
14:30:59,916 --> 14:31:04,160
采取额外的步骤来验证他们的帐户，以便他们现在来到这里

222
14:31:04,160 --> 14:31:07,596
他们必须按下另一个按钮，但如果你真的这样做了，那就太好了

223
14:31:07,596 --> 14:31:11,916
在我们进入那个屏幕之前，为他们按下那个按钮，所以

224
14:31:11,916 --> 14:31:15,360
我们实际上并不喜欢为他们点击那个按钮，但我们

225
14:31:15,360 --> 14:31:21,596
将执行与该按钮为用户执行的代码相同的代码

226
14:31:21,596 --> 14:31:26,880
所以这就是我们现在要做的，就像你的标题中所说的那样

227
14:31:26,880 --> 14:31:31,916
在导航到验证电子邮件路由之前注册视图，确保

228
14:31:31,916 --> 14:31:35,436
你基本上得到了当前用户，所以你说

229
14:31:35,436 --> 14:31:42,956
我相信最终用户是firebase off instance，当前用户还可以

230
14:31:42,956 --> 14:31:46,720
获取您的用户，然后在此处

231
14:31:46,720 --> 14:31:51,916
你会说用户 um 并且有一个叫做发送电子邮件的功能

232
14:31:51,916 --> 14:31:55,520
验证并记住您的用户是可选用户，这就是为什么您

233
14:31:55,520 --> 14:31:59,840
在这里看到这个猫王操作员有点像

234
14:31:59,840 --> 14:32:03,116
小胡子之类的 我不知道你想怎么称呼它 有些人

235
14:32:03,116 --> 14:32:08,000
如果你来自 kotlin 或者在 swift 中，你会说它是 elvis 运算符

236
14:32:08,000 --> 14:32:11,680
就像一个可选的调用，取决于你来自的语言，但是

237
14:32:11,680 --> 14:32:15,040
如果你不是 如果你不是 我有软件开发背景 那么你

238
14:32:15,040 --> 14:32:19,680
可以称之为问号，嗯，现在记住了

239
14:32:19,680 --> 14:32:23,840
所以用户是可选的，这个函数返回一个融合语音，所以你不能只是

240
14:32:23,840 --> 14:32:28,720
打电话给你，你需要等待，所以现在我们正在这样做，所以我们现在

241
14:32:28,720 --> 14:32:34,080
等着就好了，而且从现在开始我们已经改变了我们的

242
14:32:34,080 --> 14:32:37,520
成功后按下注册按钮的逻辑

243
14:32:37,520 --> 14:32:40,720
注册我们正在向您发送电子邮件验证

244
14:32:40,720 --> 14:32:44,800
最终出现在这个屏幕上并不是一个好主意，只是说请验证您的

245
14:32:44,800 --> 14:32:48,880
电子邮件地址，因为让我们面对现实吧，我们已经发送了一封电子邮件

246
14:32:48,880 --> 14:32:53,200
验证所以我们不希望用户点击我们想要的这个按钮

247
14:32:53,200 --> 14:32:56,560
用户单击此按钮或点击此按钮

248
14:32:56,560 --> 14:33:01,200
如果他们有一段时间没有收到电子邮件，那么我们不希望喜欢

249
14:33:01,200 --> 14:33:05,840
为用户发送双重电子邮件，所以这不是一个好主意

250
14:33:05,840 --> 14:33:11,360
所以，对不起，我会在这里稍微看一下我的笔记

251
14:33:11,360 --> 14:33:16,400
好的，所以我们现在需要做的是正如标题现在所说的，我们需要去

252
14:33:16,400 --> 14:33:20,480
我们的验证电子邮件视图并在顶部添加文本

253
14:33:20,480 --> 14:33:24,400
说我们已经发送了一封验证电子邮件，这只是

254
14:33:24,400 --> 14:33:28,956
常识好吧，让我们去我们的

255
14:33:28,956 --> 14:33:34,240
验证电子邮件路由，基本上是在这里验证电子邮件视图

256
14:33:34,240 --> 14:33:38,080
你可以看到我们在这里有一个专栏和第一个文本

257
14:33:38,080 --> 14:33:42,240
说请验证您的电子邮件地址，所以让我们在这里创建另一个文本

258
14:33:42,240 --> 14:33:46,800
要说缺点文本，我要说

259
14:33:46,800 --> 14:33:50,720
织你看，因为我想写这个词

260
14:33:50,720 --> 14:33:55,756
像我们一样编织，这里只有一个代码，所以我不能拥有自己的

261
14:33:55,756 --> 14:34:00,000
具有单个代码的字符串，因为 dart 不知道在哪里

262
14:34:00,000 --> 14:34:04,240
这就是这个字符串，因为它认为这是一个从这里开始的字符串

263
14:34:04,240 --> 14:34:08,480
它在这里结束，但是为了有单引号，这个是什么

264
14:34:08,480 --> 14:34:11,756
在你的黑暗弦里，那么你将不得不

265
14:34:11,756 --> 14:34:16,080
封装或基本上将您的字符串放在 double 中

266
14:34:16,080 --> 14:34:20,796
引号，这样你就可以避免这种混淆，所以我们可以说我们已经

267
14:34:20,796 --> 14:34:26,320
请给您发送电子邮件验证

268
14:34:26,320 --> 14:34:30,956
请按顺序打开

269
14:34:30,956 --> 14:34:34,880
验证你的是的，所以请打开它来验证你的

270
14:34:34,880 --> 14:34:37,040
呃帐户

271
14:34:37,040 --> 14:34:41,360
像这样的好，还有这个文本，那么我们需要

272
14:34:41,360 --> 14:34:44,400
也改变它，因为你看到我们不希望这个文本有点像

273
14:34:44,400 --> 14:34:48,320
一个号召性用语说你好就像这里我们说我们给你发了一个

274
14:34:48,320 --> 14:34:51,116
电子邮件验证请再次打开验证器，然后立即打开

275
14:34:51,116 --> 14:34:54,956
我们说，嘿，点击这个按钮，所以这不是一个好主意，让我们改变一下

276
14:34:54,956 --> 14:34:58,480
这段文字并说如果你还没有

277
14:34:58,480 --> 14:35:03,040
让我们把这个双引号和以前的故事一样

278
14:35:03,040 --> 14:35:06,796
如果您没有收到验证

279
14:35:06,796 --> 14:35:09,200
电子邮件

280
14:35:09,200 --> 14:35:14,560
按下下面这样的按钮

281
14:35:14,560 --> 14:35:18,796
好的，所以我要按 command ，现在您可以看到这些文本

282
14:35:18,796 --> 14:35:21,520
显示在屏幕上，老实说，它们不是很漂亮

283
14:35:21,520 --> 14:35:26,720
片刻，但这也没关系，所以嗯，这不是问题，让它像

284
14:35:26,720 --> 14:35:31,276
没关系，所以我们正在显示该文本

285
14:35:31,276 --> 14:35:35,040
呃给用户，我们现在需要做什么

286
14:35:35,040 --> 14:35:41,040
是基本上再次测试整个呃流程只是为了确保

287
14:35:41,040 --> 14:35:45,276
是的，它按预期工作，所以为了做到这一点，去你的火力基地

288
14:35:45,276 --> 14:35:48,640
再次控制台，我要调出控制台

289
14:35:48,640 --> 14:35:52,000
在这里希望你也能看到它，然后我要去那个项目

290
14:35:52,000 --> 14:35:56,400
身份验证和这个用户我要删除这个用户好的删除

291
14:35:56,400 --> 14:35:59,756
好吧，那个用户走了，我要去

292
14:35:59,756 --> 14:36:04,640
现在关闭屏幕然后我们要做的就是

293
14:36:04,640 --> 14:36:10,840
热重启应用程序以清除所有状态

294
14:36:10,840 --> 14:36:14,720
嗯重新开始

295
14:36:14,720 --> 14:36:21,596
是不是没有生效我会然后呃验证电子邮件

296
14:36:21,596 --> 14:36:25,520
我可以看到没有后退按钮，感觉就像

297
14:36:25,520 --> 14:36:30,320
呃，我们最终进入了那个屏幕，因为在我们的主 dart 文件中

298
14:36:30,320 --> 14:36:34,720
让我们进入主要飞镖我相信我们实际上是在发送

299
14:36:34,720 --> 14:36:41,116
用户在这种情况下验证电子邮件视图用户firebase实例卡没问题

300
14:36:41,116 --> 14:36:44,956
所以这有点问题，因为现在我们有点像

301
14:36:44,956 --> 14:36:50,480
卡在这个 uh in this

302
14:36:50,480 --> 14:36:54,560
查看因为 firebase 作为这里的标题说它说 firebase 没有

303
14:36:54,560 --> 14:36:59,200
了解我们完全删除该用户的远程更改，但

304
14:36:59,200 --> 14:37:02,956
firebase 仍然认为该用户存在，那是因为您看到

305
14:37:02,956 --> 14:37:07,680
firebase 不能喜欢位于代码内部的客户端

306
14:37:07,680 --> 14:37:11,520
您正在开发的客户端应用程序不能经常与之交谈

307
14:37:11,520 --> 14:37:14,956
firebase 说给我最新的状态给我最新的状态

308
14:37:14,956 --> 14:37:19,916
这个用户现在在这个手机上

309
14:37:19,916 --> 14:37:24,080
是曾经与后端有连接但它的本地用户

310
14:37:24,080 --> 14:37:29,520
不再，但firebase不喜欢在本地删除这个用户所以

311
14:37:29,520 --> 14:37:33,840
所以我们需要做的最好的方法来处理这种情况是

312
14:37:33,840 --> 14:37:40,560
在我们的验证电子邮件中有点像重启呃按钮所以如果

313
14:37:40,560 --> 14:37:46,480
在这种情况下，用户喜欢的某些原因明白，嘿，我被卡住了

314
14:37:46,480 --> 14:37:50,640
我需要通过验证电子邮件离开这里 我有点想回到哪里

315
14:37:50,640 --> 14:37:56,880
我是如此，我们需要做的是在用户按下重启按钮时

316
14:37:56,880 --> 14:38:00,640
在这里，我们要注销该用户，以便 firebase

317
14:38:00,640 --> 14:38:05,360
非常了解该用户不再登录，因此我们不会最终进入

318
14:38:05,360 --> 14:38:11,680
这种情况下，电子邮件已经过验证等，我们也将发送给用户

319
14:38:11,680 --> 14:38:15,680
可以到注册视图，如您所见

320
14:38:15,680 --> 14:38:19,756
我们无法将用户送回注册视图

321
14:38:19,756 --> 14:38:25,040
我的意思是我们不能期望注册视图存在于视图中

322
14:38:25,040 --> 14:38:29,436
在这种情况下，在视图堆栈上，因为如果用户刚刚开始

323
14:38:29,436 --> 14:38:33,436
应用程序应用程序，因此他们将最终在这个未来的建设者未来

324
14:38:33,436 --> 14:38:36,480
然后builder会检查用户并说哦，你应该去验证

325
14:38:36,480 --> 14:38:40,400
电子邮件视图，在这种情况下，后面没有注册视图

326
14:38:40,400 --> 14:38:45,116
嗯验证电子邮件视图，这样在这种情况下你会看到我们不会推送，但我们会

327
14:38:45,116 --> 14:38:50,080
实际上会推送名称并删除直到但我们很快就会到达那里

328
14:38:50,080 --> 14:38:54,956
首先让我们转到您的验证电子邮件视图，然后在此之后

329
14:38:54,956 --> 14:38:58,400
文本按钮 我们要添加另一个文本按钮

330
14:38:58,400 --> 14:39:04,000
向上一点，以便您看得更清楚，让我们说一个文本按钮

331
14:39:04,000 --> 14:39:07,840
unpressed 只是现在是空的，然后为了他的孩子，我们要去

332
14:39:07,840 --> 14:39:13,756
添加一个 const 文本，只是说重新启动好

333
14:39:13,756 --> 14:39:18,880
就是这样，然后我们需要做的就是我之前提到的

334
14:39:18,880 --> 14:39:24,160
是呃，正如标题在这里解释的那样，我们需要实际登录

335
14:39:24,160 --> 14:39:28,400
用户退出所以让我们说firebase auth实例

336
14:39:28,400 --> 14:39:32,796
然后我们需要做的是退出

337
14:39:32,796 --> 14:39:38,880
好吧，记住氰基，我也相信未来是虚无，所以你需要等待

338
14:39:38,880 --> 14:39:43,276
哎呀，嗯，我只是跳过屏幕而没有

339
14:39:43,276 --> 14:39:46,480
实际上真的很想这样做，所以让我们等待它，它会给予

340
14:39:46,480 --> 14:39:51,520
你是一个错误，因为现在你未按下的功能不是异步的，所以让它异步

341
14:39:51,520 --> 14:39:55,520
之后使用 if i do command s

342
14:39:55,520 --> 14:39:58,160
现在我们将在这里看到重启按钮，但是

343
14:39:58,160 --> 14:40:00,956
这样做只是注销它实际上并没有将您发送到

344
14:40:00,956 --> 14:40:05,040
注册视图，我们会尽快处理，如标题所示

345
14:40:05,040 --> 14:40:11,680
上下文导航器我推送命名删除，直到我们将在此处发送

346
14:40:11,680 --> 14:40:16,720
用户要从我们的路线视图中记住抱歉，路线文件有

347
14:40:16,720 --> 14:40:23,116
注册路线好吧，我们去那里吧，我们去注册吧

348
14:40:23,116 --> 14:40:27,436
出来在这里，我们只保留代码原样，最后我来清理

349
14:40:27,436 --> 14:40:31,116
它上升了一点并且

350
14:40:31,116 --> 14:40:35,360
那应该很好

351
14:40:35,360 --> 14:40:40,000
好的，现在我要做一个热重启你会看到现在我们最终在这里

352
14:40:40,000 --> 14:40:43,916
并且因为它仍然是用户登录，因为我们还没有执行

353
14:40:43,916 --> 14:40:48,320
这段代码，然后我将按下重新启动按钮，你会看到

354
14:40:48,320 --> 14:40:52,240
我们最终进入注册视图只是为了确保我们不会去

355
14:40:52,240 --> 14:40:55,116
再次陷入这个恶性循环，每次我们

356
14:40:55,116 --> 14:40:58,956
做一个热重启，我们将在验证电子邮件视图中结束

357
14:40:58,956 --> 14:41:03,436
现在让我们做一个热重启来看看应用程序的状态是什么

358
14:41:03,436 --> 14:41:08,320
将是，正如您在热重启时看到的那样，我们最终进入登录视图

359
14:41:08,320 --> 14:41:13,916
这意味着未来构建器中的主要 dart 文件转到此代码

360
14:41:13,916 --> 14:41:18,320
所以用户现在是空的，这正是我们想要的，因为我们

361
14:41:18,320 --> 14:41:22,720
签出当前用户没问题

362
14:41:22,720 --> 14:41:27,916
好的，然后我们将使用相同的凭据来 um

363
14:41:27,916 --> 14:41:30,880
像以前一样注册让我们去注册视图然后我要去

364
14:41:30,880 --> 14:41:36,160
说 round.np np gmail.com 然后 fubarbas

365
14:41:36,160 --> 14:41:41,116
然后我要注册这个用户，你可以看到它说它给你发了一个

366
14:41:41,116 --> 14:41:44,640
电子邮件验证请打开它进行验证，我可以在我的第三个屏幕上看到

367
14:41:44,640 --> 14:41:50,080
在这里，我实际上得到了电子邮件验证

368
14:41:50,080 --> 14:41:52,480
正如你在标题中看到的那样

369
14:41:52,480 --> 14:41:57,596
收到确认电子邮件，但尚未确认，因为我们有点需要

370
14:41:57,596 --> 14:42:00,956
看看我们在应用程序中遇到的问题

371
14:42:00,956 --> 14:42:06,480
嗯，现在让我们看看我们是否可以登录，那又如何

372
14:42:06,480 --> 14:42:10,480
我要做的是从验证返回屏幕

373
14:42:10,480 --> 14:42:14,560
电子邮件返回注册视图，而不是再次进行注册

374
14:42:14,560 --> 14:42:18,480
到登录视图现在使用你当前的呃

375
14:42:18,480 --> 14:42:22,720
喜欢您刚刚创建但尚未确认电子邮件使用的新用户

376
14:42:22,720 --> 14:42:28,956
该用户的凭据并说 gmail.com 和 foobar 作为

377
14:42:28,956 --> 14:42:33,596
然后按下登录按钮，您将看到现在我们已经进入

378
14:42:33,596 --> 14:42:38,720
应用程序的主用户界面，这是有问题的，因为

379
14:42:38,720 --> 14:42:43,200
任何像我一样的用户都可以进入注册视图，然后他们将进入

380
14:42:43,200 --> 14:42:48,796
确认视图自动他们说好的，我收到了一封确认电子邮件，然后

381
14:42:48,796 --> 14:42:52,400
他们不确认电子邮件他们按后退按钮转到注册表

382
14:42:52,400 --> 14:42:56,000
再次查看并从注册表谷歌他们转到登录视图然后他们登录

383
14:42:56,000 --> 14:42:59,756
因为您在我们的登录视图中看到

384
14:42:59,756 --> 14:43:03,520
并在使用电子邮件签名后立即在此代码中

385
14:43:03,520 --> 14:43:08,796
密码我们没有验证用户是否确实验证了他们的电子邮件

386
14:43:08,796 --> 14:43:13,276
地址，我们只是说登录，firebase 说没问题，登录很好

387
14:43:13,276 --> 14:43:17,680
电子邮件和密码与身份验证数据库中的条目匹配，我很喜欢

388
14:43:17,680 --> 14:43:21,276
go 然后我们只是说 push to notes wrap 所以

389
14:43:21,276 --> 14:43:25,436
这是一个我们需要解决的问题

390
14:43:25,436 --> 14:43:29,116
下一章好吧，但现在我们有很多代码我

391
14:43:29,116 --> 14:43:34,640
可以看到所有文件都已更改，所以让我们提交我们的代码并将其标记为

392
14:43:34,640 --> 14:43:37,596
我们在其他章节中也在做什么

393
14:43:37,596 --> 14:43:41,200
要去终端 我要稍微改变一下屏幕布局

394
14:43:41,200 --> 14:43:44,720
你看它最好增加

395
14:43:44,720 --> 14:43:49,916
视图，因此您可以更好地看到它，并且您可以看到以前的标签是

396
14:43:49,916 --> 14:43:54,400
第 6 步。现在让我们看看我们的代码的状态，我可以看到有

397
14:43:54,400 --> 14:44:00,080
修改了很多更改，您可以随时发出命令 g apa

398
14:44:00,080 --> 14:44:04,560
我称之为gopa，它会显示你所有的变化，但我只想说

399
14:44:04,560 --> 14:44:09,520
git commit 对不起，我要说 git commit，我们说

400
14:44:09,520 --> 14:44:12,956
我们将把它作为第 7 步提交 好的

401
14:44:12,956 --> 14:44:20,080
并将这些更改推送到 github，我也将其标记为第 7 步

402
14:44:20,080 --> 14:44:26,080
所以就像第七步然后我会说 git push tags

403
14:44:26,080 --> 14:44:29,840
很好，现在就像标题所说的那样我们需要得到

404
14:44:29,840 --> 14:44:33,040
准备下一章，你可以看到它说用户需要验证

405
14:44:33,040 --> 14:44:37,040
在进入主用户界面之前发送电子邮件，因为正如我所解释的那样

406
14:44:37,040 --> 14:44:40,640
一个我们尚未解决但很容易解决的问题

407
14:44:40,640 --> 14:44:44,240
地址，你将在下一章看到，所以

408
14:44:44,240 --> 14:44:48,320
呃，我会在那里见到你，大家好，欢迎来到第 23 章

409
14:44:48,320 --> 14:44:51,756
正如你在上一章中看到的那样，我们谈到了这个 vlog 课程

410
14:44:51,756 --> 14:44:57,436
清理我们的注册流程，以便当我们点击注册或

411
14:44:57,436 --> 14:45:02,560
注册按钮我们实际上向用户发送了一封电子邮件确认，我们

412
14:45:02,560 --> 14:45:06,640
看到我们去了电子邮件确认视图，甚至在我们到达那里之前，我们

413
14:45:06,640 --> 14:45:11,360
然后在我们的收件箱中收到我们的电子邮件确认，以便一切顺利

414
14:45:11,360 --> 14:45:15,840
除了现在没有注册的用户没有验证

415
14:45:15,840 --> 14:45:20,080
他们的电子邮件帐户仍然可以在我们的应用程序的主用户界面中结束，并且

416
14:45:20,080 --> 14:45:24,160
这就是我们将在本章中解决的问题，所以

417
14:45:24,160 --> 14:45:28,320
如标题所示或标题所示

418
14:45:28,320 --> 14:45:31,520
这里我们需要做的是确保

419
14:45:31,520 --> 14:45:34,160
我们首先在继续本章之前，我们需要确保我们已经

420
14:45:34,160 --> 14:45:38,320
退出应用程序，现在你在主用户界面中

421
14:45:38,320 --> 14:45:42,640
应用程序让我们进入这里并说注销，我们正在注销结束

422
14:45:42,640 --> 14:45:46,560
在登录屏幕上我要我也要调出视觉

423
14:45:46,560 --> 14:45:52,080
工作室代码，就像我们之前留下的那样

424
14:45:52,080 --> 14:45:54,796
我们现在需要做什么 我要关门了

425
14:45:54,796 --> 14:45:59,116
除了登录视图之外的其他选项卡，对不起

426
14:45:59,116 --> 14:46:02,560
在我们用电子邮件签名后，你可以在这里看到

427
14:46:02,560 --> 14:46:07,200
密码现在我们正在将用户发送到 notes 路线，我们需要

428
14:46:07,200 --> 14:46:10,956
清理这个，所以我们需要做的就是得到

429
14:46:10,956 --> 14:46:14,560
来自 firebase 的当前用户和

430
14:46:14,560 --> 14:46:18,720
我也会调出正确的标题

431
14:46:18,720 --> 14:46:21,916
我要稍微改变一下屏幕布局

432
14:46:21,916 --> 14:46:26,320
所以你可以更好地看到代码，所以你可以看到标题说你

433
14:46:26,320 --> 14:46:30,480
在将用户发送到主 ui 之前需要添加一个 if 语句

434
14:46:30,480 --> 14:46:33,276
应用程序，并确保用户是

435
14:46:33,276 --> 14:46:36,720
验证好的所以为了做到这一点，我们还需要得到

436
14:46:36,720 --> 14:46:39,916
并发用户，所以我们可以说最终用户

437
14:46:39,916 --> 14:46:45,276
等于 firebase off instance firebase off instance

438
14:46:45,276 --> 14:46:50,080
并且当前用户还可以，因此适用于当前用户

439
14:46:50,080 --> 14:46:54,480
我们会说如果你看到的用户可选我们需要可选

440
14:46:54,480 --> 14:47:00,000
当我们在这里得到一个布尔值时访问该电子邮件验证或错误

441
14:47:00,000 --> 14:47:05,520
这将返回一个 true 或重用 false 所以在这里我们说用户的电子邮件是

442
14:47:05,520 --> 14:47:13,040
否则验证用户的电子邮件

443
14:47:13,040 --> 14:47:18,000
呃，如果我能拼写它没有验证好的

444
14:47:18,000 --> 14:47:22,320
所以现在我们有两个条件

445
14:47:22,320 --> 14:47:26,320
所以我们现在需要做的是获取我们之前的代码

446
14:47:26,320 --> 14:47:31,116
可以看到它将用户发送到应用程序的主 ui，当然

447
14:47:31,116 --> 14:47:36,880
只有当用户基本上有

448
14:47:36,880 --> 14:47:43,116
验证了他们的电子邮件地址，因此获取该代码并将其放入用户电子邮件中

449
14:47:43,116 --> 14:47:47,520
在这里验证没问题，如果用户电子邮件是

450
14:47:47,520 --> 14:47:50,720
未验证然后我们需要执行相同的代码

451
14:47:50,720 --> 14:47:55,276
但不是去节点路由，这是应用程序的主要用户界面

452
14:47:55,276 --> 14:47:59,436
如果你记得的话，我们实际上知道我们需要去验证电子邮件路线

453
14:47:59,436 --> 14:48:03,916
前面章节中的路由开始我们已经定义了验证电子邮件路由

454
14:48:03,916 --> 14:48:06,400
可以，然后呢

455
14:48:06,400 --> 14:48:11,916
让我们回到我们的登录视图，然后粘贴相同的代码，除了转到

456
14:48:11,916 --> 14:48:17,680
注释我们要去的路线并验证电子邮件路线好吗

457
14:48:17,680 --> 14:48:20,796
所以我们必须为此做的一切

458
14:48:20,796 --> 14:48:24,880
章，所以它只是一步一步地清理逻辑，好吧，那就是

459
14:48:24,880 --> 14:48:28,160
好吧有些章节会很长有些章节会很短

460
14:48:28,160 --> 14:48:32,796
实际上即使对我来说有一些较短的章节也很令人耳目一新

461
14:48:32,796 --> 14:48:38,640
嗯，现在我们需要做的是让我们来测试一下

462
14:48:38,640 --> 14:48:41,916
如您所见，我们要做的是再次删除该测试用户

463
14:48:41,916 --> 14:48:45,596
从firebase控制台再次测试整个流程，所以我要做一个

464
14:48:45,596 --> 14:48:49,840
在这里热重启，只是为了确保状态是

465
14:48:49,840 --> 14:48:54,240
完全重新启动我要调出一个firebase控制台让我们去我们的

466
14:48:54,240 --> 14:48:57,680
对我来说被称为 mynotes flatware 项目的应用程序

467
14:48:57,680 --> 14:49:01,116
我要进行身份验证并删除我创建的那个测试用户

468
14:49:01,116 --> 14:49:04,880
在这里可以删除并再次热重启只是为了

469
14:49:04,880 --> 14:49:08,480
如果那里有任何缓存，请确保缓存无效

470
14:49:08,480 --> 14:49:13,680
我们现在需要做的就是哎呀

471
14:49:13,680 --> 14:49:17,840
我们现在需要做的是再次进行类似的注册，所以我

472
14:49:17,840 --> 14:49:21,756
去这里的注册页面然后我去你输入你的

473
14:49:21,756 --> 14:49:24,480
在这里发电子邮件，我要去

474
14:49:24,480 --> 14:49:29,040
写同一个email地址通过bar bath重新注册用户

475
14:49:29,040 --> 14:49:32,796
按下注册按钮，我们就到这里了，然后我就去做

476
14:49:32,796 --> 14:49:37,276
和我们之前一样被黑了，按下后退按钮然后转到

477
14:49:37,276 --> 14:49:42,796
登录屏幕我将输入相同的凭据并说 fubar baz if

478
14:49:42,796 --> 14:49:47,596
按下登录按钮后，一切都按照我们的计划进行

479
14:49:47,596 --> 14:49:52,320
代码将在这里结束，说明用户的电子邮件未经过验证

480
14:49:52,320 --> 14:49:55,200
它将从中删除登录路由

481
14:49:55,200 --> 14:50:00,240
从堆栈中将验证电子邮件路由推送到屏幕上，这样就可以了

482
14:50:00,240 --> 14:50:03,916
这正是我们要到达的地方，你可以看到我们要去

483
14:50:03,916 --> 14:50:09,916
按照我们的计划验证电子邮件视图好吧，因为我提到这一章是

484
14:50:09,916 --> 14:50:14,080
短的，这实际上非常好，所以我们现在需要做的是

485
14:50:14,080 --> 14:50:17,200
专注于我们将在下一章中做的事情，正如你所看到的那样

486
14:50:17,200 --> 14:50:21,360
身份验证逻辑遍布 ui，我们需要为

487
14:50:21,360 --> 14:50:24,796
到目前为止，您看到的身份验证我们一直在工作

488
14:50:24,796 --> 14:50:29,040
在我们一直喜欢写的源代码中直接使用firebase

489
14:50:29,040 --> 14:50:35,276
firebase auth 代码几乎在我们的 ui 中，现在你可能认为那没关系

490
14:50:35,276 --> 14:50:38,000
我的意思是如果你不是来自

491
14:50:38,000 --> 14:50:41,756
软件开发背景你可能认为那很好，它应该是

492
14:50:41,756 --> 14:50:44,880
只要它有效，但

493
14:50:44,880 --> 14:50:48,160
软件开发行业一次又一次地向我们表明，

494
14:50:48,160 --> 14:50:53,276
说哦，如果它在工作，如果它没有坏，不要修复它

495
14:50:53,276 --> 14:50:58,240
这不是真的适用于所有情况吗，正如我们所看到的那样

496
14:50:58,240 --> 14:51:03,116
例如 log 4j uh 它正在工作，但随后有一个安全飞行，并且

497
14:51:03,116 --> 14:51:06,400
每个人都必须前往他们的代码库并修复所有内容，所以我们

498
14:51:06,400 --> 14:51:10,560
周末完全静止，所以代码有效

499
14:51:10,560 --> 14:51:15,680
但它有一个问题，在这里你有你的用户界面，所以

500
14:51:15,680 --> 14:51:20,240
代码非常高级，就像字面上用户在这里然后我们

501
14:51:20,240 --> 14:51:25,116
在这里有我们的用户界面，然后我们就有了我们编写的代码

502
14:51:25,116 --> 14:51:29,436
并且像我们的 if 语句和 firebase 一样更底层

503
14:51:29,436 --> 14:51:33,116
一直坐在这里，我们就像暴露这个firebase层

504
14:51:33,116 --> 14:51:38,400
一直到我们的 ui 层 ui 直接与

505
14:51:38,400 --> 14:51:41,436
代码太高了以至于他们不应该与

506
14:51:41,436 --> 14:51:44,796
彼此所以如果你不是来自软件

507
14:51:44,796 --> 14:51:47,520
开发背景 这对你来说可能有点陌生但是软件

508
14:51:47,520 --> 14:51:50,400
开发人员真的很喜欢确保事情是

509
14:51:50,400 --> 14:51:53,520
com喜欢他们自己的隔间

510
14:51:53,520 --> 14:51:56,480
所以我们需要做的是为了得到

511
14:51:56,480 --> 14:52:00,240
为下一章做好准备就是喝杯好咖啡或茶，因为

512
14:52:00,240 --> 14:52:02,560
下一章实际上会很长，而且会是一个

513
14:52:02,560 --> 14:52:07,596
复杂的，但我会尽我所能解释所有的概念

514
14:52:07,596 --> 14:52:11,360
只能知道下一章将是

515
14:52:11,360 --> 14:52:16,560
大一号，好吧，拿你的茶点果汁茶

516
14:52:16,560 --> 14:52:21,916
喝咖啡随便你，下一章见

517
14:52:21,916 --> 14:52:26,320
你好，欢迎来到上一章 Flutter 课程的第 24 章

518
14:52:26,320 --> 14:52:30,880
我们讨论了确保用户的电子邮件在他或她可以之前得到验证

519
14:52:30,880 --> 14:52:33,680
继续

520
14:52:33,680 --> 14:52:38,240
在用户能够转到应用程序的主用户界面之前

521
14:52:38,240 --> 14:52:43,680
嗯，我们现在要做的就是从开发我们的 ui 中退后一步

522
14:52:43,680 --> 14:52:50,240
通过创建身份验证服务和应用程序的逻辑

523
14:52:50,240 --> 14:52:53,116
所以我要为你提供一个标题

524
14:52:53,116 --> 14:52:56,480
在这里，你可以看到它说 auth provider auth service 意思是作者

525
14:52:56,480 --> 14:53:01,200
现在在关闭服务上提供抽象类

526
14:53:01,200 --> 14:53:04,640
如果我们看一下到目前为止我们创建的代码，让我来看看视觉

527
14:53:04,640 --> 14:53:08,640
工作室代码，所以你可以在屏幕上看到它，就像我在这里做的那样，嗯，我要去

528
14:53:08,640 --> 14:53:12,880
增加尺寸，以便您看得更清楚，我将提出

529
14:53:12,880 --> 14:53:17,840
应用程序也是如此，所以我们可以并排看到它

530
14:53:17,840 --> 14:53:22,160
我这里有三个屏幕，所以它很多，有点难以兼顾

531
14:53:22,160 --> 14:53:24,796
嗯，对不起

532
14:53:24,796 --> 14:53:28,400
所以我要更改屏幕布局，以便您更好地查看代码

533
14:53:28,400 --> 14:53:31,840
如果你看这里我们有我们的

534
14:53:31,840 --> 14:53:35,276
嗯三视图登录

535
14:53:35,276 --> 14:53:39,040
注册并验证电子邮件视图没问题，否则我们实际上有四个视图另一个

536
14:53:39,040 --> 14:53:44,796
一个是我们现在创建的应用程序 um 的主用户界面

537
14:53:44,796 --> 14:53:48,400
这里笔记视图对不起

538
14:53:48,400 --> 14:53:51,520
但是如果您查看登录视图，您可以看到我们正在做的事情之一

539
14:53:51,520 --> 14:53:54,240
当我们进入登录视图时立即执行的是

540
14:53:54,240 --> 14:53:56,560
嗯实际上不是立即按下

541
14:53:56,560 --> 14:54:00,956
我们正在与firebase交谈的登录按钮关闭登录我们有点像

542
14:54:00,956 --> 14:54:05,200
uh 在注册视图中与 firebase 交谈时做同样的事情

543
14:54:05,200 --> 14:54:08,160
可以看到firebase auth instance create user

544
14:54:08,160 --> 14:54:11,916
我们的验证电子邮件中也有firebase

545
14:54:11,916 --> 14:54:17,360
所以你可以在这里看到我们实际上是在导入 firebase auth firebase 所以

546
14:54:17,360 --> 14:54:21,680
如果你不喜欢如果你没有软件开发背景

547
14:54:21,680 --> 14:54:25,680
从之前你可能会认为这是很好的非常重要的火力基地，但是

548
14:54:25,680 --> 14:54:30,400
您还需要知道 firebase 有点像低级抽象

549
14:54:30,400 --> 14:54:34,400
与firebase后端对话的那个层

550
14:54:34,400 --> 14:54:38,320
并为您提供很多高级的呃

551
14:54:38,320 --> 14:54:42,080
功能，但 Firebase 级别的那些高级功能

552
14:54:42,080 --> 14:54:45,360
他们有点高水平，但如果你想想

553
14:54:45,360 --> 14:54:49,520
firebase 是我们引入的依赖项

554
14:54:49,520 --> 14:54:53,436
我们与firebase后端本身对话的应用程序是

555
14:54:53,436 --> 14:54:58,400
与我们的 ui 相比低级，所以如果你认为

556
14:54:58,400 --> 14:55:03,116
用户界面代码在这里然后我们正在做的是我们就像在这里说的是

557
14:55:03,116 --> 14:55:07,680
firebase 然后 ui 直接与 firebase 库对话

558
14:55:07,680 --> 14:55:11,756
功能和在类似软件的眼中

559
14:55:11,756 --> 14:55:14,880
开发人员已经这样做了一段时间，这不是一个好主意

560
14:55:14,880 --> 14:55:20,640
因为我们在 ui 和 firebase 之间缺少了一点层

561
14:55:20,640 --> 14:55:24,400
它从 ui 中抽象出 firebase 功能

562
14:55:24,400 --> 14:55:28,640
应用程序，正如我们之前谈到的那样

563
14:55:28,640 --> 14:55:32,640
将来您可能希望允许例如苹果登录

564
14:55:32,640 --> 14:55:38,640
或谷歌登录或使用 facebook 登录等各种登录选项和

565
14:55:38,640 --> 14:55:44,160
如果你看一下firebase的控制台，你会立即看到

566
14:55:44,160 --> 14:55:48,880
在我们启用签名的那一刻，您有多种方式来验证用户身份

567
14:55:48,880 --> 14:55:53,116
在电子邮件和密码的方法中，但您也可以添加新的

568
14:55:53,116 --> 14:55:56,796
提供者你可以看到 google facebook 和这些你可以看到

569
14:55:56,796 --> 14:56:01,200
他们被称为提供者一个新的提供者，这就是我们要做的

570
14:56:01,200 --> 14:56:06,480
我们手电筒课程的这一章也是如此

571
14:56:06,480 --> 14:56:11,040
我们将采用 firebase 并将其视为身份验证

572
14:56:11,040 --> 14:56:14,240
provider 好的，所以我们要创建一个类

573
14:56:14,240 --> 14:56:19,200
我相信我们现在正在调用 firebase auth provider

574
14:56:19,200 --> 14:56:23,520
但我们会说这个 Firebase 身份验证提供程序来自另一个类

575
14:56:23,520 --> 14:56:29,436
这就是所谓的身份验证提供者，所以我们接下来要做的就是说好的

576
14:56:29,436 --> 14:56:35,596
任何需要我们的应用程序可以使用的身份验证提供程序都应该

577
14:56:35,596 --> 14:56:40,240
具有某些功能和某些属性可以，例如

578
14:56:40,240 --> 14:56:44,240
当前的身份验证提供者应该能够返回当前用户的作者

579
14:56:44,240 --> 14:56:47,680
提供者应该能够在 um 中登录用户

580
14:56:47,680 --> 14:56:51,840
注销用户 注册用户 发送电子邮件验证，以便这些

581
14:56:51,840 --> 14:56:57,116
很少的基本功能，所以这将是我们的抽象关闭

582
14:56:57,116 --> 14:57:02,320
provider 类，然后我们将创建另一个类，我们称之为它

583
14:57:02,320 --> 14:57:06,480
将是该抽象类的具体实现，因此请考虑

584
14:57:06,480 --> 14:57:12,720
抽象类就像我们的合同一样

585
14:57:12,720 --> 14:57:16,640
所以我们说的是任何身份验证提供程序，例如 google facebook 等

586
14:57:16,640 --> 14:57:20,240
将需要符合我们在此指定的功能

587
14:57:20,240 --> 14:57:23,756
抽象类好吧，那么我们将去开发一个具体的

588
14:57:23,756 --> 14:57:27,040
该抽象类的实现，我们将其称为firebase auth

589
14:57:27,040 --> 14:57:31,436
提供者，我们实际上将真正实现我们的

590
14:57:31,436 --> 14:57:35,040
firebase 的身份验证，例如创建用户

591
14:57:35,040 --> 14:57:41,520
在该具体实现中登录用户等

592
14:57:41,520 --> 14:57:45,360
然后我们将做什么我们将创建另一个我们将调用的类

593
14:57:45,360 --> 14:57:51,596
我相信我们将其取消服务及其目标

594
14:57:51,596 --> 14:57:56,080
在这门课程中，它不会做太多它会做的事情，它只会

595
14:57:56,080 --> 14:58:01,200
采用诸如 firebase auth 提供者之类的提供者 google auth 提供者和它

596
14:58:01,200 --> 14:58:05,840
只会将该提供程序的功能暴露给外界，并且

597
14:58:05,840 --> 14:58:10,956
这样做的目的是让我们的 ui 说话

598
14:58:10,956 --> 14:58:15,596
使用该服务，并且该服务将与提供者进行对话，该提供者是

599
14:58:15,596 --> 14:58:19,436
firebase auth provider 并且该 firebase auth provider 将与 firebase 对话，所以

600
14:58:19,436 --> 14:58:23,276
我们现在有firebase ui

601
14:58:23,276 --> 14:58:27,200
但是在本章结束后我们将拥有firebase

602
14:58:27,200 --> 14:58:32,560
嗯 firebase auth provider auth service 然后是 ui 所以我们会

603
14:58:32,560 --> 14:58:38,480
中间有两层，您实际上可能正确地认为

604
14:58:38,480 --> 14:58:41,756
好吧，这是很多工作，为什么我们需要它，但是

605
14:58:41,756 --> 14:58:46,560
对我来说，如果我希望这门课程只是另一门课程，我将向您展示如何

606
14:58:46,560 --> 14:58:50,080
包括火力基地那么老实说你真的值得

607
14:58:50,080 --> 14:58:53,680
再做一门关于firebase和flutter的课程，因为有很多

608
14:58:53,680 --> 14:58:57,916
可用的课程也许不是，也许不是经过这么多细节的课程

609
14:58:57,916 --> 14:59:02,720
虽然我要去，但我仍然相信我在这里的工作不仅仅是让你成为

610
14:59:02,720 --> 14:59:07,116
开发者，但也让你成为一个优秀的开发者，你需要一些额外的东西

611
14:59:07,116 --> 14:59:10,160
步骤以使您的代码更好一点，这就是为什么您

612
14:59:10,160 --> 14:59:14,080
随着您对软件开发和工作的深入了解，您实际上会注意到

613
14:59:14,080 --> 14:59:18,240
与内部团队中的其他人一起，您目前可能不会这样做，但当

614
14:59:18,240 --> 14:59:20,956
你得到你的第一份工作软件开发人员你会明白其他

615
14:59:20,956 --> 14:59:24,320
软件开发人员实际上正在采取一些额外的步骤来使他们的

616
14:59:24,320 --> 14:59:29,200
代码更容易维护，更好维护，这就是我们要做的

617
14:59:29,200 --> 14:59:34,240
在我们的代码中好吧

618
14:59:34,240 --> 14:59:37,436
这就是我们本章的介绍

619
14:59:37,436 --> 14:59:41,756
需要做的就是嗯先想想我们是怎么处理的

620
14:59:41,756 --> 14:59:46,080
如果你看里面我的意思是在

621
14:59:46,080 --> 14:59:49,596
验证视图我们没有处理异常，因此也许是

622
14:59:49,596 --> 14:59:53,360
我们也需要做一些事情，但是如果您查看登录屏幕

623
14:59:53,360 --> 14:59:58,560
例如，我们在这里有一个 try 块，然后当它关闭 firebase

624
14:59:58,560 --> 15:00:03,756
异常我们正在处理用户没有找到错误的密码，然后如果还有什么

625
15:00:03,756 --> 15:00:07,680
碰巧我们只是说显示错误所以这里有两个

626
15:00:07,680 --> 15:00:12,840
特定错误关闭错误，我们正在处理错误的密码而用户没有

627
15:00:12,840 --> 15:00:18,320
找到，如果我们进入注册视图，您还会看到我们

628
15:00:18,320 --> 15:00:25,116
已经使用了弱密码电子邮件和无效的电子邮件

629
15:00:25,116 --> 15:00:30,400
所以这些是我们需要在我们的 um 中处理的一些例外情况

630
15:00:30,400 --> 15:00:34,956
应用程序，但现在你可以看到我们的 ui 直接进入 firebase

631
15:00:34,956 --> 15:00:40,080
auth 异常，就像导入 firebase auth 异常一样

632
15:00:40,080 --> 15:00:45,200
里面创建的让我们看看firebase off accession src interface

633
15:00:45,200 --> 15:00:49,276
它在嗯

634
15:00:49,276 --> 15:00:54,720
它在我认为可以通过 firebase auth 访问的文件之一中，所以

635
15:00:54,720 --> 15:00:59,040
如果你去火力基地，可能会导入所有异常

636
15:00:59,040 --> 15:01:04,400
我们也去这里

637
15:01:04,400 --> 15:01:08,560
所以我们的用户界面不应该真的知道任何关于火力基地的事情结束

638
15:01:08,560 --> 15:01:13,756
章节所以让我们在这里迈出第一步，让我们去创建我们的

639
15:01:13,756 --> 15:01:17,276
如您所见，lib下有一个新文件

640
15:01:17,276 --> 15:01:20,520
在名为 services auth 的文件夹下，然后关闭

641
15:01:20,520 --> 15:01:23,436
exceptions.dart 所以我现在就去做

642
15:01:23,436 --> 15:01:27,276
我要折叠这些，让我们躺下，你可以看到我们没有

643
15:01:27,276 --> 15:01:30,796
现在有 con 我们有常量实用程序和视图，所以我们没有

644
15:01:30,796 --> 15:01:34,480
任何称为服务的东西，所以让我右键单击 lib 并说新文件和你

645
15:01:34,480 --> 15:01:38,080
可以做同样的事情，在这里只需输入整个路径

646
15:01:38,080 --> 15:01:42,640
所以说服务关闭，然后我们说关闭

647
15:01:42,640 --> 15:01:45,180
exceptions.dart 好的

648
15:01:45,180 --> 15:01:50,160
[音乐] 哦，那是我们创建的新文件

649
15:01:50,160 --> 15:01:52,956
在那里，我们需要做的就是去

650
15:01:52,956 --> 15:01:58,400
定义所有这些例外，所以让我们首先说我们需要一个新的

651
15:01:58,400 --> 15:02:02,796
异常称为用户未发现异常，如果您记得用户未找到

652
15:02:02,796 --> 15:02:05,436
发现是我们在这里处理的东西你还记得吗

653
15:02:05,436 --> 15:02:09,756
登录视图中的firebase off异常，如果我们找不到该用户，我们就是

654
15:02:09,756 --> 15:02:14,956
只是显示一个错误说显示错误对话框所以让我们定义一个异常

655
15:02:14,956 --> 15:02:25,436
那我会说找不到类用户并关闭

656
15:02:25,436 --> 15:02:30,400
我要说实现异常所以这是一种典型的方式

657
15:02:30,400 --> 15:02:34,796
在您所说的应用程序中创建异常类

658
15:02:34,796 --> 15:02:38,956
这是我自己的课程，例如

659
15:02:38,956 --> 15:02:42,796
代表一个例外，这是一种很好的做法，只是说它

660
15:02:42,796 --> 15:02:46,796
实现一个现有的异常异常，您可以通过命令在此处查看

661
15:02:46,796 --> 15:02:51,436
按下它你可以看到它进入flutter bin cache core exception start

662
15:02:51,436 --> 15:02:55,116
所以默认情况下它已经被导入你不必导入任何特定的文件

663
15:02:55,116 --> 15:02:57,916
为了访问异常类

664
15:02:57,916 --> 15:03:04,320
所以你只需要实现那个类就足够了

665
15:03:04,320 --> 15:03:08,240
所以现在让我们继续执行下一个

666
15:03:08,240 --> 15:03:13,916
异常作为标题作为标题说这里错误密码关闭异常

667
15:03:13,916 --> 15:03:17,916
这也在我们的登录视图中处理

668
15:03:17,916 --> 15:03:21,596
这里密码错误所以

669
15:03:21,596 --> 15:03:27,520
我只是要去，有点像复制那个代码，在这里我只想说

670
15:03:27,520 --> 15:03:33,360
错误密码验证异常

671
15:03:33,360 --> 15:03:37,916
好吧，我们还在这里处理什么，至少在登录视图中没有别的

672
15:03:37,916 --> 15:03:41,520
所以这真的很好，所以我要关闭登录视图

673
15:03:41,520 --> 15:03:46,320
现在保存这个文件好

674
15:03:46,320 --> 15:03:50,080
所以现在让我们开始处理我们正在处理的一些异常

675
15:03:50,080 --> 15:03:53,840
我们的注册视图，让我们去注册视图，你会在这里看到

676
15:03:53,840 --> 15:03:57,680
我们正在处理的第一部分异常称为弱密码

677
15:03:57,680 --> 15:04:00,956
所以我要在这里发表评论

678
15:04:00,956 --> 15:04:04,240
在这里发表评论我要说登录异常

679
15:04:04,240 --> 15:04:08,400
并且注册异常好

680
15:04:08,400 --> 15:04:11,916
所以正如标题所说，让我们创建一个名为弱密码身份验证的类

681
15:04:11,916 --> 15:04:16,880
异常会从这里复制这段代码，我会说弱

682
15:04:16,880 --> 15:04:22,560
密码关闭异常，这是针对注册视图弱的

683
15:04:22,560 --> 15:04:27,916
密码下一个是已经在使用的电子邮件，所以这就是标题所说的

684
15:04:27,916 --> 15:04:32,640
也在这里，所以让我们去复制这个，我会说电子邮件已经在使用中

685
15:04:32,640 --> 15:04:35,596
身份验证异常

686
15:04:35,596 --> 15:04:38,880
好的，现在我们有了密码和电子邮件

687
15:04:38,880 --> 15:04:44,480
已经使用异常，让我们看看

688
15:04:44,480 --> 15:04:49,276
而且我们还有无效的电子邮件身份验证异常

689
15:04:49,276 --> 15:04:53,360
我认为我没有计划好，但我们也去实施吧

690
15:04:53,360 --> 15:05:00,796
所以让我们说无效的电子邮件作者好吧

691
15:05:00,796 --> 15:05:05,840
好吧，现在我们还需要做的是

692
15:05:05,840 --> 15:05:10,480
定义一些你记得的其他例外

693
15:05:10,480 --> 15:05:15,116
注册视图我们也有一个 else where 的情况

694
15:05:15,116 --> 15:05:18,720
我们基本上说这里发生了其他事情，这是一个例外，但有些事情

695
15:05:18,720 --> 15:05:22,880
else 可能发生了我们尚未使用此代码处理的情况，或者我们也可能

696
15:05:22,880 --> 15:05:26,880
这里有另一个 cat 语句，它可以捕获通用异常和

697
15:05:26,880 --> 15:05:31,680
我们正在做同样的事情，你可以在这里看到代码，让我

698
15:05:31,680 --> 15:05:36,000
改变屏幕布局，让你看得更清楚，我要去

699
15:05:36,000 --> 15:05:39,436
登录视图也是如此，因为我们在登录中做同样的事情

700
15:05:39,436 --> 15:05:43,680
在获得 Firebase 身份验证异常时查看

701
15:05:43,680 --> 15:05:48,240
这段代码然后我们甚至还有一个 else 语句

702
15:05:48,240 --> 15:05:53,116
在那里，所以我们说如果代码不像我们处理的那样，它可能是另一个

703
15:05:53,116 --> 15:05:58,880
在这种情况下的代码也显示显示错误对话框或在这种情况下显示错误

704
15:05:58,880 --> 15:06:02,400
对话，我们也在做一个像

705
15:06:02,400 --> 15:06:05,756
通用的 catch 也是如此，所以我们需要有点像

706
15:06:05,756 --> 15:06:08,796
处理所有这些情况的异常

707
15:06:08,796 --> 15:06:14,000
firebase off 异常期间的未知代码和未知异常，因此

708
15:06:14,000 --> 15:06:17,680
我们将创建一个通用异常

709
15:06:17,680 --> 15:06:21,040
我要稍微改变一下屏幕布局

710
15:06:21,040 --> 15:06:24,796
嗯，我就去记笔记好了

711
15:06:24,796 --> 15:06:30,160
所以让我们在这里说通用异常

712
15:06:30,160 --> 15:06:35,276
嗯，我会带来

713
15:06:35,276 --> 15:06:40,640
这个今天也上来了，我要先带这个，所以

714
15:06:40,640 --> 15:06:44,240
让我们继续创建一个通用的身份验证异常，我将从中复制此代码

715
15:06:44,240 --> 15:06:47,756
在这里我要说通用身份验证异常

716
15:06:47,756 --> 15:06:50,480
好的，我们还需要做的是

717
15:06:50,480 --> 15:06:55,040
提供这个东西用户未登录

718
15:06:55,040 --> 15:07:00,400
例外，你现在会知道

719
15:07:00,400 --> 15:07:03,276
嗯，我的意思是你需要知道我们为什么

720
15:07:03,276 --> 15:07:07,040
实际上有使用或未登录异常和

721
15:07:07,040 --> 15:07:12,640
这将是一个例外，我们的 Firebase 提供商将能够

722
15:07:12,640 --> 15:07:15,200
扔如果

723
15:07:15,200 --> 15:07:21,276
例如，在注册该用户后，该用户为空

724
15:07:21,276 --> 15:07:26,000
所以假设我们告诉我们的身份验证提供者我们说注册一个用户

725
15:07:26,000 --> 15:07:30,640
这个电子邮件和密码，没有例外什么都没有发生

726
15:07:30,640 --> 15:07:34,640
所以我们的应用程序认为一切都按预期进行，但是

727
15:07:34,640 --> 15:07:38,240
如果我们访问的用户怎么办

728
15:07:38,240 --> 15:07:42,796
在这种情况下，我们的身份验证提供程序在 firebase 身份验证为空

729
15:07:42,796 --> 15:07:46,160
应该能够处理它并发送一个异常说哦我不能

730
15:07:46,160 --> 15:07:50,720
发现此用户或此用户未登录，所以让我们创建该异常为

731
15:07:50,720 --> 15:07:55,200
好吧，所以我只想说用户未登录异常，所以让我们

732
15:07:55,200 --> 15:07:58,080
只是说类实现

733
15:07:58,080 --> 15:08:02,000
异常正常，所以用户未登录异常

734
15:08:02,000 --> 15:08:06,720
我也要保存它

735
15:08:06,720 --> 15:08:10,880
好的，这是很多工作现在我们已经创建了所有这些文件哦，对不起

736
15:08:10,880 --> 15:08:13,756
也许你实际上并没有看到我写的我不喜欢的代码

737
15:08:13,756 --> 15:08:17,360
字幕一直在增加，但我也认为字幕非常重要，所以

738
15:08:17,360 --> 15:08:20,880
你总是知道我们在做什么，但是拥有这些的缺点

739
15:08:20,880 --> 15:08:24,320
屏幕左下角的标题是有时他们隐藏了什么

740
15:08:24,320 --> 15:08:27,680
我正在打字，所以我正在尽我所能

741
15:08:27,680 --> 15:08:31,756
抓住那些并抓住那个问题，如果我看到了

742
15:08:31,756 --> 15:08:34,720
发生了，我会像这样把屏幕打开，让你看到，但是

743
15:08:34,720 --> 15:08:39,276
有时我可能会想念我为此道歉所以让我们说

744
15:08:39,276 --> 15:08:43,276
现在我们已经实现了所有的异常

745
15:08:43,276 --> 15:08:47,200
正如您在标题中看到的那样，它说我们需要一个我们不应该的身份验证用户

746
15:08:47,200 --> 15:08:51,360
将firebase的用户暴露给用户界面，老实说，这是

747
15:08:51,360 --> 15:08:58,240
与我们的异常情况相同，ui代码根本不应该工作

748
15:08:58,240 --> 15:09:03,436
使用 firebase 的 ui 代码应该非常高级，并且从

749
15:09:03,436 --> 15:09:08,400
你的应用程序的其余部分，它甚至不应该知道它是怎么回事

750
15:09:08,400 --> 15:09:11,276
运作你只是给它不同

751
15:09:11,276 --> 15:09:15,200
提供者和服务，它应该不调用这些服务和提供者

752
15:09:15,200 --> 15:09:19,840
真的知道它们是如何联系在一起的，此时您可以看到我们的登录信息

753
15:09:19,840 --> 15:09:24,160
看看它就像我们进去的地方

754
15:09:24,160 --> 15:09:29,680
你可以在登录视图中看到这里，对我来说它在第 67 行，你可能在

755
15:09:29,680 --> 15:09:33,916
不同的线路，但我们在使用电子邮件和密码调用登录后

756
15:09:33,916 --> 15:09:36,560
我们也不应该做的功能

757
15:09:36,560 --> 15:09:39,840
但在那之后我们要做的是

758
15:09:39,840 --> 15:09:44,400
从firebase获取当前用户，这个用户是你可以看到的类型

759
15:09:44,400 --> 15:09:49,916
让我们进去看看它的类型是 user 所以如果我把类型放在这里

760
15:09:49,916 --> 15:09:54,956
命令点击它你会看到这个用户是你看到的firebase auth的一部分

761
15:09:54,956 --> 15:10:01,436
有趣的是，有一个名为 user 的类，所以我们都是我们也喜欢暴露一个

762
15:10:01,436 --> 15:10:05,840
firebase 用户到我们的用户界面，这不是一个好主意

763
15:10:05,840 --> 15:10:10,880
所以正如这里的标题所说，我们不应该将 firebase 的用户暴露给 ui，所以我们

764
15:10:10,880 --> 15:10:16,480
需要有我们自己的用户来抽象出功能

765
15:10:16,480 --> 15:10:21,916
或者firebase级别的当前用户还可以

766
15:10:21,916 --> 15:10:26,240
所以让我们继续这样做吧

767
15:10:26,240 --> 15:10:32,240
我们将在 lib services auth 中创建一个非用户 dart 文件，该文件名为

768
15:10:32,240 --> 15:10:36,240
关闭用户，所以我要删除或对不起我

769
15:10:36,240 --> 15:10:39,596
将关闭我创建的所有文件

770
15:10:39,596 --> 15:10:44,560
services auth 我将创建一个关闭用户

771
15:10:44,560 --> 15:10:50,956
所以我要说关闭 user.dark 而在这个关闭用户中，我们需要

772
15:10:50,956 --> 15:10:55,520
在这种情况下基本上开始使用firebase，所以我要去我的笔记

773
15:10:55,520 --> 15:10:58,796
只是为了确保我告诉你我打算做的一切

774
15:10:58,796 --> 15:11:03,680
告诉你好吧，让我们进入这里并导入

775
15:11:03,680 --> 15:11:09,116
firebase 它是用户导入包

776
15:11:09,116 --> 15:11:13,200
火力基地，它在

777
15:11:13,200 --> 15:11:18,000
我相信firebase auth，然后我们会说显示用户还可以，就像我一样

778
15:11:18,000 --> 15:11:23,040
之前提到过，这是确保您不暴露的好方法

779
15:11:23,040 --> 15:11:28,720
太多的包类到你当前的工作空间，除了你是什么

780
15:11:28,720 --> 15:11:33,360
说的是firebase auth是不是它可能是一个完整的飞镖文件

781
15:11:33,360 --> 15:11:37,116
结构可能有数千个课程，现在我夸大了，但很多

782
15:11:37,116 --> 15:11:41,916
类，但您只对用户类感兴趣，好吧

783
15:11:41,916 --> 15:11:45,040
所以你也可以说

784
15:11:45,040 --> 15:11:48,320
作为火力基地

785
15:11:48,320 --> 15:11:52,956
像这样关闭，然后你会说显示用户，这将允许你这样做，如果

786
15:11:52,956 --> 15:11:56,000
我说测试然后你就可以说

787
15:11:56,000 --> 15:12:00,000
firebaseauth.user 你也可以这样做，如果你

788
15:12:00,000 --> 15:12:04,640
例如，更喜欢在这种情况下为来自的用户添加前缀

789
15:12:04,640 --> 15:12:09,520
firebase 以及它来自您的实际位置也可以用作

790
15:12:09,520 --> 15:12:14,160
有些人可能喜欢它，我也喜欢，但我不打算在

791
15:12:14,160 --> 15:12:18,160
这个特定的文件，如果你想这样做的话

792
15:12:18,160 --> 15:12:21,360
我在这里做，所以您可以按照我提供的步骤进行操作

793
15:12:21,360 --> 15:12:25,200
在本课程中为您服务，而不会偏离

794
15:12:25,200 --> 15:12:30,160
从现在开始好吧，我们已经完成了

795
15:12:30,160 --> 15:12:33,200
将我们需要做的事情作为标题导入

796
15:12:33,200 --> 15:12:37,596
案例我们需要创建实际的类，所以让我们说类关闭用户

797
15:12:37,596 --> 15:12:45,276
在这里，我们需要一个名为 is email verify 现在记住的字段

798
15:12:45,276 --> 15:12:49,520
现在我们需要从我们的关闭用户那里知道该电子邮件是否是

799
15:12:49,520 --> 15:12:53,360
例如，如果您进入我们的登录视图，是否已验证

800
15:12:53,360 --> 15:12:56,796
你可以看到我们在这里有这段代码

801
15:12:56,796 --> 15:13:00,160
使用电子邮件和密码登录用户，然后立即获得

802
15:13:00,160 --> 15:13:04,560
用户和它对该用户所做的一切都说电子邮件已验证

803
15:13:04,560 --> 15:13:08,240
我们在注册视图中做同样的事情我相信所以让我们去

804
15:13:08,240 --> 15:13:12,080
注册视图，你可以在这里看到它说

805
15:13:12,080 --> 15:13:15,916
实际上，我们没有对已验证的电子邮件做任何事情，我们正在做的一切

806
15:13:15,916 --> 15:13:19,916
只是说发送电子邮件验证非常抱歉，所以它在登录

807
15:13:19,916 --> 15:13:25,680
screen 好的，所以让我们在这里进入我们的关闭用户并说它有一个名为的属性

808
15:13:25,680 --> 15:13:32,720
电子邮件验证没问题，所以我要说 final 而公牛是电子邮件

809
15:13:32,720 --> 15:13:36,640
你看到firebase已经实现了这个功能这个呃

810
15:13:36,640 --> 15:13:41,840
属性作为电子邮件验证我个人更喜欢调用布尔函数 boolean

811
15:13:41,840 --> 15:13:47,520
在这种情况下，getter 就像一个类的属性，只要我认为合适

812
15:13:47,520 --> 15:13:51,756
只是因为至少说用户 dot 对我来说更有意义

813
15:13:51,756 --> 15:13:55,680
电子邮件已验证，而不是说 user.email 已验证

814
15:13:55,680 --> 15:14:00,640
它只是让它在语法上更像是完整的，经过验证或

815
15:14:00,640 --> 15:14:04,320
这就是我们的原因

816
15:14:04,320 --> 15:14:07,916
分歧一点好吧

817
15:14:07,916 --> 15:14:12,480
现在你在这里看到这个，我们说你可以得到它的电子邮件验证

818
15:14:12,480 --> 15:14:17,200
Visual Studio 代码的帮助为最终字段创建构造函数

819
15:14:17,200 --> 15:14:20,080
即使您不想这样做，也可以随时手动输入

820
15:14:20,080 --> 15:14:25,840
您可以说用户自己已通过电子邮件验证对不起，这是已通过电子邮件验证

821
15:14:25,840 --> 15:14:31,436
并且因为这个类它只有一个你可以设置的属性

822
15:14:31,436 --> 15:14:34,956
初始化并且您不会更改它，因为它是最终字段

823
15:14:34,956 --> 15:14:40,796
对不起，你可以让你的构造函数成为 const

824
15:14:40,796 --> 15:14:45,276
再次对不起，如果可以的话也很好

825
15:14:45,276 --> 15:14:49,596
基本上让我们说不可变作为另一个尝试定义

826
15:14:49,596 --> 15:14:53,840
未定义我相信你实际上必须在这里导入基础

827
15:14:53,840 --> 15:14:59,520
现在不可变基本上是但在这里不可变我认为我们没有

828
15:14:59,520 --> 15:15:04,160
之前讨论过，但这就像一个注释告诉这个

829
15:15:04,160 --> 15:15:08,956
类和该类的任何子类将是不可变的，这意味着

830
15:15:08,956 --> 15:15:13,520
它们的内部结构在初始化时永远不会改变，所以如果你

831
15:15:13,520 --> 15:15:20,880
然后去创建例如我的关闭用户类并说扩展身份验证用户

832
15:15:20,880 --> 15:15:26,240
然后你会有一个公牛，嗯，让我们在这里说，你创建一个

833
15:15:26,240 --> 15:15:31,360
它的构造函数，所以让我们为它创建一个构造函数吧，太好了

834
15:15:31,360 --> 15:15:36,320
更喜欢声明什么是 const 好然后我们说 const 然后你说好

835
15:15:36,320 --> 15:15:39,840
我想要一个布尔标志在这里公牛是废话

836
15:15:39,840 --> 15:15:42,400
和嗯

837
15:15:42,400 --> 15:15:45,520
是的，公牛被封锁了

838
15:15:45,520 --> 15:15:49,116
现在你看到它说 null 而不是不可为 null 的实例 flab 但它必须

839
15:15:49,116 --> 15:15:53,840
被初始化让我们把它初始化为 false 并且它说不能定义一个

840
15:15:53,840 --> 15:15:57,596
cons 构造函数好的，那么我们不打算将它变成一个 cons 构造函数和

841
15:15:57,596 --> 15:16:01,756
现在你看到这里的小警告它说这个类或这个类

842
15:16:01,756 --> 15:16:06,720
继承自的类被标记为不可变，但它的一个或多个

843
15:16:06,720 --> 15:16:11,756
实例感觉不是最终的所以现在你明白什么是不可变的了

844
15:16:11,756 --> 15:16:17,116
告诉 dart 这个类及其所有子类需要是免疫不可变的

845
15:16:17,116 --> 15:16:22,320
他们不能有任何更改的字段，因此通过删除此字段，您将得到

846
15:16:22,320 --> 15:16:25,276
摆脱那个小警告，你可以做到这一点

847
15:16:25,276 --> 15:16:30,480
缺点和错误完全消失了所以现在你知道什么是不可变的了

848
15:16:30,480 --> 15:16:34,956
好的，好的，现在我们创建了

849
15:16:34,956 --> 15:16:38,796
在 cons 构造函数中为我们的关闭用户验证的电子邮件

850
15:16:38,796 --> 15:16:44,240
让我们转到下一点下一点，正如您在此处看到的那样

851
15:16:44,240 --> 15:16:50,400
说我们需要一个工厂构造函数来创建我们的

852
15:16:50,400 --> 15:16:55,436
来自 firebase 用户和工厂构造函数的 auth 用户非常有用

853
15:16:55,436 --> 15:17:00,720
为此，您假设对象 x 并且您想要

854
15:17:00,720 --> 15:17:06,000
从中创建一个对象 y ，而不是手动以某种方式粘合东西

855
15:17:06,000 --> 15:17:10,480
中间层说现在我拿对象 x 并添加一些废话和融合

856
15:17:10,480 --> 15:17:14,640
把它放在一起，然后把对象 y 你可以把责任放在对象 y 上

857
15:17:14,640 --> 15:17:19,116
并说你需要能够初始化自己或构造一个

858
15:17:19,116 --> 15:17:22,720
来自这个对象的你自己的实例，这就像一个典型的模式

859
15:17:22,720 --> 15:17:27,276
你会到处看到所以嗯到处都是但是在哪里

860
15:17:27,276 --> 15:17:31,840
你有能力做到这一点所以这就是我们现在要做的

861
15:17:31,840 --> 15:17:36,880
工厂构造函数所以假设我们这里有一个工厂构造函数

862
15:17:36,880 --> 15:17:42,320
我们会说关闭用户，我们会说从火力基地好的，正如标题所说的那样

863
15:17:42,320 --> 15:17:47,200
我们像这样把一个firebase用户带到这里，然后我们说我们会说什么

864
15:17:47,200 --> 15:17:52,240
在这里我们将创建一个我们自己的类的实例

865
15:17:52,240 --> 15:17:56,160
鉴于该用户还可以，所以假设我们创建

866
15:17:56,160 --> 15:18:00,796
这里有一个关闭用户和很多用户，它是电子邮件

867
15:18:00,796 --> 15:18:04,000
验证来自像这样验证的用户电子邮件

868
15:18:04,000 --> 15:18:07,116
好吧，所以这不应该是他们不应该那么难

869
15:18:07,116 --> 15:18:10,240
理解，所以这创造了这个进入

870
15:18:10,240 --> 15:18:15,680
您可以看到此构造函数，它采用电子邮件验证值

871
15:18:15,680 --> 15:18:20,240
firebase 用户并将其放在此类中，所以我们所做的只是我们

872
15:18:20,240 --> 15:18:24,240
就像复制了一个firebase用户和

873
15:18:24,240 --> 15:18:27,840
我们将其复制到我们自己的关闭用户中

874
15:18:27,840 --> 15:18:32,880
好的，所以我们不会暴露 firebase 的用户及其所有内容

875
15:18:32,880 --> 15:18:39,040
我们的用户界面的属性

876
15:18:39,040 --> 15:18:44,160
好吧，那是很多信息现在让我们来谈谈身份验证提供者

877
15:18:44,160 --> 15:18:46,640
我在本章开头提到

878
15:18:46,640 --> 15:18:52,080
正如您在 firebase 控制台中看到的那样，您将可以添加

879
15:18:52,080 --> 15:18:54,880
使用时为您的应用程序提供各种身份验证提供程序

880
15:18:54,880 --> 15:18:59,360
firebase 诸如 google 和 apple facebook

881
15:18:59,360 --> 15:19:03,200
还有更多像我们这样做的电子邮件和密码组合

882
15:19:03,200 --> 15:19:07,200
所有这些都是提供者，我们现在需要做的是创建一个

883
15:19:07,200 --> 15:19:14,160
alt 提供者类，它封装了我们可能添加的每个提供者

884
15:19:14,160 --> 15:19:19,520
未来并为他们创建一个漂亮的界面说我们的每个供应商

885
15:19:19,520 --> 15:19:24,560
应用程序可以使用应该符合这个特定的接口好吗

886
15:19:24,560 --> 15:19:29,116
所以让我们继续处理这个问题，我可以在这里看到我们要

887
15:19:29,116 --> 15:19:32,080
在 lib services auth 上创建该文件

888
15:19:32,080 --> 15:19:38,080
关闭提供程序，因此我们关闭了 lib 服务，但我们没有身份验证提供程序文件，所以

889
15:19:38,080 --> 15:19:46,320
让我们右键单击 auth 并说出提供者 dart

890
15:19:46,320 --> 15:19:49,680
去我的笔记

891
15:19:49,680 --> 15:19:53,840
所以我们接下来要做的是

892
15:19:53,840 --> 15:19:59,276
因为我们的off uh提供商将与我们合作

893
15:19:59,276 --> 15:20:02,240
嗯，例如

894
15:20:02,240 --> 15:20:05,360
我们将为我们的身份验证提供者提供的功能是

895
15:20:05,360 --> 15:20:10,560
实例一个获取当前用户的getter，所以这不是一个函数，它只是

896
15:20:10,560 --> 15:20:14,640
如果你看到让我去登录，我们实际上在这里做的方式是吸气剂

897
15:20:14,640 --> 15:20:18,560
查看，您将在此处的登录视图中看到

898
15:20:18,560 --> 15:20:22,956
目前的事情说firebase auth instance current user这是一个getter

899
15:20:22,956 --> 15:20:28,880
所以这是一个属性并返回firebase用户我们想要的是我们的

900
15:20:28,880 --> 15:20:34,080
auth provider 也能够为我们提供当前用户现在记住

901
15:20:34,080 --> 15:20:40,080
我们已经用我们自己的 auth 用户抽象了 firebase 用户，我们刚刚

902
15:20:40,080 --> 15:20:46,000
创建好了，所以我们需要的是这个抽象类，它可以返回一个

903
15:20:46,000 --> 15:20:51,840
我们关闭用户的实例没问题，因此我们需要将其导入关闭

904
15:20:51,840 --> 15:20:56,160
用户进入这个 dart 文件，所以我们只说导入

905
15:20:56,160 --> 15:20:59,276
将我创建的这个应用程序打包为

906
15:20:59,276 --> 15:21:02,080
你可以在标题中看到它叫做我的笔记

907
15:21:02,080 --> 15:21:08,956
所以让我们去我的笔记服务 auth 然后去 auth user 所以这就是

908
15:21:08,956 --> 15:21:13,116
如您在标题中看到的导入语句，我已经编写了 package xxx 和

909
15:21:13,116 --> 15:21:17,200
这就是您需要在这种情况下输入包裹名称的地方，因为我是我的

910
15:21:17,200 --> 15:21:20,796
笔记

911
15:21:20,796 --> 15:21:26,720
好的，现在我们去创建一个抽象类，所以我已经

912
15:21:26,720 --> 15:21:31,756
之前提到过两次，但我们的身份验证提供程序 dart 文件不会有

913
15:21:31,756 --> 15:21:36,240
真的没有任何逻辑

914
15:21:36,240 --> 15:21:40,956
抽象类虽然 dart 中的抽象类可以包含逻辑但是在这个

915
15:21:40,956 --> 15:21:44,560
如果我们的抽象类只是一个协议，或者你可能知道它为

916
15:21:44,560 --> 15:21:50,080
接口，或者你可能也知道它是一个抽象类，所以让我们继续吧

917
15:21:50,080 --> 15:21:55,040
并创建让我们说抽象类身份验证提供程序

918
15:21:55,040 --> 15:22:01,116
这样抽象类的创建就完成了，我们现在需要做的就是给它

919
15:22:01,116 --> 15:22:05,596
就像标题说的那样，可以返回当前关闭的用户

920
15:22:05,596 --> 15:22:10,880
我们要关闭用户并让当前用户正常

921
15:22:10,880 --> 15:22:14,480
所以我们说任何作者提供者是否可以使用电子邮件密码

922
15:22:14,480 --> 15:22:18,560
是否是 google auth provider 是否是 Apple facebook twitter

923
15:22:18,560 --> 15:22:22,956
无论它需要能够有选择地返回当前的当前

924
15:22:22,956 --> 15:22:26,080
经过身份验证的用户，这就是这个可选站点

925
15:22:26,080 --> 15:22:31,276
在这里可以，然后我们还需要做的是

926
15:22:31,276 --> 15:22:33,680
允许它

927
15:22:33,680 --> 15:22:39,680
能够让用户登录没问题，所以我们会说我们将拥有一个功能

928
15:22:39,680 --> 15:22:43,436
在未来完成

929
15:22:43,436 --> 15:22:48,956
并返回一个关闭用户，它说登录

930
15:22:48,956 --> 15:22:53,520
像这样没关系，现在我们必须想想这是什么

931
15:22:53,520 --> 15:22:58,400
在我们的例子中，登录实际上需要很好，它需要电子邮件和密码，所以让我们

932
15:22:58,400 --> 15:23:02,000
只需输入电子邮件和密码，我们认为每个作者提供者

933
15:23:02,000 --> 15:23:06,240
我们正在写作将有某种电子邮件和密码组合

934
15:23:06,240 --> 15:23:10,560
你可以说 id 和 password 但我只会用 email 和 password

935
15:23:10,560 --> 15:23:14,480
现在好了，所以让我们也制作这些必需的参数，所以我要走了

936
15:23:14,480 --> 15:23:18,240
把大括号放在这里，把大括号放在这里，我要说是必需的

937
15:23:18,240 --> 15:23:22,000
流电子邮件，然后是所需的流密码，例如

938
15:23:22,000 --> 15:23:24,560
没关系

939
15:23:24,560 --> 15:23:28,720
和该命令末尾的分号 s 将文件保存为如此黑暗

940
15:23:28,720 --> 15:23:35,436
格式化程序可以发挥它的魔力以及我们去的原因

941
15:23:35,436 --> 15:23:39,200
如果您再次进入我们的登录屏幕，请原谅作者

942
15:23:39,200 --> 15:23:43,840
在这里我们说用用户名和密码登录你可以看到它总是

943
15:23:43,840 --> 15:23:49,040
现在返回一个用户凭证你可能会想我怎么能总是返回一个

944
15:23:49,040 --> 15:23:53,116
如果当前的电子邮件和密码实际上不正确并且他们

945
15:23:53,116 --> 15:23:57,276
不属于有效用户firebase处理的方式是，如果

946
15:23:57,276 --> 15:24:01,680
你说用电子邮件和密码登录，如果你能抓住当前用户，如果他

947
15:24:01,680 --> 15:24:05,040
无法使用您提供的信息登录该用户返回

948
15:24:05,040 --> 15:24:09,360
否则它会失败并出现异常，这意味着只要

949
15:24:09,360 --> 15:24:13,276
你打电话给我，没有例外，如果有，我会给你用户凭证

950
15:24:13,276 --> 15:24:18,160
是一个例外，你需要处理它，所以这是避免的好方法

951
15:24:18,160 --> 15:24:23,200
拥有功能让我关闭关闭用户以及避免拥有的功能

952
15:24:23,200 --> 15:24:27,040
在你的返回用户上做这个选项，所以

953
15:24:27,040 --> 15:24:32,560
在你的函数中做你的工作返回用户并返回对象

954
15:24:32,560 --> 15:24:37,436
你承诺如果你不能这样做会抛出一个错误，所以你不必这样做

955
15:24:37,436 --> 15:24:43,596
这做这种可选的回报好吧

956
15:24:43,596 --> 15:24:48,480
对于登录功能，现在我们还需要一个可以创建

957
15:24:48,480 --> 15:24:52,480
用户以便想象它是用于注册或

958
15:24:52,480 --> 15:24:56,240
嗯，是的，我们还能叫它什么，呃，注册

959
15:24:56,240 --> 15:25:00,560
是的，所以我们称它为创建用户，所以我们说

960
15:25:00,560 --> 15:25:06,240
这也返回一个身份验证用户，我们称之为创建用户这样

961
15:25:06,240 --> 15:25:09,680
这也有所有这些参数所以我只是要复制和粘贴这个

962
15:25:09,680 --> 15:25:14,480
你不必这样做两次，最后一个分号

963
15:25:14,480 --> 15:25:20,080
好吧，守卫格式化程序做它的事情，然后让我们去吧

964
15:25:20,080 --> 15:25:24,880
并创建一个函数，允许我们然后注销用户，因为那是

965
15:25:24,880 --> 15:25:28,720
我们在应用程序的主用户界面中正在做什么

966
15:25:28,720 --> 15:25:32,320
如您在此处的标题中所见，注销它不会返回任何值

967
15:25:32,320 --> 15:25:37,680
只是一个未来的空白，所以我们说未来的空白就像那样注销

968
15:25:37,680 --> 15:25:42,880
好吧，这很简单，而且我们还需要一个函数

969
15:25:42,880 --> 15:25:47,040
可以发送电子邮件验证，所以这个也很简单，它只是一个

970
15:25:47,040 --> 15:25:52,840
未来无效，正如您在标题中看到的那样，我们称之为发送电子邮件

971
15:25:52,840 --> 15:25:57,520
验证没问题所以

972
15:25:57,520 --> 15:26:00,240
怎么样？

973
15:26:00,240 --> 15:26:03,360
正如我提到的，我们目前的办公室供应商是

974
15:26:03,360 --> 15:26:06,840
只是一个抽象类，所以它是

975
15:26:06,840 --> 15:26:11,520
为我们将要使用的任何身份验证提供程序指定一个接口

976
15:26:11,520 --> 15:26:16,400
添加到我们的应用程序中，但只是为了让您知道我们只是

977
15:26:16,400 --> 15:26:20,160
将添加一个电子邮件作者提供商好的

978
15:26:20,160 --> 15:26:23,840
或对不起firebase作者提供者

979
15:26:23,840 --> 15:26:28,720
但是这样通过创建一个以作者提供者为名称的抽象类

980
15:26:28,720 --> 15:26:32,080
然后你创建一个名为 firebase auth provider 的具体类

981
15:26:32,080 --> 15:26:36,560
将来能够扩展此功能并添加越来越多的身份验证提供程序

982
15:26:36,560 --> 15:26:40,956
这将遵循相同的界面，这就是目标

983
15:26:40,956 --> 15:26:46,000
但我们仅在本课程中将使用 firebase auth provider

984
15:26:46,000 --> 15:26:50,720
所以，呃，你知道，正如标题所说，继续创造

985
15:26:50,720 --> 15:26:56,080
在您的服务身份验证文件夹中创建一个名为 firebase 身份验证提供程序的文件

986
15:26:56,080 --> 15:27:00,720
右键单击此处，我​​会说 oops uh 并说新文件我要调用它

987
15:27:00,720 --> 15:27:05,200
firebase off dot provider.net

988
15:27:05,200 --> 15:27:09,360
现在让我们进去说，嗯，我要去看看我的笔记

989
15:27:09,360 --> 15:27:13,436
嗯，就像这样，好吧，所以这会是这样的

990
15:27:13,436 --> 15:27:19,916
本章中最有趣的部分，我们实际上要讲

991
15:27:19,916 --> 15:27:25,200
将 Firebase 身份验证的方式抽象到我们自己的提供者中，所以期待这个

992
15:27:25,200 --> 15:27:29,840
文件大小增加一点我可以看到我的笔记它会去

993
15:27:29,840 --> 15:27:36,000
100 行代码，但这也没关系，我们可以开始使用它

994
15:27:36,000 --> 15:27:39,040
正如你在标题中看到的，我们需要

995
15:27:39,040 --> 15:27:44,640
导入一些文件 auth user auth provider 并关闭我们需要的异常

996
15:27:44,640 --> 15:27:48,560
auth 用户，因为这个对不起实际上让我先

997
15:27:48,560 --> 15:27:52,080
解释为什么我们需要导入身份验证提供程序，因为我们的 firebase 身份验证

998
15:27:52,080 --> 15:27:56,080
provider 将是文件身份验证提供程序的具体实现

999
15:27:56,080 --> 15:27:59,360
或者我们刚刚创建的类身份验证提供程序，这就是原因

1000
15:27:59,360 --> 15:28:02,240
导入操作系统用户导入将是

1001
15:28:02,240 --> 15:28:05,116
因为正如您在身份验证提供程序中看到的那样

1002
15:28:05,116 --> 15:28:09,840
他们需要返回关闭用户的登录和创建用户功能，这就是为什么

1003
15:28:09,840 --> 15:28:13,596
我们需要导入用户，以便我们的提供者可以返回该用户的实例

1004
15:28:13,596 --> 15:28:16,480
好的，最后但并非最不重要的是，我们还需要

1005
15:28:16,480 --> 15:28:20,640
导入身份验证异常，因为请记住我们的 firebase 身份验证提供程序也在进行

1006
15:28:20,640 --> 15:28:23,680
抽象出所有的身份验证

1007
15:28:23,680 --> 15:28:28,080
否则会在 firebase 级别发生的错误和异常进入我们的

1008
15:28:28,080 --> 15:28:33,360
我们在这里创建的自己的例外 好的，让我走吧

1009
15:28:33,360 --> 15:28:38,160
提前并首先导入用户so包

1010
15:28:38,160 --> 15:28:44,320
这个应用程序叫我的笔记，我们有服务认证

1011
15:28:44,320 --> 15:28:49,116
然后我们已经关闭用户了，所以我要导入它

1012
15:28:49,116 --> 15:28:53,436
然后我要复制这个文件，这一行和下一个将是

1013
15:28:53,436 --> 15:28:57,040
关闭提供程序，正如您在我们的捕获中看到的那样

1014
15:28:57,040 --> 15:29:02,160
还必须导入身份验证异常

1015
15:29:02,160 --> 15:29:06,000
所以这是三个进口

1016
15:29:06,000 --> 15:29:09,680
现在因为我们有自己的进口

1017
15:29:09,680 --> 15:29:12,880
这个文件将直接与firebase对话，我们还需要导入

1018
15:29:12,880 --> 15:29:17,360
firebase 当然是这样，让我们​​继续导入

1019
15:29:17,360 --> 15:29:20,880
我将实际复制该代码，因此我不必输入所有代码

1020
15:29:20,880 --> 15:29:23,520
因为它有点无聊，但你可以看到

1021
15:29:23,520 --> 15:29:28,240
在字幕中，至少你需要什么来导入 firebase 并且你需要

1022
15:29:28,240 --> 15:29:32,480
也可以导入 firebase off 异常

1023
15:29:32,480 --> 15:29:36,720
太好了，这就是我们的进口产品

1024
15:29:36,720 --> 15:29:40,720
嗯，现在我们需要做的是创建实际的类和

1025
15:29:40,720 --> 15:29:43,916
嗯，如您所见，它将被称为 firebase all provider 和

1026
15:29:43,916 --> 15:29:48,400
实现身份验证提供程序，这是我们自己的类，所以让我们说 firebase

1027
15:29:48,400 --> 15:29:53,276
auth provider 实现了一个像这样的提供者，好吧，现在

1028
15:29:53,276 --> 15:29:56,480
你可以看到你得到一个错误，同样缺少我的具体实现

1029
15:29:56,480 --> 15:30:01,200
将更改屏幕的布局，以便您看到完整的代码

1030
15:30:01,200 --> 15:30:05,276
然后我们需要做的是实现你看到的那些功能

1031
15:30:05,276 --> 15:30:09,596
验证提供者抽象类的函数和吸气剂

1032
15:30:09,596 --> 15:30:14,240
说实现它的每个类也需要实现这些东西

1033
15:30:14,240 --> 15:30:18,640
所以你可以试着用手做这些事情，但我绝对

1034
15:30:18,640 --> 15:30:24,720
我我我根本不喜欢手工做事抱歉，所以我更喜欢

1035
15:30:24,720 --> 15:30:27,756
得到编辑的帮助来完成这些事情所以我只想说

1036
15:30:27,756 --> 15:30:31,840
命令点并使类firebase关闭抽象

1037
15:30:31,840 --> 15:30:36,640
创建五个缺少的覆盖好的，所以我们开始了，所以 Visual Studio 代码

1038
15:30:36,640 --> 15:30:39,756
在这里创建了所有这些功能，您可以在所有这些功能中看到它只是说

1039
15:30:39,756 --> 15:30:44,080
抛出未实现的错误很棒的东西

1040
15:30:44,080 --> 15:30:48,560
我要在这里减小字体的大小 回到

1041
15:30:48,560 --> 15:30:53,680
与我们之前的布局相同，所以我们需要做的第一件事

1042
15:30:53,680 --> 15:30:59,200
在这里，让我们继续实现这个当前用户好吧

1043
15:30:59,200 --> 15:31:03,680
所以这将有很多而不是很多但它会有一点

1044
15:31:03,680 --> 15:31:07,360
逻辑上的，所以我要这样做而不是用指针

1045
15:31:07,360 --> 15:31:12,560
让我们继续在这里尝试获取该用户，让我们说

1046
15:31:12,560 --> 15:31:17,680
您会看到我们现在的工作是获取 firebase 用户并将其关闭

1047
15:31:17,680 --> 15:31:22,240
用户记得我们的关闭用户有一个工厂构造函数，所以我们需要调用它

1048
15:31:22,240 --> 15:31:28,880
工厂构造函数可以，所以我们只是说最终用户等于 firebase off

1049
15:31:28,880 --> 15:31:32,080
我们的火力基地和身份验证

1050
15:31:32,080 --> 15:31:35,520
实例，然后我们说当前用户

1051
15:31:35,520 --> 15:31:40,320
然后我们说如果用户不为空

1052
15:31:40,320 --> 15:31:45,116
我们需要创建一个它的实例作为关闭用户所以我们只说return

1053
15:31:45,116 --> 15:31:54,320
从firebase用户关闭用户好吧，否则我们像这样返回null

1054
15:31:54,320 --> 15:31:58,320
如果firebase说有一个用户，那么我们会创建一个关闭用户，然后我们

1055
15:31:58,320 --> 15:32:02,560
把它还回去

1056
15:32:02,560 --> 15:32:06,400
好吧，对于当前用户来说，说实话并没有那么多代码

1057
15:32:06,400 --> 15:32:10,400
你现在我们需要做的就是保重

1058
15:32:10,400 --> 15:32:14,240
的创建用户，这是这里的功能

1059
15:32:14,240 --> 15:32:19,276
所以说实话，创建用户会有点厚

1060
15:32:19,276 --> 15:32:24,560
让我们继续，首先在

1061
15:32:24,560 --> 15:32:29,200
在这里，所以我喜欢总是在最后一个末尾附加一个逗号

1062
15:32:29,200 --> 15:32:33,200
我的函数的参数，这样当我做暗格式化程序时

1063
15:32:33,200 --> 15:32:37,840
或 dart 格式，它将把所有这些参数分解成它们自己的参数

1064
15:32:37,840 --> 15:32:41,520
线条还可以，因为在它看起来像这样之前，它在我眼中并不那么干净

1065
15:32:41,520 --> 15:32:44,720
至少这是一个偏好，好吧

1066
15:32:44,720 --> 15:32:50,160
在这里我们需要做的就是创建基本上 uh

1067
15:32:50,160 --> 15:32:55,276
一个有 uh firebase 的用户，所以我要把这整个东西放进去

1068
15:32:55,276 --> 15:33:01,360
在 try 块中，然后我们将捕获 firebase 异常

1069
15:33:01,360 --> 15:33:08,000
并且在 firebase off 异常捕获 e 好

1070
15:33:08,000 --> 15:33:11,520
所以就像那样，然后我们将有一个通用的

1071
15:33:11,520 --> 15:33:17,360
像这样在这里缓存块

1072
15:33:17,360 --> 15:33:21,840
好吧，现在我们需要在三态 main 中创建用户

1073
15:33:21,840 --> 15:33:25,276
声明我们需要实际告诉firebase我们要创建一个新的

1074
15:33:25,276 --> 15:33:30,000
用户所以让我们说firebase关闭

1075
15:33:30,000 --> 15:33:33,840
即时然后我们说用电子邮件和密码创建用户好吧，所以我们有

1076
15:33:33,840 --> 15:33:38,320
在这里发送电子邮件和密码，我们可以看到这些参数已经存在，所以我们

1077
15:33:38,320 --> 15:33:40,560
不必做任何事情

1078
15:33:40,560 --> 15:33:45,200
嗯，但我们需要在这里做的是你可以首先真正看到是的

1079
15:33:45,200 --> 15:33:48,480
函数需要返回一个值，我们会解决这个问题，所以不用担心

1080
15:33:48,480 --> 15:33:52,956
但我们还需要等待，因为请记住创建用户或

1081
15:33:52,956 --> 15:33:56,400
电子邮件密码不是立即返回的功能，这是一个

1082
15:33:56,400 --> 15:33:59,276
飞镖的绝妙之处在于

1083
15:33:59,276 --> 15:34:03,040
接口我们实际上并没有说这个函数必须是异步的，但是你

1084
15:34:03,040 --> 15:34:07,436
可以在这个具体的实现中使这个函数异步所以它是绝对的

1085
15:34:07,436 --> 15:34:11,436
美丽，所以异步不是函数签名的一部分，但它有

1086
15:34:11,436 --> 15:34:14,956
更多地与该函数的内部有关，所以为了调用它

1087
15:34:14,956 --> 15:34:19,200
带有await的函数你看看我们是否在这里放了一个权重我们得到了一个我们需要的错误

1088
15:34:19,200 --> 15:34:25,360
让这个函数异步好极了

1089
15:34:25,360 --> 15:34:30,956
好吧，在这样做之后，我们要做的是获取当前用户

1090
15:34:30,956 --> 15:34:35,840
如果当前用户在那里，那么我们将返回当前用户

1091
15:34:35,840 --> 15:34:40,240
创建用户或电子邮件和密码后的当前用户，没有例外

1092
15:34:40,240 --> 15:34:45,360
不在那里那是一个不好的迹象，我们需要返回我们的身份验证之一

1093
15:34:45,360 --> 15:34:48,880
称为用户未登录的异常关闭异常正常

1094
15:34:48,880 --> 15:34:52,720
所以我要关闭这个所以让我们进去说final

1095
15:34:52,720 --> 15:34:57,596
用户是获取或只是用户是当前用户

1096
15:34:57,596 --> 15:35:01,840
请记住，我们已经在这里为当前用户提供了一个吸气剂

1097
15:35:01,840 --> 15:35:04,640
好的，它只是获取当前用户

1098
15:35:04,640 --> 15:35:10,956
firebase 所以我们说这里是用户，如果用户在那里可用

1099
15:35:10,956 --> 15:35:15,360
不为空，则只返回用户

1100
15:35:15,360 --> 15:35:20,320
否则你应该抛出一个未找到的用户，或者我认为这就是我们所说的

1101
15:35:20,320 --> 15:35:23,756
用户未登录

1102
15:35:23,756 --> 15:35:28,560
身份验证异常正常

1103
15:35:28,560 --> 15:35:32,560
如果除此之外一切正常，那是为了创建用户

1104
15:35:32,560 --> 15:35:36,160
现在部分我们需要去我们的firebase auth

1105
15:35:36,160 --> 15:35:39,680
例外，我们需要处理一些事情

1106
15:35:39,680 --> 15:35:44,880
因此，如果您查看我们的注册视图中的位置

1107
15:35:44,880 --> 15:35:51,040
在这里，我们正在处理已在使用的弱密码电子邮件和无效电子邮件

1108
15:35:51,040 --> 15:35:55,596
所以让我们复制这三件事好吧实际上这四件事因为

1109
15:35:55,596 --> 15:35:59,276
我们那里也有一个 else 块

1110
15:35:59,276 --> 15:36:03,916
所以我要复制那个代码只是做同样的事情请去你的注册表

1111
15:36:03,916 --> 15:36:08,000
并将该代码复制回您的 Firebase 身份验证提供程序

1112
15:36:08,000 --> 15:36:11,756
firebase off 异常，你正在捕捉它

1113
15:36:11,756 --> 15:36:15,916
粘贴该代码，但删除与节目有关的所有内容

1114
15:36:15,916 --> 15:36:21,840
错误对话框没问题，所以至少我们有 if 和 else 语句没问题

1115
15:36:21,840 --> 15:36:26,080
像这样，所以你最终应该得到一个看起来像这样的代码

1116
15:36:26,080 --> 15:36:29,596
现在我们在哪里有一个弱密码

1117
15:36:29,596 --> 15:36:33,276
实际上会抛出我们自己的错误，所以我们会说 throw

1118
15:36:33,276 --> 15:36:38,080
弱密码关闭异常 这是一封已在使用的电子邮件 我们正在

1119
15:36:38,080 --> 15:36:42,000
已经开始发送电子邮件并使用身份验证

1120
15:36:42,000 --> 15:36:47,520
万一无效电子邮件抛出无效电子邮件异常，如果有任何

1121
15:36:47,520 --> 15:36:51,596
我们不知道的其他代码我们只是要抛出一个通用的身份验证

1122
15:36:51,596 --> 15:36:54,560
例外

1123
15:36:54,560 --> 15:36:59,840
并且如果有一个最终的捕获基本上意味着通过调用

1124
15:36:59,840 --> 15:37:03,916
如果有任何其他异常，请为用户创建带有电子邮件和密码的电子邮件

1125
15:37:03,916 --> 15:37:08,400
除了 firebase auth 异常，我们还需要处理它并抛出

1126
15:37:08,400 --> 15:37:13,360
那里也有一个通用的身份验证异常

1127
15:37:13,360 --> 15:37:19,040
很多代码，但希望这使我们的 ui 代码

1128
15:37:19,040 --> 15:37:23,360
更容易阅读好吧，所以我们这样做是为了一个好的目的

1129
15:37:23,360 --> 15:37:25,916
适合我们的好东西

1130
15:37:25,916 --> 15:37:30,720
创建用户我会摔倒创建用户呃如果它允许我折叠整个

1131
15:37:30,720 --> 15:37:35,360
创建用户poof，我也将折叠当前用户，所以这是一个

1132
15:37:35,360 --> 15:37:37,840
你能做或不能做的技术 只是你能做的把戏的技术

1133
15:37:37,840 --> 15:37:41,360
在你的编辑器中，如果它支持折叠和展开只是为了确保它

1134
15:37:41,360 --> 15:37:45,200
看起来更干净一点，因为现在您已经编写了创建用户

1135
15:37:45,200 --> 15:37:49,200
可能对您可能只想知道的所有细节不直接感兴趣

1136
15:37:49,200 --> 15:37:53,276
没关系

1137
15:37:53,276 --> 15:37:57,916
好的，接下来我们需要做的是实现发送电子邮件验证

1138
15:37:57,916 --> 15:38:01,436
所以让我们找到那个功能，我可以看到它就在这里发送电子邮件

1139
15:38:01,436 --> 15:38:04,400
验证我要向上滚动一点，所以你看

1140
15:38:04,400 --> 15:38:09,200
像那样我也会去我的笔记

1141
15:38:09,200 --> 15:38:14,560
所以我们需要做的是激励我们需要的电子邮件验证

1142
15:38:14,560 --> 15:38:18,956
也将其标记为异步，因为它将调用异步

1143
15:38:18,956 --> 15:38:23,116
在 firebase 上运行也可以，我们需要

1144
15:38:23,116 --> 15:38:26,956
在firebase用户上调用发送电子邮件验证功能记住

1145
15:38:26,956 --> 15:38:30,796
我们的用户没有我们的用户只有通过电子邮件验证的功能

1146
15:38:30,796 --> 15:38:36,240
属性所以在这里让我们获取firebase用户所以我要说用户

1147
15:38:36,240 --> 15:38:39,596
火力基地关闭

1148
15:38:39,596 --> 15:38:42,840
实例当前用户，我们说

1149
15:38:42,840 --> 15:38:50,320
如果用户不为空，那么我们调用该函数，所以我们说等待用户发送电子邮件

1150
15:38:50,320 --> 15:38:53,596
验证我记得我认为这是虚空的未来所以这就是为什么我们

1151
15:38:53,596 --> 15:38:58,880
对其进行加权，这就是为什么我们现在在这里有异步标签的原因

1152
15:38:58,880 --> 15:39:04,080
如果用户为零，那么我们只会说用户没有登录，你不能

1153
15:39:04,080 --> 15:39:08,080
向未登录的用户发送电子邮件验证，那么您

1154
15:39:08,080 --> 15:39:12,640
抛出用户未登录异常

1155
15:39:12,640 --> 15:39:17,520
好的，这就是我们的发送电子邮件验证

1156
15:39:17,520 --> 15:39:21,680
函数让我们也折叠这个函数

1157
15:39:21,680 --> 15:39:25,520
正如标题所说，我们看不到它的内部结构，现在我们需要走了

1158
15:39:25,520 --> 15:39:30,480
并实现登录登录与创建用户一样重要

1159
15:39:30,480 --> 15:39:34,480
首先在此处的密码参数和命令 s 的末尾放置一个逗号

1160
15:39:34,480 --> 15:39:38,796
为了保存它并在登录功能中，我们

1161
15:39:38,796 --> 15:39:41,756
将做一些与我们在注册表中所做的非常相似的事情

1162
15:39:41,756 --> 15:39:45,756
我可以通过尝试在笔记中看到的功能

1163
15:39:45,756 --> 15:39:50,320
然后我们在firebase off异常上说

1164
15:39:50,320 --> 15:39:53,360
并抓住 e

1165
15:39:53,360 --> 15:39:55,840
然后我们会说 catch

1166
15:39:55,840 --> 15:40:02,400
任何其他例外都可以，所以让我们进入这里然后从嗯开始

1167
15:40:02,400 --> 15:40:06,840
告诉firebase我们想用这些凭据登录所以让我们说

1168
15:40:06,840 --> 15:40:10,720
firebase auth 实例，然后我们说 uh

1169
15:40:10,720 --> 15:40:15,756
使用电子邮件和密码登录，所以那里有一个功能可以

1170
15:40:15,756 --> 15:40:19,840
我要在最后加一个分号，这样你就可以看到

1171
15:40:19,840 --> 15:40:22,480
代码没问题，这就是我们正在做的，但是

1172
15:40:22,480 --> 15:40:26,720
再次记住这些函数是异步的，所以你不能只调用它

1173
15:40:26,720 --> 15:40:31,200
功能并期望它能够工作 这是用户凭证的未来 好的，所以让

1174
15:40:31,200 --> 15:40:34,840
你的函数是异步的，然后等待这个

1175
15:40:34,840 --> 15:40:39,040
函数，所以我们将做一些与我们正在做的非常相似的事情

1176
15:40:39,040 --> 15:40:43,596
在创建用户中注册抱歉，因为我们说最终用户是

1177
15:40:43,596 --> 15:40:47,756
当前用户，我希望您能看到该代码是的，我可以

1178
15:40:47,756 --> 15:40:54,160
看到你可以在这个呃代码中看到所以我们将采用完全相同的

1179
15:40:54,160 --> 15:40:58,240
我们在 um create user 中编写的代码，所以我要扩展你

1180
15:40:58,240 --> 15:41:02,160
可以看到这里我要复制那个代码，你可以

1181
15:41:02,160 --> 15:41:06,796
做同样的事情我们正在做的只是确保在登录后在那里

1182
15:41:06,796 --> 15:41:12,400
当前用户是否可以复制该代码将折叠此然后我要带

1183
15:41:12,400 --> 15:41:16,480
登录并在使用电子邮件和密码登录后立即粘贴

1184
15:41:16,480 --> 15:41:20,080
那个代码没问题，所以这就是现在的那部分

1185
15:41:20,080 --> 15:41:24,080
您现在看到我们再次使用firebase auhexception来处理

1186
15:41:24,080 --> 15:41:29,596
我们做了创建所以让我们去你的登录视图

1187
15:41:29,596 --> 15:41:34,880
看看我们正在处理哪些异常以及哪些异常

1188
15:41:34,880 --> 15:41:39,596
我可以在这里看到我们正在处理这些我实际上要复制整个

1189
15:41:39,596 --> 15:41:44,160
登录视图中的代码您会看到 firebase off 异常用户名错误密码

1190
15:41:44,160 --> 15:41:49,680
等等，包括捕获任何其他异常块在这里复制

1191
15:41:49,680 --> 15:41:54,796
代码并将其带到您的 Firebase 身份验证提供商

1192
15:41:54,796 --> 15:41:57,756
并替换让我实际看看它的外观

1193
15:41:57,756 --> 15:42:02,560
是的

1194
15:42:02,560 --> 15:42:07,596
然后像我们以前一样卸下你的重量，老实说这个这个

1195
15:42:07,596 --> 15:42:10,956
只是说我们大谈特谈

1196
15:42:10,956 --> 15:42:14,640
嗯需要一些来自另一个地方的代码

1197
15:42:14,640 --> 15:42:18,796
带到这里，这样你的代码现在应该看起来像这样，所以它说 on firebase off

1198
15:42:18,796 --> 15:42:22,720
异常，我们正在处理用户未找到错误密码关闭异常

1199
15:42:22,720 --> 15:42:30,000
firebase 和一个通用的 catch 块没关系，所以在用户找不到的情况下

1200
15:42:30,000 --> 15:42:35,116
firebase office 会话我们要说 throw user not found alt 异常

1201
15:42:35,116 --> 15:42:38,796
在密码错误的情况下，我们会说 throw on password boss

1202
15:42:38,796 --> 15:42:42,000
异常和此处可能发生的任何其他情况

1203
15:42:42,000 --> 15:42:45,756
我们只是要抛出通用异常

1204
15:42:45,756 --> 15:42:50,560
在这里我们也会说 throw generic with exception

1205
15:42:50,560 --> 15:42:54,000
我真正喜欢做的是你看到

1206
15:42:54,000 --> 15:42:58,320
dart 在这种情况下还不能说我想忽略一个变量

1207
15:42:58,320 --> 15:43:01,916
你可以看到，在这个我们有一个问题的地方

1208
15:43:01,916 --> 15:43:05,840
我们实际上必须针对异常进行模式匹配，然后我们必须

1209
15:43:05,840 --> 15:43:09,520
为其分配一个名称，该名称在此函数中称为 e 所以如果我

1210
15:43:09,520 --> 15:43:13,040
键入 e，您可以看到它是一个对象，但是正如您在

1211
15:43:13,040 --> 15:43:16,160
这个函数我们实际上对 e 并不感兴趣，我们根本没有使用

1212
15:43:16,160 --> 15:43:20,480
所以在其他语言中可以像在javascript中一样忽略

1213
15:43:20,480 --> 15:43:25,756
python swift rust 可以忽略一个变量并说嘿

1214
15:43:25,756 --> 15:43:28,796
我对这个值不感兴趣，把一个叫做

1215
15:43:28,796 --> 15:43:33,040
下划线或您可以在艺术中做同样的事情的不同之处在于

1216
15:43:33,040 --> 15:43:36,796
在飞镖中，如果你说下划线，你实际上并没有忽略它，变量是

1217
15:43:36,796 --> 15:43:40,956
也在那里，但在这种情况下它只是称为下划线，所以你可以看到

1218
15:43:40,956 --> 15:43:45,916
你仍然可以在上面调用字符串，所以你可能想要这样做，或者你可能只是

1219
15:43:45,916 --> 15:43:49,276
不想管它，因为你可以看到它不给的分析器

1220
15:43:49,276 --> 15:43:53,276
你说是的，你的任何错误

1221
15:43:53,276 --> 15:43:57,200
模式匹配，但你没有使用它，所以这取决于你想怎么做

1222
15:43:57,200 --> 15:44:01,040
我喜欢这样做

1223
15:44:01,040 --> 15:44:05,200
哇，那是很多代码，或者更像是很多解释，所以让我们

1224
15:44:05,200 --> 15:44:08,796
去登录并折叠它，正如你在标题中看到的那样，现在我们必须采取

1225
15:44:08,796 --> 15:44:12,160
照顾注销功能和标题也说这个功能

1226
15:44:12,160 --> 15:44:16,560
需要是异步的，你知道为什么，因为我们要

1227
15:44:16,560 --> 15:44:22,796
在firebase上调用一个函数以处理注销

1228
15:44:22,796 --> 15:44:26,640
所以为了让用户被注销，用户应该实际存在所以让我们

1229
15:44:26,640 --> 15:44:31,116
只是说最终用户需要关闭firebase

1230
15:44:31,116 --> 15:44:34,560
实例，然后我们将说当前用户

1231
15:44:34,560 --> 15:44:40,880
我们说如果用户不为空并且它是用户登录呃注销它是什么

1232
15:44:40,880 --> 15:44:45,436
叫什么或者叫什么哦，我们必须告诉火力基地，所以我们

1233
15:44:45,436 --> 15:44:50,880
然后我们说firebase关闭实例注销

1234
15:44:50,880 --> 15:44:57,040
重量还可以，否则我们说不要扔用户

1235
15:44:57,040 --> 15:45:00,400
登录所以我们基本上在这里说你

1236
15:45:00,400 --> 15:45:04,480
如果该用户不存在或该用户不存在，则无法注销该用户

1237
15:45:04,480 --> 15:45:07,360
登录

1238
15:45:07,360 --> 15:45:11,040
好的很多代码很多描述但是

1239
15:45:11,040 --> 15:45:16,796
没关系，我们现在已经实现了一个 auth provider firebase auth provider

1240
15:45:16,796 --> 15:45:19,756
好的，这是一个具体的实现

1241
15:45:19,756 --> 15:45:24,480
auth provider now 正如标题所示，我们在这里

1242
15:45:24,480 --> 15:45:28,840
需要身份验证服务

1243
15:45:28,840 --> 15:45:33,116
嗯，现在什么是身份验证服务，我之前提到过一点，但是

1244
15:45:33,116 --> 15:45:38,240
身份验证服务也将实施身份验证提供程序

1245
15:45:38,240 --> 15:45:42,240
本身就是一个例子

1246
15:45:42,240 --> 15:45:47,520
身份验证提供程序也是如此，但正如您将在本章和

1247
15:45:47,520 --> 15:45:52,560
这个嗯课程的其余部分你会看到我们的

1248
15:45:52,560 --> 15:45:58,560
我们的身份验证服务实际上只是提供者本身，它是

1249
15:45:58,560 --> 15:46:02,640
暴露我们提供给它的提供者的所有功能

1250
15:46:02,640 --> 15:46:07,596
它不是，它目前绝对没有其他逻辑可以，但是

1251
15:46:07,596 --> 15:46:12,240
我们这样做的原因是为了让我告诉你你需要拥有

1252
15:46:12,240 --> 15:46:15,596
提供者，然后你需要有他们相互交谈的服务

1253
15:46:15,596 --> 15:46:20,480
然后此服务可以向您的用户界面展示更多价值

1254
15:46:20,480 --> 15:46:26,000
您的 ui 代码比提供者所做的通常是服务的情况

1255
15:46:26,000 --> 15:46:30,000
将其他一些供应商融合在一起 与少数人交谈

1256
15:46:30,000 --> 15:46:34,400
提供者，最后它将数据融合在一起并提供

1257
15:46:34,400 --> 15:46:40,160
在我们的情况下，现在向 ui 提供信息，但情况并非如此，好吧，我们的

1258
15:46:40,160 --> 15:46:46,320
firebit 我们的身份验证服务只会与我们给定的身份验证提供者交谈

1259
15:46:46,320 --> 15:46:50,796
并将其所有功能暴露给 ui，但我们正在做这个练习

1260
15:46:50,796 --> 15:46:55,596
你看到了如何抽象出各种功能的点点滴滴

1261
15:46:55,596 --> 15:47:00,480
从 ui 代码中，请记住这就是我们拥有身份验证服务的原因

1262
15:47:00,480 --> 15:47:06,080
我们很快就会创建好的，所以在这里的案例中作为标题让我们

1263
15:47:06,080 --> 15:47:10,720
继续在此处的 auth 文件夹中创建我们的奇怪服务，以便 auth 和

1264
15:47:10,720 --> 15:47:16,640
我要在这里创建一个新文件我只是将其称为所有服务

1265
15:47:16,640 --> 15:47:22,000
在这个 dart 文件中，我们需要创建开始创建我们的

1266
15:47:22,000 --> 15:47:26,400
auth service 好吧，对不起，我会在这里做笔记

1267
15:47:26,400 --> 15:47:30,560
那么我们在这里需要的是

1268
15:47:30,560 --> 15:47:34,720
导入一些我们需要导入我们的身份验证提供程序和关闭用户的东西，所以我

1269
15:47:34,720 --> 15:47:39,116
不再解释这个所以嗯打包我的笔记

1270
15:47:39,116 --> 15:47:44,000
我们有服务关闭，我们有，我们需要导入身份验证

1271
15:47:44,000 --> 15:47:47,680
提供者并复制这种代码，然后我

1272
15:47:47,680 --> 15:47:52,160
我相信要说新闻用户

1273
15:47:52,160 --> 15:47:54,956
所以嗯

1274
15:47:54,956 --> 15:48:00,160
所以让我们看看这里的字幕

1275
15:48:00,160 --> 15:48:03,680
像这样好的，所以我们现在需要尽可能地创建

1276
15:48:03,680 --> 15:48:09,360
看到我们需要创建一个也实现身份验证提供程序的身份验证服务好吧

1277
15:48:09,360 --> 15:48:11,276
所以嗯

1278
15:48:11,276 --> 15:48:14,560
如果我在这里查看标题，为什么身份验证服务是我提供的作者提供者

1279
15:48:14,560 --> 15:48:19,116
已经向您解释了这一点，但您可以看到它说但可以有更多逻辑

1280
15:48:19,116 --> 15:48:23,200
所以这就是原因，好吧，所以不要忘记，所以让我们去创建一个

1281
15:48:23,200 --> 15:48:28,956
此处所有服务的类，它实现了身份验证

1282
15:48:28,956 --> 15:48:33,680
提供者嗯抽象类好

1283
15:48:33,680 --> 15:48:37,596
现在你需要做的是你需要知道的是身份验证服务

1284
15:48:37,596 --> 15:48:42,080
本身不会被硬编码以使用 firebase auth 提供程序

1285
15:48:42,080 --> 15:48:46,160
它要做的是实际上从

1286
15:48:46,160 --> 15:48:48,880
你说好吧，我会暴露

1287
15:48:48,880 --> 15:48:52,160
从该身份验证提供程序到外部世界的功能

1288
15:48:52,160 --> 15:48:55,840
甚至可能在将数据返回给您之前更改该数据的能力，但在我们的

1289
15:48:55,840 --> 15:48:58,880
章，然后是本课程的其余部分

1290
15:48:58,880 --> 15:49:02,560
将向外界公开相同的身份验证提供程序功能，所以

1291
15:49:02,560 --> 15:49:08,080
让我们继续吧，正如标题所说，我们需要一个身份验证提供程序，我们只是

1292
15:49:08,080 --> 15:49:13,276
称它为提供者好吧，我们需要做的就是创建一个

1293
15:49:13,276 --> 15:49:17,360
此处为您的身份验证服务的构造函数，因此命令

1294
15:49:17,360 --> 15:49:21,360
点在 mac 或控制点 windows 和 linux 并说创建构造函数

1295
15:49:21,360 --> 15:49:24,080
final 字段并使其保持不变

1296
15:49:24,080 --> 15:49:28,956
好的，所以现在我们有了这个漂亮的小服务，它需要

1297
15:49:28,956 --> 15:49:32,480
提供者，但正如您所看到的，它说缺少具体的实现和

1298
15:49:32,480 --> 15:49:37,596
那是因为我们说我们的身份验证服务也是身份验证提供者，所以我们必须

1299
15:49:37,596 --> 15:49:43,680
实现这些身份验证提供程序类覆盖，所以让我们添加它们

1300
15:49:43,680 --> 15:49:48,320
也在这里，但是这次实现这些会容易得多

1301
15:49:48,320 --> 15:49:52,880
功能是因为我们的身份验证服务内部有一个提供者和

1302
15:49:52,880 --> 15:49:56,720
它所要做的就是公开

1303
15:49:56,720 --> 15:50:01,360
提供者在自己的实现中可以

1304
15:50:01,360 --> 15:50:03,436
所以嗯

1305
15:50:03,436 --> 15:50:06,880
正如标题还说我们需要委托给我们的

1306
15:50:06,880 --> 15:50:10,160
在我们这样做之前，我会做一个实际的提供者

1307
15:50:10,160 --> 15:50:13,436
在这里稍微清理一下，我建议你在某些地方也这样做

1308
15:50:13,436 --> 15:50:16,480
我们有多个参数让我们在末尾加一个逗号

1309
15:50:16,480 --> 15:50:20,560
最后一个参数在这里和那里繁荣

1310
15:50:20,560 --> 15:50:23,756
这就是我要做的命令

1311
15:50:23,756 --> 15:50:26,880
dart 格式化程序更好地格式化代码

1312
15:50:26,880 --> 15:50:31,276
让我们继续前进并公开我们的功能

1313
15:50:31,276 --> 15:50:36,320
提供者在我们的身份验证的具体实现中

1314
15:50:36,320 --> 15:50:44,080
提供者所以在这里我们说提供者点创建用户电子邮件和密码完美

1315
15:50:44,080 --> 15:50:50,480
对于当前用户，我们返回提供者的当前用户，我们说提供者

1316
15:50:50,480 --> 15:50:56,080
采用当前用户登录，然后公开

1317
15:50:56,080 --> 15:51:01,756
提供者登录功能我们说提供者使用该信息登录

1318
15:51:01,756 --> 15:51:08,480
对于我们的注销我们做同样的事情所以我会说供应商注销好吧

1319
15:51:08,480 --> 15:51:14,320
并且为了发送你，所以说提供商发送电子邮件

1320
15:51:14,320 --> 15:51:19,840
提供者和通知很棒的东西

1321
15:51:19,840 --> 15:51:25,040
如您所见，进展非常快

1322
15:51:25,040 --> 15:51:27,276
现在嗯

1323
15:51:27,276 --> 15:51:32,560
你看我们现在已经做了很多代码如果我们去如果我改变屏幕

1324
15:51:32,560 --> 15:51:36,640
布局稍微好一点，这样你就能更好地看到代码，然后我们开始吧

1325
15:51:36,640 --> 15:51:40,480
到我们的终端内置终端我绝对喜欢它在 Visual Studio 代码中

1326
15:51:40,480 --> 15:51:45,756
有一个集成终端，让我们看看我们的 git 状态

1327
15:51:45,756 --> 15:51:50,796
您会看到我们更改了登录视图，但也有一个全新的

1328
15:51:50,796 --> 15:51:56,400
此处的文件夹称为 lib 服务，因此如果您随后添加所有这些

1329
15:51:56,400 --> 15:52:01,840
并且要获得状态，您会看到我们实际上已经做了很多工作，所以

1330
15:52:01,840 --> 15:52:05,360
如果我增加你看到的大小，我们已经添加了所有异常身份验证提供程序

1331
15:52:05,360 --> 15:52:08,720
服务身份验证用户和 Firebase 身份验证提供者

1332
15:52:08,720 --> 15:52:13,200
加上现在登录视图中的更改

1333
15:52:13,200 --> 15:52:16,480
嗯实际上我不知道我们在登录视图中改变了什么

1334
15:52:16,480 --> 15:52:18,956
所以很有趣知道你是否去

1335
15:52:18,956 --> 15:52:22,400
登录视图我们做了什么我们在登录视图中改变了任何东西

1336
15:52:22,400 --> 15:52:26,640
因为此刻我真的不记得我们是否改变了什么特别的东西

1337
15:52:26,640 --> 15:52:31,840
在登录视图中，因此实际上会很有趣

1338
15:52:31,840 --> 15:52:35,520
看看我们做了什么，所以如果我在这里去我的终端

1339
15:52:35,520 --> 15:52:38,080
如果我发出这个命令，你可以看到

1340
15:52:38,080 --> 15:52:43,360
在这里，我将从登台环境中删除该登录视图

1341
15:52:43,360 --> 15:52:47,520
所以像这样粘贴在那里

1342
15:52:47,520 --> 15:52:52,080
我会说 git status 然后我会说 bit diff 我可以说好的

1343
15:52:52,080 --> 15:52:58,080
不同的是我在这里添加了firebase核心

1344
15:52:58,080 --> 15:53:02,480
我在

1345
15:53:02,480 --> 15:53:07,840
登录视图以及更改的内容

1346
15:53:07,840 --> 15:53:12,400
此导航器是否已被删除

1347
15:53:12,400 --> 15:53:16,080
这里有很多代码可能还没有从

1348
15:53:16,080 --> 15:53:20,000
上一章可能是这样，所以这可能是原因，但仅此而已

1349
15:53:20,000 --> 15:53:25,680
好吧，现在让我们开始吧，然后让我们进入下一个阶段

1350
15:53:25,680 --> 15:53:28,956
你可以看到我们已经做了很多工作让我们确保一切正常

1351
15:53:28,956 --> 15:53:32,796
这次提交好了，所以获取状态所有内容都添加到暂存中

1352
15:53:32,796 --> 15:53:37,200
环境那么我只会说 git commit

1353
15:53:37,200 --> 15:53:43,680
这次是消息和第八步，我将推动所有这些更改

1354
15:53:43,680 --> 15:53:46,720
并获得状态，我可以看到一切都很好

1355
15:53:46,720 --> 15:53:51,680
也让我们标记我们的代码，因为我相信前面的

1356
15:53:51,680 --> 15:53:55,680
章节我们没有标记任何东西，除了之前我们标记了那一步

1357
15:53:55,680 --> 15:54:00,160
七，那是第 22 章，我们在其中讨论了错误处理

1358
15:54:00,160 --> 15:54:03,756
注册表并在注册后进入下一个屏幕，所以我们没有

1359
15:54:03,756 --> 15:54:08,080
标记上一章中的任何内容，所以现在我们将标记内容作为第 8 步

1360
15:54:08,080 --> 15:54:13,756
所以让我们说 git tag step 8 我可以在这里拼写

1361
15:54:13,756 --> 15:54:18,796
如果你可以说 git log ，它也会推送标签，你会看到 get

1362
15:54:18,796 --> 15:54:23,040
第 8 步在那里 第 7 步每一步都有初始提交

1363
15:54:23,040 --> 15:54:27,680
这是第一步，如果你说 git tag 你会看到所有可用的标签

1364
15:54:27,680 --> 15:54:32,080
好吧，所以我们已经承诺并标记了我们已经完成了

1365
15:54:32,080 --> 15:54:35,680
本章有很多工作，我认为我们不需要把它拖下去

1366
15:54:35,680 --> 15:54:40,160
更长，因为是的，如果太长，可能会难以忍受

1367
15:54:40,160 --> 15:54:43,276
现在就像我们通常做的那样，这是传统

1368
15:54:43,276 --> 15:54:47,756
在进入下一章之前，我们为即将到来的事情做好准备

1369
15:54:47,756 --> 15:54:51,276
您可以在缓存中看到我们需要将现有代码迁移到使用

1370
15:54:51,276 --> 15:54:55,520
我们自己的身份验证服务 我们有身份验证服务

1371
15:54:55,520 --> 15:55:00,320
它抽象了提供者，我们有一个 firebase auth 提供者，但我们

1372
15:55:00,320 --> 15:55:04,796
仍然没有使用该代码，所以这正是我们将在

1373
15:55:04,796 --> 15:55:10,160
下一章，如果我在我的笔记中稍微看一下，我实际上可以看到

1374
15:55:10,160 --> 15:55:15,276
下一章也会很长，可能没有这一章那么长

1375
15:55:15,276 --> 15:55:18,560
也许你需要一杯咖啡或茶，所以

1376
15:55:18,560 --> 15:55:22,640
让我们这样做，事不宜迟，我们下一章见

1377
15:55:22,640 --> 15:55:26,480
大家好，欢迎来到 Flutter 课程的第 25 章

1378
15:55:26,480 --> 15:55:30,000
在上一章中，我们谈到了地球服务，这是一个相当大的

1379
15:55:30,000 --> 15:55:35,276
章节我们谈到清理确保我们的身份验证

1380
15:55:35,276 --> 15:55:40,080
相关代码位于我们创建身份验证的一个中心位置

1381
15:55:40,080 --> 15:55:43,756
provider firebase auth provider 然后我们创建

1382
15:55:43,756 --> 15:55:49,200
我们的身份验证服务，我们还确保

1383
15:55:49,200 --> 15:55:54,880
服务和提供者都符合提供的接口

1384
15:55:54,880 --> 15:56:01,756
我们用于身份验证的抽象类，所以我们称它们为关闭服务和

1385
15:56:01,756 --> 15:56:07,596
firebase 身份验证提供程序，然后我们的抽象类被称为身份验证提供程序

1386
15:56:07,596 --> 15:56:11,916
现在我们已经完成了所有这些工作，但我们还没有真正开始使用它

1387
15:56:11,916 --> 15:56:18,400
auth 服务，这就是我们在本章中要做的

1388
15:56:18,400 --> 15:56:21,596
嗯，我们要做的第一件事是

1389
15:56:21,596 --> 15:56:24,640
实际上确保我们可以轻松访问

1390
15:56:24,640 --> 15:56:28,560
我们的服务，嗯，你看到我们创建身份验证的方式

1391
15:56:28,560 --> 15:56:35,840
服务让我把代码带到这里，这样我们都可以看到

1392
15:56:35,840 --> 15:56:42,000
改变视觉工作室代码嗯布局一点点

1393
15:56:42,000 --> 15:56:46,640
然后让我们看看我们的 um 让我看看我是否可以调整它的大小

1394
15:56:46,640 --> 15:56:52,000
好吧，让我们在这里看看我们的身份验证服务，您可以通过这种方式看到

1395
15:56:52,000 --> 15:56:56,240
我们创建我们的关闭服务是它在它的初始化程序或构造函数中

1396
15:56:56,240 --> 15:57:01,756
但是你想称之为嗯它需要一个提供者所以我们能够

1397
15:57:01,756 --> 15:57:06,080
每次您想使用我们的身份验证服务时，我们实际上都会使用我们的身份验证服务

1398
15:57:06,080 --> 15:57:09,596
必须为它提供一个身份验证提供程序，在我们的例子中将是

1399
15:57:09,596 --> 15:57:13,680
它驻留在此处的firebase身份验证提供程序

1400
15:57:13,680 --> 15:57:17,116
所以这可能很麻烦，特别是如果你正在使用 firebase

1401
15:57:17,116 --> 15:57:21,680
每次你想使用它时，你的用户界面中都有很多，那么你需要说

1402
15:57:21,680 --> 15:57:25,680
auth service 初始化 auth 服务，然后初始化你的 firebase auth

1403
15:57:25,680 --> 15:57:30,240
提供者并将其提供给您的身份验证服务，以便

1404
15:57:30,240 --> 15:57:35,436
我们不想每次都这样做，这正是我们需要这样做的原因

1405
15:57:35,436 --> 15:57:40,240
开个工厂呃

1406
15:57:40,240 --> 15:57:44,320
初始化器，您可以在 uh 中看到

1407
15:57:44,320 --> 15:57:47,916
在字幕中，嗯，它说添加firebase

1408
15:57:47,916 --> 15:57:52,240
工厂到官员，这正是我们要在这里做的

1409
15:57:52,240 --> 15:57:56,956
所以让我们去我们的身份验证服务，因为代码是为您提供的，只需编写

1410
15:57:56,956 --> 15:57:59,596
它工厂，我要说 auth

1411
15:57:59,596 --> 15:58:04,400
firebase 中的服务点，因此负责

1412
15:58:04,400 --> 15:58:09,360
这个关闭服务的firebase工厂在这里或抱歉的责任

1413
15:58:09,360 --> 15:58:13,596
firebase 呃工厂在这里

1414
15:58:13,596 --> 15:58:17,916
在我们的关闭服务上是返回我们的身份验证服务的一个实例，它是

1415
15:58:17,916 --> 15:58:23,116
已经配置了 Firebase 身份验证提供程序，所以

1416
15:58:23,116 --> 15:58:27,596
然后我们会说它返回一个身份验证服务的实例

1417
15:58:27,596 --> 15:58:32,160
在屏幕上更改代码的布局，以便您可以更好地看到它

1418
15:58:32,160 --> 15:58:35,596
我们会说 firebase 嗯

1419
15:58:35,596 --> 15:58:42,880
auth provider 好的，那就是这样，嗯，现在你看到我有一个

1420
15:58:42,880 --> 15:58:45,680
Visual Studio 代码中的列，它告诉我代码的去向

1421
15:58:45,680 --> 15:58:51,116
甚至在他们的 uh dart 代码或颤振代码中破坏一些人

1422
15:58:51,116 --> 15:58:55,596
他们更喜欢在它的末尾加上一个逗号，以便它准备好接受新的

1423
15:58:55,596 --> 15:58:59,040
未来的参数，所以如果你这样做，那么嗯

1424
15:58:59,040 --> 15:59:02,796
dart 格式将把你的代码分解成多行准备好

1425
15:59:02,796 --> 15:59:06,320
如果这是您的偏好，您可以输入下一个参数，但我

1426
15:59:06,320 --> 15:59:09,756
在这里没有偏好，当我有一个参数时，我就这样离开

1427
15:59:09,756 --> 15:59:14,240
把它放在一行就可以了

1428
15:59:14,240 --> 15:59:20,560
在我们真正开始使用我们的身份验证服务之前，我们需要采取

1429
15:59:20,560 --> 15:59:25,276
回到主 dart 文件，如标题所示，所以你

1430
15:59:25,276 --> 15:59:29,436
要么去资源管理器，但我通常喜欢这样做的方式是使用命令 p

1431
15:59:29,436 --> 15:59:34,080
我说主要飞镖然后我去那里记住你是linux还是windows

1432
15:59:34,080 --> 15:59:38,560
那么你必须控制 p 好，所以让我们看看我们的主要 dar 文件

1433
15:59:38,560 --> 15:59:43,840
让我们看看我是否可以关闭这些地方 firebase off firebase provider

1434
15:59:43,840 --> 15:59:48,080
登录飞镖我们在那里改变了什么保存为

1435
15:59:48,080 --> 15:59:51,840
好吧，让我们现在回到主要内容，所以基本上我只是关闭了所有文件

1436
15:59:51,840 --> 15:59:55,840
呃，因为我只想把它们放在我们的文件中，所以标题是

1437
15:59:55,840 --> 16:00:02,160
在这里告诉你我们的菜单操作和注释视图现在已经展开

1438
16:00:02,160 --> 16:00:07,116
就在主 dart 文件中，这通常不是一个好主意，因为

1439
16:00:07,116 --> 16:00:10,160
您需要成为您需要的软件开发人员的一部分

1440
16:00:10,160 --> 16:00:15,360
确保您的代码是干净的，并且现在其他人很容易阅读

1441
16:00:15,360 --> 16:00:20,400
我不是说我的意思是我不是一个真正相信代码必须如此的人

1442
16:00:20,400 --> 16:00:23,680
很容易理解，即使你从街上随便抓一个人，他们

1443
16:00:23,680 --> 16:00:27,680
必须理解代码，因为有时您需要确保

1444
16:00:27,680 --> 16:00:32,240
查看您的代码的人具有一定的知识水平

1445
16:00:32,240 --> 16:00:35,680
但是话虽如此，您需要确保您的代码易于

1446
16:00:35,680 --> 16:00:40,000
理解并阅读，让我们确保菜单操作和

1447
16:00:40,000 --> 16:00:45,276
笔记视图被重构并且它们在正确的位置，而不仅仅是

1448
16:00:45,276 --> 16:00:50,480
在主 dart 文件中传播，以便标题表明我们要

1449
16:00:50,480 --> 16:00:56,320
将我们的菜单操作移动到 lib 中名为 enums 的新文件夹中

1450
16:00:56,320 --> 16:01:00,720
并且文件名将是菜单操作点 dart 和

1451
16:01:00,720 --> 16:01:04,640
标题有点不对，它不应该是黑暗的 10 它应该是飞镖

1452
16:01:04,640 --> 16:01:10,720
所以我要保存标题并将其重新显示出来，以便正确显示

1453
16:01:10,720 --> 16:01:16,240
文件扩展名，所以让我们去创建那个文件吧

1454
16:01:16,240 --> 16:01:21,200
我要在这里进入 lib 我要右键单击 lib 我要说新文件

1455
16:01:21,200 --> 16:01:24,720
在新文件中，我将输入 ins

1456
16:01:24,720 --> 16:01:28,480
并把它也提出来，让你看得更清楚

1457
16:01:28,480 --> 16:01:33,756
或者您在所有枚举中看到它，然后在菜单操作中看到它。好的

1458
16:01:33,756 --> 16:01:37,200
对不起，让我们去抓住那个菜单动作

1459
16:01:37,200 --> 16:01:42,400
从那里将其粘贴到此菜单操作中并保存该文件，好吧，不要

1460
16:01:42,400 --> 16:01:45,680
担心 main.dart 目前有问题，因为菜单操作没有

1461
16:01:45,680 --> 16:01:48,880
这里不再存在了，所以我们遇到了一些错误，没关系，我们要修复

1462
16:01:48,880 --> 16:01:54,320
那让我们现在去我们的嗯

1463
16:01:54,320 --> 16:01:59,360
再次到主暗文件，我们必须清理此注释视图，并作为

1464
16:01:59,360 --> 16:02:01,756
标题在我们要将其移入的情况下

1465
16:02:01,756 --> 16:02:06,640
lib views notes view 好的，我们已经有了可以记住的 views 文件夹

1466
16:02:06,640 --> 16:02:11,040
在我们要做的只是将此注释视图移动到它自己的文件之前

1467
16:02:11,040 --> 16:02:14,240
所以我要右键单击视图，我要说

1468
16:02:14,240 --> 16:02:18,796
笔记查看点飞镖

1469
16:02:18,796 --> 16:02:24,400
好吧，让我们去主守卫抓住笔记视图和它的状态，从那里开始

1470
16:02:24,400 --> 16:02:28,000
笔记查看有状态的小部件，我将抓住所有这些

1471
16:02:28,000 --> 16:02:31,436
我们甚至会

1472
16:02:31,436 --> 16:02:37,596
带上显示注销对话框并带上它

1473
16:02:37,596 --> 16:02:42,640
记下 2 并粘贴到那里，好吧，所以现在我们有很多问题，因为呃

1474
16:02:42,640 --> 16:02:48,160
正如我之前提到的那样，在一个空的飞镖文件中没有材料导入，所以我

1475
16:02:48,160 --> 16:02:52,640
现在要进行材料导入所以命令点并说导入库

1476
16:02:52,640 --> 16:02:56,240
包装花卉材料，这将解决那些进口问题

1477
16:02:56,240 --> 16:03:00,796
现在给你的那些错误这个文件没有它没有

1478
16:03:00,796 --> 16:03:04,796
导入了 uh 菜单操作，所以让我们也修复它

1479
16:03:04,796 --> 16:03:08,400
使用 Visual Studio 命令点并从 Visual Studio 代码中获得帮助

1480
16:03:08,400 --> 16:03:14,560
自动导入我们的菜单动作 dart 文件好吗

1481
16:03:14,560 --> 16:03:21,520
所以这也是固定的，现在在笔记视图中也记得现在也是

1482
16:03:21,520 --> 16:03:25,360
关闭firebase，我们将在本章中修复一些人，以便

1483
16:03:25,360 --> 16:03:29,520
note2 不是或我们的任何观点，他们都不会直接与之交谈

1484
16:03:29,520 --> 16:03:32,796
firebase 所以这将在本章结束时修复

1485
16:03:32,796 --> 16:03:36,956
但是现在让我们继续清理它并确保firebase auth

1486
16:03:36,956 --> 16:03:43,116
被导入并且还记得当我们注销时这里使用了登录路由

1487
16:03:43,116 --> 16:03:48,720
应用程序的主界面，因此当我们注销时，它会将我们发送回

1488
16:03:48,720 --> 16:03:53,040
登录路线，在我们的路线中定义

1489
16:03:53,040 --> 16:03:58,640
dart 文件在这里，所以让我们也导入它，对不起

1490
16:03:58,640 --> 16:04:02,640
好的，我们已经做了很多工作，我们现在已经完成了，所以我们完成了

1491
16:04:02,640 --> 16:04:07,116
所以我要保存这个notes view dot dart

1492
16:04:07,116 --> 16:04:09,916
现在我们需要回去

1493
16:04:09,916 --> 16:04:14,240
到主要飞镖并解决我们需要导入的这个问题

1494
16:04:14,240 --> 16:04:18,720
笔记视图呃从视觉工作室代码或你最喜欢的编辑器或

1495
16:04:18,720 --> 16:04:22,640
如果您的编辑器中没有此功能 如果您正在使用 vim 或

1496
16:04:22,640 --> 16:04:25,840
您可能只需要手动导入一些东西，而导入只是

1497
16:04:25,840 --> 16:04:31,436
您的应用程序视图的包名称注释视图好的，所以我要

1498
16:04:31,436 --> 16:04:34,160
从视觉工作室代码获得帮助来做到这一点

1499
16:04:34,160 --> 16:04:36,640
伟大的

1500
16:04:36,640 --> 16:04:39,680
所以嗯

1501
16:04:39,680 --> 16:04:43,200
现在让我们来看看我们之前实际上忘记的东西

1502
16:04:43,200 --> 16:04:46,880
章节嗯，你看，我们已经完成了我们的所有内容

1503
16:04:46,880 --> 16:04:51,276
关闭服务，如果您查看我们的身份验证服务，它几乎拥有所有

1504
16:04:51,276 --> 16:04:55,360
我们需要它的功能创建视图抱歉创建用户它有

1505
16:04:55,360 --> 16:04:59,916
当前用户已登录注销并发送电子邮件验证，但有一个

1506
16:04:59,916 --> 16:05:04,956
我们忘记的细节让我们去主要飞镖看看

1507
16:05:04,956 --> 16:05:09,840
你可以在这里看到我们的整个主要飞镖

1508
16:05:09,840 --> 16:05:15,436
就像主页构建功能是围绕我的未来构建器构建的

1509
16:05:15,436 --> 16:05:19,436
知道我说的是建立了很多也许我应该说它是旋转的 它正在旋转

1510
16:05:19,436 --> 16:05:24,480
围绕一个未来的构建器，它反过来初始化你看到它调用的firebase

1511
16:05:24,480 --> 16:05:29,520
firebase 初始化应用程序，现在我们想要远离我们的用户

1512
16:05:29,520 --> 16:05:33,276
直接与firebase交互的界面我们

1513
16:05:33,276 --> 16:05:37,916
还需要解决这个不应该去的用户界面

1514
16:05:37,916 --> 16:05:42,796
直接火力基地，理想情况下应该去我们的

1515
16:05:42,796 --> 16:05:47,436
停止服务，这就是标题所说的

1516
16:05:47,436 --> 16:05:55,040
所以现在让我们转到我们的身份验证提供者抽象类，让我们

1517
16:05:55,040 --> 16:05:58,000
关闭所有这些文件确保所有内容都已保存

1518
16:05:58,000 --> 16:06:02,560
让我们去我们的关闭供应商，并确保我们有一个功能

1519
16:06:02,560 --> 16:06:07,200
在那里，让我真正拿出我的笔记

1520
16:06:07,200 --> 16:06:12,720
说初始化所以我们要说未来无效

1521
16:06:12,720 --> 16:06:16,160
初始化好的记住现在我们已经添加了这个

1522
16:06:16,160 --> 16:06:19,756
对我们的身份验证提供程序起作用，我们将遇到问题，因为

1523
16:06:19,756 --> 16:06:24,720
他们目前符合的 firebase 身份验证提供程序和身份验证服务

1524
16:06:24,720 --> 16:06:28,880
作者提供者抽象类并向该抽象添加新功能

1525
16:06:28,880 --> 16:06:33,436
class 意味着我们会得到两个错误，表明这个函数

1526
16:06:33,436 --> 16:06:37,596
未在 firebase 身份验证提供程序和我们的身份验证服务中实现，因此我们

1527
16:06:37,596 --> 16:06:44,080
需要解决这些问题，您可以看到它们实际上在此处突出显示为红色

1528
16:06:44,080 --> 16:06:47,840
好的嗯

1529
16:06:47,840 --> 16:06:52,160
让我们转到下一个标题

1530
16:06:52,160 --> 16:06:57,040
我要摆脱那个底部视图所以它不会打扰我们所以我们走吧

1531
16:06:57,040 --> 16:07:00,956
现在您可以在 firebase auth 提供程序中看到并覆盖初始化和

1532
16:07:00,956 --> 16:07:05,276
使其异步并在firebase上调用初始化应用程序

1533
16:07:05,276 --> 16:07:10,160
所以为了做firebase初始化代码，我们需要看看

1534
16:07:10,160 --> 16:07:13,360
在我们的主要飞镖上，看看现在是如何完成的，你可以看到它是

1535
16:07:13,360 --> 16:07:17,596
称为firebase初始化应用程序，所以我要获取该代码，我建议

1536
16:07:17,596 --> 16:07:22,160
你做同样的事情我只是要复制代码来初始化应用程序

1537
16:07:22,160 --> 16:07:27,116
然后让我们去我们的firebase auth provider

1538
16:07:27,116 --> 16:07:30,640
并从 Visual Studio Code 或 android Studio 获得帮助以完成该操作

1539
16:07:30,640 --> 16:07:33,596
初始化函数缺少一个覆盖

1540
16:07:33,596 --> 16:07:37,840
我相信它会被添加到这里的某个地方

1541
16:07:37,840 --> 16:07:41,360
或者它没有去哪里

1542
16:07:41,360 --> 16:07:46,956
我们应该初始化一个缺失的混凝土

1543
16:07:46,956 --> 16:07:55,916
创建一个丢失的覆盖初始化我仍然没有看到丢失的

1544
16:07:55,916 --> 16:08:01,276
我会在这里自己做，future void 像这样初始化好吗

1545
16:08:01,276 --> 16:08:05,520
呃，我们要做的，正如名字所暗示的那样，它将是一个异步的

1546
16:08:05,520 --> 16:08:11,680
这里的功能，我们需要做的只是保存firebase初始化应用程序所以

1547
16:08:11,680 --> 16:08:14,796
嗯，我们会等待这个，就像

1548
16:08:14,796 --> 16:08:18,160
记住我们有我们需要有两个

1549
16:08:18,160 --> 16:08:22,796
在此处导入，一个用于 firebase，另一个用于默认 firebase

1550
16:08:22,796 --> 16:08:26,956
选项，所以让我们从 Visual Studio 代码中获得帮助来导入这些 Firebase

1551
16:08:26,956 --> 16:08:29,680
核心和进口

1552
16:08:29,680 --> 16:08:34,400
firebase options dark 文件，如果您还记得我们何时设置 firebase

1553
16:08:34,400 --> 16:08:39,200
最初是从 firebase cli 引入我们的应用程序的

1554
16:08:39,200 --> 16:08:42,956
is 不是我们自己创建的文件，除了它是 firebase cli

1555
16:08:42,956 --> 16:08:46,560
为我们创造了这个，好吧

1556
16:08:46,560 --> 16:08:50,480
现在这里它说对成员进行注释，这正是我们需要做的

1557
16:08:50,480 --> 16:08:53,116
让我们再说一遍

1558
16:08:53,116 --> 16:08:58,796
就像这样，现在我们已经初始化了我们作者的成员

1559
16:08:58,796 --> 16:09:01,916
firebase 作者提供者中的提供者，所以

1560
16:09:01,916 --> 16:09:05,756
基本上我们所说的是firebase auth提供者实现初始化

1561
16:09:05,756 --> 16:09:10,400
功能，它有实际的实现还可以

1562
16:09:10,400 --> 16:09:14,796
好吧，我们还有一个错误，那是在身份验证服务中，所以让我们开始吧

1563
16:09:14,796 --> 16:09:19,040
进行身份验证服务，我们将遇到完全相同的问题

1564
16:09:19,040 --> 16:09:23,276
在这里说缺少具体的实现，所以我要看看我能不能

1565
16:09:23,276 --> 16:09:27,756
获取 Visual Studio 代码以添加该实现并将其添加到此处

1566
16:09:27,756 --> 16:09:32,796
初始化好，所以在这里我们要做的就是

1567
16:09:32,796 --> 16:09:38,720
将此功能委托给实际的提供者，所以我们要说提供者

1568
16:09:38,720 --> 16:09:43,436
我们会说初始化就像那样，所以这很容易

1569
16:09:43,436 --> 16:09:45,840
一个，如果你不记得

1570
16:09:45,840 --> 16:09:48,956
上一章，或者你跳过了上一章，我不知道

1571
16:09:48,956 --> 16:09:52,240
如果你没有看过前一章，你是如何进入这一章的

1572
16:09:52,240 --> 16:09:56,640
强烈建议您这样做，我们提供关闭服务是有原因的

1573
16:09:56,640 --> 16:10:00,080
实现身份验证提供程序，其背后的原因是

1574
16:10:00,080 --> 16:10:05,756
通常，服务中的逻辑比它们的逻辑要多

1575
16:10:05,756 --> 16:10:09,756
如果一个服务有两个其他服务连接到

1576
16:10:09,756 --> 16:10:13,840
本身那么它实际上可能会从服务和其他

1577
16:10:13,840 --> 16:10:18,400
来自另一个服务的点点滴滴，并将它们与一些额外的逻辑融合在一起

1578
16:10:18,400 --> 16:10:23,200
这正是作者作为一个奇怪的提供者服务的原因，所以目标

1579
16:10:23,200 --> 16:10:27,916
对我们来说是让官员比作者提供者做更多的工作

1580
16:10:27,916 --> 16:10:32,160
尽管现在它所做的只是将其所有功能委托给

1581
16:10:32,160 --> 16:10:36,880
身份验证提供者，记住你也可以看到确保我的意思是如果你

1582
16:10:36,880 --> 16:10:41,520
不喜欢这个实现你可以例如删除它然后

1583
16:10:41,520 --> 16:10:46,480
基本上删除所有这些功能，这样做你只是说

1584
16:10:46,480 --> 16:10:50,000
身份验证服务包括一个关闭的提供者，这就是你正在做的，或者你可以

1585
16:10:50,000 --> 16:10:55,436
完全杀死你的服务，所以这取决于你，但如果你跟随

1586
16:10:55,436 --> 16:10:59,200
除了这门课程，我建议你保持原样

1587
16:10:59,200 --> 16:11:03,756
因为这是有道理的所以

1588
16:11:03,756 --> 16:11:07,840
好的，现在我们已经完成了，嗯，是时候

1589
16:11:07,840 --> 16:11:12,480
做一些清理工作，这是一个非常令人兴奋的部分，呃

1590
16:11:12,480 --> 16:11:17,360
章，因为我们现在有我们的身份验证服务和我们的 firebase 身份验证提供程序

1591
16:11:17,360 --> 16:11:22,560
此外，我们还有一个关闭服务的火力基地工厂，它允许我们

1592
16:11:22,560 --> 16:11:26,880
到我们代码中的任何地方，我们都可以说 autoservice.firebase

1593
16:11:26,880 --> 16:11:32,956
这样我们就可以访问我们的 um firebase auth provider

1594
16:11:32,956 --> 16:11:37,520
身份验证服务，所以它真的很神奇，你很快就会看到它

1595
16:11:37,520 --> 16:11:41,916
所以我要在这里关闭所有文件，确保所有文件都保存为

1596
16:11:41,916 --> 16:11:47,276
标题表示我将进入主要艺术文件

1597
16:11:47,276 --> 16:11:51,680
主飞镖，你可以看到它说删除

1598
16:11:51,680 --> 16:11:56,240
与firebase相关的所有内容并通过导入替换为身份验证服务

1599
16:11:56,240 --> 16:12:01,520
身份验证服务还可以，所以这样做的一种方法就是确保您去

1600
16:12:01,520 --> 16:12:06,000
从源头杀死它，这样你就可以在这里看到我们有两个 firebase 导入，如果

1601
16:12:06,000 --> 16:12:08,956
您删除了这两个 firebase 进口

1602
16:12:08,956 --> 16:12:13,520
我通常使用软件的首选方式是我尝试喜欢删除

1603
16:12:13,520 --> 16:12:17,756
从它的源头中得到一些东西，所以现在我已经删除了那些然后视觉工作室是

1604
16:12:17,756 --> 16:12:22,000
告诉我，嘿，你在两个需要修复的地方使用了 firebase

1605
16:12:22,000 --> 16:12:24,956
这是因为你没有进口那么我知道好吧

1606
16:12:24,956 --> 16:12:28,880
这是我必须进行重构的两个地方

1607
16:12:28,880 --> 16:12:31,116
所以你可以在这里看到它说firebase

1608
16:12:31,116 --> 16:12:34,480
初始化应用程序，我们需要确保我们不再这样做了

1609
16:12:34,480 --> 16:12:40,640
我们只想说在这种情况下我们的未来记住是嗯

1610
16:12:40,640 --> 16:12:45,436
这是身份验证服务，因为我还没有导入它，但视觉工作室是

1611
16:12:45,436 --> 16:12:49,040
提供自动导入它，所以我会说是的

1612
16:12:49,040 --> 16:12:52,880
嗯，它现在是自动导入的，但如果你不想，如果你正在工作

1613
16:12:52,880 --> 16:12:57,756
使用 vim 或其他一些不具备该功能的文本编辑器

1614
16:12:57,756 --> 16:13:01,360
可以将其导入

1615
16:13:01,360 --> 16:13:04,956
这种方式每个包你的包的名称

1616
16:13:04,956 --> 16:13:09,520
services off auth service dart 我只是注意到这是另一个

1617
16:13:09,520 --> 16:13:12,796
我现在要删除的 firebase 导入

1618
16:13:12,796 --> 16:13:17,596
对不起，现在我们想告诉您身份验证服务

1619
16:13:17,596 --> 16:13:22,560
因为我们使用的是firebase，所以我们要说auth service dot firebase and in

1620
16:13:22,560 --> 16:13:27,360
在这里，我们只是说初始化好，这样就可以完美地适应

1621
16:13:27,360 --> 16:13:32,956
在这里你可以看到我们正在使用firebase um

1622
16:13:32,956 --> 16:13:36,720
instance firebase auth instance current user 在这种情况下，我们将要

1623
16:13:36,720 --> 16:13:43,436
说呃关闭服务点我们的基础人员当前用户就像

1624
16:13:43,436 --> 16:13:48,560
好吧，现在记得奇怪，我在前面的章节中谈到了这个，但是

1625
16:13:48,560 --> 16:13:53,040
我更喜欢在单词 is 前加上布尔标志前缀

1626
16:13:53,040 --> 16:13:56,560
只要有意义，在这种情况下，您就可以看到 firebase 实现

1627
16:13:56,560 --> 16:14:00,400
已验证电子邮件，但我们已验证电子邮件，所以我要说的是电子邮件

1628
16:14:00,400 --> 16:14:03,520
可以这样验证

1629
16:14:03,520 --> 16:14:09,200
and s or control x and linux and windows a command is on mac on to save this file

1630
16:14:09,200 --> 16:14:12,320
现在看起来还不错，但我们不是

1631
16:14:12,320 --> 16:14:18,480
真的完成了，我们的登录视图也有问题

1632
16:14:18,480 --> 16:14:23,756
我的意思是问题不是错误或警告，而是我们正在使用的问题

1633
16:14:23,756 --> 16:14:29,596
firebase 直接，我们将在登录视图中直接进入 firebase auth

1634
16:14:29,596 --> 16:14:32,480
我们需要修复，因为您可以看到字幕系统登录视图删除

1635
16:14:32,480 --> 16:14:37,596
firebase 并用关闭服务替换好的

1636
16:14:37,596 --> 16:14:44,640
所以让我们去 uh 的源头并从

1637
16:14:44,640 --> 16:14:48,320
你的登录视图命令，现在你会看到我们有一个

1638
16:14:48,320 --> 16:14:55,116
这里有很多问题，一二三是的，就是这样，三三个地方

1639
16:14:55,116 --> 16:15:00,720
我们需要修复所以让我们继续修复那些地方

1640
16:15:00,720 --> 16:15:05,360
因为是的，嗯，这里有很多事情要处理，所以我们开始

1641
16:15:05,360 --> 16:15:08,880
此刻，我们说的是 firebase off 使用电子邮件即时登录

1642
16:15:08,880 --> 16:15:12,640
和密码，我们需要做的就是呃

1643
16:15:12,640 --> 16:15:18,320
取消我们的服务，所以我们会说 auth service 和

1644
16:15:18,320 --> 16:15:22,720
自动导入和身份验证服务具有 Firebase 身份验证

1645
16:15:22,720 --> 16:15:29,116
提供商，然后我们会说分配或我们说登录是的电子邮件

1646
16:15:29,116 --> 16:15:33,520
密码好的，所以我要按原样使用此代码

1647
16:15:33,520 --> 16:15:38,080
我没有把它们粘贴在这里

1648
16:15:38,080 --> 16:15:43,520
所以现在我们说auth service firebase login没问题

1649
16:15:43,520 --> 16:15:47,520
然后我们在这里看到我们正在获取当前用户和权限

1650
16:15:47,520 --> 16:15:51,596
现在获取当前用户的方法是停止服务

1651
16:15:51,596 --> 16:15:56,640
dot firebase 当前用户和验证的电子邮件应该是 ms 电子邮件

1652
16:15:56,640 --> 16:16:02,000
验证没问题，所以现在我们通过解决所有问题来解决这方面的问题

1653
16:16:02,000 --> 16:16:07,596
搜索而不是直接进入 firebase

1654
16:16:07,596 --> 16:16:13,116
好吧，那就是现在我们需要开始看看我们的错误

1655
16:16:13,116 --> 16:16:18,000
处理，你可以在这里看到我们在火力基地关闭

1656
16:16:18,000 --> 16:16:24,560
例外所以我们需要用各种 um 修复这些

1657
16:16:24,560 --> 16:16:28,160
其他异常处理不是firebase auth

1658
16:16:28,160 --> 16:16:32,000
例外，但现在记住我们有自己的

1659
16:16:32,000 --> 16:16:37,116
auth exception start 中的异常和

1660
16:16:37,116 --> 16:16:40,880
这些都来自例外，但我们是什么

1661
16:16:40,880 --> 16:16:43,520
要做的是我们会喜欢上

1662
16:16:43,520 --> 16:16:48,720
诸如此类的各种例外，您很快就会看到，所以我是

1663
16:16:48,720 --> 16:16:54,480
我要做的是我要接受这段代码并保持原样

1664
16:16:54,480 --> 16:16:59,360
像那样，我要添加新的声明所以

1665
16:16:59,360 --> 16:17:02,240
嗯，让我们照顾未找到的用户，所以我

1666
16:17:02,240 --> 16:17:06,480
会说用户未找到异常，你可以看到它说用户没有

1667
16:17:06,480 --> 16:17:09,596
found exception 是我们手动创建但未导入的异常

1668
16:17:09,596 --> 16:17:13,680
在这里，因为它在 auth exceptions dart 文件中，所以我要说

1669
16:17:13,680 --> 16:17:17,756
视觉工作室代码请完成并为我导入它好吗

1670
16:17:17,756 --> 16:17:24,880
所以说在这种情况下，我们必须做显示错误对话框所以抓住那个代码和

1671
16:17:24,880 --> 16:17:29,596
把它放在这里好吧，然后我们要说

1672
16:17:29,596 --> 16:17:33,916
我们还有什么密码错误

1673
16:17:33,916 --> 16:17:40,000
因为这就是我要说的关于错误密码的异常

1674
16:17:40,000 --> 16:17:45,200
然后进入这里，然后从这里抓取你的显示错误对话框

1675
16:17:45,200 --> 16:17:48,080
把它放在那里好吗

1676
16:17:48,080 --> 16:17:51,916
然后我们还需要打开

1677
16:17:51,916 --> 16:17:56,796
通用身份验证异常等通用身份验证异常

1678
16:17:56,796 --> 16:18:02,480
我们这样做显示错误我喜欢这里的方式

1679
16:18:02,480 --> 16:18:06,400
那么我们去把它带到这里，你可以看到通用错误关闭

1680
16:18:06,400 --> 16:18:10,160
例外，我们没有任何特定的类似信息，如任何 e 或任何东西

1681
16:18:10,160 --> 16:18:13,756
串起来，所以我们在这里要做的就是说我们要说

1682
16:18:13,756 --> 16:18:18,480
身份验证错误好吧，然后你需要去删除

1683
16:18:18,480 --> 16:18:22,000
其他 catch 块，所以你的代码应该

1684
16:18:22,000 --> 16:18:28,720
基本上看起来像这样还可以，所以一个 try 块，然后是三个

1685
16:18:28,720 --> 16:18:34,080
一个接一个的特殊异常处理

1686
16:18:34,080 --> 16:18:39,040
现在您的登录视图上的命令很棒，您应该不会有任何问题

1687
16:18:39,040 --> 16:18:44,560
登录视图，并且在您的登录视图中没有导入firebase

1688
16:18:44,560 --> 16:18:48,400
在主 dart 文件中，让我们确保没有 firebase

1689
16:18:48,400 --> 16:18:53,756
在这里导入 firebase 是的 firebase 是的 没有进口

1690
16:18:53,756 --> 16:18:57,596
firebase 很棒 [音乐]

1691
16:18:57,596 --> 16:19:02,240
正如标题现在所说，我们需要去注册视图并删除firebase

1692
16:19:02,240 --> 16:19:06,720
并用身份验证服务替换，因为我们现在已经完成了相同的练习

1693
16:19:06,720 --> 16:19:10,640
登录视图你现在应该基本上知道我们在注册视图中要做什么

1694
16:19:10,640 --> 16:19:14,080
我们将进行与在登录视图中所做的几乎完全相同的事情，除了

1695
16:19:14,080 --> 16:19:19,200
在注册表中从导入中删除 firebase 会得到我们遇到的所有错误

1696
16:19:19,200 --> 16:19:23,360
得到，在得到这些错误之后，我们将解决问题

1697
16:19:23,360 --> 16:19:27,040
在注册中，让我们继续做吧

1698
16:19:27,040 --> 16:19:30,956
让我们去我们的进口那里我们要进口的火力基地

1699
16:19:30,956 --> 16:19:35,756
删除它，现在我们可能有很多错误是的

1700
16:19:35,756 --> 16:19:39,596
那很好，让我们去解决我要去的问题

1701
16:19:39,596 --> 16:19:44,160
去我的笔记只是为了确保我遵循所有的

1702
16:19:44,160 --> 16:19:48,160
我应该告诉你的笔记

1703
16:19:48,160 --> 16:19:50,956
然后我们不使用电子邮件创建用户和

1704
16:19:50,956 --> 16:19:54,560
我们的身份验证服务器中的密码，所以我们只说所有服务

1705
16:19:54,560 --> 16:19:59,276
它没有被导入，所以让我们自动导入它 dot firebase，我们要

1706
16:19:59,276 --> 16:20:05,360
说标志，我们称之为什么创建用户电子邮件和密码

1707
16:20:05,360 --> 16:20:10,956
在最后一个参数的末尾获取代码并替换您的 Firebase 身份验证

1708
16:20:10,956 --> 16:20:16,796
使用我们的身份验证服务创建用户电子邮件和密码

1709
16:20:16,796 --> 16:20:19,436
好的，在我们得到的地方

1710
16:20:19,436 --> 16:20:25,596
用户让我们说 auth service firebase 我们会说 current

1711
16:20:25,596 --> 16:20:30,160
用户，现在我们已经发送电子邮件验证

1712
16:20:30,160 --> 16:20:34,160
但我认为我们称它为我们所说的其他东西

1713
16:20:34,160 --> 16:20:37,840
哦，我们没有实现发送电子邮件

1714
16:20:37,840 --> 16:20:43,756
验证还是我们让我去身份验证服务

1715
16:20:43,756 --> 16:20:46,880
然后发送电子邮件验证是的

1716
16:20:46,880 --> 16:20:51,360
就在那里，所以我要哦，我明白了，因为以前

1717
16:20:51,360 --> 16:20:55,200
发生的事情是firebase实现发送电子邮件

1718
16:20:55,200 --> 16:21:00,240
在用户级别进行验证，但我们没有，我们不再想要了

1719
16:21:00,240 --> 16:21:05,116
而我们的用户实际上没有这个功能

1720
16:21:05,116 --> 16:21:08,640
一个布尔标志，所以我们需要在这里做的是

1721
16:21:08,640 --> 16:21:13,116
会要求我们的服务发送电子邮件验证，所以我们会说

1722
16:21:13,116 --> 16:21:18,320
火灾和身份验证服务，这只是发送电子邮件验证

1723
16:21:18,320 --> 16:21:21,436
喜欢

1724
16:21:21,436 --> 16:21:24,796
好的，那么我们需要将这些异常修复为

1725
16:21:24,796 --> 16:21:27,840
好吧，因为正如您在登录视图中看到的那样，我们没有 firebase auth

1726
16:21:27,840 --> 16:21:32,000
在这种情况下出现异常，就像我们删除了 ui 一样

1727
16:21:32,000 --> 16:21:36,640
通过删除所有导入直接与firebase对话的能力所以现在我们

1728
16:21:36,640 --> 16:21:39,680
需要确保我们像在登录时一样处理异常

1729
16:21:39,680 --> 16:21:44,400
好吧，让我们继续说

1730
16:21:44,400 --> 16:21:47,040
嗯

1731
16:21:47,040 --> 16:21:50,640
每个密码，因为我认为这是我们处理的第一个密码

1732
16:21:50,640 --> 16:21:54,796
嗯，我的意思是你看到几乎整个屏幕现在都是红色的，这是其中之一

1733
16:21:54,796 --> 16:21:59,040
使用我在第一个中谈到的扩展的缺点

1734
16:21:59,040 --> 16:22:02,240
本课程中我使用扩展程序的章节

1735
16:22:02,240 --> 16:22:07,596
称为空气透镜和空气透镜扩展并扩大了所有的误差，

1736
16:22:07,596 --> 16:22:12,320
否则只会在扩展它们的线条旁边出现小图标

1737
16:22:12,320 --> 16:22:16,720
放到他们自己单独的行中，这有点让代码看起来有点

1738
16:22:16,720 --> 16:22:21,360
当您对代码进行重大更改但不这样做时，有时会生气

1739
16:22:21,360 --> 16:22:25,360
担心它只是看看你的语法，看看是的，我是

1740
16:22:25,360 --> 16:22:28,956
有点做正确的事我会尽快修复它所以不要被吓倒

1741
16:22:28,956 --> 16:22:34,480
在这里所有这些红旗都可以，或者这些红线

1742
16:22:34,480 --> 16:22:39,680
所以让我们处理弱密码异常现在它会有点

1743
16:22:39,680 --> 16:22:43,916
在这里安静点，然后抓住你的显示错误对话框

1744
16:22:43,916 --> 16:22:46,796
从那里开始，这是一周的密码

1745
16:22:46,796 --> 16:22:51,680
就这样放在这里，嗯

1746
16:22:51,680 --> 16:22:54,956
那么我们需要处理我们的

1747
16:22:54,956 --> 16:23:01,360
电子邮件已在使用中 电子邮件已在使用中 例外

1748
16:23:01,360 --> 16:23:05,520
然后我们将已经从电子邮件中获取代码并使用它只是一个

1749
16:23:05,520 --> 16:23:10,240
更短的对话放在那里好吧

1750
16:23:10,240 --> 16:23:15,276
像那样，我们也需要处理

1751
16:23:15,276 --> 16:23:22,320
无效的电子邮件，所以我要在这里说无效电子邮件关闭异常

1752
16:23:22,320 --> 16:23:27,596
让我们从无效电子邮件异常中获取代码

1753
16:23:27,596 --> 16:23:30,240
和

1754
16:23:30,240 --> 16:23:35,916
并且那部分也完成了，我们也需要在通用 als 上

1755
16:23:35,916 --> 16:23:40,480
异常，所以让我们进入这里，只说通用身份验证异常

1756
16:23:40,480 --> 16:23:45,040
让我们处理那个肩膀对话

1757
16:23:45,040 --> 16:23:49,436
实际上这就是我们为通用身份验证异常所做的，所以我要走了

1758
16:23:49,436 --> 16:23:53,520
抓住那个代码把它放在那里，因为通用关闭

1759
16:23:53,520 --> 16:23:59,360
例外我们不接受任何 e 所以我们不会说 on catch like e like

1760
16:23:59,360 --> 16:24:04,000
我们本可以做到这一点，但我们只是完全忽略了 e 和 in

1761
16:24:04,000 --> 16:24:07,840
在这里，我们只会说注册失败

1762
16:24:07,840 --> 16:24:10,956
然后让我们清理其余代码删除其他 cat 语句

1763
16:24:10,956 --> 16:24:14,720
好的，所以你的代码现在基本上看起来像这样干净，所以你有一个

1764
16:24:14,720 --> 16:24:19,756
尝试阻止，然后您说好的，我正在这里尝试此代码创建用户

1765
16:24:19,756 --> 16:24:24,160
如果发生弱密码身份验证异常，请执行此操作如果电子邮件已在使用中，请执行此操作

1766
16:24:24,160 --> 16:24:30,240
如果电子邮件无效，请执行此操作或任何其他身份验证异常，请执行此操作

1767
16:24:30,240 --> 16:24:34,880
它在我眼里看起来更干净，至少我们现在做的方式比我们以前的方式

1768
16:24:34,880 --> 16:24:39,276
在我们去firebase和firebase之前做这个

1769
16:24:39,276 --> 16:24:43,116
在firebase auth异常上执行此操作，否则执行此操作

1770
16:24:43,116 --> 16:24:47,520
所以现在我们唯一要做的就是通过我们的

1771
16:24:47,520 --> 16:24:54,840
身份验证服务和处理与身份验证相关的异常，仅此而已

1772
16:24:54,840 --> 16:25:00,480
好吧好吧，现在我们已经完成了我们的工作

1773
16:25:00,480 --> 16:25:04,480
您可以看到的寄存器我们需要去的寄存器中没有错误

1774
16:25:04,480 --> 16:25:08,720
注释视图如标题所示，所以我关闭

1775
16:25:08,720 --> 16:25:12,560
注册视图现在让我们打开我们的笔记视图

1776
16:25:12,560 --> 16:25:17,360
看看我们在用 firebase 和 notes 视图做什么，所以做同样的事情

1777
16:25:17,360 --> 16:25:22,320
我们之前将firebase删除为您的进口之一，因此您得到了

1778
16:25:22,320 --> 16:25:26,640
想法是对这里发生的事情以及我们如何使用的总体想法

1779
16:25:26,640 --> 16:25:30,796
firebase，我可以看到在笔记视图中使用 firebase 的唯一地方是

1780
16:25:30,796 --> 16:25:34,956
firebase off instance 注销很好，它只是一个地方，但我们必须

1781
16:25:34,956 --> 16:25:38,400
也解决这个问题，然后让我们走吧，对不起，我只是要去

1782
16:25:38,400 --> 16:25:43,916
调出我的笔记，嗯，我们在笔记视图中

1783
16:25:43,916 --> 16:25:48,320
好吧，那我们就去吧

1784
16:25:48,320 --> 16:25:52,160
在这里，我们要说出来

1785
16:25:52,160 --> 16:25:56,400
auth service 没问题，然后我们会说

1786
16:25:56,400 --> 16:26:00,400
注销我想我们会调用它，我们需要等待它好吧

1787
16:26:00,400 --> 16:26:03,436
像那样和

1788
16:26:03,436 --> 16:26:08,640
这很糟糕，所以我们现在可以做的是我们已经从那里移除了 firebase

1789
16:26:08,640 --> 16:26:13,276
好吧，我们走吧

1790
16:26:13,276 --> 16:26:16,480
正如标题所示，我们现在需要浏览整个应用程序并确保

1791
16:26:16,480 --> 16:26:21,360
一切都按预期工作，但在我们这样做之前让我们看看

1792
16:26:21,360 --> 16:26:26,640
在我们看来，并确保他们都没有导入 firebase，所以我可以看到登录

1793
16:26:26,640 --> 16:26:29,840
view 没有导入任何与 firebase 相关的东西，这意味着它没有使用

1794
16:26:29,840 --> 16:26:34,880
firebase 让我们去注释查看没有与 firebase 相关的导入

1795
16:26:34,880 --> 16:26:38,640
不使用 firebase 或至少不直接使用 firebase

1796
16:26:38,640 --> 16:26:43,916
请记住它正在使用 firebase 但通过我们的身份验证服务可以，所以没有从

1797
16:26:43,916 --> 16:26:49,916
firebase 也在这里，我们有我们的验证电子邮件视图，目前我

1798
16:26:49,916 --> 16:26:52,400
可以看到

1799
16:26:52,400 --> 16:26:57,040
验证电子邮件视图哦，我看到我们还没有清理我们的验证电子邮件视图

1800
16:26:57,040 --> 16:27:00,560
这也是我们需要做的，所以我们忘记了，让我们

1801
16:27:00,560 --> 16:27:05,276
让我们照顾好那好吧，让我们进去看看

1802
16:27:05,276 --> 16:27:10,160
也从此处删除此 Firebase 身份验证

1803
16:27:10,160 --> 16:27:15,596
我要去我的笔记这里

1804
16:27:15,596 --> 16:27:18,796
好的，现在让我们来看看

1805
16:27:18,796 --> 16:27:23,680
说呃发送电子邮件验证不应该在那里所以让我们就在那时

1806
16:27:23,680 --> 16:27:28,080
说熄火服务嗯

1807
16:27:28,080 --> 16:27:33,916
firebase 哎呀，firebase 是当前用户，我可以看到你看到

1808
16:27:33,916 --> 16:27:37,916
在这里，它使用当前用户只是发送电子邮件验证，但我们

1809
16:27:37,916 --> 16:27:41,200
不要再这样做了，我们只是因为发送电子邮件验证不是

1810
16:27:41,200 --> 16:27:44,480
当我们开发了我们的离线服务时，在用户级别上记住了

1811
16:27:44,480 --> 16:27:47,840
我们只会说发送电子邮件验证等待

1812
16:27:47,840 --> 16:27:50,720
好的，然后删除那两行代码

1813
16:27:50,720 --> 16:27:53,916
这只是获取用户并发送电子邮件验证删除

1814
16:27:53,916 --> 16:27:57,756
那些和回答你我没有计划

1815
16:27:57,756 --> 16:28:01,436
为此，我实际上可以在我的笔记中看到我没有

1816
16:28:01,436 --> 16:28:04,720
修复了验证电子邮件视图，这就是为什么我没有在标题中显示它

1817
16:28:04,720 --> 16:28:09,436
这完全没关系，我有时也必须即兴发挥，所以

1818
16:28:09,436 --> 16:28:14,400
然后让我们继续在它们中的文本按钮中显示重新启动为

1819
16:28:14,400 --> 16:28:18,560
你可以在这里看到只需要注销用户所以让我们说一下

1820
16:28:18,560 --> 16:28:23,840
服务基地注销并确保您等待

1821
16:28:23,840 --> 16:28:28,880
就可以了，就这样并删除这行代码，以便验证视图

1822
16:28:28,880 --> 16:28:32,880
现在也没有从 firebase 的任何进口

1823
16:28:32,880 --> 16:28:35,756
我相信那些是

1824
16:28:35,756 --> 16:28:39,520
我们所有的观点，除了主要的，让我们确保没有火力基地

1825
16:28:39,520 --> 16:28:44,080
这里的进口要么完美，所以现在我们已经完成了

1826
16:28:44,080 --> 16:28:47,916
在我们要进行热重启的情况下，我们可以做什么作为标题

1827
16:28:47,916 --> 16:28:52,560
在这里，让我们看看一切是否正常

1828
16:28:52,560 --> 16:28:56,720
我只想说在这里重新启动，让我们看看

1829
16:28:56,720 --> 16:29:01,116
应用程序的当前状态我将打开一个 firebase 控制台

1830
16:29:01,116 --> 16:29:06,080
去我的笔记应用程序这里认证，我可以看到我有两个

1831
16:29:06,080 --> 16:29:11,680
这里的用户还好，所以我要说 pixelityab.gmail.com

1832
16:29:11,680 --> 16:29:15,520
foob​​arbass，让我们说注册然后它

1833
16:29:15,520 --> 16:29:19,520
应该给我们一个错误，说电子邮件已经在使用中，所以电子邮件已经在使用中

1834
16:29:19,520 --> 16:29:25,756
使用 let's go in here 说 pixelityab gmail.combarbaz 我记得

1835
16:29:25,756 --> 16:29:30,640
前几章 这是一个已经验证了他的电子邮件地址的用户，所以

1836
16:29:30,640 --> 16:29:34,240
通过按登录，我们实际上应该转到应用程序的主用户界面，所以

1837
16:29:34,240 --> 16:29:38,720
注销应该像以前一样工作，然后让我们去

1838
16:29:38,720 --> 16:29:42,080
uh 并尝试使用该用户登录

1839
16:29:42,080 --> 16:29:45,520
那是我认为还没有

1840
16:29:45,520 --> 16:29:50,240
验证了他的电子邮件地址，这样你就可以看到我们将被发送到这里

1841
16:29:50,240 --> 16:29:53,840
验证电子邮件，然后我们可以按发送电子邮件验证，这反过来

1842
16:29:53,840 --> 16:29:59,680
然后将电子邮件发送给用户

1843
16:29:59,680 --> 16:30:04,880
那是很多信息，还有一些即兴版本

1844
16:30:04,880 --> 16:30:08,400
我没有计划的验证电子邮件视图的章节，所以这对我有好处

1845
16:30:08,400 --> 16:30:11,360
也知道有时我也会错过一些东西，但现在我们没有

1846
16:30:11,360 --> 16:30:14,956
在本章中谈论它时错过了它

1847
16:30:14,956 --> 16:30:17,200
现在让我们

1848
16:30:17,200 --> 16:30:21,596
结束本章我们已经做了很多，本章的主要目标是

1849
16:30:21,596 --> 16:30:24,400
现在我们已经实现了，因为我们想要

1850
16:30:24,400 --> 16:30:29,436
远离直接在我们的 ui 中使用 firebase 并远离使用

1851
16:30:29,436 --> 16:30:34,400
我们为与 firebase 相关的所有内容提供的身份验证服务已经实现

1852
16:30:34,400 --> 16:30:37,680
现在做得很好 我们需要做的就是我们正在做的

1853
16:30:37,680 --> 16:30:42,000
在其他章节中，我们需要呃提交和标记我们已经完成的所有代码

1854
16:30:42,000 --> 16:30:44,636
因为如果我们

1855
16:30:44,636 --> 16:30:50,320
由于某种原因丢失了所有这些代码，所以让我更改 um 的布局

1856
16:30:50,320 --> 16:30:54,400
屏幕在这里，我要制作

1857
16:30:54,400 --> 16:30:58,560
浏览大一点的编辑器，这样你会看得更清楚，我要走了

1858
16:30:58,560 --> 16:31:01,276
进入我在视觉工作室中非常喜欢的终端，称为

1859
16:31:01,276 --> 16:31:06,320
集成终端，您可以看到在上一章中我们已经提交

1860
16:31:06,320 --> 16:31:11,436
并将我们的代码标记为步骤 8 现在我们需要提交为步骤 9

1861
16:31:11,436 --> 16:31:15,040
首先让我们看看状态并添加所有

1862
16:31:15,040 --> 16:31:22,080
状态，我们说 git commit ，我们说第九步好吧

1863
16:31:22,080 --> 16:31:26,720
然后我们说 git tag

1864
16:31:26,720 --> 16:31:30,636
九个，我们首先推送我们的提交

1865
16:31:30,636 --> 16:31:34,636
我们说好的推税

1866
16:31:34,636 --> 16:31:39,276
好吧，这也被推动了，做得很好，我们完成了

1867
16:31:39,276 --> 16:31:43,680
这一章和我谈过的其他章节的情况一样

1868
16:31:43,680 --> 16:31:46,480
关于我们通常会在最后讨论下一章我们要做什么

1869
16:31:46,480 --> 16:31:50,080
的当前章节，所以我们完成了身份验证服务

1870
16:31:50,080 --> 16:31:56,480
工作正常，但我们没有一些测试

1871
16:31:56,480 --> 16:32:00,480
你看有三种不同类型的测试

1872
16:32:00,480 --> 16:32:06,160
你可以在颤振单元测试集成测试和小部件中编写

1873
16:32:06,160 --> 16:32:11,436
现在测试一个单元测试是你例如

1874
16:32:11,436 --> 16:32:17,200
试着取消你目前的服务然后你呃

1875
16:32:17,200 --> 16:32:22,560
只想说好的认证服务登录注册这样做这样做然后

1876
16:32:22,560 --> 16:32:27,200
鉴于这种情况，我希望您现在可以执行此操作，我们的身份验证服务正在运行

1877
16:32:27,200 --> 16:32:32,160
很好，但我们不能 100 确定它正在工作

1878
16:32:32,160 --> 16:32:36,400
应该如此，假设您在一个团队中工作，并且有

1879
16:32:36,400 --> 16:32:40,480
其他三个人和你在同一个代码库上工作，而你在

1880
16:32:40,480 --> 16:32:44,880
身份验证服务，然后您承诺每个人都审查代码或

1881
16:32:44,880 --> 16:32:49,200
我喜欢做我的代码的方式是配对程序或暴民程序，所以有

1882
16:32:49,200 --> 16:32:52,636
没有代码审查，因为每个人都在同时处理相同的代码

1883
16:32:52,636 --> 16:32:57,596
时间，所以这取决于您在团队中的工作方式，然后您发送

1884
16:32:57,596 --> 16:33:01,360
你的代码然后两周后一个新的开发者进来改变你的身份验证

1885
16:33:01,360 --> 16:33:05,040
service and to 并且他们改变了服务

1886
16:33:05,040 --> 16:33:09,436
这对他们来说很有意义，但是他们会破坏你的代码，所以也许例如

1887
16:33:09,436 --> 16:33:12,720
电子邮件验证屏幕停止工作，因为它们发生了变化

1888
16:33:12,720 --> 16:33:17,276
代码，使其不会按照您认为的方式执行逻辑

1889
16:33:17,276 --> 16:33:22,400
执行逻辑，这就是为什么我们需要测试来验证我们的

1890
16:33:22,400 --> 16:33:27,360
嗯，我们设计软件的方式其实是

1891
16:33:27,360 --> 16:33:32,320
呃是它应该执行它的工作的方式，这样它就不会丢失任何点

1892
16:33:32,320 --> 16:33:34,400
这就是我们在

1893
16:33:34,400 --> 16:33:39,040
下一章，嗯，吃点点心，我会看到的

1894
16:33:39,040 --> 16:33:44,240
你在下一章你好，欢迎来到第 26 章

1895
16:33:44,240 --> 16:33:47,520
上一章中的颤振课程你看到我们

1896
16:33:47,520 --> 16:33:52,956
开始在我们的用户界面代码中使用我们的身份验证服务，所以我们不是

1897
16:33:52,956 --> 16:33:57,436
直接对抗firebase，所以我们删除了所有

1898
16:33:57,436 --> 16:34:02,560
在我们的用户界面中导入到 firebase

1899
16:34:02,560 --> 16:34:08,720
登录注册主 dart 文件和 um 中的文件

1900
16:34:08,720 --> 16:34:13,040
注释视图并验证电子邮件视图

1901
16:34:13,040 --> 16:34:18,080
我们有一个很好的身份验证服务但是我们缺少的是一些

1902
16:34:18,080 --> 16:34:23,436
当我谈论时，测试和测试是我最喜欢的话题之一

1903
16:34:23,436 --> 16:34:27,680
软件开发，因为它们使您的代码更加健壮

1904
16:34:27,680 --> 16:34:30,880
不仅仅是编写代码并将其留在

1905
16:34:30,880 --> 16:34:34,320
在那里，我知道一些软件开发人员可能

1906
16:34:34,320 --> 16:34:38,636
把事情看成黑白的，说你必须有代码或

1907
16:34:38,636 --> 16:34:43,756
你不必有代码，但我更像是一个灰色的人

1908
16:34:43,756 --> 16:34:47,040
认为你必须现实一些，如果你是为了

1909
16:34:47,040 --> 16:34:51,520
例如在黑客马拉松中为自己编写一个应用程序，例如

1910
16:34:51,520 --> 16:34:55,596
在你的时间压力下，你只想把事情做好

1911
16:34:55,596 --> 16:35:00,160
如果您参加黑客马拉松，那不是编写单元测试的正确位置

1912
16:35:00,160 --> 16:35:04,240
但是如果你和一家公司合作，他们和你写作是有报酬的

1913
16:35:04,240 --> 16:35:08,080
好的软件，你也得到报酬来编写你的测试，以确保

1914
16:35:08,080 --> 16:35:10,400
一切正常，尤其是如果您是后端

1915
16:35:10,400 --> 16:35:13,276
开发人员软件，例如前端开发人员

1916
16:35:13,276 --> 16:35:20,080
那么您需要确保您的代码经过正确测试，以便

1917
16:35:20,080 --> 16:35:23,916
我要在这里调出标题

1918
16:35:23,916 --> 16:35:29,916
关于为什么我们实际上需要测试，尤其是单元测试

1919
16:35:29,916 --> 16:35:34,400
嗯，我们稍后会讨论不同类型的测试，但是

1920
16:35:34,400 --> 16:35:39,200
让我们谈谈单元测试，嗯，我在

1921
16:35:39,200 --> 16:35:43,276
就像上一章关于什么是单元测试的结尾

1922
16:35:43,276 --> 16:35:47,520
以及为什么我们需要它们，对我来说，拥有一个单位的主要原因

1923
16:35:47,520 --> 16:35:52,320
测试是为了确保如果您认为这里是我们留下的身份验证提供程序

1924
16:35:52,320 --> 16:35:57,680
它的状态很好 它工作正常

1925
16:35:57,680 --> 16:36:02,320
它正在工作，但是如果新的开发人员进入项目并且

1926
16:36:02,320 --> 16:36:06,320
尝试更改一些代码，使其适用于她或他

1927
16:36:06,320 --> 16:36:10,080
但是无意中更改它会更改代码，因此它对我们不起作用

1928
16:36:10,080 --> 16:36:15,200
我们打算这样做的方式，这就是为什么这就是我们的原因之一

1929
16:36:15,200 --> 16:36:18,796
进行单元测试，嗯，这就是我们要做的

1930
16:36:18,796 --> 16:36:23,276
本章，我完全理解，如果你正在看这个

1931
16:36:23,276 --> 16:36:27,596
当然，你可能正坐在一个安静的地方，一个安静的房间，你正在

1932
16:36:27,596 --> 16:36:31,116
自己看这门课这是聊天我想你看的机会

1933
16:36:31,116 --> 16:36:35,116
一群人的这门课程相当苗条，所以

1934
16:36:35,116 --> 16:36:38,480
嗯，很可能你只是跟着课程走，你正在尝试

1935
16:36:38,480 --> 16:36:41,520
编写应用程序或将其发布到应用商店或游戏商店并播放

1936
16:36:41,520 --> 16:36:43,360
如此存放

1937
16:36:43,360 --> 16:36:47,276
也许您对确保您的身份验证服务实际上不是很感兴趣

1938
16:36:47,276 --> 16:36:51,360
经过测试，我完全理解，但我基本上是在设计这门课程

1939
16:36:51,360 --> 16:36:55,520
对于那些试图成为优秀软件开发人员的人来说，如果你是

1940
16:36:55,520 --> 16:36:58,796
正如我所提到的，就像我开发这门课程的角色之一

1941
16:36:58,796 --> 16:37:02,636
因为是设计师，所以如果你是设计师，没有 Flutter 的背景

1942
16:37:02,636 --> 16:37:07,200
您可能也有兴趣为您的应用程序编写测试

1943
16:37:07,200 --> 16:37:11,276
尤其是如果您的目标是进入一个更大的组织并实际获得

1944
16:37:11,276 --> 16:37:14,880
作为 Flutter 开发人员或软件开发人员的工作

1945
16:37:14,880 --> 16:37:18,956
鉴于此背景，您应该知道什么是测试，什么是单元测试

1946
16:37:18,956 --> 16:37:25,200
集成测试是什么，例如小部件测试是什么？

1947
16:37:25,200 --> 16:37:30,320
现在我还需要提到有一种叫做 tdd 或测试的东西

1948
16:37:30,320 --> 16:37:34,636
驱动发展和真正的正确道路

1949
16:37:34,636 --> 16:37:38,720
做测试驱动开发是首先

1950
16:37:38,720 --> 16:37:42,880
编写测试，然后你在我们正在做的那一刻编写你的软件

1951
16:37:42,880 --> 16:37:47,040
恰恰相反，因为我不想让事情复杂化，因为我们要去

1952
16:37:47,040 --> 16:37:49,840
因为我有这个，正如我所说的，我为可能的人设计了这门课程

1953
16:37:49,840 --> 16:37:53,116
Flutter 开发或软件开发的新手，所以喜欢去

1954
16:37:53,116 --> 16:37:56,880
直接进入测试开发测试驱动开发再编写

1955
16:37:56,880 --> 16:38:00,636
我们的关闭服务可能会使事情变得更加复杂

1956
16:38:00,636 --> 16:38:04,400
为了简单起见，我们编写了代码，然后我们正在编写测试，但就是这样

1957
16:38:04,400 --> 16:38:09,200
你知道如果你听到人们谈论 tdd 测试

1958
16:38:09,200 --> 16:38:13,360
驱动开发他们的意思是你编写测试并在

1959
16:38:13,360 --> 16:38:17,596
编写测试你得出的接口如何

1960
16:38:17,596 --> 16:38:21,276
您实际上正在为其编写测试的课程应该看起来像

1961
16:38:21,276 --> 16:38:24,880
使用类，所以有测试驱动的开发

1962
16:38:24,880 --> 16:38:29,916
非常重要，我们应该知道如何使用它，如果你是

1963
16:38:29,916 --> 16:38:34,080
在软件开发组织工作，你应该做测试

1964
16:38:34,080 --> 16:38:38,560
开发测试驱动开发如果时间允许并且如果

1965
16:38:38,560 --> 16:38:42,956
嗯，所有的限制都在正确的地方让你实际进行测试和

1966
16:38:42,956 --> 16:38:48,480
正如我所说，我看东西更像不是黑白的

1967
16:38:48,480 --> 16:38:52,880
视力更像是灰色视力我说你应该做测试但是

1968
16:38:52,880 --> 16:38:56,796
又是完全取决于你和你的情况

1969
16:38:56,796 --> 16:39:01,840
你在里面，所以要知道 tdd 是什么，那

1970
16:39:01,840 --> 16:39:05,436
进行测试驱动开发的正确方法是你首先编写你的

1971
16:39:05,436 --> 16:39:09,200
测试然后你编写接口和

1972
16:39:09,200 --> 16:39:14,320
测试实际执行测试的代码有很多

1973
16:39:14,320 --> 16:39:19,200
呃有很多关于 tdd 的在线资源以及它的实际含义

1974
16:39:19,200 --> 16:39:24,400
它也应该使用 tdd flutter 所以我强烈建议你看看

1975
16:39:24,400 --> 16:39:28,880
在这些资源上，也许在你经历过这个之后

1976
16:39:28,880 --> 16:39:33,276
章节和完成测试的基础知识

1977
16:39:33,276 --> 16:39:38,240
现在，你看我们这门课有时间限制，因为这门课不能去

1978
16:39:38,240 --> 16:39:43,276
先上几百个小时，嗯，因为我可能不会

1979
16:39:43,276 --> 16:39:48,240
能够投入这么多时间，我知道这门课程已经超过 20

1980
16:39:48,240 --> 16:39:53,116
几个小时的时间，但这将花费很多时间

1981
16:39:53,116 --> 16:39:58,240
如果您想涵盖所有内容以及所有不同类型的测试

1982
16:39:58,240 --> 16:40:02,636
为了简单和制作而颤动

1983
16:40:02,636 --> 16:40:06,160
确保您遵循本课程而不会下车并获得

1984
16:40:06,160 --> 16:40:10,080
害怕我们要做的所有测试我会给你喜欢的

1985
16:40:10,080 --> 16:40:13,756
基础知识，我会给你你需要的构建块

1986
16:40:13,756 --> 16:40:17,916
为了以后能够自己进行并编写越来越多的测试

1987
16:40:17,916 --> 16:40:20,320
所以我只知道我们的原因

1988
16:40:20,320 --> 16:40:23,756
将本章专门用于测试是为了确保每个人都理解

1989
16:40:23,756 --> 16:40:28,160
测试非常重要，但我们不会有很多很多

1990
16:40:28,160 --> 16:40:34,796
几个小时只是为了专注于测试虽然这是一个非常重要的主题

1991
16:40:34,796 --> 16:40:40,400
现在让我们谈谈我在结尾中提到的不同类型的测试

1992
16:40:40,400 --> 16:40:44,560
上一章，但我会在这里提一下，以防你跳了

1993
16:40:44,560 --> 16:40:48,636
在我不推荐的那一章，如果你谈论

1994
16:40:48,636 --> 16:40:52,240
Flutter中不同类型的测试你应该知道有单元

1995
16:40:52,240 --> 16:40:57,840
测试小部件测试和集成测试，让我们快速谈谈

1996
16:40:57,840 --> 16:41:02,720
这些不同类型的测试是什么？

1997
16:41:02,720 --> 16:41:05,756
让我们来谈谈类实例的概念假设你已经

1998
16:41:05,756 --> 16:41:10,240
创建了一个名为 auth service 的类，对我们来说就是这种情况，您想要

1999
16:41:10,240 --> 16:41:15,276
为这个类写一些测试现在这个类在它自己的内部是非常孤立的

2000
16:41:15,276 --> 16:41:19,436
自己喜欢它是它有一组功能功能功能，它有一个

2001
16:41:19,436 --> 16:41:22,720
getter 调用当前用户，如果你不记得，让我只是

2002
16:41:22,720 --> 16:41:30,400
把它带到屏幕上，这样你就看得更清楚了，所以让我们去我们的身份验证服务吧

2003
16:41:30,400 --> 16:41:34,796
它符合并实现了 auth 提供者 它有一个构造函数 它有一个

2004
16:41:34,796 --> 16:41:38,160
工厂构造函数也在这里，它具有所有功能

2005
16:41:38,160 --> 16:41:43,360
由身份验证提供程序提供，因为它实现了身份验证提供程序，所以我要

2006
16:41:43,360 --> 16:41:46,320
实际上增加尺寸，以便您看得更清楚

2007
16:41:46,320 --> 16:41:51,756
所以嗯，这是一个独立的单元，所以它是一个

2008
16:41:51,756 --> 16:41:58,400
与身份验证提供程序对话的隔离代码，然后它给了我们

2009
16:41:58,400 --> 16:42:02,480
基本上反映了该作者提供者的功能，其中

2010
16:42:02,480 --> 16:42:06,956
案例是在firebase案例中是firebase auth提供者所以

2011
16:42:06,956 --> 16:42:10,720
它没有太多的功能，但它的功能足够好

2012
16:42:10,720 --> 16:42:13,916
为了对其进行测试，实际上测试它很重要

2013
16:42:13,916 --> 16:42:18,080
确保没有人在没有咨询的情况下无意中更改此代码

2014
16:42:18,080 --> 16:42:22,160
与我们在一起或不喜欢，并确保他们的更改不会中断

2015
16:42:22,160 --> 16:42:25,916
我们的代码，所以这是单元测试，所以你有一个代码单元你有一段

2016
16:42:25,916 --> 16:42:30,796
代码隔离，您想测试那段代码并确保

2017
16:42:30,796 --> 16:42:36,000
该代码中的不同功能正在按应有的方式工作，因此

2018
16:42:36,000 --> 16:42:38,840
就像单元测试的一般概念

2019
16:42:38,840 --> 16:42:45,520
现在是一个小部件测试，顾名思义，它是您作为软件的一种方式

2020
16:42:45,520 --> 16:42:49,436
开发人员，以使其成为您作为软件开发人员的一种方式

2021
16:42:49,436 --> 16:42:54,080
确保您的小部件（如您正在创建的 ui）正在作为轮班工作

2022
16:42:54,080 --> 16:42:59,596
例如，如果您的应用程序中有登录视图

2023
16:42:59,596 --> 16:43:04,720
这个登录视图允许用户点击一个按钮来登录和

2024
16:43:04,720 --> 16:43:07,520
你在用户界面中说没问题，我会确保你一按

2025
16:43:07,520 --> 16:43:11,040
登录按钮，直到用户登录，这

2026
16:43:11,040 --> 16:43:15,360
登录按钮应该被禁用好吧，这是你认为的一段逻辑

2027
16:43:15,360 --> 16:43:18,636
关于好主意，你把代码放在那里

2028
16:43:18,636 --> 16:43:22,080
但是你如何测试它如何确保登录按钮保持不变

2029
16:43:22,080 --> 16:43:27,756
在登录成功之前禁用，这就是小部件测试的用武之地

2030
16:43:27,756 --> 16:43:34,480
玩所以小部件测试有点像端到端测试

2031
16:43:34,480 --> 16:43:40,720
我们的意思是您的小部件可能正在与您的服务和您的

2032
16:43:40,720 --> 16:43:42,956
供应商所以

2033
16:43:42,956 --> 16:43:45,596
您的小部件，例如登录小部件

2034
16:43:45,596 --> 16:43:49,596
或者按下登录按钮后的登录屏幕会调用你的

2035
16:43:49,596 --> 16:43:53,520
服务在这种情况下是身份验证服务，它将进入此登录

2036
16:43:53,520 --> 16:43:57,116
函数这个登录函数又会与提供者交谈

2037
16:43:57,116 --> 16:44:01,596
提供者反过来将与 firebase 代码交谈，而 firebase 代码又将

2038
16:44:01,596 --> 16:44:06,160
与 firebase 后端交谈，以便您看到图层正在堆叠 ui 是

2039
16:44:06,160 --> 16:44:11,596
这里按钮在 ui 上 ui 正在与 auth 服务交谈

2040
16:44:11,596 --> 16:44:16,400
此处身份验证服务正在与提供者正在与之交谈的提供者交谈

2041
16:44:16,400 --> 16:44:19,680
firebase firebase 正在与 firebase 后端对话，也许是后端

2042
16:44:19,680 --> 16:44:22,240
也在与其他一些服务商谈，所以

2043
16:44:22,240 --> 16:44:27,916
这是端对端 这是一端 而另一端就在这里 所以

2044
16:44:27,916 --> 16:44:31,680
您基本上是通过编写小部件测试来进行端到端测试

2045
16:44:31,680 --> 16:44:37,276
一种方法没问题，所以这是小部件测试，其他的东西是集成测试

2046
16:44:37,276 --> 16:44:40,880
您会看到集成测试是您需要的地方

2047
16:44:40,880 --> 16:44:46,000
实例有一个服务，在这种情况下我们有 auth 服务和 auth

2048
16:44:46,000 --> 16:44:50,956
在这种情况下，服务是身份验证服务构造函数或工厂构造函数

2049
16:44:50,956 --> 16:44:56,400
正在与 firebase 交谈，所以如果您以确切的方式测试我们的关闭服务

2050
16:44:56,400 --> 16:44:59,360
你去说 auth service firebase

2051
16:44:59,360 --> 16:45:02,560
然后您针对此身份验证服务发出命令

2052
16:45:02,560 --> 16:45:06,560
firebase 你创建一个用户 你用你注销的用户登录 你发送一个

2053
16:45:06,560 --> 16:45:10,320
电子邮件验证，如果你正在做这些测试，你是

2054
16:45:10,320 --> 16:45:15,116
实际上是在做集成测试，所以你是因为你要确保

2055
16:45:15,116 --> 16:45:19,916
该代码也可以端到端工作，但不涉及用户界面，所以

2056
16:45:19,916 --> 16:45:21,916
呃但是

2057
16:45:21,916 --> 16:45:25,840
我提到我的意思是你现在正在考虑如果测试身份验证服务怎么办

2058
16:45:25,840 --> 16:45:29,276
方式是集成测试你怎么在开头说

2059
16:45:29,276 --> 16:45:32,956
我们要进行单元测试的章节

2060
16:45:32,956 --> 16:45:38,080
这就是我们现在需要讨论的，因为你在这个单元测试中看到

2061
16:45:38,080 --> 16:45:40,796
我们将在本章中进行的练习，我们实际上不会调用

2062
16:45:40,796 --> 16:45:45,756
firebase 我们将调用我们将做一些称为模拟的事情

2063
16:45:45,756 --> 16:45:50,240
我不知道我是否真的在这里提到了一些东西

2064
16:45:50,240 --> 16:45:54,320
是的，我可以看到稍后我实际上要谈论嘲笑

2065
16:45:54,320 --> 16:45:58,000
用英语嘲讽可能意味着你在取笑某人

2066
16:45:58,000 --> 16:46:02,796
不是这个，我们在这里谈论的嘲笑有点像你

2067
16:46:02,796 --> 16:46:08,480
模仿 um 一个真正的服务，所以想象一下你有 auth 服务关闭

2068
16:46:08,480 --> 16:46:12,080
服务有一个火力基地工厂与火力基地对话，它转而与

2069
16:46:12,080 --> 16:46:15,436
firebase 代码，然后与后端对话，我们将摆脱所有

2070
16:46:15,436 --> 16:46:20,240
该管道并说我们将测试服务，但我们将给予

2071
16:46:20,240 --> 16:46:23,916
它是另一个提供者 我们的提供者

2072
16:46:23,916 --> 16:46:28,720
控制你看到火，firebase auth provider里面有很多代码，所以

2073
16:46:28,720 --> 16:46:31,916
我们可以进去让我们进入firebase auth provider

2074
16:46:31,916 --> 16:46:36,480
它直接与 firebase 对话，但如果我们可以创建一个

2075
16:46:36,480 --> 16:46:41,520
auth provider 符合 auth provider 然后写了很多逻辑

2076
16:46:41,520 --> 16:46:46,720
在该身份验证提供程序中并将该作者提供程序提供给身份验证服务

2077
16:46:46,720 --> 16:46:50,880
现在突然之间，我们有了一个身份验证服务，将他的所有任务委托给

2078
16:46:50,880 --> 16:46:54,000
这个模拟嗯

2079
16:46:54,000 --> 16:46:58,560
我们控制其代码的身份验证提供程序，因此我们确切知道登录的内容

2080
16:46:58,560 --> 16:47:01,360
将要做什么 我们确切地知道注销将要做什么或登录并

2081
16:47:01,360 --> 16:47:04,400
根据您喜欢使用的术语锁定它

2082
16:47:04,400 --> 16:47:06,956
所以我们将在本章中做什么

2083
16:47:06,956 --> 16:47:11,360
是在嘲笑，我很快就会解释，所以让我们跳过那个

2084
16:47:11,360 --> 16:47:13,680
现在

2085
16:47:13,680 --> 16:47:16,320
好的嗯

2086
16:47:16,320 --> 16:47:20,480
接下来我们需要讨论的是开发依赖项

2087
16:47:20,480 --> 16:47:24,560
如果您来自节点背景 如果您使用过 nodejs

2088
16:47:24,560 --> 16:47:30,320
或者表达你已经知道 npm 是节点包管理器

2089
16:47:30,320 --> 16:47:34,560
你知道那里有什么开发依赖项

2090
16:47:34,560 --> 16:47:39,756
如果您来自 ios 背景，则对开发人员的依赖并不多

2091
16:47:39,756 --> 16:47:42,480
对你诚实，除非你来自 ios 开发

2092
16:47:42,480 --> 16:47:45,596
背景然后你知道当你编写测试时那些测试框架

2093
16:47:45,596 --> 16:47:50,400
等你带入你的测试目标里面有他们自己的目标所以

2094
16:47:50,400 --> 16:47:54,480
如果您不是来自任何国家，它们不会随最终产品一起发货

2095
16:47:54,480 --> 16:47:57,040
那些背景，你只想知道什么是开发依赖

2096
16:47:57,040 --> 16:48:01,916
现在解释一下，如果我们去

2097
16:48:01,916 --> 16:48:07,200
我们的流行规范 yaml 你会看到我们在这里有一个部分

2098
16:48:07,200 --> 16:48:11,840
称为依赖项，目前我们依赖于各种库

2099
16:48:11,840 --> 16:48:16,320
例如 firebase core firebase auth cloud firestore 和

2100
16:48:16,320 --> 16:48:20,400
firebase 分析这些是我们的依赖项或库

2101
16:48:20,400 --> 16:48:24,080
带入我们的应用程序，如果您认为这是我们的

2102
16:48:24,080 --> 16:48:27,916
应用程序这些是进来的各种库，然后我们在

2103
16:48:27,916 --> 16:48:30,880
结束实际上在这个 um 结束时

2104
16:48:30,880 --> 16:48:34,480
当然我们会把我们的应用程序发送到应用商店和谷歌游戏商店

2105
16:48:34,480 --> 16:48:38,956
当我们创建我们的应用程序以发送到这些各自的商店时，我们

2106
16:48:38,956 --> 16:48:44,160
将应用程序和所有依赖项捆绑在一起并发送

2107
16:48:44,160 --> 16:48:48,636
作为各自 um 的完整二进制文件

2108
16:48:48,636 --> 16:48:52,240
应用商店，但是你也有一个部分在这里

2109
16:48:52,240 --> 16:48:55,756
您的流行规范 yaml 称为 def 依赖项

2110
16:48:55,756 --> 16:49:01,596
现在开发依赖项是您使用并带入您的依赖项

2111
16:49:01,596 --> 16:49:05,040
仅在您的开发过程中应用

2112
16:49:05,040 --> 16:49:08,720
应用程序意味着当您发布您的应用程序时，这是一个使用的术语

2113
16:49:08,720 --> 16:49:10,560
说当你创建

2114
16:49:10,560 --> 16:49:14,160
应用程序并将其发布到相应的应用程序商店，例如

2115
16:49:14,160 --> 16:49:18,080
查看然后这些依赖项实际上并没有打包在你的

2116
16:49:18,080 --> 16:49:22,320
应用程序，因此它们仅在您开发应用程序时位于您的应用程序中

2117
16:49:22,320 --> 16:49:25,520
并且一旦您将其打包并发送以进行发布，那么那些

2118
16:49:25,520 --> 16:49:28,880
依赖项不会被打包到应用程序中

2119
16:49:28,880 --> 16:49:37,756
所以这些是开发依赖项

2120
16:49:37,756 --> 16:49:41,276
现在让我们去我们的

2121
16:49:41,276 --> 16:49:45,436
在这里测试，你可以在这里看到我们需要带

2122
16:49:45,436 --> 16:49:49,360
测试我们的

2123
16:49:49,360 --> 16:49:52,636
进入我们的颤振应用程序，以确保我们可以实际运行我们的测试

2124
16:49:52,636 --> 16:49:56,480
所以你会看到这里已经包含了颤振测试我要给你看

2125
16:49:56,480 --> 16:50:00,000
您需要在终端中发出的命令才能手动执行

2126
16:50:00,000 --> 16:50:02,880
同样，如果我们进入这里并且只是

2127
16:50:02,880 --> 16:50:09,680
输入flutter pop添加测试开发

2128
16:50:09,680 --> 16:50:12,560
好的

2129
16:50:12,560 --> 16:50:18,480
它正在做一个流行音乐到那里好吧这项工作现在完成了现在让我们拥有

2130
16:50:18,480 --> 16:50:22,480
看看这里，你可以看到现在我们有一个开发者

2131
16:50:22,480 --> 16:50:26,720
称为 test 的依赖项，这就是您将其引入应用程序的方式

2132
16:50:26,720 --> 16:50:31,596
这个命令，所以我要再次提出它，这样你就可以看到它颤动 pop add

2133
16:50:31,596 --> 16:50:37,200
测试和破折号开发如果正如我所说，如果你是一个节点

2134
16:50:37,200 --> 16:50:40,796
node.js 开发者，你会从 npm 知道这一点

2135
16:50:40,796 --> 16:50:46,160
d 将其作为开发要求或依赖项添加到您的

2136
16:50:46,160 --> 16:50:50,320
申请所以我不会假设你带来了

2137
16:50:50,320 --> 16:50:53,520
在这个测试包到你的应用程序中，使用我的命令

2138
16:50:53,520 --> 16:50:57,840
在终端中为您提供这里，所以如果您查看您的弹回 yaml

2139
16:50:57,840 --> 16:51:02,240
文件，所以如果您查看您的流行规范 yaml 文件，我将把它记下来

2140
16:51:02,240 --> 16:51:06,480
在 dev 依赖项中，那么你应该只在你的内部有这个测试包

2141
16:51:06,480 --> 16:51:10,160
dev 依赖项，如果您看到它被带入依赖项部分

2142
16:51:10,160 --> 16:51:14,320
不正确它不应该在那里，那是因为你可能错过了

2143
16:51:14,320 --> 16:51:19,916
在你的颤振弹出添加测试命令的末尾添加破折号开发，所以如果

2144
16:51:19,916 --> 16:51:23,360
你这样做然后测试将被添加到

2145
16:51:23,360 --> 16:51:30,000
依赖项，这是不正确的，因此请确保修复该错误

2146
16:51:30,000 --> 16:51:36,720
好的，让我们进入下一部分，如果你提出你的问题，现在就讨论这个

2147
16:51:36,720 --> 16:51:41,116
explorer 你会注意到，如果你去你的测试文件夹，整个测试

2148
16:51:41,116 --> 16:51:45,360
此时文件夹标记为红色，并且

2149
16:51:45,360 --> 16:51:50,000
呃实际上它不像电子邮件那样被标记为红色

2150
16:51:50,000 --> 16:51:54,956
用红色渲染这就是我的意思所以它可能是嗯也许

2151
16:51:54,956 --> 16:52:00,080
以错误的语气听到，所以如果你进去，那个文件夹被读取了，然后

2152
16:52:00,080 --> 16:52:04,160
如果您单击这个称为小部件测试的文件，该文件也是

2153
16:52:04,160 --> 16:52:07,596
red 这里有很多错误实际上没有它有一个错误，因为它正在创建

2154
16:52:07,596 --> 16:52:10,240
有个东西叫我的应用程序

2155
16:52:10,240 --> 16:52:13,916
我们需要在这里做的，因为我们不需要你看到的这个现有的测试

2156
16:52:13,916 --> 16:52:17,840
这个测试是在我们创建我们需要的 Flutter 应用程序时为我们创建的

2157
16:52:17,840 --> 16:52:22,160
摆脱它好吧，让我们进入这里并右键单击它，然后说

2158
16:52:22,160 --> 16:52:27,840
删除并且该文件已经消失了，所以这是我们拥有的第一件事

2159
16:52:27,840 --> 16:52:31,360
在这里做和折叠这个跳跃文件夹

2160
16:52:31,360 --> 16:52:35,040
好吧，现在我们需要在这里做一个标题

2161
16:52:35,040 --> 16:52:40,956
表示我们需要创建一个名为 auth test dot dart 的新文件 OK

2162
16:52:40,956 --> 16:52:47,756
所以让我们继续在测试文件夹下执行此操作

2163
16:52:47,756 --> 16:52:52,480
让我继续，现在在测试文件夹下右键单击并执行此操作

2164
16:52:52,480 --> 16:52:56,480
说新文件，然后取消测试飞镖

2165
16:52:56,480 --> 16:52:59,596
好的

2166
16:52:59,596 --> 16:53:04,636
好的，我们需要在这个关闭测试中做的事情现在开始这个功能

2167
16:53:04,636 --> 16:53:10,636
完全是空的所以让我们先在这里添加一个主函数

2168
16:53:10,636 --> 16:53:14,796
像这样，只要我们在这里添加 main 函数，你就可以看到 dart 是

2169
16:53:14,796 --> 16:53:18,400
足够智能，可以在这里为我们提供运行和调试功能，这就是

2170
16:53:18,400 --> 16:53:22,160
显示在 Visual Studio 代码中我认为 android Studio 也做同样的事情

2171
16:53:22,160 --> 16:53:27,276
我不认为 vim 是可用的，它可能是 vim 是时间和时间

2172
16:53:27,276 --> 16:53:31,680
再次让我惊讶于所有这些令人惊叹的功能

2173
16:53:31,680 --> 16:53:36,240
呃，但取决于工具或文本编辑器或

2174
16:53:36,240 --> 16:53:39,756
您正在使用的 id 可能会有所不同，但不用担心，我们是

2175
16:53:39,756 --> 16:53:43,520
实际上不会点击这些东西，所以如果你没有看到这些东西

2176
16:53:43,520 --> 16:53:47,200
在您的文本编辑器中，您不必担心

2177
16:53:47,200 --> 16:53:49,840
所以现在我们已经完成了

2178
16:53:49,840 --> 16:53:54,400
添加测试包，因为我们已经导入了依赖于我们的测试包

2179
16:53:54,400 --> 16:53:58,400
还需要导入它所以让我们在这里说导入

2180
16:53:58,400 --> 16:54:03,276
并摆脱左侧的这个编辑器抱歉资源管理器，我是

2181
16:54:03,276 --> 16:54:07,116
会说如果我们导入一个名为 test 的包

2182
16:54:07,116 --> 16:54:14,080
里面有一个文件叫做 test start 所以现在我们准备好了

2183
16:54:14,080 --> 16:54:18,320
好吧，现在你明白了

2184
16:54:18,320 --> 16:54:22,720
你可能没有注意到它，但我已经运行了这个应用程序

2185
16:54:22,720 --> 16:54:26,636
在我的实际安卓手机上，就像我们在上一章中所做的那样，所以我从来没有

2186
16:54:26,636 --> 16:54:30,320
无缘无故杀死了这个应用程序，它总是在那个android上运行

2187
16:54:30,320 --> 16:54:36,240
电话我总是可以用 scr cpy 调出它，所以我可以在这里看到

2188
16:54:36,240 --> 16:54:40,240
但是运行没有问题

2189
16:54:40,240 --> 16:54:44,320
记住前面的章节之一 前面的第一章之一

2190
16:54:44,320 --> 16:54:48,636
我们谈到了在我们的应用程序中添加 firebase 我认为这是第五章

2191
16:54:48,636 --> 16:54:53,680
或者六，当我们引入firebase时，我们需要在课程的早期阶段

2192
16:54:53,680 --> 16:54:56,560
我们需要终止应用程序，这意味着我们需要终止

2193
16:54:56,560 --> 16:54:59,756
应用程序并从头开始运行它

2194
16:54:59,756 --> 16:55:03,360
取决于一些依赖实际上不，我不认为这取决于你什么时候

2195
16:55:03,360 --> 16:55:06,880
在您的项目中引入新的依赖项，您需要始终确保

2196
16:55:06,880 --> 16:55:10,796
你重建你的项目，所以你不能做热重载和热重启，因为

2197
16:55:10,796 --> 16:55:14,880
其中一些依赖项实际上需要您的应用程序

2198
16:55:14,880 --> 16:55:18,160
从头开始编译，然后

2199
16:55:18,160 --> 16:55:22,796
然后被带入您的二进制文件，因此不会进行热重载和热重启

2200
16:55:22,796 --> 16:55:26,796
实际上喜欢能够带来那些依赖

2201
16:55:26,796 --> 16:55:30,796
但至少进入你的颤振应用程序所以我需要你做什么

2202
16:55:30,796 --> 16:55:36,880
就是停止执行你的程序然后让我们进去保存这些

2203
16:55:36,880 --> 16:55:42,880
改变然后让我们说 main.dart

2204
16:55:42,880 --> 16:55:47,840
让我们在不调试的情况下运行应用程序，看看这是否

2205
16:55:47,840 --> 16:55:50,956
也将在正确的设备上正确启动应用程序

2206
16:55:50,956 --> 16:55:55,200
我可以看到是的，它将在正确的设备上运行它我更改了

2207
16:55:55,200 --> 16:55:59,436
屏幕布局也在这里

2208
16:55:59,436 --> 16:56:06,400
我们就等着这个毕业带完成它的工作吧

2209
16:56:06,400 --> 16:56:09,596
这可能需要一些时间，具体取决于您对

2210
16:56:09,596 --> 16:56:13,276
在这种情况下，我们为我们的应用程序引入了一个名为 testing 的全新包

2211
16:56:13,276 --> 16:56:16,320
应用程序，所以它需要时间，那就是

2212
16:56:16,320 --> 16:56:20,560
完全没问题

2213
16:56:20,560 --> 16:56:26,320
我现在可以看到它已经运行我们的代码没有问题了

2214
16:56:26,320 --> 16:56:33,116
本章的内容我认为我们不需要带有 scr cpy 的 um 设备 if

2215
16:56:33,116 --> 16:56:36,560
您正在使用 ios 模拟器，如果您使用的是模拟器，我认为您不需要它

2216
16:56:36,560 --> 16:56:39,360
我认为你也不需要它，所以我们可以摆脱它，所以我们不需要

2217
16:56:39,360 --> 16:56:42,240
必须在屏幕上显示它，但请记住我的应用程序仍在运行

2218
16:56:42,240 --> 16:56:44,320
可以，然后呢

2219
16:56:44,320 --> 16:56:48,956
嗯，让我在这里摆脱这个摆脱小部件检查器摆脱

2220
16:56:48,956 --> 16:56:54,956
main dart，让我们在这里访问我们的 auth test dart 文件

2221
16:56:54,956 --> 16:56:59,200
好的，现在我们还需要解决一件事

2222
16:56:59,200 --> 16:57:04,480
在我们开始编写测试之前，这里有这个小功能

2223
16:57:04,480 --> 16:57:11,116
如果我在这里提出关闭用户，我们的 auth 用户中的小家伙

2224
16:57:11,116 --> 16:57:16,080
你会看到它有我们离开的方式是我们添加了一个

2225
16:57:16,080 --> 16:57:21,680
嗯，我们向这个关闭用户的不可变类添加了一个成员变量，这里称为

2226
16:57:21,680 --> 16:57:25,360
已验证的电子邮件以及我们构建此身份验证用户的方式（如果您看到）

2227
16:57:25,360 --> 16:57:30,160
在这里，我们说用户只要给我们这个威廉，所以如果从里面的任何地方

2228
16:57:30,160 --> 16:57:34,080
你的功能，你有

2229
16:57:34,080 --> 16:57:37,200
如果您想从应用程序内部的任何位置创建一个

2230
16:57:37,200 --> 16:57:41,596
关闭用户的实例，您可能会这样做关闭用户，然后您必须

2231
16:57:41,596 --> 16:57:47,040
通过该布尔值已通过电子邮件验证，但是您会看到

2232
16:57:47,040 --> 16:57:50,956
参数没有名字它只是一个真或假

2233
16:57:50,956 --> 16:57:56,240
如果我作为一名程序员看到 auth 用户真明显或假我不明白什么

2234
16:57:56,240 --> 16:58:00,400
这对或错是什么意思这是否意味着身份验证用户

2235
16:58:00,400 --> 16:58:03,680
已开启 已关闭 是什么意思

2236
16:58:03,680 --> 16:58:10,880
因为 dart 能够为您提供所需的命名参数，并且

2237
16:58:10,880 --> 16:58:14,320
意味着您不会在这里传递 true ，而是

2238
16:58:14,320 --> 16:58:21,916
被迫注销用户他的电子邮件验证真假

2239
16:58:21,916 --> 16:58:25,916
所以为了做到这一点，正如标题所示，我们需要去做

2240
16:58:25,916 --> 16:58:29,200
所需的参数，这样做的方法是

2241
16:58:29,200 --> 16:58:33,756
像这样将它包裹在大括号中，然后在它前面加上

2242
16:58:33,756 --> 16:58:38,956
关键字是必需的，所以在你完成那个和这个之后

2243
16:58:38,956 --> 16:58:43,436
功能不再起作用，因为缺少此参数，所以

2244
16:58:43,436 --> 16:58:47,756
它已通过电子邮件验证，我们将通过

2245
16:58:47,756 --> 16:58:51,840
这个值就在那里好吧，让我们移动那个删除

2246
16:58:51,840 --> 16:58:55,436
这个功能，所以现在我们已经实现了我们所说的

2247
16:58:55,436 --> 16:58:58,160
要做

2248
16:58:58,160 --> 16:59:01,596
现在，嗯，因为你知道我们不会，我们会

2249
16:59:01,596 --> 16:59:05,360
实际上，您可能认为没关系，我们已将此参数更改为 required

2250
16:59:05,360 --> 16:59:09,360
那么我们代码中的所有错误都在哪里，为什么没有任何错误，这就是一个

2251
16:59:09,360 --> 16:59:13,116
到目前为止我们所做的一切以及我们已经抽象出来的美好事物

2252
16:59:13,116 --> 16:59:18,720
很多代码，现在代码更加健壮了，因为在我们的内部没有任何地方

2253
16:59:18,720 --> 16:59:24,320
应用程序我们实际上是在创建我们的用户，除了这个工厂函数

2254
16:59:24,320 --> 16:59:28,400
我们唯一需要解决的地方是电子邮件验证是在这个工厂内

2255
16:59:28,400 --> 16:59:31,680
功能对我来说很美，因为

2256
16:59:31,680 --> 16:59:36,720
通过将必需的参数添加到它没有的类来做类似激烈的事情

2257
16:59:36,720 --> 16:59:42,796
打破任何东西，所以我们很好

2258
16:59:42,796 --> 16:59:47,200
好吧，嗯，这就是我提到的重点

2259
16:59:47,200 --> 16:59:52,880
以前我们需要一个模拟供应商

2260
16:59:52,880 --> 16:59:57,596
为了做一个模拟作者提供者，我需要更多地了解什么

2261
16:59:57,596 --> 17:00:02,240
模拟是以及为什么我们需要它们，你在软件中看到

2262
17:00:02,240 --> 17:00:06,720
我们在测试方面尤其如此，甚至在应用程序架构级别或

2263
17:00:06,720 --> 17:00:10,720
软件架构师架构级别我们有一种称为依赖关系的东西

2264
17:00:10,720 --> 17:00:14,000
注入依赖注入

2265
17:00:14,000 --> 17:00:18,560
只是快速解释一下它与我们的身份验证服务非常相似让我们有一个

2266
17:00:18,560 --> 17:00:24,560
在这里查看我们的关闭服务，您看到关闭服务取决于身份验证提供程序

2267
17:00:24,560 --> 17:00:30,080
这不仅仅是假设它的身份验证提供者总是火力基地

2268
17:00:30,080 --> 17:00:34,880
它为firebase提供了一个工厂，但它没有对此做出假设

2269
17:00:34,880 --> 17:00:38,560
嘿，我总是被锁定到 firebase auth provider

2270
17:00:38,560 --> 17:00:43,680
这是依赖注入，所以这个关闭服务依赖于使用的提供者

2271
17:00:43,680 --> 17:00:47,276
我们是一个常量构造函数初始化器

2272
17:00:47,276 --> 17:00:50,880
将提供者注入其中

2273
17:00:50,880 --> 17:00:55,040
简而言之就是软件开发中的依赖注入

2274
17:00:55,040 --> 17:00:58,560
您可以详细了解它，但我们没有时间

2275
17:00:58,560 --> 17:01:03,436
嗯，所以什么是模拟，模拟非常

2276
17:01:03,436 --> 17:01:07,040
非常好地与依赖注入携手并进

2277
17:01:07,040 --> 17:01:11,360
在这种情况下，您可以看到我们有一个关闭服务正在镜像

2278
17:01:11,360 --> 17:01:15,680
您可以注入其提供者的功能

2279
17:01:15,680 --> 17:01:17,916
但是我们在

2280
17:01:17,916 --> 17:01:22,000
时刻被称为 firebase 如果我们创建一个

2281
17:01:22,000 --> 17:01:27,596
我们可以完全控制的全新供应商

2282
17:01:27,596 --> 17:01:32,000
确保它符合并实现身份验证提供程序，我们可以确保

2283
17:01:32,000 --> 17:01:35,756
它实现了身份验证提供者实现的所有功能

2284
17:01:35,756 --> 17:01:40,956
并覆盖所有这些，但我们自己有一些特殊的逻辑

2285
17:01:40,956 --> 17:01:45,916
模拟身份验证提供程序，然后我们将将此身份验证提供程序提供给

2286
17:01:45,916 --> 17:01:51,436
我们的 auth 服务，然后让 auth 服务发挥它的魔力，并镜像所有

2287
17:01:51,436 --> 17:01:58,000
提供者的那些功能，所以我们要模拟一个关闭的提供者和

2288
17:01:58,000 --> 17:02:03,520
将其提供到我们的身份验证服务中，这就是模拟的时候

2289
17:02:03,520 --> 17:02:09,680
当你创建一个新函数或一个类然后你

2290
17:02:09,680 --> 17:02:13,116
然后可以将其注入另一个

2291
17:02:13,116 --> 17:02:18,400
放置然后测试另一个地方好吗

2292
17:02:18,400 --> 17:02:22,880
所以让我们进入我们在这里的非测试飞镖文件，我要去

2293
17:02:22,880 --> 17:02:31,276
command 就可以了，让我们去创建我们的小东西，就像模拟提供者一样

2294
17:02:31,276 --> 17:02:35,840
所以我要进去，我只想说类模拟提供者和

2295
17:02:35,840 --> 17:02:39,916
建议你做同样的事情，这家伙会实施

2296
17:02:39,916 --> 17:02:44,956
嗯，身份验证提供程序可以自动导入

2297
17:02:44,956 --> 17:02:48,720
我们还好就这样

2298
17:02:48,720 --> 17:02:51,596
现在我们需要做的就是得到

2299
17:02:51,596 --> 17:02:55,520
模拟提供程序以实现所有功能

2300
17:02:55,520 --> 17:03:00,160
身份验证提供程序应用程序抽象类要求我们实现，所以我

2301
17:03:00,160 --> 17:03:04,956
去命令 dot 并恭敬地询问 Visual Studio 代码

2302
17:03:04,956 --> 17:03:09,276
创建这六个缺失的覆盖非常感谢 Visual Studio 代码

2303
17:03:09,276 --> 17:03:14,160
让我们的生活更轻松好吗

2304
17:03:14,160 --> 17:03:19,520
现在我们需要做的就是完成这个模拟身份验证提供者的繁重工作

2305
17:03:19,520 --> 17:03:25,596
这意味着继续为身份验证提供程序创建功能

2306
17:03:25,596 --> 17:03:28,480
我知道代码现在完全是巨大的，所以我要

2307
17:03:28,480 --> 17:03:32,080
稍微减小尺寸，以便您看到更多代码

2308
17:03:32,080 --> 17:03:37,680
所以让我们继续处理这里的第一个函数，即 create

2309
17:03:37,680 --> 17:03:41,040
用户好，现在你看到了

2310
17:03:41,040 --> 17:03:45,040
我们要做的是如果你记得

2311
17:03:45,040 --> 17:03:50,000
我们的身份验证提供程序有一个名为 initialize all 的函数

2312
17:03:50,000 --> 17:03:53,680
现在当我们在

2313
17:03:53,680 --> 17:03:59,520
firebase 的上下文 firebase 内部有这个概念

2314
17:03:59,520 --> 17:04:03,520
是否已初始化，但是当我们创建模拟身份验证时

2315
17:04:03,520 --> 17:04:09,040
提供者在哪里我们还没有跟踪我们的模拟功能是否

2316
17:04:09,040 --> 17:04:12,160
身份验证提供程序是否实际初始化

2317
17:04:12,160 --> 17:04:18,720
我们只有一个初始化函数，但是如果有人调用 create user on

2318
17:04:18,720 --> 17:04:24,400
我们的模拟身份验证提供者还没有初始化提供者，那就是

2319
17:04:24,400 --> 17:04:29,200
我们现在需要做什么，所以让我们继续跟踪它

2320
17:04:29,200 --> 17:04:34,160
所以我们在这里要做的是我们只是说 var 已初始化

2321
17:04:34,160 --> 17:04:39,520
以ok开头是错误的，我说下划线的原因是

2322
17:04:39,520 --> 17:04:44,480
初始化是因为嗯，这几乎使这个属性

2323
17:04:44,480 --> 17:04:49,200
对我们的模拟提供商私有，因此我们向外界表明

2324
17:04:49,200 --> 17:04:52,560
嘿，您不应该从此属性中读取或写入此属性

2325
17:04:52,560 --> 17:04:55,680
财产

2326
17:04:55,680 --> 17:05:00,636
好的，现在完成了，让我们为这个属性创建一个小吸气剂，这样

2327
17:05:00,636 --> 17:05:05,680
当我们测试我们的模拟身份验证提供程序时，我们实际上可以说

2328
17:05:05,680 --> 17:05:10,320
嘿，你初始化了吗，我们还可以为模拟创建一个测试

2329
17:05:10,320 --> 17:05:14,560
我们实际上要做的身份验证提供程序是在我们创建

2330
17:05:14,560 --> 17:05:19,200
模拟身份验证提供程序最初不应初始化，但之后

2331
17:05:19,200 --> 17:05:24,000
对其调用初始化然后我们进行测试以确保初始化标志

2332
17:05:24,000 --> 17:05:28,320
设置为 true 所以让我们为了做到这一点，我们需要能够阅读这是

2333
17:05:28,320 --> 17:05:32,880
初始化标志让我们继续为它创建一个布尔 getter，我们称之为

2334
17:05:32,880 --> 17:05:38,080
它已初始化它已初始化，我们只是返回

2335
17:05:38,080 --> 17:05:41,680
在那里初始化

2336
17:05:41,680 --> 17:05:46,080
好吧，现在让我们进入我们的创建用户我是

2337
17:05:46,080 --> 17:05:49,200
将在该参数的末尾添加一个逗号我也将采用

2338
17:05:49,200 --> 17:05:52,956
在登录结束时自由创建和添加逗号

2339
17:05:52,956 --> 17:05:57,840
功能，这是仅有的两个地方

2340
17:05:57,840 --> 17:06:01,436
这需要在其参数列表的末尾有一个逗号，所以现在飞镖

2341
17:06:01,436 --> 17:06:06,320
格式化程序能够更好地格式化代码

2342
17:06:06,320 --> 17:06:11,680
好吧，让我们去创建用户现在你在创建用户中看到我几乎

2343
17:06:11,680 --> 17:06:14,796
我们在这里编写的这些功能，例如登录发送电子邮件

2344
17:06:14,796 --> 17:06:20,080
验证我们需要确保这个模拟身份验证提供程序已经

2345
17:06:20,080 --> 17:06:24,796
初始化，所以如果你调用这些，我们实际上会抛出一个异常

2346
17:06:24,796 --> 17:06:29,040
需要初始化而没有初始化模拟身份验证的函数

2347
17:06:29,040 --> 17:06:36,720
首先提供者，所以让我们在这里定义一个 um 一个异常

2348
17:06:36,720 --> 17:06:40,720
所以让我看看我是否把它写在某个地方

2349
17:06:40,720 --> 17:06:45,276
不，所以让我们进去，只是说上课

2350
17:06:45,276 --> 17:06:49,276
非迷你初始化异常

2351
17:06:49,276 --> 17:06:53,200
实现异常，所以你应该知道这一点

2352
17:06:53,200 --> 17:06:56,956
之前和现在是空的

2353
17:06:56,956 --> 17:07:00,956
好的，所以我们需要在这里做的，我们需要

2354
17:07:00,956 --> 17:07:06,880
只是说如果它没有被初始化就被初始化

2355
17:07:06,880 --> 17:07:11,756
然后抛出未初始化的异常

2356
17:07:11,756 --> 17:07:14,080
好的

2357
17:07:14,080 --> 17:07:17,596
所以这是一个 if 语句它是一个单行这就是为什么我们不真的

2358
17:07:17,596 --> 17:07:20,796
在这里打破它，否则你把花括号放在这里然后做

2359
17:07:20,796 --> 17:07:24,636
扔在那里，但如果仅此而已，您也可以使用单行 if 语句

2360
17:07:24,636 --> 17:07:28,000
如果这就是你正在做的只是一行代码

2361
17:07:28,000 --> 17:07:31,520
好吧，老实说，我有点喜欢这些单行 if 语句

2362
17:07:31,520 --> 17:07:36,720
如果没有初始化模拟身份验证提供程序，我希望你能得到这个

2363
17:07:36,720 --> 17:07:41,756
抛出那个特殊的异常，我们要做的就是我们

2364
17:07:41,756 --> 17:07:46,080
假装创建用户好吧，所以我们只想说

2365
17:07:46,080 --> 17:07:50,080
例如，如果您在 firebase 上调用 create 用户，它可能需要执行

2366
17:07:50,080 --> 17:07:54,160
与firebase后端交谈，所以这需要一些时间，所以让我们构建

2367
17:07:54,160 --> 17:07:58,880
在这里稍等一下，我们要做的就是

2368
17:07:58,880 --> 17:08:02,560
说未来并删除

2369
17:08:02,560 --> 17:08:06,400
在这里你必须将持续时间传递给它，所以我们说 const duration

2370
17:08:06,400 --> 17:08:11,200
秒，他们做到了

2371
17:08:11,200 --> 17:08:17,276
我相信就是这样让我们在这里说一个并记住

2372
17:08:17,276 --> 17:08:22,560
如果我去移动它的未来延迟它是一个函数签名它返回一个

2373
17:08:22,560 --> 17:08:27,840
动态的未来，所以通过创造一个未来，你实际上并没有在等待它

2374
17:08:27,840 --> 17:08:32,840
所以让我们将我们的函数标记为异步，让我们等待它

2375
17:08:32,840 --> 17:08:40,000
好的，现在要做的是确保

2376
17:08:40,000 --> 17:08:43,360
嗯，这个创建用户实际上返回了一个

2377
17:08:43,360 --> 17:08:48,480
作者用户，但也记得在 firebase 嗯，或者我实际上不知道是否

2378
17:08:48,480 --> 17:08:52,400
firebase 是这样工作的，但是通过创建一个用户我们要做什么

2379
17:08:52,400 --> 17:08:58,796
在我们的模拟身份验证提供程序中，实际上该用户也可以登录

2380
17:08:58,796 --> 17:09:02,080
所以假设你看到登录返回

2381
17:09:02,080 --> 17:09:06,636
也是 auth 用户的未来，所以在这个创建用户结束时，我们将

2382
17:09:06,636 --> 17:09:10,080
让我们的生活更轻松，只返回登录结果，所以让我们

2383
17:09:10,080 --> 17:09:12,720
说返回并登录

2384
17:09:12,720 --> 17:09:17,596
当此电子邮件和密码正常时

2385
17:09:17,596 --> 17:09:23,040
所以这是一个非常愚蠢且非常简单的创建用户的模拟实现

2386
17:09:23,040 --> 17:09:27,756
它本身会做三件事检查以确保您已初始化，如果

2387
17:09:27,756 --> 17:09:30,880
你没有初始化它会引发异常

2388
17:09:30,880 --> 17:09:37,436
它做了一个模拟呃一秒钟的等待只是为了喜欢假的做一个 api 调用和

2389
17:09:37,436 --> 17:09:40,956
它所做的第三件事是它以相同的方式调用登录函数

2390
17:09:40,956 --> 17:09:45,520
邮箱和密码，并返回登录结果，以便获取

2391
17:09:45,520 --> 17:09:49,276
它的关闭用户

2392
17:09:49,276 --> 17:09:54,560
好的，现在我们需要模拟当前用户，所以

2393
17:09:54,560 --> 17:09:59,040
我们如何做到这一点 我们如何获得您看到的当前用户

2394
17:09:59,040 --> 17:10:03,200
firebase 有能力跟踪当前用户，但我们该怎么做

2395
17:10:03,200 --> 17:10:07,276
我们现在不能把这个功能委托给firebase，所以

2396
17:10:07,276 --> 17:10:12,796
我们还需要在这里创建一个身份验证用户，所以让我们去阻止模拟身份验证

2397
17:10:12,796 --> 17:10:17,916
提供者就在那里被初始化或低于它没有

2398
17:10:17,916 --> 17:10:22,320
重要的地方我会在上面做我会说用户

2399
17:10:22,320 --> 17:10:27,040
像这样，如果你做一个飞镖，你会在远处看到

2400
17:10:27,040 --> 17:10:32,400
成员变量默认情况下是可选的，它是空的，所以它没有值，所以你不要

2401
17:10:32,400 --> 17:10:35,916
必须真的去说不，你可以看到它说不明确

2402
17:10:35,916 --> 17:10:40,636
将变量初始化为不好的分析器

2403
17:10:40,636 --> 17:10:44,000
我没有我们要在内部管理的用户，我是

2404
17:10:44,000 --> 17:10:48,796
实际上要用下划线作为前缀，以便将其标记为

2405
17:10:48,796 --> 17:10:52,080
私有函数作为私有成员变量

2406
17:10:52,080 --> 17:10:59,596
然后在当前用户中简单地返回该用户，这样就可以了

2407
17:10:59,596 --> 17:11:01,596
现在完美

2408
17:11:01,596 --> 17:11:06,160
我们需要去处理初始化函数让我们看看我们是否可以

2409
17:11:06,160 --> 17:11:11,040
找到它登录这里是初始化

2410
17:11:11,040 --> 17:11:12,956
所以我们唯一要做的

2411
17:11:12,956 --> 17:11:18,240
我们要假装等待的初始化器，只需等待一秒钟

2412
17:11:18,240 --> 17:11:25,520
然后将 r 初始化标志设置为 true 所以让我们获取这个权重代码

2413
17:11:25,520 --> 17:11:30,320
从我们的创建用户函数中，然后将其初始化，然后说

2414
17:11:30,320 --> 17:11:34,000
等待并使您的函数异步，然后我们将

2415
17:11:34,000 --> 17:11:37,360
等等，我们只是说初始化

2416
17:11:37,360 --> 17:11:43,520
是真的，所以这很容易

2417
17:11:43,520 --> 17:11:48,636
那么我们的模拟作者提供者中最丰富的部分实际上是

2418
17:11:48,636 --> 17:11:54,080
登录功能，因为它不是在登录，而是在登录

2419
17:11:54,080 --> 17:11:58,636
注册函数正在使用的函数还是我们说的创建

2420
17:11:58,636 --> 17:12:02,240
用户创建用户，因此功能也是

2421
17:12:02,240 --> 17:12:05,756
记录它正在调用登录功能，所以我们

2422
17:12:05,756 --> 17:12:10,240
需要真正测试此功能以确保其正常工作

2423
17:12:10,240 --> 17:12:13,840
正如我之前在大多数这些功能中提到的，当我们需要确保

2424
17:12:13,840 --> 17:12:17,436
我们的模拟身份验证提供程序在调用这些函数之前进行初始化

2425
17:12:17,436 --> 17:12:22,796
他们所以让我们去抓取这段代码，你会看到它说是否已初始化并带来

2426
17:12:22,796 --> 17:12:27,840
该代码也在我们的登录功能中，所以这是我们要做的第一件事

2427
17:12:27,840 --> 17:12:30,880
现在要做

2428
17:12:30,880 --> 17:12:36,320
我们还将在登录功能中构建一些虚假功能

2429
17:12:36,320 --> 17:12:40,880
只是这样我们就可以为他们编写测试，因为你在现实世界中看到你

2430
17:12:40,880 --> 17:12:45,116
可能有很多很多真实的逻辑

2431
17:12:45,116 --> 17:12:49,916
在您的身份验证提供商和身份验证服务中，但我们没有那么真实

2432
17:12:49,916 --> 17:12:53,520
现在的逻辑，因为我们的应用程序现在非常小，所以我们要

2433
17:12:53,520 --> 17:12:58,560
在我们的 mod 提供程序中构建一些虚假功能，然后在我们的模拟中抱歉

2434
17:12:58,560 --> 17:13:03,040
身份验证提供程序，然后我们将编写测试来测试那些

2435
17:13:03,040 --> 17:13:07,520
场景，以便您了解模拟，您还将了解编写测试

2436
17:13:07,520 --> 17:13:12,000
对于那些模拟，这就是本章的全部目的

2437
17:13:12,000 --> 17:13:14,720
所以我们接下来要做的是

2438
17:13:14,720 --> 17:13:18,320
会说如果和所以我们要编一个电子邮件

2439
17:13:18,320 --> 17:13:21,520
我们不喜欢我们会说如果电子邮件是

2440
17:13:21,520 --> 17:13:27,596
嗯 fooatvar.com 然后抛出用户未找到异常好吗

2441
17:13:27,596 --> 17:13:31,276
因此，如果您尝试使用此电子邮件地址登录，我们只会说用户

2442
17:13:31,276 --> 17:13:36,636
没有找到好的，如果密码

2443
17:13:36,636 --> 17:13:40,880
与 foobar 密码不同的是 foobar

2444
17:13:40,880 --> 17:13:46,796
我们会说从异常中抛出错误的密码所以

2445
17:13:46,796 --> 17:13:51,276
记住登录本身，如果我们去我们的

2446
17:13:51,276 --> 17:13:56,400
firebase auth provider 所以去这个文件 firebase auth provider dart 它有

2447
17:13:56,400 --> 17:14:00,240
那些功能，例如，如果您查看登录信息，它具有功能

2448
17:14:00,240 --> 17:14:03,916
像处理用户未找到错误密码通用身份验证异常等

2449
17:14:03,916 --> 17:14:07,116
我们正在做的是我们正在创建某种类似的模拟

2450
17:14:07,116 --> 17:14:12,000
但我们将其锁定到特定的电子邮件和密码

2451
17:14:12,000 --> 17:14:16,320
好的，这是密码，我们不喜欢 bar.com 上 foo 的电子邮件，我们

2452
17:14:16,320 --> 17:14:21,200
现在不喜欢 foobar 的密码

2453
17:14:21,200 --> 17:14:24,560
我们现在也将在这里删除未实现的错误

2454
17:14:24,560 --> 17:14:30,000
案例让我们创建一个用户，所以我们会说用户是和关闭用户

2455
17:14:30,000 --> 17:14:34,720
并且它是电子邮件验证我们只是说真或者我们只是说假所以我们

2456
17:14:34,720 --> 17:14:39,116
说当您尝试登录时，我们只是说电子邮件验证是错误的

2457
17:14:39,116 --> 17:14:42,880
现在我们已经创建了一个用户，让我们将它分配给我们的用户

2458
17:14:42,880 --> 17:14:46,560
像这样，因为记住我们有一个名为的私有字段

2459
17:14:46,560 --> 17:14:52,240
下划线用户，我们只是这样保持它

2460
17:14:52,240 --> 17:14:56,400
然后我们会这样做，因为记住我们需要返回该身份验证的未来

2461
17:14:56,400 --> 17:15:05,680
用户然后我们说返回值等于我们的用户这样的未来

2462
17:15:05,680 --> 17:15:10,636
这就是我们的登录功能

2463
17:15:10,636 --> 17:15:14,480
所以这是相当多的工作，但我认为

2464
17:15:14,480 --> 17:15:19,276
希望你能理解我们在那里所做的事情

2465
17:15:19,276 --> 17:15:23,840
现在我们必须看看注销功能，注销功能将有

2466
17:15:23,840 --> 17:15:28,796
还有一些代码，所以嗯，它不仅仅是会说好的，我

2467
17:15:28,796 --> 17:15:32,240
正如我之前提到的那样注销，我们需要确保

2468
17:15:32,240 --> 17:15:35,916
模拟提供程序已初始化，因此让我们将代码带入此处

2469
17:15:35,916 --> 17:15:40,636
繁荣好吧，我们还需要确保如果你想注销你已经

2470
17:15:40,636 --> 17:15:44,240
实际上之前登录过所以让我们说如果

2471
17:15:44,240 --> 17:15:49,840
嗯，如果用户为空，我能找到我的钥匙吗

2472
17:15:49,840 --> 17:15:55,916
然后抛出 uh user not found off 异常好吗

2473
17:15:55,916 --> 17:15:59,200
否则我们要做的就是等待

2474
17:15:59,200 --> 17:16:04,080
所以让我们在假装等待之前找到一个等待代码

2475
17:16:04,080 --> 17:16:09,840
只需一秒钟，我们也将设置我们的用户

2476
17:16:09,840 --> 17:16:13,840
为 null 我们只是说当前用户不是你可以看到的

2477
17:16:13,840 --> 17:16:18,240
抱怨我们正在使用重量但让我在这里说

2478
17:16:18,240 --> 17:16:21,596
就像那样异步然后错误消失

2479
17:16:21,596 --> 17:16:26,480
因为如果您将注销功能标记为异步，那么您可以等待未来

2480
17:16:26,480 --> 17:16:30,560
注销也很容易说我是否已初始化

2481
17:16:30,560 --> 17:16:34,480
为了让我退出，需要有一个用户，然后我要

2482
17:16:34,480 --> 17:16:38,560
假等待一秒钟，然后我将该用户设置为 null 如此简单的 pc

2483
17:16:38,560 --> 17:16:41,040
好的

2484
17:16:41,040 --> 17:16:45,680
现在让我们模拟我们的电子邮件验证码

2485
17:16:45,680 --> 17:16:49,116
所以同样的事情所以你现在应该熟悉这个让我们确保

2486
17:16:49,116 --> 17:16:52,956
我们已经初始化了，我要从房间里获取一个代码

2487
17:16:52,956 --> 17:16:55,276
未实现的错误实际上让我们离开它

2488
17:16:55,276 --> 17:16:58,720
至少现在让我们把它放在那里好吧

2489
17:16:58,720 --> 17:17:03,360
然后在发送电子邮件验证期间

2490
17:17:03,360 --> 17:17:08,080
我们要做的是你看到当我们登录时我们说呃让我们有一个

2491
17:17:08,080 --> 17:17:11,680
看我们说的登录默认用户邮箱验证的邮箱

2492
17:17:11,680 --> 17:17:16,160
是错误的，但在发送发送电子邮件验证后，我们将翻转

2493
17:17:16,160 --> 17:17:19,436
突然间我要在你的电子邮件之外说“哦”的那面旗帜

2494
17:17:19,436 --> 17:17:22,636
验证了哪个不太现实但

2495
17:17:22,636 --> 17:17:27,116
这就是我们现在正在嘲笑的逻辑，好吧，记住一个身份验证

2496
17:17:27,116 --> 17:17:29,520
用户呃在这里

2497
17:17:29,520 --> 17:17:35,276
有一个并且它的电子邮件已验证它像你一样只读它是一个常数你不能

2498
17:17:35,276 --> 17:17:39,276
改变它只是因为我们有一个可选用户

2499
17:17:39,276 --> 17:17:43,116
我们的模拟身份验证提供者并不意味着我们可以直接说用户是

2500
17:17:43,116 --> 17:17:48,400
email 验证为 true 我们无法写入，因此我们需要重写整个用户

2501
17:17:48,400 --> 17:17:50,956
可以，然后呢

2502
17:17:50,956 --> 17:17:55,840
在检查您是否已初始化之后，我们正在做的就是说

2503
17:17:55,840 --> 17:17:59,680
如果让我们让用户真正成为最终用户

2504
17:17:59,680 --> 17:18:03,436
这是让我们获取您当前的用户，然后我们

2505
17:18:03,436 --> 17:18:10,480
说如果用户为空并抛出用户未找到所以我们的

2506
17:18:10,480 --> 17:18:14,400
发送电子邮件验证码确保您已登录

2507
17:18:14,400 --> 17:18:17,680
在您发送电子邮件验证或至少您注册之前

2508
17:18:17,680 --> 17:18:21,040
你的用户还好，嗯

2509
17:18:21,040 --> 17:18:24,956
好的，那么我们要做的是创建

2510
17:18:24,956 --> 17:18:29,200
一个新用户我们说新用户是一个关闭用户并且他的电子邮件验证是真实的

2511
17:18:29,200 --> 17:18:33,840
这一次，然后我们将其设置为我们的当前用户，所以我们说当前用户

2512
17:18:33,840 --> 17:18:39,200
是新用户，然后我们将其删除并制作

2513
17:18:39,200 --> 17:18:44,400
我们确定我们的代码也是异步的

2514
17:18:44,400 --> 17:18:47,596
这是用于发送电子邮件和验证

2515
17:18:47,596 --> 17:18:50,880
所以你看确实需要一段时间，但实际上我们已经

2516
17:18:50,880 --> 17:18:55,436
现在编写了一个模拟身份验证提供程序，它有自己的代码并且有自己的

2517
17:18:55,436 --> 17:19:00,000
初始化等好吧，现在我们需要做的是

2518
17:19:00,000 --> 17:19:06,000
实际上谈论测试所以嗯

2519
17:19:06,000 --> 17:19:12,080
让我们看看是的，嗯，什么是测试组，什么是

2520
17:19:12,080 --> 17:19:16,956
测试你看到如果你认为测试是或至少

2521
17:19:16,956 --> 17:19:22,160
单元测试作为测试其他代码段的代码段

2522
17:19:22,160 --> 17:19:26,080
你可能认为好吧，我要为创建用户写一个测试

2523
17:19:26,080 --> 17:19:29,840
在这里，我要为当前用户编写一个测试，我要为其编写测试

2524
17:19:29,840 --> 17:19:34,000
初始化登录等等等等现在所有这些都是常见的并且他们很友善

2525
17:19:34,000 --> 17:19:39,040
相关的，他们都在测试模拟身份验证提供程序，这就是测试组

2526
17:19:39,040 --> 17:19:45,360
在你的测试功能中为你的测试和测试套件中的颤振抱歉

2527
17:19:45,360 --> 17:19:50,240
佛罗里达，您实际上可以将您的测试功能分组到一个具有

2528
17:19:50,240 --> 17:19:55,436
name 然后你可以让 Flutter 为你运行整个测试组

2529
17:19:55,436 --> 17:20:02,160
这就是测试组的用途，所以现在我们需要做的是进入

2530
17:20:02,160 --> 17:20:07,276
我们的主要测试功能就在那里，基本上创建一个组，然后添加

2531
17:20:07,276 --> 17:20:12,956
provider 里面，所以让我们继续，然后输入 group

2532
17:20:12,956 --> 17:20:17,596
在这里我们只是说模拟身份验证没问题

2533
17:20:17,596 --> 17:20:20,956
让我们在这里将第二个参数作为函数

2534
17:20:20,956 --> 17:20:23,916
就像那样，现在你应该有这样的代码，所以基本上你

2535
17:20:23,916 --> 17:20:28,000
创建了一个测试组，你可以看到 Visual Studio 代码告诉我哦

2536
17:20:28,000 --> 17:20:32,160
你可以运行这个组，所以我们要把我们所有的模拟

2537
17:20:32,160 --> 17:20:36,240
该组内的身份验证测试可以

2538
17:20:36,240 --> 17:20:40,560
正如标题所说，我们要做的第一件事就是创建我们的

2539
17:20:40,560 --> 17:20:46,320
我们的模拟 aus 提供者的一个实例，所以让我们继续说一个 final

2540
17:20:46,320 --> 17:20:51,200
提供者就是这样的模拟提供者

2541
17:20:51,200 --> 17:20:53,360
可以，然后呢

2542
17:20:53,360 --> 17:20:57,596
现在我们有了，所以现在我们要开始多汁的部分了

2543
17:20:57,596 --> 17:21:00,240
我对此感到非常高兴，因为我们已经做了很多基础工作

2544
17:21:00,240 --> 17:21:02,880
只是为了本章的这一点

2545
17:21:02,880 --> 17:21:07,200
所以现在我们要写我们的第一个测试，你可以看到标题说测试

2546
17:21:07,200 --> 17:21:11,116
提供者被初始化 提供者不应该被初始化开始

2547
17:21:11,116 --> 17:21:14,240
你看我们从一个

2548
17:21:14,240 --> 17:21:18,720
一个断言，我们说根据我们的实现方式，我们已经

2549
17:21:18,720 --> 17:21:23,680
实现了我们的模拟身份验证提供程序，它不应该被初始化

2550
17:21:23,680 --> 17:21:26,880
所以我们只是通过创建一个模拟身份验证实例来确保

2551
17:21:26,880 --> 17:21:31,276
提供者它被初始化为布尔 getter

2552
17:21:31,276 --> 17:21:36,080
应该返回 false 如果它返回 true 我们将失败我们的测试所以

2553
17:21:36,080 --> 17:21:39,360
这意味着如果有人稍后偷偷进入代码并说哦

2554
17:21:39,360 --> 17:21:43,116
默认情况下这是真的，那么测试将失败，所有开发人员都在

2555
17:21:43,116 --> 17:21:46,320
团队会收到通知的

2556
17:21:46,320 --> 17:21:50,000
所以让我们创建我们的第一个测试方法

2557
17:21:50,000 --> 17:21:54,400
在颤振中创建测试是你开始输入测试好了

2558
17:21:54,400 --> 17:21:58,080
在这种情况下你给它起个名字我会说不应该

2559
17:21:58,080 --> 17:22:03,916
被初始化为以ok开头，所以这就是名字，然后你会

2560
17:22:03,916 --> 17:22:08,160
为它提供一个在进行测试时执行的函数

2561
17:22:08,160 --> 17:22:13,116
在这里你可以说你可以使用一个名为expect的函数

2562
17:22:13,116 --> 17:22:18,240
你说作家提供者已初始化

2563
17:22:18,240 --> 17:22:23,360
一开始就应该是假的 所以

2564
17:22:23,360 --> 17:22:28,400
这是我们编写的第一个测试，所以测试函数然后你写一个名字

2565
17:22:28,400 --> 17:22:33,596
然后它是一个要执行的函数，在那里你可以使用各种风格的

2566
17:22:33,596 --> 17:22:38,636
期望功能，你会看到期望有各种不同的风格

2567
17:22:38,636 --> 17:22:41,200
所以现在我们只期待简单的

2568
17:22:41,200 --> 17:22:46,160
初始化标志为假好的

2569
17:22:46,160 --> 17:22:52,880
现在我们必须做的下一个测试是字幕案例测试记录

2570
17:22:52,880 --> 17:22:57,360
在初始化之前，提供者应该抛出而不是初始化

2571
17:22:57,360 --> 17:22:59,756
例外所以

2572
17:22:59,756 --> 17:23:03,756
基本上我们所说的是根据注销功能

2573
17:23:03,756 --> 17:23:07,756
如果它没有首先初始化，则应该无法注销，所以我们实际上是

2574
17:23:07,756 --> 17:23:11,916
测试这行代码没问题，以确保没有人只是无意

2575
17:23:11,916 --> 17:23:16,000
将其注释掉或无意中删除了我们不需要的所有内容

2576
17:23:16,000 --> 17:23:21,200
对，所以让我们测试一下功能，所以让我们说测试我

2577
17:23:21,200 --> 17:23:24,240
去看看我的笔记，看看我在那里命名了什么

2578
17:23:24,240 --> 17:23:28,320
如果没有初始化就无法注销，现在你知道了

2579
17:23:28,320 --> 17:23:31,596
作为测试功能的第二个参数，您需要提供一个功能

2580
17:23:31,596 --> 17:23:34,160
所以呃括号

2581
17:23:34,160 --> 17:23:38,560
然后是大括号，在这里我们要说

2582
17:23:38,560 --> 17:23:42,560
期待，现在我们正在使用这种新风格

2583
17:23:42,560 --> 17:23:46,240
期望在这里我只想说提供商注销

2584
17:23:46,240 --> 17:23:54,240
在调用这个注销函数时，我们实际上希望期待一个异常

2585
17:23:54,240 --> 17:23:59,840
所以你可以在这里使用一个非常好的 uh catch

2586
17:23:59,840 --> 17:24:04,160
被称为 throws a 你可以看到 throws a 是一个匹配器

2587
17:24:04,160 --> 17:24:08,636
它会将注销功能的结果与您提供的任何内容相匹配

2588
17:24:08,636 --> 17:24:12,956
在这里，你说 throws a 然后你期望

2589
17:24:12,956 --> 17:24:18,000
这里有一个例外，您会看到 const 类型匹配器

2590
17:24:18,000 --> 17:24:21,756
高度匹配器只会说未初始化

2591
17:24:21,756 --> 17:24:26,400
例外所以我要输入这个然后我要告诉你我是什么

2592
17:24:26,400 --> 17:24:30,880
基本上在这里做看看我通过 jose const 做了什么

2593
17:24:30,880 --> 17:24:35,436
blah blah blah huh 看起来也不错

2594
17:24:35,436 --> 17:24:41,520
让我们看看为什么类型管理器不提取方法 cons 我可能会抛出

2595
17:24:41,520 --> 17:24:45,916
在这里搞砸了一些东西

2596
17:24:45,916 --> 17:24:50,560
所以让我们看看这里发生了什么，所以我们在这里告诉期望的是

2597
17:24:50,560 --> 17:24:54,480
说执行注销功能和

2598
17:24:54,480 --> 17:24:59,756
我们现在正在针对一个叫做 a 的东西测试该函数的结果

2599
17:24:59,756 --> 17:25:05,116
matcher 和 matcher 是因为你在这里看到你不能说这个结果

2600
17:25:05,116 --> 17:25:08,880
应该是一个例外，因为你要做什么是你要创造

2601
17:25:08,880 --> 17:25:11,840
一个不是该异常的实例

2602
17:25:11,840 --> 17:25:15,436
这不是在这里测试你的功能的好方法你说

2603
17:25:15,436 --> 17:25:19,756
您正在匹配调用它获得的注销功能的结果

2604
17:25:19,756 --> 17:25:25,840
预期类型，如您所见，类型匹配器是如果您进入它，您可以看到

2605
17:25:25,840 --> 17:25:31,276
是一个匹配器还可以，所以这就是你所期望的

2606
17:25:31,276 --> 17:25:37,756
函数可以抛出异常

2607
17:25:37,756 --> 17:25:42,000
好的，有很多信息，现在我们需要在测试后做什么

2608
17:25:42,000 --> 17:25:45,840
我们只需要确保我们可以实际初始化我们的功能

2609
17:25:45,840 --> 17:25:49,116
模拟提供者我要带一点代码

2610
17:25:49,116 --> 17:25:52,636
在这里让你看得更清楚

2611
17:25:52,636 --> 17:25:54,720
所以现在让我们

2612
17:25:54,720 --> 17:25:58,796
进入这里说测试，让我看看它应该能够被初始化

2613
17:25:58,796 --> 17:26:02,080
应该可以初始化

2614
17:26:02,080 --> 17:26:06,480
并在这里创建一个空函数然后我们要做的就是

2615
17:26:06,480 --> 17:26:11,436
说等待提供者点初始化像这样

2616
17:26:11,436 --> 17:26:14,956
记住就像你的飞镖代码中的任何地方一样，你可以让你的

2617
17:26:14,956 --> 17:26:19,200
只需将 async 放在大括号之前就可以实现异步功能，所以

2618
17:26:19,200 --> 17:26:22,400
它不是函数签名的一部分，它只是告诉飞镖

2619
17:26:22,400 --> 17:26:26,636
在这个函数里面我要异步执行一些代码

2620
17:26:26,636 --> 17:26:30,956
所以在初始化我们然后在初始化之后，如果你看一下代码

2621
17:26:30,956 --> 17:26:35,040
我们做了初始化它只是做了一个呃

2622
17:26:35,040 --> 17:26:39,040
和一秒的权重，然后它设置的标志被初始化为真

2623
17:26:39,040 --> 17:26:44,240
我们可以通过读取这个 boolean getter 来读取那个标志，所以让我们说吧

2624
17:26:44,240 --> 17:26:48,000
提供者初始化，然后我们会说期望

2625
17:26:48,000 --> 17:26:52,000
在此之后提供者被初始化标志为真

2626
17:26:52,000 --> 17:26:57,916
好吧，这样一个很容易

2627
17:26:57,916 --> 17:27:02,560
所以在我们完成所有这些之后，您会看到已初始化并正在执行初始化

2628
17:27:02,560 --> 17:27:06,160
实际上不会为我们创建用户，所以让我们确定一下

2629
17:27:06,160 --> 17:27:10,956
初始化我们的提供者，用户不是所以让我们说测试

2630
17:27:10,956 --> 17:27:15,436
初始化后用户应该为空

2631
17:27:15,436 --> 17:27:20,000
空函数，然后让我们期待用户

2632
17:27:20,000 --> 17:27:22,796
当前用户是已知的，所以让我们说期望

2633
17:27:22,796 --> 17:27:27,276
提供者当前用户应该知道它是正确的

2634
17:27:27,276 --> 17:27:32,080
易于阅读，几乎就像阅读英语一样

2635
17:27:32,080 --> 17:27:35,680
就是这样了

2636
17:27:35,680 --> 17:27:39,436
现在我们要做的是做一些我想要的异步测试

2637
17:27:39,436 --> 17:27:43,040
你也要看到这个，因为它非常重要，现在假设你是

2638
17:27:43,040 --> 17:27:47,116
我们要测试，因为标题告诉您测试所需的时间

2639
17:27:47,116 --> 17:27:50,636
初始化我们可以在这种情况下测试超时，所以

2640
17:27:50,636 --> 17:27:57,680
我们要做的是在这里查看我们的初始化代码，让我们看看

2641
17:27:57,680 --> 17:28:02,160
此刻这里的初始化函数正在等待一秒钟什么

2642
17:28:02,160 --> 17:28:06,320
我们将在我们的测试中做只是为了使用你如何测试

2643
17:28:06,320 --> 17:28:10,796
超时以及如何在未来测试例如 api 调用

2644
17:28:10,796 --> 17:28:15,276
在这里做一些异步测试，超时说明我们的测试

2645
17:28:15,276 --> 17:28:19,360
如果在我们的提供者上初始化需要更多时间，则应该失败

2646
17:28:19,360 --> 17:28:25,916
比 x 秒数好吧，所以现在让我们进去说 test um

2647
17:28:25,916 --> 17:28:29,840
应该可以初始化

2648
17:28:29,840 --> 17:28:34,320
在不到两秒钟的时间内，好的，一个空的功能是

2649
17:28:34,320 --> 17:28:39,756
异步的，就像现在的那个空的身体

2650
17:28:39,756 --> 17:28:45,200
我们在这里要做的是等待

2651
17:28:45,200 --> 17:28:49,596
关于提供者的初始化没问题

2652
17:28:49,596 --> 17:28:53,596
并且在初始化之后，我们也会期待 is initialize 标志

2653
17:28:53,596 --> 17:28:57,840
就像那样是真的，但是我们要

2654
17:28:57,840 --> 17:29:01,680
使用我们测试的一个新参数，称为超时

2655
17:29:01,680 --> 17:29:06,796
现在 timeout 将为它提供一个恒定的超时时间

2656
17:29:06,796 --> 17:29:11,200
持续时间这么长，在这种情况下，我们只是

2657
17:29:11,200 --> 17:29:13,916
要说两秒钟，我想我们在这里有一个额外的参数

2658
17:29:13,916 --> 17:29:18,880
宪法超时参数零预期发现了什么

2659
17:29:18,880 --> 17:29:25,596
缺点时间，然后在这里秒，并避免在这里缺点好的，所以这是非常

2660
17:29:25,596 --> 17:29:29,436
简单地说，我们说我们创建了一个测试，它调用

2661
17:29:29,436 --> 17:29:35,040
在我们的提供者上初始化函数，并确保该函数返回

2662
17:29:35,040 --> 17:29:40,480
在超时过去之前到测试上下文，所以在内部这个测试

2663
17:29:40,480 --> 17:29:45,276
您提供超时的功能将创建一个小计时器和

2664
17:29:45,276 --> 17:29:49,200
然后它会在调用

2665
17:29:49,200 --> 17:29:52,080
函数这个函数在这里让我告诉你

2666
17:29:52,080 --> 17:29:55,916
就在这里

2667
17:29:55,916 --> 17:30:01,040
正在进行并完成其工作，它将终止其结果处理

2668
17:30:01,040 --> 17:30:06,080
只要超时基本上过去了，所以在这种情况下，我们的初始化函数

2669
17:30:06,080 --> 17:30:10,880
如果在此期间无法完成这项工作，将需要一秒钟的时间来处理这项工作

2670
17:30:10,880 --> 17:30:16,720
这两秒钟的超时测试将失败，所以现在你知道了

2671
17:30:16,720 --> 17:30:19,916
如何测试它

2672
17:30:19,916 --> 17:30:24,956
所以让我们进入这里，现在测试我们的中间部分

2673
17:30:24,956 --> 17:30:30,080
如您所见，正在创建用户的提供者我们必须进行测试以确保

2674
17:30:30,080 --> 17:30:34,560
创建用户实际上委托给我们的登录功能，我们必须测试

2675
17:30:34,560 --> 17:30:38,160
所有边缘情况都可以

2676
17:30:38,160 --> 17:30:42,840
所以让我们继续做吧让我们说我们测试

2677
17:30:42,840 --> 17:30:49,276
呃创建用户应该委托嗯委托

2678
17:30:49,276 --> 17:30:53,436
登录功能，在这里我们要创建

2679
17:30:53,436 --> 17:30:57,040
一个异步函数

2680
17:30:57,040 --> 17:31:00,240
正确需要做的是创造这个

2681
17:31:00,240 --> 17:31:03,436
基本上，如果您记得创建用户没有自己的内部逻辑

2682
17:31:03,436 --> 17:31:06,880
它只是调用登录，但登录有这个美丽的逻辑，首先测试

2683
17:31:06,880 --> 17:31:09,916
美食吧

2684
17:31:09,916 --> 17:31:14,320
任何密码都应该抛出这个错误用户未发现异常所以

2685
17:31:14,320 --> 17:31:17,916
让我们测试一下那个场景好吧让我们进去吧

2686
17:31:17,916 --> 17:31:25,360
并说最终的不良电子邮件用户是提供商创建

2687
17:31:25,360 --> 17:31:27,680
呃

2688
17:31:27,680 --> 17:31:32,796
作家哦，我们没有我们的供应商吗

2689
17:31:32,796 --> 17:31:38,160
哦，我已经添加了这个测试我很抱歉我已经添加了这个测试我相信在结束时

2690
17:31:38,160 --> 17:31:42,160
这整个测试组我应该在这里添加它所以如果你做了同样的

2691
17:31:42,160 --> 17:31:46,000
错误我很抱歉这是我的错你应该解决这个问题并做出

2692
17:31:46,000 --> 17:31:50,796
确保您的测试位于可以访问提供者的同一组中，以便

2693
17:31:50,796 --> 17:31:56,000
然后我要说提供者，所以最终的坏电子邮件用户是

2694
17:31:56,000 --> 17:32:01,596
呃提供商创建用户电子邮件是 fooatbar.com

2695
17:32:01,596 --> 17:32:04,796
密码可以是任何密码

2696
17:32:04,796 --> 17:32:10,000
逗号分号确保 dart 格式化程序正确地格式化您的代码，然后呢

2697
17:32:10,000 --> 17:32:14,480
我们需要确定坏用户是什么时候

2698
17:32:14,480 --> 17:32:19,276
基本上返回给我们那么它实际上应该包含一个未找到的用户

2699
17:32:19,276 --> 17:32:23,276
例外所以让我们继续说期望

2700
17:32:23,276 --> 17:32:29,276
实际上是一个糟糕的电子邮件用户

2701
17:32:29,276 --> 17:32:32,320
抛出一个常量

2702
17:32:32,320 --> 17:32:36,080
类型匹配器

2703
17:32:36,080 --> 17:32:42,400
该用户没有发现这样的异常

2704
17:32:42,400 --> 17:32:45,436
好吧，让我们看看，我

2705
17:32:45,436 --> 17:32:50,000
也必须在这里关闭它，所以我们基本上是在说调用

2706
17:32:50,000 --> 17:32:55,360
错误的电子邮件用户使用该特定电子邮件创建用户应该抛出一个

2707
17:32:55,360 --> 17:32:58,956
用户未发现异常并记住您可能会认为我们已经测试过

2708
17:32:58,956 --> 17:33:02,320
这之前还没有，但那是在

2709
17:33:02,320 --> 17:33:06,636
在这里让我们看看实际上不，我们还没有测试过

2710
17:33:06,636 --> 17:33:09,596
在它之前，我们已经测试过这个东西，所以很抱歉，所以我们已经

2711
17:33:09,596 --> 17:33:12,796
测试了很多，是的，我们还没有测试过这个特殊情况，所以

2712
17:33:12,796 --> 17:33:16,080
好吧，现在我们已经测试过了，现在让我们测试一下

2713
17:33:16,080 --> 17:33:20,320
这种情况下密码错误 fubar 的密码，你看我们有

2714
17:33:20,320 --> 17:33:24,796
我们的模拟提供程序中用于登录功能的逻辑让我们测试这个场景

2715
17:33:24,796 --> 17:33:29,840
现在让我们测试这段代码，我们应该把错误的密码抛出异常，好吧，所以

2716
17:33:29,840 --> 17:33:34,400
让我们进去说final

2717
17:33:34,400 --> 17:33:40,560
我可以看到您看不到代码，所以密码错误的用户是提供者并创建

2718
17:33:40,560 --> 17:33:45,916
电子邮件的用户让我们说 bar.com 上的某人，密码是

2719
17:33:45,916 --> 17:33:50,000
fubar，那是我们不喜欢的密码，记住了，好吧

2720
17:33:50,000 --> 17:33:53,916
现在我们从这里复制代码然后我们说

2721
17:33:53,916 --> 17:34:00,560
该密码用户应该抛出一个名为错误密码的异常

2722
17:34:00,560 --> 17:34:06,480
关闭异常好吧，所以我们也测试了那个场景

2723
17:34:06,480 --> 17:34:12,240
现在我们实际上应该测试积极的情况，所以让我们继续吧

2724
17:34:12,240 --> 17:34:18,956
并说最终用户正在等待提供者，我们说创建用户

2725
17:34:18,956 --> 17:34:23,040
好吧，一封电子邮件将是

2726
17:34:23,040 --> 17:34:27,520
foo 和密码将是 bar 记住我们的模拟身份验证提供程序是

2727
17:34:27,520 --> 17:34:32,560
没有实际测试电子邮件是否是正确的电子邮件

2728
17:34:32,560 --> 17:34:36,956
firebase 正在这样做，但模拟提供商没有这样做

2729
17:34:36,956 --> 17:34:41,276
我们可以提供任何电子邮件 foo 和密码栏，它只会

2730
17:34:41,276 --> 17:34:45,276
接受它，只要它不是密码不是 foobar 并且只要

2731
17:34:45,276 --> 17:34:52,956
因为电子邮件不是footbar.com 好的，现在让我们确保

2732
17:34:52,956 --> 17:34:59,040
然后将该用户分配给我们的身份验证提供者的当前用户

2733
17:34:59,040 --> 17:35:04,560
所以让我们期待身份验证提供商提供对不起提供商的当前用户

2734
17:35:04,560 --> 17:35:09,596
实际上等于这个用户好吧，因为嗯

2735
17:35:09,596 --> 17:35:13,520
这就是我们在创建用户时所做的，记住我们创建用户委托这个

2736
17:35:13,520 --> 17:35:17,596
工作到登录，然后登录在内部将当前用户设置为

2737
17:35:17,596 --> 17:35:21,916
他们刚刚创建好的用户，这就是我们现在正在测试的场景

2738
17:35:21,916 --> 17:35:27,520
这里的代码行没问题，就是这样

2739
17:35:27,520 --> 17:35:30,636
嗯，那么我们需要做的就是

2740
17:35:30,636 --> 17:35:33,596
确保只需创建一个我们的用户

2741
17:35:33,596 --> 17:35:38,560
在这里做的是电子邮件验证功能抱歉是电子邮件

2742
17:35:38,560 --> 17:35:45,436
我们的auth用户的验证um参数默认设置为false记住

2743
17:35:45,436 --> 17:35:49,680
这里设置的登录功能是电子邮件验证假让我们

2744
17:35:49,680 --> 17:35:54,080
测试该功能没问题，所以我们只说期望

2745
17:35:54,080 --> 17:35:58,320
我们使用电子邮件验证为虚假的用户

2746
17:35:58,320 --> 17:36:02,160
哇，那是很多

2747
17:36:02,160 --> 17:36:06,400
代码对你说实话，我希望你得到我提到的一切

2748
17:36:06,400 --> 17:36:10,560
现在我们已经完成了，让我们测试一下

2749
17:36:10,560 --> 17:36:14,956
电子邮件验证功能 呃，让我们看看我们

2750
17:36:14,956 --> 17:36:19,436
实际上在电子邮件验证中做了你看到我们没有这个功能

2751
17:36:19,436 --> 17:36:22,320
初始化然后我们取当前用户，如果

2752
17:36:22,320 --> 17:36:26,720
当前用户为空然后我们说用户未找到异常然后我们创建一个

2753
17:36:26,720 --> 17:36:32,000
新用户的电子邮件验证为真，然后我们将该用户设置为

2754
17:36:32,000 --> 17:36:38,160
当前用户，这就是发送电子邮件验证码的作用

2755
17:36:38,160 --> 17:36:40,400
现在你知道什么时候了

2756
17:36:40,400 --> 17:36:43,436
当颤动然后运行我们的代码时，它将按顺序运行它们，所以它是

2757
17:36:43,436 --> 17:36:47,200
只是从上到下然后你记得

2758
17:36:47,200 --> 17:36:51,276
在我们测试电子邮件验证之前，我们实际上是在测试创建用户

2759
17:36:51,276 --> 17:36:56,240
反过来调用登录函数，所以因为我们要保持我们的

2760
17:36:56,240 --> 17:36:59,680
提供者这创建用户调用登录功能

2761
17:36:59,680 --> 17:37:05,040
确保当前用户实际设置并且未通过电子邮件验证，因此我们可以

2762
17:37:05,040 --> 17:37:08,000
指望那好吧，所以让我们说

2763
17:37:08,000 --> 17:37:13,040
我们测试，我们说登录用户应该能够

2764
17:37:13,040 --> 17:37:19,200
得到验证 呃 登录用户应该可以

2765
17:37:19,200 --> 17:37:23,200
得到验证没问题，然后在这里有一个空函数

2766
17:37:23,200 --> 17:37:28,480
嗯，就是这样，所以在这里我们说供应商发送

2767
17:37:28,480 --> 17:37:33,200
电子邮件验证没问题，最终用户是提供商

2768
17:37:33,200 --> 17:37:36,560
用户呃

2769
17:37:36,560 --> 17:37:39,916
当前用户这样

2770
17:37:39,916 --> 17:37:45,916
我们现在确保当前用户不为空，所以我们说期望用户

2771
17:37:45,916 --> 17:37:52,240
不是呃或者是期望用户不是空的

2772
17:37:52,240 --> 17:37:55,756
如您所见，这是一个很棒的匹配器，您可以将某些东西与之匹配，所以

2773
17:37:55,756 --> 17:38:00,720
你说不应该这样好吧

2774
17:38:00,720 --> 17:38:05,596
然后我们还需要确保设置了这个用户的 uh 验证

2775
17:38:05,596 --> 17:38:08,796
所以它的电子邮件验证应该是真的然后我们说期望，我们会得到一个

2776
17:38:08,796 --> 17:38:14,080
错误现在您会看到用户已通过电子邮件验证它应该是真的

2777
17:38:14,080 --> 17:38:16,880
好的，你可以看到你在这里得到一个错误，说用户是可选的，但是

2778
17:38:16,880 --> 17:38:19,916
我们要在这里做一个星号说

2779
17:38:19,916 --> 17:38:25,520
对我们快速强制强制

2780
17:38:25,520 --> 17:38:30,320
现在我们应该做的最后一个测试我们作为标题说测试注销

2781
17:38:30,320 --> 17:38:33,360
并登录，这是正常情况，应该可以正常工作让我们

2782
17:38:33,360 --> 17:38:37,360
为它创建一个测试，所以我们只说测试

2783
17:38:37,360 --> 17:38:41,276
我们将调用它应该能够注销并再次登录应该

2784
17:38:41,276 --> 17:38:47,276
能够注销并再次登录

2785
17:38:47,276 --> 17:38:51,596
和一个异步函数 so 和一个分号在最后

2786
17:38:51,596 --> 17:38:55,276
所以我们在这里要做的就是说

2787
17:38:55,276 --> 17:38:59,040
注销并登录，然后我们获取当前用户，我们只需确保

2788
17:38:59,040 --> 17:39:04,240
你不是空的，所以让我们说等待提供者

2789
17:39:04,240 --> 17:39:08,636
注销，我们说等待提供商登录

2790
17:39:08,636 --> 17:39:14,240
仅包含用户名和密码的电子邮件

2791
17:39:14,240 --> 17:39:19,840
就这样好吧，或者只是发送电子邮件，因为我们实际上并没有验证

2792
17:39:19,840 --> 17:39:25,436
我们的模拟作者提供者中的身份验证提供者中的电子邮件和密码

2793
17:39:25,436 --> 17:39:30,160
然后我们要获取当前用户，所以我们说最终用户是提供者

2794
17:39:30,160 --> 17:39:34,160
当前用户，我们只是确保该用户不为人所知，所以让我们说

2795
17:39:34,160 --> 17:39:42,000
期望用户不为空，这是内置的方法

2796
17:39:42,000 --> 17:39:46,880
颤振测试好吧，那是很多工作，我

2797
17:39:46,880 --> 17:39:51,116
为你坚持这一章而自豪

2798
17:39:51,116 --> 17:39:55,596
我们谈了很多关于测试的事情，你需要经历很多事情

2799
17:39:55,596 --> 17:39:58,720
材料，您还需要自己学习不同类型的

2800
17:39:58,720 --> 17:40:03,040
事情和不同风格的期望和谈论期望我有点

2801
17:40:03,040 --> 17:40:06,796
期待你自己去阅读这些东西

2802
17:40:06,796 --> 17:40:10,000
并在您自己的时间了解它们

2803
17:40:10,000 --> 17:40:15,756
现在是我们需要运行测试的激动人心的部分，所以让我更改屏幕布局

2804
17:40:15,756 --> 17:40:19,520
让我们进入我们的终端

2805
17:40:19,520 --> 17:40:23,200
让我们增加尺寸和

2806
17:40:23,200 --> 17:40:27,360
那么让我们打破这个，你可以看到你可以

2807
17:40:27,360 --> 17:40:32,320
通过说颤振测试并提供该路径来告诉颤振运行您的测试

2808
17:40:32,320 --> 17:40:37,360
你的测试，所以现在颤动将继续并发布并通过那些

2809
17:40:37,360 --> 17:40:41,040
一一测试

2810
17:40:41,040 --> 17:40:45,360
让我们看看我们得到的结果

2811
17:40:45,360 --> 17:40:50,000
你可以看到它为所有这些测试提供了同样的时间，它说明了一切

2812
17:40:50,000 --> 17:40:54,956
测试通过了，我只是想在继续之前强调这一点，我们做了一个

2813
17:40:54,956 --> 17:41:00,080
很多测试我已经手动准备了这些测试，以确保它们

2814
17:41:00,080 --> 17:41:04,400
实际上在我们的身份验证提供程序中测试了重要的功能，但是我已经

2815
17:41:04,400 --> 17:41:07,680
非常仔细地编写测试以确保

2816
17:41:07,680 --> 17:41:12,000
他们在工作时，情况并非如此

2817
17:41:12,000 --> 17:41:16,880
现实生活中的事情，如果你做对了，你的测试应该会失败

2818
17:41:16,880 --> 17:41:22,240
测试应该无法开始，然后你需要去写你的并修复

2819
17:41:22,240 --> 17:41:26,720
你的逻辑如果你做的事情更正确你应该写你的测试

2820
17:41:26,720 --> 17:41:31,520
首先什么都行不通，然后你应该去写你的逻辑来适应

2821
17:41:31,520 --> 17:41:35,916
这些测试和期望只是因为这些测试正确通过

2822
17:41:35,916 --> 17:41:40,160
现在我知道我们内心充满喜悦我们说哦一切都过去了一切都很好

2823
17:41:40,160 --> 17:41:45,436
但实际上通常情况并非如此

2824
17:41:45,436 --> 17:41:48,400
所以我们做了很多工作让我们像我们一样做

2825
17:41:48,400 --> 17:41:54,956
通常会保持传统，让我们投入我们的工作，并标记它

2826
17:41:54,956 --> 17:41:59,756
然后让我们说 git status 来查看状态很多事情发生了变化

2827
17:41:59,756 --> 17:42:04,160
嘿，点击添加 git 状态

2828
17:42:04,160 --> 17:42:07,756
好的，我们将把它作为第 10 步提交

2829
17:42:07,756 --> 17:42:13,680
我们要在这里说 get push 它将把我们的提交推送到 github

2830
17:42:13,680 --> 17:42:18,240
然后我们得到标签以及第10步

2831
17:42:18,240 --> 17:42:24,000
并推税

2832
17:42:24,000 --> 17:42:28,636
传统，因为它是我们经常谈论的这个呃哲学课程中的传统

2833
17:42:28,636 --> 17:42:31,680
在结束当前章节之前，我们将在下一章中做什么

2834
17:42:31,680 --> 17:42:34,320
章节，所以你可以看到缓存已经说让我们为下一章做好准备

2835
17:42:34,320 --> 17:42:38,480
章我们需要一个数据库来存储用户注释在你使用之前或者如果我们使用

2836
17:42:38,480 --> 17:42:44,080
用于存储的火力基地现在你看到我们现在不是

2837
17:42:44,080 --> 17:42:48,320
实际上在没有节点的任何地方写任何东西

2838
17:42:48,320 --> 17:42:52,400
用户甚至不能创建新节点，但是如果我们想给

2839
17:42:52,400 --> 17:42:55,680
用户创建新节点然后删除这些节点并更新的能力

2840
17:42:55,680 --> 17:43:00,796
那些节点和 uh 首先我们要存储

2841
17:43:00,796 --> 17:43:05,040
这些节点位于应用程序内部的本地数据库中，因此您将在

2842
17:43:05,040 --> 17:43:08,636
下一章关于 sqlite

2843
17:43:08,636 --> 17:43:12,956
和本地数据库以及如何将它们与 firebase 一起使用

2844
17:43:12,956 --> 17:43:18,480
抱歉以及如何在最新章节中使用它们

2845
17:43:18,480 --> 17:43:22,636
在后面的章节中，我们将改变这个逻辑，所以我们不会使用 sql

2846
17:43:22,636 --> 17:43:26,880
精简版呃，但我相信任何开发人员呃

2847
17:43:26,880 --> 17:43:30,480
如果你喜欢我不能说任何开发人员，但如果你是

2848
17:43:30,480 --> 17:43:33,436
您应该熟悉的前端开发人员或后端开发人员

2849
17:43:33,436 --> 17:43:36,480
数据库，这正是我们要做的

2850
17:43:36,480 --> 17:43:40,480
在下一章中，请吃点点心，我会在

2851
17:43:40,480 --> 17:43:44,796
下一章你好，欢迎来到第 27 章

2852
17:43:44,796 --> 17:43:48,000
前几章中的 flasa 课程

2853
17:43:48,000 --> 17:43:51,840
谈论我们的用户界面，我们也一直在

2854
17:43:51,840 --> 17:43:56,240
看看我们的服务和

2855
17:43:56,240 --> 17:44:00,480
我们也花了一些时间来创造一些

2856
17:44:00,480 --> 17:44:04,956
测试我们的服务和提供者直到现在我们已经

2857
17:44:04,956 --> 17:44:08,560
一直在谈论从一个屏幕到另一个屏幕的逻辑

2858
17:44:08,560 --> 17:44:13,680
其他 uh 与 firebase 等集成，但我们实际上还没有谈到

2859
17:44:13,680 --> 17:44:18,400
将用户创建的内容存储在我们的应用程序中或某些内部

2860
17:44:18,400 --> 17:44:22,240
一种云服务，我们将在本章中做些什么

2861
17:44:22,240 --> 17:44:27,756
我们要讨论 sql lite 并将用户生成的内容存储在

2862
17:44:27,756 --> 17:44:33,840
这种情况下，用户现在在 sqlite 内生成节点

2863
17:44:33,840 --> 17:44:37,360
我要了解 sqlite 是什么，但首先让我们看看

2864
17:44:37,360 --> 17:44:41,436
本章的标题，如您所见，上面写着 crotlocal storage for

2865
17:44:41,436 --> 17:44:44,320
你们中那些以前是软件开发人员并且熟悉的人

2866
17:44:44,320 --> 17:44:48,480
人群你可以跳过本章的这一部分

2867
17:44:48,480 --> 17:44:53,360
不熟悉 crowdcrot 代表创建读取更新和删除这些是

2868
17:44:53,360 --> 17:44:58,560
任何开发人员都会对其执行的四个非常基本的操作

2869
17:44:58,560 --> 17:45:04,320
数据，例如，如果您是烧瓶或 django 开发人员 node express um

2870
17:45:04,320 --> 17:45:08,880
开发人员，您可能已经熟悉这些，因为

2871
17:45:08,880 --> 17:45:13,840
您可能正在使用某种数据库 mysql 或 sqlite

2872
17:45:13,840 --> 17:45:17,200
嗯，您将数据存储在那里，您只是在处理数据

2873
17:45:17,200 --> 17:45:21,116
并且您熟悉作物一词，但如果您不熟悉它

2874
17:45:21,116 --> 17:45:25,360
把它想象成 c 是你在创造

2875
17:45:25,360 --> 17:45:30,560
数据库中的某种对象，例如

2876
17:45:30,560 --> 17:45:35,276
您阅读的用户生成的注释当然希望能够

2877
17:45:35,276 --> 17:45:38,636
例如，在我们应用程序的主用户界面中读取该数据

2878
17:45:38,636 --> 17:45:41,840
可能要读取数据库的全部内容

2879
17:45:41,840 --> 17:45:45,520
不是全部内容，而是至少在用户为该特定内容生成的注释中

2880
17:45:45,520 --> 17:45:50,080
用户所以那是人群中的 r 然后你有你

2881
17:45:50,080 --> 17:45:54,956
它代表更新嗯或者它不代表更新它意味着更新

2882
17:45:54,956 --> 17:45:59,436
因为 u 是更新的第一个字母，所以更新是例如如果我有

2883
17:45:59,436 --> 17:46:02,796
已经在此应用程序中生成了一个节点，我想去更改

2884
17:46:02,796 --> 17:46:06,160
那个节点的内容然后就是 crod 中的 u

2885
17:46:06,160 --> 17:46:11,840
最后但并非最不重要的是你有 d 这是删除 um 并作为它的名字

2886
17:46:11,840 --> 17:46:15,596
基本上代表你允许用户能够删除

2887
17:46:15,596 --> 17:46:20,636
他们自己从数据库中生成的内容，所以

2888
17:46:20,636 --> 17:46:24,080
我们在这门课程中要做的是

2889
17:46:24,080 --> 17:46:29,596
说说sqlite是数据库还是c

2890
17:46:29,596 --> 17:46:33,756
库和在 c um 中创建的库

2891
17:46:33,756 --> 17:46:37,680
这使我们可以将 c 视为一种程序员语言

2892
17:46:37,680 --> 17:46:42,560
允许我们现在将数据存储在文件中，如果您来自类似的地方

2893
17:46:42,560 --> 17:46:46,880
后端世界，如果你在里面用 python 编程的话

2894
17:46:46,880 --> 17:46:50,320
django 你已经熟悉了，因为 sqlite 是默认数据库

2895
17:46:50,320 --> 17:46:55,596
这将在 django 中提供给你，我相信还有一个烧瓶正在使用

2896
17:46:55,596 --> 17:46:59,276
sqlite 默认情况下非常类似于

2897
17:46:59,276 --> 17:47:03,520
django 但如果你不熟悉 sqlite

2898
17:47:03,520 --> 17:47:07,756
我在这里准备了一个网站吗？我的意思是我还没有准备好我已经准备好的网站

2899
17:47:07,756 --> 17:47:11,116
刚打开网站所以嗯

2900
17:47:11,116 --> 17:47:15,436
所以你可以在这里看到我会在这里增加字体的大小，你可以看到

2901
17:47:15,436 --> 17:47:19,276
sqlite是一个c语言库，实现了一个小型快速自包含

2902
17:47:19,276 --> 17:47:23,360
高可靠全功能sql数据库引擎sqlite是最

2903
17:47:23,360 --> 17:47:29,200
世界上用过的数据库引擎很好，只是将sqlite视为数据库

2904
17:47:29,200 --> 17:47:33,520
我们将在我们的应用程序中使用的引擎，它不是

2905
17:47:33,520 --> 17:47:40,320
是内置在 um flutter 里面的，我们将不得不使用一个所谓的插件来实现它

2906
17:47:40,320 --> 17:47:44,080
嗯，但这也没关系，我的意思是不多

2907
17:47:44,080 --> 17:47:49,200
语言支持与数据库对话，并且原生支持

2908
17:47:49,200 --> 17:47:51,840
嗯，但我们会到达那里，我们会到达那里

2909
17:47:51,840 --> 17:47:56,160
点好吧，现在让我们谈谈我们实际上是怎样的

2910
17:47:56,160 --> 17:48:00,240
将与 sqlite 集成并开始，所以我假设你

2911
17:48:00,240 --> 17:48:04,480
难道你以前从未使用过 sqlite 或者你没有使用过任何

2912
17:48:04,480 --> 17:48:07,596
之前的数据库类型，您正在尝试学习如何做到这一点，所以

2913
17:48:07,596 --> 17:48:10,720
这就是我从本课程开始时的假设，所以如果

2914
17:48:10,720 --> 17:48:14,400
您已经是经验丰富的开发人员，您确切了解 school sql light 的工作原理

2915
17:48:14,400 --> 17:48:18,160
您可能想跳过本章的这一部分并喜欢更多

2916
17:48:18,160 --> 17:48:22,080
多汁的部分，我们实际上与漂浮物内部的同等光线整合在一起

2917
17:48:22,080 --> 17:48:25,756
应用程序所以让我关闭这个 um 或者让我们

2918
17:48:25,756 --> 17:48:29,360
保持打开状态，我现在要谈论的是

2919
17:48:29,360 --> 17:48:34,720
um 一个程序 一个名为 db browser for sql 的免费程序

2920
17:48:34,720 --> 17:48:40,400
lite 你看到 sqlite 允许你我的意思是如果你想到

2921
17:48:40,400 --> 17:48:44,240
sql lite 有不同的组件，首先你有你的数据库，它只是一个

2922
17:48:44,240 --> 17:48:49,520
位于磁盘上的文件，然后您将拥有 sqlite

2923
17:48:49,520 --> 17:48:54,880
可以从此文件读取并写入此文件的引擎，这就是

2924
17:48:54,880 --> 17:48:59,200
引擎，然后这个引擎应该在某个地方运行，所以它要么运行

2925
17:48:59,200 --> 17:49:03,360
在一个应用程序中，比如我在这里提到的一个用于 sql 的 db 浏览器

2926
17:49:03,360 --> 17:49:08,320
轻巧，所以 sqlite 就像烘焙到该应用程序中一样，或者您也可以带来

2927
17:49:08,320 --> 17:49:12,080
sql light 进入你的终端，这样你就可以真正与 sql lite 交谈

2928
17:49:12,080 --> 17:49:15,840
来自终端内的数据库，或者如果您已经安装

2929
17:49:15,840 --> 17:49:20,160
django 在您的计算机上，然后您可以使用 django 以与 sql 集成

2930
17:49:20,160 --> 17:49:25,040
iso sqlite 是与 sqlite 文件对话的引擎

2931
17:49:25,040 --> 17:49:30,400
呃，这是你的数据库，但是这个引擎应该在它的某个地方运行

2932
17:49:30,400 --> 17:49:35,040
不仅仅是一个可执行文件，就像你在这里说的那样，你现在必须拥有这个文件

2933
17:49:35,040 --> 17:49:40,160
就像是续集光引擎基本上所在的某种容器

2934
17:49:40,160 --> 17:49:42,796
然后当我们谈论我们的颤振应用程序时，我们将带来这个

2935
17:49:42,796 --> 17:49:47,596
引擎进入颤振应用程序，因此我们的应用程序可以与该数据库进行对话，但是

2936
17:49:47,596 --> 17:49:52,560
现在我们来看一个名为 db browser for lite db browser 的程序

2937
17:49:52,560 --> 17:49:56,720
因为 sql lite 是免费的，我相信它是一个开源程序让我们搜索

2938
17:49:56,720 --> 17:49:59,436
为此我要说

2939
17:49:59,436 --> 17:50:04,840
sqlite的db浏览器，我们最终在这个

2940
17:50:04,840 --> 17:50:09,200
网站和嗯，你可以看到 db 浏览器的官方主页

2941
17:50:09,200 --> 17:50:12,720
sqlite，这就是程序的样子

2942
17:50:12,720 --> 17:50:18,000
嗯，我不确定是不是我现在可以看到它实际上可用于 windows mac

2943
17:50:18,000 --> 17:50:21,596
os 如果它也可用于 linux 那就太棒了

2944
17:50:21,596 --> 17:50:24,000
嗯，是的

2945
17:50:24,000 --> 17:50:27,916
它似乎可用，你实际上可以使用 snap 所以

2946
17:50:27,916 --> 17:50:31,276
太好了，所以如果你像我一样使用 ubuntu

2947
17:50:31,276 --> 17:50:33,916
现在不在这台机器上，但如果你在 ubuntu 上，你实际上可以使用

2948
17:50:33,916 --> 17:50:38,160
snapstore 甚至 debian 任何类型的操作系统 linux 空间操作

2949
17:50:38,160 --> 17:50:44,880
具有 snapstore 的系统，即使在 arch linux 上也非常棒

2950
17:50:44,880 --> 17:50:49,916
好吧，在你使用 apt 的 debian 上，这很好，但无论如何，它是可用的

2951
17:50:49,916 --> 17:50:56,160
对于 windows linux 和 mac os 所以我需要你基本上去 sqlite 浏览器或

2952
17:50:56,160 --> 17:51:02,320
db browser 因为它被称为 db browser for sqlite 如果你去我需要的主页

2953
17:51:02,320 --> 17:51:05,840
找到这个网站，让我改变屏幕布局

2954
17:51:05,840 --> 17:51:09,680
你看得更清楚，我需要你下载这个程序

2955
17:51:09,680 --> 17:51:14,080
好的，我已经在我的电脑上下载了，所以我要关闭它

2956
17:51:14,080 --> 17:51:18,240
safari 窗口，我将为您带来 sqlite 的 db 浏览器，因为它看起来

2957
17:51:18,240 --> 17:51:21,596
就像在我的电脑上我唯一改变的东西

2958
17:51:21,596 --> 17:51:25,840
这里的界面是我把字体从13改成了20

2959
17:51:25,840 --> 17:51:30,796
不是因为我不喜欢数字 13。这与它无关，但它是

2960
17:51:30,796 --> 17:51:37,916
只是我认为对于这门课程来说，20 是一个更好的字体大小

2961
17:51:37,916 --> 17:51:44,160
好吧，我们现在要做什么，嗯，让我谈谈吧

2962
17:51:44,160 --> 17:51:47,840
我们数据库的结构以及我们将如何设置它

2963
17:51:47,840 --> 17:51:52,000
如果您考虑一下我们是如何创建用户界面的，这里是用户

2964
17:51:52,000 --> 17:51:58,000
界面如果我们去这里你可以看到我们可以注册不同的用户所以

2965
17:51:58,000 --> 17:52:02,720
然后我们有一个用户实体或用户表，我们将称之为

2966
17:52:02,720 --> 17:52:07,360
然后我们也有我们将允许

2967
17:52:07,360 --> 17:52:11,436
在我们的数据库中创建这些用户，所以想象一下我们将拥有

2968
17:52:11,436 --> 17:52:15,360
某种表 我们数据库中的某种实体，专用于

2969
17:52:15,360 --> 17:52:19,436
users 和 users 可能只会拥有

2970
17:52:19,436 --> 17:52:21,916
他们将拥有什么他们是

2971
17:52:21,916 --> 17:52:27,436
将有一个 id 和一个电子邮件，以便您在创建时记住

2972
17:52:27,436 --> 17:52:32,880
当您向 firebase 注册用户时，您总是会得到一个用户标识符，所以

2973
17:52:32,880 --> 17:52:38,160
我们将在我们的数据库中存储该 id 和用户的电子邮件

2974
17:52:38,160 --> 17:52:41,840
好的，所以我们不会存储不是绝对的用户密码

2975
17:52:41,840 --> 17:52:46,160
no-no 好的，所以来自 firebase 的用户 ID 和

2976
17:52:46,160 --> 17:52:50,636
我们将存储在数据库中的电子邮件地址

2977
17:52:50,636 --> 17:52:55,756
而且我们将有另一张桌子和

2978
17:52:55,756 --> 17:53:00,796
我们数据库中的另一个表专门用于注释，以便在我登录时作为用户

2979
17:53:00,796 --> 17:53:04,000
我应该能够创建自己的笔记和这些笔记的应用程序

2980
17:53:04,000 --> 17:53:09,520
应该有点像绑定到并且喜欢他们应该粘在我的用户身上，所以如果我的

2981
17:53:09,520 --> 17:53:14,080
用户在数据库中我应该能够有笔记，如果我的用户被删除

2982
17:53:14,080 --> 17:53:17,200
所有这些笔记也应该从数据库中删除，所以很友好

2983
17:53:17,200 --> 17:53:21,916
对于那些熟悉后端开发的人来说就像一个级联

2984
17:53:21,916 --> 17:53:25,200
所以这就像我们的结构

2985
17:53:25,200 --> 17:53:30,000
将为我们的数据库进行设置，因此在我们的笔记中我可以看到

2986
17:53:30,000 --> 17:53:35,200
我们的笔记表我们实际上将有一个用户ID

2987
17:53:35,200 --> 17:53:39,756
该表中的整数，喜欢绑定

2988
17:53:39,756 --> 17:53:43,680
每个节点对象都指向创建它的用户，但我们会到达那里，所以不要

2989
17:53:43,680 --> 17:53:47,276
担心它，所以我要摆脱它

2990
17:53:47,276 --> 17:53:50,880
放在这里，这样我们就看不到了

2991
17:53:50,880 --> 17:53:55,360
现在我们需要做的是开始测试所以我们要创建一个简单的数据库

2992
17:53:55,360 --> 17:53:59,596
数据库并开始在那里创建一些表好吧，所以我需要你做什么

2993
17:53:59,596 --> 17:54:03,756
只是按下新数据库，我将把它保存在我的桌面上

2994
17:54:03,756 --> 17:54:09,116
让我们称之为测试好吧，我要按下

2995
17:54:09,116 --> 17:54:14,560
保存按钮就在那里好吧你可以看到现在我们创建了一个

2996
17:54:14,560 --> 17:54:19,756
数据库，我们在这里有一个表它看起来不太好我的意思是它不是

2997
17:54:19,756 --> 17:54:23,040
渲染得很好，因为我改变了屏幕上的字体

2998
17:54:23,040 --> 17:54:26,796
但你我想你能明白吗

2999
17:54:26,796 --> 17:54:30,720
所以我们需要做的是正如标题所说我们需要创建一个表

3000
17:54:30,720 --> 17:54:36,320

