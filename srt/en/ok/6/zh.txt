1
00:15:29,116 --> 00:15:32,879
对于这一章，所以这也是一个快速的章节，这完全是

2
00:15:32,879 --> 00:15:37,040
好吧，我也有这些简短的章节，真的很令人耳目一新

3
00:15:37,040 --> 00:15:41,275
嗯，现在我们已经完成了错误处理

4
00:15:41,275 --> 00:15:44,955
我们的登录视图我们还需要清理我们的注册表

5
00:15:44,955 --> 00:15:48,480
查看你可以看到我们的注册表有同样的问题

6
00:15:48,480 --> 00:15:52,639
正如本章开头的登录视图那样，我们有很多

7
00:15:52,639 --> 00:15:58,080
像开发工具这样的错误在这里记录了一些不太有用的东西，所以对于下一个

8
00:15:58,080 --> 00:16:01,915
章嗯，我们需要做的是确保

9
00:16:01,915 --> 00:16:07,595
我们已经退出了应用程序，我们可以进入注册视图

10
00:16:07,595 --> 00:16:13,040
我们可以在这里做，所以这是下一章和我们之前你需要的地方

11
00:16:13,040 --> 00:16:17,275
可以继续学习下一章的课程，所以我

12
00:16:17,275 --> 00:16:21,680
希望你喜欢这一章，我们下一章再见

13
00:16:21,680 --> 00:16:25,915
大家好，欢迎来到 Flutter 课程的第 22 章

14
00:16:25,915 --> 00:16:28,639
在前面的章节中，我们已经谈论了很多关于登录和

15
00:16:28,639 --> 00:16:33,116
注册和电子邮件验证，正如您在上一章中看到的，我们

16
00:16:33,116 --> 00:16:37,595
在我们的注册视图中仍然存在一些问题，因为当我们来到

17
00:16:37,595 --> 00:16:40,400
我们仍在做日志的错误处理

18
00:16:40,400 --> 00:16:44,000
基本上不是使用我们称为 show error 的新函数

19
00:16:44,000 --> 00:16:48,400
对话框和我们的注册视图基本上

20
00:16:48,400 --> 00:16:52,800
成功后真的不能把我们送到正确的地方

21
00:16:52,800 --> 00:16:56,955
注册您会看到我们在每个用户中都设置了电子邮件验证

22
00:16:56,955 --> 00:17:01,519
注册的人还需要在进入之前验证他或她的电子邮件

23
00:17:01,519 --> 00:17:07,116
应用程序的主用户界面，所以如果这是该应用程序的默认行为

24
00:17:07,116 --> 00:17:11,519
新注册的用户需要验证他们的电子邮件，也许这是最好的

25
00:17:11,519 --> 00:17:15,519
我们在注册后立即发送给用户

26
00:17:15,519 --> 00:17:19,199
到电子邮件验证视图，这些是我们基本上要做的事情

27
00:17:19,199 --> 00:17:23,680
将在本章中解决在寄存器视图中修复我们的日志语句

28
00:17:23,680 --> 00:17:28,080
并将用户发送到电子邮件验证视图

29
00:17:28,080 --> 00:17:31,275
之后立即将注册用户发送到电子邮件验证视图

30
00:17:31,275 --> 00:17:35,275
注册好的，这就是本章的目标

31
00:17:35,275 --> 00:17:38,559
所以你知道，我会把我的视觉工作室代码带到屏幕上，所以你

32
00:17:38,559 --> 00:17:43,116
也可以看到它 我要在右侧调出 scr cpy 让你看到

33
00:17:43,116 --> 00:17:47,360
你看到这些窗口的位置也好一点

34
00:17:47,360 --> 00:17:50,480
好吧，我们需要做的第一个任务

35
00:17:50,480 --> 00:17:55,595
这是为了确保我们在我们的

36
00:17:55,595 --> 00:17:58,720
注册视图，如果您还没有看过以前的

37
00:17:58,720 --> 00:18:02,000
这就是我们在之前讨论过的章节中所做的

38
00:18:02,000 --> 00:18:06,080
实用程序中的这个 uh 文件显示错误对话框，该对话框会增加

39
00:18:06,080 --> 00:18:09,915
窗口，以便您看得更清楚，因此此显示错误对话框是通用的

40
00:18:09,915 --> 00:18:13,595
标题显示发生错误的对话

41
00:18:13,595 --> 00:18:18,800
还有您选择的文本，让我们进入我们的注册表视图

42
00:18:18,800 --> 00:18:22,639
标题说在这里我要最小化这里的终端并摆脱

43
00:18:22,639 --> 00:18:26,400
explorer，让我们去这个弱密码和

44
00:18:26,400 --> 00:18:30,400
然后开始输入显示错误对话框，你可以看到它

45
00:18:30,400 --> 00:18:33,519
会自动导入，对不起

46
00:18:33,519 --> 00:18:37,680
它将为我们自动导入它所以让我们说显示空气对话

47
00:18:37,680 --> 00:18:40,720
上下文，我只是要在这个

48
00:18:40,720 --> 00:18:43,436
弱密码的情况 um

49
00:18:43,436 --> 00:18:50,000
我们只需要说弱密码就可以了，这样部分就完成了，你也可以

50
00:18:50,000 --> 00:18:54,319
在第二个参数的末尾加一个逗号只是为了确保它是

51
00:18:54,319 --> 00:18:58,319
干净，但请记住，显示错误对话是

52
00:18:58,319 --> 00:19:02,319
是一个异步函数，所以如果你将鼠标移到它上面，你会看到

53
00:19:02,319 --> 00:19:05,915
它说未来无效，所以只需像你没有显示一样调用显示空气拨号

54
00:19:05,915 --> 00:19:09,436
您基本上只是在告诉简短的错误对话，我喜欢返回

55
00:19:09,436 --> 00:19:14,879
如果你等待它，那么你可以显示错误对话框

56
00:19:14,879 --> 00:19:19,839
完成后不要忘记等待让我们删除我们的开发

57
00:19:19,839 --> 00:19:25,360
devtools 从弱密码和 if 语句中记录

58
00:19:25,360 --> 00:19:29,275
现在我们要做的是复制

59
00:19:29,275 --> 00:19:34,239
我们在此处编写的这段代码并转到已在使用的电子邮件并显示另一个

60
00:19:34,239 --> 00:19:39,275
错误对话框在这里使用相同的确切代码，我只想说

61
00:19:39,275 --> 00:19:46,160
电子邮件已经在使用中，好吧，所以这是用于电子邮件 rna 新闻以及

62
00:19:46,160 --> 00:19:51,436
对于无效的电子邮件，我们会说无效

63
00:19:51,436 --> 00:19:54,879
如果你应该说，让我看看无效的电子邮件

64
00:19:54,879 --> 00:20:01,756
嗯，这是一个无效的电子邮件地址，对吧

65
00:20:01,756 --> 00:20:07,839
我可以看到我们还没有真正处理其他可能的异常

66
00:20:07,839 --> 00:20:11,839
发生是因为您记得在登录视图中

67
00:20:11,839 --> 00:20:17,595
我们看看处理例如其他呃

68
00:20:17,595 --> 00:20:21,756
其他可能发生的异常，例如我们在

69
00:20:21,756 --> 00:20:25,839
那里有一个 else 语句，我们还做了一个通用的 catch 语句来捕获

70
00:20:25,839 --> 00:20:29,756
任何其他不是 Firebase 身份验证异常的异常，我可以看到

71
00:20:29,756 --> 00:20:32,879
现在我们还没有在注册视图中这样做，所以让我们去处理它

72
00:20:32,879 --> 00:20:37,116
所以让我们说 else 所以在这个 else 语句中我们正在捕捉

73
00:20:37,116 --> 00:20:41,360
任何其他可能发生的firebase off异常都可以，所以我只是去

74
00:20:41,360 --> 00:20:44,319
在这里说，我只想说

75
00:20:44,319 --> 00:20:48,955
错误和美元 e 代码没关系，所以这非常

76
00:20:48,955 --> 00:20:52,720
类似于我们在登录视图中所做的

77
00:20:52,720 --> 00:20:55,275
所以我很抱歉我只能看到

78
00:20:55,275 --> 00:20:59,360
你看不到代码，因为它隐藏在标题后面，但现在你

79
00:20:59,360 --> 00:21:02,639
可以看到，所以我在这里放了一个 else 声明，然后我说

80
00:21:02,639 --> 00:21:06,720
基本上是一个重量更短的对话和电子代码所以

81
00:21:06,720 --> 00:21:11,199
如果你看的话，那就看看这个

82
00:21:11,199 --> 00:21:16,955
花括号就在这里，你现在可以看到它开始的这个紫色的

83
00:21:16,955 --> 00:21:20,639
在这里，因为这是我们开始赶上火力基地的开始

84
00:21:20,639 --> 00:21:22,879
例外和

85
00:21:22,879 --> 00:21:27,519
我们还需要做的是在这里放另一个 l 另一个 catch 语句

86
00:21:27,519 --> 00:21:33,839
捕获不是 Firebase 身份验证异常的任何其他异常

87
00:21:33,839 --> 00:21:37,360
所以我们在上一章讨论异常时已经讨论过了

88
00:21:37,360 --> 00:21:43,275
在登录视图中处理，所以我认为我不需要再次解释

89
00:21:43,275 --> 00:21:46,559
好的，所以我们在这里要做的，我们也将显示错误

90
00:21:46,559 --> 00:21:50,559
在这种情况下也可以使用对话框，但对于消息，我们只会说 e2

91
00:21:50,559 --> 00:21:54,480
字符串 好吧 类似的事情 我们在

92
00:21:54,480 --> 00:21:59,040
我们的登录视图实际上完全一样

93
00:21:59,040 --> 00:22:02,800
好的，那太好了，所以现在我们使用简短的错误对话框而不是登录

94
00:22:02,800 --> 00:22:06,160
注册视图，现在基本上我不认为我们正在使用开发

95
00:22:06,160 --> 00:22:10,319
使用 devtools 登录的工具我不在这里

96
00:22:10,319 --> 00:22:13,199
认为我们需要再这样做，这样我们才能摆脱它

97
00:22:13,199 --> 00:22:17,436
然后我们也可以摆脱devtools um

98
00:22:17,436 --> 00:22:23,040
在这里导入好的，它会看看我的笔记

99
00:22:23,040 --> 00:22:25,595
一点点只是为了确保我告诉你你所有的信息

100
00:22:25,595 --> 00:22:28,800
需要知道这很好

101
00:22:28,800 --> 00:22:32,559
嗯，既然我们已经完成了所有这些，我们还需要

102
00:22:32,559 --> 00:22:35,275
确保您可以看到后面的缓存

103
00:22:35,275 --> 00:22:40,480
每次注册我们都需要确认用户的电子邮件，就像嗯

104
00:22:40,480 --> 00:22:44,720
应用中每个新注册用户的模式

105
00:22:44,720 --> 00:22:49,915
新注册的用户不能拥有

106
00:22:49,915 --> 00:22:53,595
已经确认了他们的电子邮件，因为他们两个不去是不可能的

107
00:22:53,595 --> 00:22:57,756
一个新用户 一个新注册的用户没有他们的电子邮件地址

108
00:22:57,756 --> 00:23:02,720
在我们的系统中注册，因此在此期间未收到验证电子邮件

109
00:23:02,720 --> 00:23:05,680
这个会话所以这是我们需要的模式

110
00:23:05,680 --> 00:23:09,915
基本上可以帮助我们的用户，所以在每次成功注册后，我们就可以

111
00:23:09,915 --> 00:23:15,275
将自动将用户发送到验证电子邮件视图，如果您

112
00:23:15,275 --> 00:23:18,879
记得在前面的章节中，我们在这里有这个验证电子邮件视图

113
00:23:18,879 --> 00:23:22,800
这是它自己的有状态小部件和

114
00:23:22,800 --> 00:23:26,400
我的意思是它不一定是有状态的小部件我可以看到它不是

115
00:23:26,400 --> 00:23:30,559
做任何有状态的事情，但我们刚刚离开它，状态将保持完整的小部件

116
00:23:30,559 --> 00:23:34,879
它现在可以是这样，但我们也可以把它变成一个

117
00:23:34,879 --> 00:23:39,436
无状态小部件，如果你想，好吧

118
00:23:39,436 --> 00:23:44,319
这就是我们的用户使用注册视图所做的模式

119
00:23:44,319 --> 00:23:48,400
所以如果我们去这里注册，呃，糟糕，不，我们实际上是在

120
00:23:48,400 --> 00:23:52,639
对此感到抱歉，嗯，好吧，所以我们现在需要做的是

121
00:23:52,639 --> 00:23:56,639
因为我们要从注册视图发送用户，所以我们要发送到

122
00:23:56,639 --> 00:24:00,160
验证电子邮件视图，我们需要一个路由，如果你记得

123
00:24:00,160 --> 00:24:03,756
之前的章节我们现在在这个文件 lib 中定义我们的路由

124
00:24:03,756 --> 00:24:06,639
常量路线点镖

125
00:24:06,639 --> 00:24:11,436
我们现在已经定义了登录路由注册路由和节点路由

126
00:24:11,436 --> 00:24:15,595
那么我们需要一个新的路由来验证电子邮件视图，所以让我们继续

127
00:24:15,595 --> 00:24:19,519
标题在这里说，只需输入，然后说 cons verify

128
00:24:19,519 --> 00:24:22,955
发送电子邮件是

129
00:24:22,955 --> 00:24:28,319
斜线验证电子邮件，最后也有一个斜线

130
00:24:28,319 --> 00:24:33,275
既然我们已经定义了我们需要的路线那么请原谅我们需要

131
00:24:33,275 --> 00:24:38,000
进入我们的主要飞镖文件所以我要关闭这个文件关闭这个文件并

132
00:24:38,000 --> 00:24:44,160
然后在 Visual Studio 中的 mac 上命令 p 或在 linux 和 windows 中控制 p 和

133
00:24:44,160 --> 00:24:47,595
去 main.dart 好吧

134
00:24:47,595 --> 00:24:52,480
在您的 main.dart 中，您记得所有路线都在路线内注册

135
00:24:52,480 --> 00:24:58,080
您的材料应用程序的参数，所以让我们继续注册 um

136
00:24:58,080 --> 00:25:03,915
电子邮件验证电子邮件在这里换行，我们说上下文，我们只说 const

137
00:25:03,915 --> 00:25:08,559
验证电子邮件视图，然后注册

138
00:25:08,559 --> 00:25:12,639
在 main 函数中，好的，记住你正在做的任何事情

139
00:25:12,639 --> 00:25:17,756
当你做热时，主函数内部不会重新加载

140
00:25:17,756 --> 00:25:23,436
热重载，所以你需要在这里做一个热重启，以便那些

141
00:25:23,436 --> 00:25:26,559
为了使主要功能中的这些更改生效，所以我只是

142
00:25:26,559 --> 00:25:30,559
在这里做一个热重启好吗

143
00:25:30,559 --> 00:25:33,519
所以现在我们已经注册了

144
00:25:33,519 --> 00:25:37,680
让我们去我们的注册，现在我们已经注册了，有这么多

145
00:25:37,680 --> 00:25:40,319
注册的话我扔在那里所以我现在只想澄清一下，我们已经

146
00:25:40,319 --> 00:25:45,519
注册以验证我们在主要飞镖路线中的电子邮件路线，我们需要去

147
00:25:45,519 --> 00:25:51,116
成功后注册视图并在其中使用此验证电子邮件路由

148
00:25:51,116 --> 00:25:54,720
注册好的所以嗯

149
00:25:54,720 --> 00:25:58,800
然后让我们去我们的我要关闭这个，我要

150
00:25:58,800 --> 00:26:02,000
去注册查看

151
00:26:02,000 --> 00:26:05,275
就在这里好吧

152
00:26:05,275 --> 00:26:09,519
在这里我可以看到我们正在获取用户凭据，然后

153
00:26:09,519 --> 00:26:12,720
将其分配给此用户凭据，我们不必再这样做了，所以让我们

154
00:26:12,720 --> 00:26:15,915
只需删除我们不会实际使用的

155
00:26:15,915 --> 00:26:19,595
使用电子邮件成功创建用户后返回用户凭据和

156
00:26:19,595 --> 00:26:24,639
密码我们将自动转到下一行，因为我们有一个尝试

157
00:26:24,639 --> 00:26:28,800
并在这里捕获声明

158
00:26:28,800 --> 00:26:33,756
现在我们需要做的是，呃，我们要显示验证电子邮件

159
00:26:33,756 --> 00:26:36,720
路线可以哦

160
00:26:36,720 --> 00:26:40,720
所以让我们去我们的

161
00:26:40,720 --> 00:26:45,436
呃验证这里的电子邮件，我们要说的是导航器

162
00:26:45,436 --> 00:26:48,239
和点推

163
00:26:48,239 --> 00:26:52,800
上下文导航器，然后我们要说 push named

164
00:26:52,800 --> 00:26:56,879
你看在这种情况下我们实际上会说 push name 而不是使用

165
00:26:56,879 --> 00:27:00,080
显示推送名称的其他功能和

166
00:27:00,080 --> 00:27:03,756
删除直到，这背后的原因是

167
00:27:03,756 --> 00:27:06,800
嗯

168
00:27:06,800 --> 00:27:11,199
当用户在此处的注册页面内时

169
00:27:11,199 --> 00:27:16,000
当我们想去的时候，假设你输入了一些电子邮件

170
00:27:16,000 --> 00:27:20,319
在这里然后你输入一些密码然后你点击注册按钮或者你

171
00:27:20,319 --> 00:27:25,519
点击注册按钮，我们会将您发送到验证电子邮件页面

172
00:27:25,519 --> 00:27:28,000
我们说哦，嗯

173
00:27:28,000 --> 00:27:32,319
如果您意识到这一点，您可以在此处验证您的电子邮件等

174
00:27:32,319 --> 00:27:37,199
哦，我注册时使用了错误的电子邮件，您需要能够返回

175
00:27:37,199 --> 00:27:41,360
注册页面，以便避免发送所有这些按钮

176
00:27:41,360 --> 00:27:45,436
一个用户从一个页面到另一个页面，如果他从

177
00:27:45,436 --> 00:27:50,480
注册视图可以只推送新的呃电子邮件验证路线，所以我们

178
00:27:50,480 --> 00:27:56,160
不要用新路由替换整个路由，比如注册页面，所以

179
00:27:56,160 --> 00:27:59,199
基本上这里想要的效果是我们的注册页面会保留

180
00:27:59,199 --> 00:28:03,116
就在这里，然后我们将在上面推送验证电子邮件路由，如果

181
00:28:03,116 --> 00:28:06,400
验证电子邮件路由中的用户意识到他们做错了什么

182
00:28:06,400 --> 00:28:11,519
电子邮件地址，然后他们只需按顶部栏上的后退按钮，然后

183
00:28:11,519 --> 00:28:15,360
回到注册页面，这样就很自然了

184
00:28:15,360 --> 00:28:19,519
在屏幕之间导航的方式，这就是为什么我们使用 push named in

185
00:28:19,519 --> 00:28:23,116
这种情况没关系，所以我要说推送名称并推送

186
00:28:23,116 --> 00:28:28,000
名称，然后在名称中，我们只会说验证

187
00:28:28,000 --> 00:28:33,680
电子邮件路由哎呀，像这样验证电子邮件路由

188
00:28:33,680 --> 00:28:38,160
我会在那里做一个命令，嗯

189
00:28:38,160 --> 00:28:43,436
那么让我们确保我们可以把所有这些都付诸行动，所以我要

190
00:28:43,436 --> 00:28:47,199
热重启只是为了确保你记得我们做了

191
00:28:47,199 --> 00:28:50,559
更改我们的主要功能，因此如果您忘记进行热重启，请这样做

192
00:28:50,559 --> 00:28:55,199
现在嗯，这样您的更改实际上可以从登录视图生效，即

193
00:28:55,199 --> 00:28:59,519
用户看到的第一个视图我们将进入注册页面

194
00:28:59,519 --> 00:29:05,360
在这个注册页面中，我将注册一个新用户，所以因为

195
00:29:05,360 --> 00:29:11,040
我已经注册了我的用户，我实际上可以去 firebase 控制台所以

196
00:29:11,040 --> 00:29:16,400
让我们去控制台 firebase 我通常使用的用户已经是

197
00:29:16,400 --> 00:29:20,800
注册了这个应用程序，所以我的笔记颤动项目还可以

198
00:29:20,800 --> 00:29:25,595
让我们进行身份验证，我可以看到 pixelityab gmail.com 已经存在

199
00:29:25,595 --> 00:29:29,040
注册所以我要在这里注册一个新用户我要说

200
00:29:29,040 --> 00:29:33,436
van.mp 和密码是 foobarbaz 我只是

201
00:29:33,436 --> 00:29:37,915
将选择这里，请不要在生产中使用此密码

202
00:29:37,915 --> 00:29:42,639
你的帐户在任何地方这只是一个坏主意，我正在使用 fubar bass

203
00:29:42,639 --> 00:29:47,360
共识一致性，并且为了这个项目的简单性，所以

204
00:29:47,360 --> 00:29:51,839
因为对我来说，输入和写下所有密码要容易得多

205
00:29:51,839 --> 00:29:54,720
一遍又一遍地使用fullbarbass，但这不是一个好

206
00:29:54,720 --> 00:29:58,160
密码，所以我想只是为了说明这一点

207
00:29:58,160 --> 00:30:02,800
嗯，现在我要注册这个用户，现在你可以看到

208
00:30:02,800 --> 00:30:06,559
成功注册后，现在我们将在此验证电子邮件中结束

209
00:30:06,559 --> 00:30:11,360
屏幕，这真的很好，但是

210
00:30:11,360 --> 00:30:15,199
有一种方法可以让这件事变得更好，让我们去这里的火力基地

211
00:30:15,199 --> 00:30:19,595
我现在可以看到用户已经在这里注册了，你看，它有一个

212
00:30:19,595 --> 00:30:23,915
用户 ID，这是最后一次登录日期

213
00:30:23,915 --> 00:30:27,756
所以我们怎样才能让这变得更好你看

214
00:30:27,756 --> 00:30:32,800
如果这是用户在注册时的自然流程

215
00:30:32,800 --> 00:30:38,639
页面或注册视图，它们总是出现在验证电子邮件页面中

216
00:30:38,639 --> 00:30:42,639
我们可以让它变得更好的方法是嗯

217
00:30:42,639 --> 00:30:47,839
在我们推送之前成功注册

218
00:30:47,839 --> 00:30:51,915
验证屏幕上的电子邮件视图

219
00:30:51,915 --> 00:30:56,800
是我们实际上向该用户发送了一封验证电子邮件，否则

220
00:30:56,800 --> 00:30:59,915
你正在创建什么你正在为用户创建一个他们必须做的逻辑

221
00:30:59,915 --> 00:31:04,160
采取额外的步骤来验证他们的帐户，以便他们现在来到这里

222
00:31:04,160 --> 00:31:07,595
他们必须按下另一个按钮，但如果你真的这样做了，那就太好了

223
00:31:07,595 --> 00:31:11,915
在我们进入那个屏幕之前，为他们按下那个按钮，所以

224
00:31:11,915 --> 00:31:15,360
我们实际上并不喜欢为他们点击那个按钮，但我们

225
00:31:15,360 --> 00:31:21,595
将执行与该按钮为用户执行的代码相同的代码

226
00:31:21,595 --> 00:31:26,879
所以这就是我们现在要做的，就像你的标题中所说的那样

227
00:31:26,879 --> 00:31:31,915
在导航到验证电子邮件路由之前注册视图，确保

228
00:31:31,915 --> 00:31:35,436
你基本上得到了当前用户，所以你说

229
00:31:35,436 --> 00:31:42,955
我相信最终用户是firebase off instance，当前用户还可以

230
00:31:42,955 --> 00:31:46,720
获取您的用户，然后在此处

231
00:31:46,720 --> 00:31:51,915
你会说用户 um 并且有一个叫做发送电子邮件的功能

232
00:31:51,915 --> 00:31:55,519
验证并记住您的用户是可选用户，这就是为什么您

233
00:31:55,519 --> 00:31:59,839
在这里看到这个猫王操作员有点像

234
00:31:59,839 --> 00:32:03,116
小胡子之类的 我不知道你想怎么称呼它 有些人

235
00:32:03,116 --> 00:32:08,000
如果你来自 kotlin 或者在 swift 中，你会说它是 elvis 运算符

236
00:32:08,000 --> 00:32:11,680
就像一个可选的调用，取决于你来自的语言，但是

237
00:32:11,680 --> 00:32:15,040
如果你不是 如果你不是 我有软件开发背景 那么你

238
00:32:15,040 --> 00:32:19,680
可以称之为问号，嗯，现在记住了

239
00:32:19,680 --> 00:32:23,839
所以用户是可选的，这个函数返回一个融合语音，所以你不能只是

240
00:32:23,839 --> 00:32:28,720
打电话给你，你需要等待，所以现在我们正在这样做，所以我们现在

241
00:32:28,720 --> 00:32:34,080
等着就好了，而且从现在开始我们已经改变了我们的

242
00:32:34,080 --> 00:32:37,519
成功后按下注册按钮的逻辑

243
00:32:37,519 --> 00:32:40,720
注册我们正在向您发送电子邮件验证

244
00:32:40,720 --> 00:32:44,800
最终出现在这个屏幕上并不是一个好主意，只是说请验证您的

245
00:32:44,800 --> 00:32:48,879
电子邮件地址，因为让我们面对现实吧，我们已经发送了一封电子邮件

246
00:32:48,879 --> 00:32:53,199
验证所以我们不希望用户点击我们想要的这个按钮

247
00:32:53,199 --> 00:32:56,559
用户单击此按钮或点击此按钮

248
00:32:56,559 --> 00:33:01,199
如果他们有一段时间没有收到电子邮件，那么我们不希望喜欢

249
00:33:01,199 --> 00:33:05,839
为用户发送双重电子邮件，所以这不是一个好主意

250
00:33:05,839 --> 00:33:11,360
所以，对不起，我会在这里稍微看一下我的笔记

251
00:33:11,360 --> 00:33:16,400
好的，所以我们现在需要做的是正如标题现在所说的，我们需要去

252
00:33:16,400 --> 00:33:20,480
我们的验证电子邮件视图并在顶部添加文本

253
00:33:20,480 --> 00:33:24,400
说我们已经发送了一封验证电子邮件，这只是

254
00:33:24,400 --> 00:33:28,955
常识好吧，让我们去我们的

255
00:33:28,955 --> 00:33:34,239
验证电子邮件路由，基本上是在这里验证电子邮件视图

256
00:33:34,239 --> 00:33:38,080
你可以看到我们在这里有一个专栏和第一个文本

257
00:33:38,080 --> 00:33:42,239
说请验证您的电子邮件地址，所以让我们在这里创建另一个文本

258
00:33:42,239 --> 00:33:46,800
要说缺点文本，我要说

259
00:33:46,800 --> 00:33:50,720
织你看，因为我想写这个词

260
00:33:50,720 --> 00:33:55,756
像我们一样编织，这里只有一个代码，所以我不能拥有自己的

261
00:33:55,756 --> 00:34:00,000
具有单个代码的字符串，因为 dart 不知道在哪里

262
00:34:00,000 --> 00:34:04,239
这就是这个字符串，因为它认为这是一个从这里开始的字符串

263
00:34:04,239 --> 00:34:08,480
它在这里结束，但是为了有单引号，这个是什么

264
00:34:08,480 --> 00:34:11,756
在你的黑暗弦里，那么你将不得不

265
00:34:11,756 --> 00:34:16,080
封装或基本上将您的字符串放在 double 中

266
00:34:16,080 --> 00:34:20,796
引号，这样你就可以避免这种混淆，所以我们可以说我们已经

267
00:34:20,796 --> 00:34:26,319
请给您发送电子邮件验证

268
00:34:26,319 --> 00:34:30,955
请按顺序打开

269
00:34:30,955 --> 00:34:34,879
验证你的是的，所以请打开它来验证你的

270
00:34:34,879 --> 00:34:37,040
呃帐户

271
00:34:37,040 --> 00:34:41,360
像这样的好，还有这个文本，那么我们需要

272
00:34:41,360 --> 00:34:44,400
也改变它，因为你看到我们不希望这个文本有点像

273
00:34:44,400 --> 00:34:48,319
一个号召性用语说你好就像这里我们说我们给你发了一个

274
00:34:48,319 --> 00:34:51,116
电子邮件验证请再次打开验证器，然后立即打开

275
00:34:51,116 --> 00:34:54,955
我们说，嘿，点击这个按钮，所以这不是一个好主意，让我们改变一下

276
00:34:54,955 --> 00:34:58,480
这段文字并说如果你还没有

277
00:34:58,480 --> 00:35:03,040
让我们把这个双引号和以前的故事一样

278
00:35:03,040 --> 00:35:06,796
如果您没有收到验证

279
00:35:06,796 --> 00:35:09,199
电子邮件

280
00:35:09,199 --> 00:35:14,559
按下下面这样的按钮

281
00:35:14,559 --> 00:35:18,796
好的，所以我要按 command ，现在您可以看到这些文本

282
00:35:18,796 --> 00:35:21,519
显示在屏幕上，老实说，它们不是很漂亮

283
00:35:21,519 --> 00:35:26,720
片刻，但这也没关系，所以嗯，这不是问题，让它像

284
00:35:26,720 --> 00:35:31,275
没关系，所以我们正在显示该文本

285
00:35:31,275 --> 00:35:35,040
呃给用户，我们现在需要做什么

286
00:35:35,040 --> 00:35:41,040
是基本上再次测试整个呃流程只是为了确保

287
00:35:41,040 --> 00:35:45,275
是的，它按预期工作，所以为了做到这一点，去你的火力基地

288
00:35:45,275 --> 00:35:48,639
再次控制台，我要调出控制台

289
00:35:48,639 --> 00:35:52,000
在这里希望你也能看到它，然后我要去那个项目

290
00:35:52,000 --> 00:35:56,400
身份验证和这个用户我要删除这个用户好的删除

291
00:35:56,400 --> 00:35:59,756
好吧，那个用户走了，我要去

292
00:35:59,756 --> 00:36:04,639
现在关闭屏幕然后我们要做的就是

293
00:36:04,639 --> 00:36:10,839
热重启应用程序以清除所有状态

294
00:36:10,839 --> 00:36:14,720
嗯重新开始

295
00:36:14,720 --> 00:36:21,595
是不是没有生效我会然后呃验证电子邮件

296
00:36:21,595 --> 00:36:25,519
我可以看到没有后退按钮，感觉就像

297
00:36:25,519 --> 00:36:30,319
呃，我们最终进入了那个屏幕，因为在我们的主 dart 文件中

298
00:36:30,319 --> 00:36:34,720
让我们进入主要飞镖我相信我们实际上是在发送

299
00:36:34,720 --> 00:36:41,116
用户在这种情况下验证电子邮件视图用户firebase实例卡没问题

300
00:36:41,116 --> 00:36:44,955
所以这有点问题，因为现在我们有点像

301
00:36:44,955 --> 00:36:50,480
卡在这个 uh in this

302
00:36:50,480 --> 00:36:54,559
查看因为 firebase 作为这里的标题说它说 firebase 没有

303
00:36:54,559 --> 00:36:59,199
了解我们完全删除该用户的远程更改，但

304
00:36:59,199 --> 00:37:02,955
firebase 仍然认为该用户存在，那是因为您看到

305
00:37:02,955 --> 00:37:07,680
firebase 不能喜欢位于代码内部的客户端

306
00:37:07,680 --> 00:37:11,519
您正在开发的客户端应用程序不能经常与之交谈

307
00:37:11,519 --> 00:37:14,955
firebase 说给我最新的状态给我最新的状态

308
00:37:14,955 --> 00:37:19,915
这个用户现在在这个手机上

309
00:37:19,915 --> 00:37:24,080
是曾经与后端有连接但它的本地用户

310
00:37:24,080 --> 00:37:29,519
不再，但firebase不喜欢在本地删除这个用户所以

311
00:37:29,519 --> 00:37:33,839
所以我们需要做的最好的方法来处理这种情况是

312
00:37:33,839 --> 00:37:40,559
在我们的验证电子邮件中有点像重启呃按钮所以如果

313
00:37:40,559 --> 00:37:46,480
在这种情况下，用户喜欢的某些原因明白，嘿，我被卡住了

314
00:37:46,480 --> 00:37:50,639
我需要通过验证电子邮件离开这里 我有点想回到哪里

315
00:37:50,639 --> 00:37:56,879
我是如此，我们需要做的是在用户按下重启按钮时

316
00:37:56,879 --> 00:38:00,639
在这里，我们要注销该用户，以便 firebase

317
00:38:00,639 --> 00:38:05,360
非常了解该用户不再登录，因此我们不会最终进入

318
00:38:05,360 --> 00:38:11,680
这种情况下，电子邮件已经过验证等，我们也将发送给用户

319
00:38:11,680 --> 00:38:15,680
可以到注册视图，如您所见

320
00:38:15,680 --> 00:38:19,756
我们无法将用户送回注册视图

321
00:38:19,756 --> 00:38:25,040
我的意思是我们不能期望注册视图存在于视图中

322
00:38:25,040 --> 00:38:29,436
在这种情况下，在视图堆栈上，因为如果用户刚刚开始

323
00:38:29,436 --> 00:38:33,436
应用程序应用程序，因此他们将最终在这个未来的建设者未来

324
00:38:33,436 --> 00:38:36,480
然后builder会检查用户并说哦，你应该去验证

325
00:38:36,480 --> 00:38:40,400
电子邮件视图，在这种情况下，后面没有注册视图

326
00:38:40,400 --> 00:38:45,116
嗯验证电子邮件视图，这样在这种情况下你会看到我们不会推送，但我们会

327
00:38:45,116 --> 00:38:50,080
实际上会推送名称并删除直到但我们很快就会到达那里

328
00:38:50,080 --> 00:38:54,955
首先让我们转到您的验证电子邮件视图，然后在此之后

329
00:38:54,955 --> 00:38:58,400
文本按钮 我们要添加另一个文本按钮

330
00:38:58,400 --> 00:39:04,000
向上一点，以便您看得更清楚，让我们说一个文本按钮

331
00:39:04,000 --> 00:39:07,839
unpressed 只是现在是空的，然后为了他的孩子，我们要去

332
00:39:07,839 --> 00:39:13,756
添加一个 const 文本，只是说重新启动好

333
00:39:13,756 --> 00:39:18,879
就是这样，然后我们需要做的就是我之前提到的

334
00:39:18,879 --> 00:39:24,160
是呃，正如标题在这里解释的那样，我们需要实际登录

335
00:39:24,160 --> 00:39:28,400
用户退出所以让我们说firebase auth实例

336
00:39:28,400 --> 00:39:32,796
然后我们需要做的是退出

337
00:39:32,796 --> 00:39:38,879
好吧，记住氰基，我也相信未来是虚无，所以你需要等待

338
00:39:38,879 --> 00:39:43,275
哎呀，嗯，我只是跳过屏幕而没有

339
00:39:43,275 --> 00:39:46,480
实际上真的很想这样做，所以让我们等待它，它会给予

340
00:39:46,480 --> 00:39:51,519
你是一个错误，因为现在你未按下的功能不是异步的，所以让它异步

341
00:39:51,519 --> 00:39:55,519
之后使用 if i do command s

342
00:39:55,519 --> 00:39:58,160
现在我们将在这里看到重启按钮，但是

343
00:39:58,160 --> 00:40:00,955
这样做只是注销它实际上并没有将您发送到

344
00:40:00,955 --> 00:40:05,040
注册视图，我们会尽快处理，如标题所示

345
00:40:05,040 --> 00:40:11,680
上下文导航器我推送命名删除，直到我们将在此处发送

346
00:40:11,680 --> 00:40:16,720
用户要从我们的路线视图中记住抱歉，路线文件有

347
00:40:16,720 --> 00:40:23,116
注册路线好吧，我们去那里吧，我们去注册吧

348
00:40:23,116 --> 00:40:27,436
出来在这里，我们只保留代码原样，最后我来清理

349
00:40:27,436 --> 00:40:31,116
它上升了一点并且

350
00:40:31,116 --> 00:40:35,360
那应该很好

351
00:40:35,360 --> 00:40:40,000
好的，现在我要做一个热重启你会看到现在我们最终在这里

352
00:40:40,000 --> 00:40:43,915
并且因为它仍然是用户登录，因为我们还没有执行

353
00:40:43,915 --> 00:40:48,319
这段代码，然后我将按下重新启动按钮，你会看到

354
00:40:48,319 --> 00:40:52,239
我们最终进入注册视图只是为了确保我们不会去

355
00:40:52,239 --> 00:40:55,116
再次陷入这个恶性循环，每次我们

356
00:40:55,116 --> 00:40:58,955
做一个热重启，我们将在验证电子邮件视图中结束

357
00:40:58,955 --> 00:41:03,436
现在让我们做一个热重启来看看应用程序的状态是什么

358
00:41:03,436 --> 00:41:08,319
将是，正如您在热重启时看到的那样，我们最终进入登录视图

359
00:41:08,319 --> 00:41:13,915
这意味着未来构建器中的主要 dart 文件转到此代码

360
00:41:13,915 --> 00:41:18,319
所以用户现在是空的，这正是我们想要的，因为我们

361
00:41:18,319 --> 00:41:22,720
签出当前用户没问题

362
00:41:22,720 --> 00:41:27,915
好的，然后我们将使用相同的凭据来 um

363
00:41:27,915 --> 00:41:30,879
像以前一样注册让我们去注册视图然后我要去

364
00:41:30,879 --> 00:41:36,160
说 round.np np gmail.com 然后 fubarbas

365
00:41:36,160 --> 00:41:41,116
然后我要注册这个用户，你可以看到它说它给你发了一个

366
00:41:41,116 --> 00:41:44,639
电子邮件验证请打开它进行验证，我可以在我的第三个屏幕上看到

367
00:41:44,639 --> 00:41:50,080
在这里，我实际上得到了电子邮件验证

368
00:41:50,080 --> 00:41:52,480
正如你在标题中看到的那样

369
00:41:52,480 --> 00:41:57,595
收到确认电子邮件，但尚未确认，因为我们有点需要

370
00:41:57,595 --> 00:42:00,955
看看我们在应用程序中遇到的问题

371
00:42:00,955 --> 00:42:06,480
嗯，现在让我们看看我们是否可以登录，那又如何

372
00:42:06,480 --> 00:42:10,480
我要做的是从验证返回屏幕

373
00:42:10,480 --> 00:42:14,559
电子邮件返回注册视图，而不是再次进行注册

374
00:42:14,559 --> 00:42:18,480
到登录视图现在使用你当前的呃

375
00:42:18,480 --> 00:42:22,720
喜欢您刚刚创建但尚未确认电子邮件使用的新用户

376
00:42:22,720 --> 00:42:28,955
该用户的凭据并说 gmail.com 和 foobar 作为

377
00:42:28,955 --> 00:42:33,595
然后按下登录按钮，您将看到现在我们已经进入

378
00:42:33,595 --> 00:42:38,720
应用程序的主用户界面，这是有问题的，因为

379
00:42:38,720 --> 00:42:43,199
任何像我一样的用户都可以进入注册视图，然后他们将进入

380
00:42:43,199 --> 00:42:48,796
确认视图自动他们说好的，我收到了一封确认电子邮件，然后

381
00:42:48,796 --> 00:42:52,400
他们不确认电子邮件他们按后退按钮转到注册表

382
00:42:52,400 --> 00:42:56,000
再次查看并从注册表谷歌他们转到登录视图然后他们登录

383
00:42:56,000 --> 00:42:59,756
因为您在我们的登录视图中看到

384
00:42:59,756 --> 00:43:03,519
并在使用电子邮件签名后立即在此代码中

385
00:43:03,519 --> 00:43:08,796
密码我们没有验证用户是否确实验证了他们的电子邮件

386
00:43:08,796 --> 00:43:13,275
地址，我们只是说登录，firebase 说没问题，登录很好

387
00:43:13,275 --> 00:43:17,680
电子邮件和密码与身份验证数据库中的条目匹配，我很喜欢

388
00:43:17,680 --> 00:43:21,275
go 然后我们只是说 push to notes wrap 所以

389
00:43:21,275 --> 00:43:25,436
这是一个我们需要解决的问题

390
00:43:25,436 --> 00:43:29,116
下一章好吧，但现在我们有很多代码我

391
00:43:29,116 --> 00:43:34,639
可以看到所有文件都已更改，所以让我们提交我们的代码并将其标记为

392
00:43:34,639 --> 00:43:37,595
我们在其他章节中也在做什么

393
00:43:37,595 --> 00:43:41,199
要去终端 我要稍微改变一下屏幕布局

394
00:43:41,199 --> 00:43:44,720
你看它最好增加

395
00:43:44,720 --> 00:43:49,915
视图，因此您可以更好地看到它，并且您可以看到以前的标签是

396
00:43:49,915 --> 00:43:54,400
第 6 步。现在让我们看看我们的代码的状态，我可以看到有

397
00:43:54,400 --> 00:44:00,080
修改了很多更改，您可以随时发出命令 g apa

398
00:44:00,080 --> 00:44:04,559
我称之为gopa，它会显示你所有的变化，但我只想说

399
00:44:04,559 --> 00:44:09,519
git commit 对不起，我要说 git commit，我们说

400
00:44:09,519 --> 00:44:12,955
我们将把它作为第 7 步提交 好的

401
00:44:12,955 --> 00:44:20,080
并将这些更改推送到 github，我也将其标记为第 7 步

402
00:44:20,080 --> 00:44:26,080
所以就像第七步然后我会说 git push tags

403
00:44:26,080 --> 00:44:29,839
很好，现在就像标题所说的那样我们需要得到

404
00:44:29,839 --> 00:44:33,040
准备下一章，你可以看到它说用户需要验证

405
00:44:33,040 --> 00:44:37,040
在进入主用户界面之前发送电子邮件，因为正如我所解释的那样

406
00:44:37,040 --> 00:44:40,639
一个我们尚未解决但很容易解决的问题

407
00:44:40,639 --> 00:44:44,239
地址，你将在下一章看到，所以

408
00:44:44,239 --> 00:44:48,319
呃，我会在那里见到你，大家好，欢迎来到第 23 章

409
00:44:48,319 --> 00:44:51,756
正如你在上一章中看到的那样，我们谈到了这个 vlog 课程

410
00:44:51,756 --> 00:44:57,436
清理我们的注册流程，以便当我们点击注册或

411
00:44:57,436 --> 00:45:02,559
注册按钮我们实际上向用户发送了一封电子邮件确认，我们

412
00:45:02,559 --> 00:45:06,639
看到我们去了电子邮件确认视图，甚至在我们到达那里之前，我们

413
00:45:06,639 --> 00:45:11,360
然后在我们的收件箱中收到我们的电子邮件确认，以便一切顺利

414
00:45:11,360 --> 00:45:15,839
除了现在没有注册的用户没有验证

415
00:45:15,839 --> 00:45:20,080
他们的电子邮件帐户仍然可以在我们的应用程序的主用户界面中结束，并且

416
00:45:20,080 --> 00:45:24,160
这就是我们将在本章中解决的问题，所以

417
00:45:24,160 --> 00:45:28,319
如标题所示或标题所示

418
00:45:28,319 --> 00:45:31,519
这里我们需要做的是确保

419
00:45:31,519 --> 00:45:34,160
我们首先在继续本章之前，我们需要确保我们已经

420
00:45:34,160 --> 00:45:38,319
退出应用程序，现在你在主用户界面中

421
00:45:38,319 --> 00:45:42,639
应用程序让我们进入这里并说注销，我们正在注销结束

422
00:45:42,639 --> 00:45:46,559
在登录屏幕上我要我也要调出视觉

423
00:45:46,559 --> 00:45:52,080
工作室代码，就像我们之前留下的那样

424
00:45:52,080 --> 00:45:54,796
我们现在需要做什么 我要关门了

425
00:45:54,796 --> 00:45:59,116
除了登录视图之外的其他选项卡，对不起

426
00:45:59,116 --> 00:46:02,559
在我们用电子邮件签名后，你可以在这里看到

427
00:46:02,559 --> 00:46:07,199
密码现在我们正在将用户发送到 notes 路线，我们需要

428
00:46:07,199 --> 00:46:10,955
清理这个，所以我们需要做的就是得到

429
00:46:10,955 --> 00:46:14,559
来自 firebase 的当前用户和

430
00:46:14,559 --> 00:46:18,720
我也会调出正确的标题

431
00:46:18,720 --> 00:46:21,915
我要稍微改变一下屏幕布局

432
00:46:21,915 --> 00:46:26,319
所以你可以更好地看到代码，所以你可以看到标题说你

433
00:46:26,319 --> 00:46:30,480
在将用户发送到主 ui 之前需要添加一个 if 语句

434
00:46:30,480 --> 00:46:33,275
应用程序，并确保用户是

435
00:46:33,275 --> 00:46:36,720
验证好的所以为了做到这一点，我们还需要得到

436
00:46:36,720 --> 00:46:39,915
并发用户，所以我们可以说最终用户

437
00:46:39,915 --> 00:46:45,275
等于 firebase off instance firebase off instance

438
00:46:45,275 --> 00:46:50,080
并且当前用户还可以，因此适用于当前用户

439
00:46:50,080 --> 00:46:54,480
我们会说如果你看到的用户可选我们需要可选

440
00:46:54,480 --> 00:47:00,000
当我们在这里得到一个布尔值时访问该电子邮件验证或错误

441
00:47:00,000 --> 00:47:05,519
这将返回一个 true 或重用 false 所以在这里我们说用户的电子邮件是

442
00:47:05,519 --> 00:47:13,040
否则验证用户的电子邮件

443
00:47:13,040 --> 00:47:18,000
呃，如果我能拼写它没有验证好的

444
00:47:18,000 --> 00:47:22,319
所以现在我们有两个条件

445
00:47:22,319 --> 00:47:26,319
所以我们现在需要做的是获取我们之前的代码

446
00:47:26,319 --> 00:47:31,116
可以看到它将用户发送到应用程序的主 ui，当然

447
00:47:31,116 --> 00:47:36,879
只有当用户基本上有

448
00:47:36,879 --> 00:47:43,116
验证了他们的电子邮件地址，因此获取该代码并将其放入用户电子邮件中

449
00:47:43,116 --> 00:47:47,519
在这里验证没问题，如果用户电子邮件是

450
00:47:47,519 --> 00:47:50,720
未验证然后我们需要执行相同的代码

451
00:47:50,720 --> 00:47:55,275
但不是去节点路由，这是应用程序的主要用户界面

452
00:47:55,275 --> 00:47:59,436
如果你记得的话，我们实际上知道我们需要去验证电子邮件路线

453
00:47:59,436 --> 00:48:03,915
前面章节中的路由开始我们已经定义了验证电子邮件路由

454
00:48:03,915 --> 00:48:06,400
可以，然后呢

455
00:48:06,400 --> 00:48:11,915
让我们回到我们的登录视图，然后粘贴相同的代码，除了转到

456
00:48:11,915 --> 00:48:17,680
注释我们要去的路线并验证电子邮件路线好吗

457
00:48:17,680 --> 00:48:20,796
所以我们必须为此做的一切

458
00:48:20,796 --> 00:48:24,879
章，所以它只是一步一步地清理逻辑，好吧，那就是

459
00:48:24,879 --> 00:48:28,160
好吧有些章节会很长有些章节会很短

460
00:48:28,160 --> 00:48:32,796
实际上即使对我来说有一些较短的章节也很令人耳目一新

461
00:48:32,796 --> 00:48:38,639
嗯，现在我们需要做的是让我们来测试一下

462
00:48:38,639 --> 00:48:41,915
如您所见，我们要做的是再次删除该测试用户

463
00:48:41,915 --> 00:48:45,595
从firebase控制台再次测试整个流程，所以我要做一个

464
00:48:45,595 --> 00:48:49,839
在这里热重启，只是为了确保状态是

465
00:48:49,839 --> 00:48:54,239
完全重新启动我要调出一个firebase控制台让我们去我们的

466
00:48:54,239 --> 00:48:57,680
对我来说被称为 mynotes flatware 项目的应用程序

467
00:48:57,680 --> 00:49:01,116
我要进行身份验证并删除我创建的那个测试用户

468
00:49:01,116 --> 00:49:04,879
在这里可以删除并再次热重启只是为了

469
00:49:04,879 --> 00:49:08,480
如果那里有任何缓存，请确保缓存无效

470
00:49:08,480 --> 00:49:13,680
我们现在需要做的就是哎呀

471
00:49:13,680 --> 00:49:17,839
我们现在需要做的是再次进行类似的注册，所以我

472
00:49:17,839 --> 00:49:21,756
去这里的注册页面然后我去你输入你的

473
00:49:21,756 --> 00:49:24,480
在这里发电子邮件，我要去

474
00:49:24,480 --> 00:49:29,040
写同一个email地址通过bar bath重新注册用户

475
00:49:29,040 --> 00:49:32,796
按下注册按钮，我们就到这里了，然后我就去做

476
00:49:32,796 --> 00:49:37,275
和我们之前一样被黑了，按下后退按钮然后转到

477
00:49:37,275 --> 00:49:42,796
登录屏幕我将输入相同的凭据并说 fubar baz if

478
00:49:42,796 --> 00:49:47,595
按下登录按钮后，一切都按照我们的计划进行

479
00:49:47,595 --> 00:49:52,319
代码将在这里结束，说明用户的电子邮件未经过验证

480
00:49:52,319 --> 00:49:55,199
它将从中删除登录路由

481
00:49:55,199 --> 00:50:00,239
从堆栈中将验证电子邮件路由推送到屏幕上，这样就可以了

482
00:50:00,239 --> 00:50:03,915
这正是我们要到达的地方，你可以看到我们要去

483
00:50:03,915 --> 00:50:09,915
按照我们的计划验证电子邮件视图好吧，因为我提到这一章是

484
00:50:09,915 --> 00:50:14,080
短的，这实际上非常好，所以我们现在需要做的是

485
00:50:14,080 --> 00:50:17,199
专注于我们将在下一章中做的事情，正如你所看到的那样

486
00:50:17,199 --> 00:50:21,360
身份验证逻辑遍布 ui，我们需要为

487
00:50:21,360 --> 00:50:24,796
到目前为止，您看到的身份验证我们一直在工作

488
00:50:24,796 --> 00:50:29,040
在我们一直喜欢写的源代码中直接使用firebase

489
00:50:29,040 --> 00:50:35,275
firebase auth 代码几乎在我们的 ui 中，现在你可能认为那没关系

490
00:50:35,275 --> 00:50:38,000
我的意思是如果你不是来自

491
00:50:38,000 --> 00:50:41,756
软件开发背景你可能认为那很好，它应该是

492
00:50:41,756 --> 00:50:44,879
只要它有效，但

493
00:50:44,879 --> 00:50:48,160
软件开发行业一次又一次地向我们表明，

494
00:50:48,160 --> 00:50:53,275
说哦，如果它在工作，如果它没有坏，不要修复它

495
00:50:53,275 --> 00:50:58,239
这不是真的适用于所有情况吗，正如我们所看到的那样

496
00:50:58,239 --> 00:51:03,116
例如 log 4j uh 它正在工作，但随后有一个安全飞行，并且

497
00:51:03,116 --> 00:51:06,400
每个人都必须前往他们的代码库并修复所有内容，所以我们

498
00:51:06,400 --> 00:51:10,559
周末完全静止，所以代码有效

499
00:51:10,559 --> 00:51:15,680
但它有一个问题，在这里你有你的用户界面，所以

500
00:51:15,680 --> 00:51:20,239
代码非常高级，就像字面上用户在这里然后我们

501
00:51:20,239 --> 00:51:25,116
在这里有我们的用户界面，然后我们就有了我们编写的代码

502
00:51:25,116 --> 00:51:29,436
并且像我们的 if 语句和 firebase 一样更底层

503
00:51:29,436 --> 00:51:33,116
一直坐在这里，我们就像暴露这个firebase层

504
00:51:33,116 --> 00:51:38,400
一直到我们的 ui 层 ui 直接与

505
00:51:38,400 --> 00:51:41,436
代码太高了以至于他们不应该与

506
00:51:41,436 --> 00:51:44,796
彼此所以如果你不是来自软件

507
00:51:44,796 --> 00:51:47,519
开发背景 这对你来说可能有点陌生但是软件

508
00:51:47,519 --> 00:51:50,400
开发人员真的很喜欢确保事情是

509
00:51:50,400 --> 00:51:53,519
com喜欢他们自己的隔间

510
00:51:53,519 --> 00:51:56,480
所以我们需要做的是为了得到

511
00:51:56,480 --> 00:52:00,239
为下一章做好准备就是喝杯好咖啡或茶，因为

512
00:52:00,239 --> 00:52:02,559
下一章实际上会很长，而且会是一个

513
00:52:02,559 --> 00:52:07,595
复杂的，但我会尽我所能解释所有的概念

514
00:52:07,595 --> 00:52:11,360
只能知道下一章将是

515
00:52:11,360 --> 00:52:16,559
大一号，好吧，拿你的茶点果汁茶

516
00:52:16,559 --> 00:52:21,915
喝咖啡随便你，下一章见

517
00:52:21,915 --> 00:52:26,319
你好，欢迎来到上一章 Flutter 课程的第 24 章

518
00:52:26,319 --> 00:52:30,879
我们讨论了确保用户的电子邮件在他或她可以之前得到验证

519
00:52:30,879 --> 00:52:33,680
继续

520
00:52:33,680 --> 00:52:38,239
在用户能够转到应用程序的主用户界面之前

521
00:52:38,239 --> 00:52:43,680
嗯，我们现在要做的就是从开发我们的 ui 中退后一步

522
00:52:43,680 --> 00:52:50,239
通过创建身份验证服务和应用程序的逻辑

523
00:52:50,239 --> 00:52:53,116
所以我要为你提供一个标题

524
00:52:53,116 --> 00:52:56,480
在这里，你可以看到它说 auth provider auth service 意思是作者

525
00:52:56,480 --> 00:53:01,199
现在在关闭服务上提供抽象类

526
00:53:01,199 --> 00:53:04,639
如果我们看一下到目前为止我们创建的代码，让我来看看视觉

527
00:53:04,639 --> 00:53:08,639
工作室代码，所以你可以在屏幕上看到它，就像我在这里做的那样，嗯，我要去

528
00:53:08,639 --> 00:53:12,879
增加尺寸，以便您看得更清楚，我将提出

529
00:53:12,879 --> 00:53:17,839
应用程序也是如此，所以我们可以并排看到它

530
00:53:17,839 --> 00:53:22,160
我这里有三个屏幕，所以它很多，有点难以兼顾

531
00:53:22,160 --> 00:53:24,796
嗯，对不起

532
00:53:24,796 --> 00:53:28,400
所以我要更改屏幕布局，以便您更好地查看代码

533
00:53:28,400 --> 00:53:31,839
如果你看这里我们有我们的

534
00:53:31,839 --> 00:53:35,275
嗯三视图登录

535
00:53:35,275 --> 00:53:39,040
注册并验证电子邮件视图没问题，否则我们实际上有四个视图另一个

536
00:53:39,040 --> 00:53:44,796
一个是我们现在创建的应用程序 um 的主用户界面

537
00:53:44,796 --> 00:53:48,400
这里笔记视图对不起

538
00:53:48,400 --> 00:53:51,519
但是如果您查看登录视图，您可以看到我们正在做的事情之一

539
00:53:51,519 --> 00:53:54,239
当我们进入登录视图时立即执行的是

540
00:53:54,239 --> 00:53:56,559
嗯实际上不是立即按下

541
00:53:56,559 --> 00:54:00,955
我们正在与firebase交谈的登录按钮关闭登录我们有点像

542
00:54:00,955 --> 00:54:05,199
uh 在注册视图中与 firebase 交谈时做同样的事情

543
00:54:05,199 --> 00:54:08,160
可以看到firebase auth instance create user

544
00:54:08,160 --> 00:54:11,915
我们的验证电子邮件中也有firebase

545
00:54:11,915 --> 00:54:17,360
所以你可以在这里看到我们实际上是在导入 firebase auth firebase 所以

546
00:54:17,360 --> 00:54:21,680
如果你不喜欢如果你没有软件开发背景

547
00:54:21,680 --> 00:54:25,680
从之前你可能会认为这是很好的非常重要的火力基地，但是

548
00:54:25,680 --> 00:54:30,400
您还需要知道 firebase 有点像低级抽象

549
00:54:30,400 --> 00:54:34,400
与firebase后端对话的那个层

550
00:54:34,400 --> 00:54:38,319
并为您提供很多高级的呃

551
00:54:38,319 --> 00:54:42,080
功能，但 Firebase 级别的那些高级功能

552
00:54:42,080 --> 00:54:45,360
他们有点高水平，但如果你想想

553
00:54:45,360 --> 00:54:49,519
firebase 是我们引入的依赖项

554
00:54:49,519 --> 00:54:53,436
我们与firebase后端本身对话的应用程序是

555
00:54:53,436 --> 00:54:58,400
与我们的 ui 相比低级，所以如果你认为

556
00:54:58,400 --> 00:55:03,116
用户界面代码在这里然后我们正在做的是我们就像在这里说的是

557
00:55:03,116 --> 00:55:07,680
firebase 然后 ui 直接与 firebase 库对话

558
00:55:07,680 --> 00:55:11,756
功能和在类似软件的眼中

559
00:55:11,756 --> 00:55:14,879
开发人员已经这样做了一段时间，这不是一个好主意

560
00:55:14,879 --> 00:55:20,639
因为我们在 ui 和 firebase 之间缺少了一点层

561
00:55:20,639 --> 00:55:24,400
它从 ui 中抽象出 firebase 功能

562
00:55:24,400 --> 00:55:28,639
应用程序，正如我们之前谈到的那样

563
00:55:28,639 --> 00:55:32,639
将来您可能希望允许例如苹果登录

564
00:55:32,639 --> 00:55:38,639
或谷歌登录或使用 facebook 登录等各种登录选项和

565
00:55:38,639 --> 00:55:44,160
如果你看一下firebase的控制台，你会立即看到

566
00:55:44,160 --> 00:55:48,879
在我们启用签名的那一刻，您有多种方式来验证用户身份

567
00:55:48,879 --> 00:55:53,116
在电子邮件和密码的方法中，但您也可以添加新的

568
00:55:53,116 --> 00:55:56,796
提供者你可以看到 google facebook 和这些你可以看到

569
00:55:56,796 --> 00:56:01,199
他们被称为提供者一个新的提供者，这就是我们要做的

570
00:56:01,199 --> 00:56:06,480
我们手电筒课程的这一章也是如此

571
00:56:06,480 --> 00:56:11,040
我们将采用 firebase 并将其视为身份验证

572
00:56:11,040 --> 00:56:14,239
provider 好的，所以我们要创建一个类

573
00:56:14,239 --> 00:56:19,199
我相信我们现在正在调用 firebase auth provider

574
00:56:19,199 --> 00:56:23,519
但我们会说这个 Firebase 身份验证提供程序来自另一个类

575
00:56:23,519 --> 00:56:29,436
这就是所谓的身份验证提供者，所以我们接下来要做的就是说好的

576
00:56:29,436 --> 00:56:35,595
任何需要我们的应用程序可以使用的身份验证提供程序都应该

577
00:56:35,595 --> 00:56:40,239
具有某些功能和某些属性可以，例如

578
00:56:40,239 --> 00:56:44,239
当前的身份验证提供者应该能够返回当前用户的作者

579
00:56:44,239 --> 00:56:47,680
提供者应该能够在 um 中登录用户

580
00:56:47,680 --> 00:56:51,839
注销用户 注册用户 发送电子邮件验证，以便这些

581
00:56:51,839 --> 00:56:57,116
很少的基本功能，所以这将是我们的抽象关闭

582
00:56:57,116 --> 00:57:02,319
provider 类，然后我们将创建另一个类，我们称之为它

583
00:57:02,319 --> 00:57:06,480
将是该抽象类的具体实现，因此请考虑

584
00:57:06,480 --> 00:57:12,720
抽象类就像我们的合同一样

585
00:57:12,720 --> 00:57:16,639
所以我们说的是任何身份验证提供程序，例如 google facebook 等

586
00:57:16,639 --> 00:57:20,239
将需要符合我们在此指定的功能

587
00:57:20,239 --> 00:57:23,756
抽象类好吧，那么我们将去开发一个具体的

588
00:57:23,756 --> 00:57:27,040
该抽象类的实现，我们将其称为firebase auth

589
00:57:27,040 --> 00:57:31,436
提供者，我们实际上将真正实现我们的

590
00:57:31,436 --> 00:57:35,040
firebase 的身份验证，例如创建用户

591
00:57:35,040 --> 00:57:41,519
在该具体实现中登录用户等

592
00:57:41,519 --> 00:57:45,360
然后我们将做什么我们将创建另一个我们将调用的类

593
00:57:45,360 --> 00:57:51,595
我相信我们将其取消服务及其目标

594
00:57:51,595 --> 00:57:56,080
在这门课程中，它不会做太多它会做的事情，它只会

595
00:57:56,080 --> 00:58:01,199
采用诸如 firebase auth 提供者之类的提供者 google auth 提供者和它

596
00:58:01,199 --> 00:58:05,839
只会将该提供程序的功能暴露给外界，并且

597
00:58:05,839 --> 00:58:10,955
这样做的目的是让我们的 ui 说话

598
00:58:10,955 --> 00:58:15,595
使用该服务，并且该服务将与提供者进行对话，该提供者是

599
00:58:15,595 --> 00:58:19,436
firebase auth provider 并且该 firebase auth provider 将与 firebase 对话，所以

600
00:58:19,436 --> 00:58:23,275
我们现在有firebase ui

601
00:58:23,275 --> 00:58:27,199
但是在本章结束后我们将拥有firebase

602
00:58:27,199 --> 00:58:32,559
嗯 firebase auth provider auth service 然后是 ui 所以我们会

603
00:58:32,559 --> 00:58:38,480
中间有两层，您实际上可能正确地认为

604
00:58:38,480 --> 00:58:41,756
好吧，这是很多工作，为什么我们需要它，但是

605
00:58:41,756 --> 00:58:46,559
对我来说，如果我希望这门课程只是另一门课程，我将向您展示如何

606
00:58:46,559 --> 00:58:50,080
包括火力基地那么老实说你真的值得

607
00:58:50,080 --> 00:58:53,680
再做一门关于firebase和flutter的课程，因为有很多

608
00:58:53,680 --> 00:58:57,915
可用的课程也许不是，也许不是经过这么多细节的课程

609
00:58:57,915 --> 00:59:02,720
虽然我要去，但我仍然相信我在这里的工作不仅仅是让你成为

610
00:59:02,720 --> 00:59:07,116
开发者，但也让你成为一个优秀的开发者，你需要一些额外的东西

611
00:59:07,116 --> 00:59:10,160
步骤以使您的代码更好一点，这就是为什么您

612
00:59:10,160 --> 00:59:14,080
随着您对软件开发和工作的深入了解，您实际上会注意到

613
00:59:14,080 --> 00:59:18,239
与内部团队中的其他人一起，您目前可能不会这样做，但当

614
00:59:18,239 --> 00:59:20,955
你得到你的第一份工作软件开发人员你会明白其他

615
00:59:20,955 --> 00:59:24,319
软件开发人员实际上正在采取一些额外的步骤来使他们的

616
00:59:24,319 --> 00:59:29,199
代码更容易维护，更好维护，这就是我们要做的

617
00:59:29,199 --> 00:59:34,239
在我们的代码中好吧

618
00:59:34,239 --> 00:59:37,436
这就是我们本章的介绍

619
00:59:37,436 --> 00:59:41,756
需要做的就是嗯先想想我们是怎么处理的

620
00:59:41,756 --> 00:59:46,080
如果你看里面我的意思是在

621
00:59:46,080 --> 00:59:49,595
验证视图我们没有处理异常，因此也许是

622
00:59:49,595 --> 00:59:53,360
我们也需要做一些事情，但是如果您查看登录屏幕

623
00:59:53,360 --> 00:59:58,559
例如，我们在这里有一个 try 块，然后当它关闭 firebase

624
00:59:58,559 --> 01:00:03,756
异常我们正在处理用户没有找到错误的密码，然后如果还有什么

625
01:00:03,756 --> 01:00:07,680
碰巧我们只是说显示错误所以这里有两个

626
01:00:07,680 --> 01:00:12,839
特定错误关闭错误，我们正在处理错误的密码而用户没有

627
01:00:12,839 --> 01:00:18,319
找到，如果我们进入注册视图，您还会看到我们

628
01:00:18,319 --> 01:00:25,116
已经使用了弱密码电子邮件和无效的电子邮件

629
01:00:25,116 --> 01:00:30,400
所以这些是我们需要在我们的 um 中处理的一些例外情况

630
01:00:30,400 --> 01:00:34,955
应用程序，但现在你可以看到我们的 ui 直接进入 firebase

631
01:00:34,955 --> 01:00:40,080
auth 异常，就像导入 firebase auth 异常一样

632
01:00:40,080 --> 01:00:45,199
里面创建的让我们看看firebase off accession src interface

633
01:00:45,199 --> 01:00:49,275
它在嗯

634
01:00:49,275 --> 01:00:54,720
它在我认为可以通过 firebase auth 访问的文件之一中，所以

635
01:00:54,720 --> 01:00:59,040
如果你去火力基地，可能会导入所有异常

636
01:00:59,040 --> 01:01:04,400
我们也去这里

637
01:01:04,400 --> 01:01:08,559
所以我们的用户界面不应该真的知道任何关于火力基地的事情结束

638
01:01:08,559 --> 01:01:13,756
章节所以让我们在这里迈出第一步，让我们去创建我们的

639
01:01:13,756 --> 01:01:17,275
如您所见，lib下有一个新文件

640
01:01:17,275 --> 01:01:20,519
在名为 services auth 的文件夹下，然后关闭

641
01:01:20,519 --> 01:01:23,436
exceptions.dart 所以我现在就去做

642
01:01:23,436 --> 01:01:27,275
我要折叠这些，让我们躺下，你可以看到我们没有

643
01:01:27,275 --> 01:01:30,796
现在有 con 我们有常量实用程序和视图，所以我们没有

644
01:01:30,796 --> 01:01:34,480
任何称为服务的东西，所以让我右键单击 lib 并说新文件和你

645
01:01:34,480 --> 01:01:38,080
可以做同样的事情，在这里只需输入整个路径

646
01:01:38,080 --> 01:01:42,639
所以说服务关闭，然后我们说关闭

647
01:01:42,639 --> 01:01:45,180
exceptions.dart 好的

648
01:01:45,180 --> 01:01:50,160
[音乐] 哦，那是我们创建的新文件

649
01:01:50,160 --> 01:01:52,955
在那里，我们需要做的就是去

650
01:01:52,955 --> 01:01:58,400
定义所有这些例外，所以让我们首先说我们需要一个新的

651
01:01:58,400 --> 01:02:02,796
异常称为用户未发现异常，如果您记得用户未找到

652
01:02:02,796 --> 01:02:05,436
发现是我们在这里处理的东西你还记得吗

653
01:02:05,436 --> 01:02:09,756
登录视图中的firebase off异常，如果我们找不到该用户，我们就是

654
01:02:09,756 --> 01:02:14,955
只是显示一个错误说显示错误对话框所以让我们定义一个异常

655
01:02:14,955 --> 01:02:25,436
那我会说找不到类用户并关闭

656
01:02:25,436 --> 01:02:30,400
我要说实现异常所以这是一种典型的方式

657
01:02:30,400 --> 01:02:34,796
在您所说的应用程序中创建异常类

658
01:02:34,796 --> 01:02:38,955
这是我自己的课程，例如

659
01:02:38,955 --> 01:02:42,796
代表一个例外，这是一种很好的做法，只是说它

660
01:02:42,796 --> 01:02:46,796
实现一个现有的异常异常，您可以通过命令在此处查看

661
01:02:46,796 --> 01:02:51,436
按下它你可以看到它进入flutter bin cache core exception start

662
01:02:51,436 --> 01:02:55,116
所以默认情况下它已经被导入你不必导入任何特定的文件

663
01:02:55,116 --> 01:02:57,915
为了访问异常类

664
01:02:57,915 --> 01:03:04,319
所以你只需要实现那个类就足够了

665
01:03:04,319 --> 01:03:08,239
所以现在让我们继续执行下一个

666
01:03:08,239 --> 01:03:13,915
异常作为标题作为标题说这里错误密码关闭异常

667
01:03:13,915 --> 01:03:17,915
这也在我们的登录视图中处理

668
01:03:17,915 --> 01:03:21,595
这里密码错误所以

669
01:03:21,595 --> 01:03:27,519
我只是要去，有点像复制那个代码，在这里我只想说

670
01:03:27,519 --> 01:03:33,360
错误密码验证异常

671
01:03:33,360 --> 01:03:37,915
好吧，我们还在这里处理什么，至少在登录视图中没有别的

672
01:03:37,915 --> 01:03:41,519
所以这真的很好，所以我要关闭登录视图

673
01:03:41,519 --> 01:03:46,319
现在保存这个文件好

674
01:03:46,319 --> 01:03:50,080
所以现在让我们开始处理我们正在处理的一些异常

675
01:03:50,080 --> 01:03:53,839
我们的注册视图，让我们去注册视图，你会在这里看到

676
01:03:53,839 --> 01:03:57,680
我们正在处理的第一部分异常称为弱密码

677
01:03:57,680 --> 01:04:00,955
所以我要在这里发表评论

678
01:04:00,955 --> 01:04:04,239
在这里发表评论我要说登录异常

679
01:04:04,239 --> 01:04:08,400
并且注册异常好

680
01:04:08,400 --> 01:04:11,915
所以正如标题所说，让我们创建一个名为弱密码身份验证的类

681
01:04:11,915 --> 01:04:16,879
异常会从这里复制这段代码，我会说弱

682
01:04:16,879 --> 01:04:22,559
密码关闭异常，这是针对注册视图弱的

683
01:04:22,559 --> 01:04:27,915
密码下一个是已经在使用的电子邮件，所以这就是标题所说的

684
01:04:27,915 --> 01:04:32,639
也在这里，所以让我们去复制这个，我会说电子邮件已经在使用中

685
01:04:32,639 --> 01:04:35,595
身份验证异常

686
01:04:35,595 --> 01:04:38,879
好的，现在我们有了密码和电子邮件

687
01:04:38,879 --> 01:04:44,480
已经使用异常，让我们看看

688
01:04:44,480 --> 01:04:49,275
而且我们还有无效的电子邮件身份验证异常

689
01:04:49,275 --> 01:04:53,360
我认为我没有计划好，但我们也去实施吧

690
01:04:53,360 --> 01:05:00,796
所以让我们说无效的电子邮件作者好吧

691
01:05:00,796 --> 01:05:05,839
好吧，现在我们还需要做的是

692
01:05:05,839 --> 01:05:10,480
定义一些你记得的其他例外

693
01:05:10,480 --> 01:05:15,116
注册视图我们也有一个 else where 的情况

694
01:05:15,116 --> 01:05:18,720
我们基本上说这里发生了其他事情，这是一个例外，但有些事情

695
01:05:18,720 --> 01:05:22,879
else 可能发生了我们尚未使用此代码处理的情况，或者我们也可能

696
01:05:22,879 --> 01:05:26,879
这里有另一个 cat 语句，它可以捕获通用异常和

697
01:05:26,879 --> 01:05:31,680
我们正在做同样的事情，你可以在这里看到代码，让我

698
01:05:31,680 --> 01:05:36,000
改变屏幕布局，让你看得更清楚，我要去

699
01:05:36,000 --> 01:05:39,436
登录视图也是如此，因为我们在登录中做同样的事情

700
01:05:39,436 --> 01:05:43,680
在获得 Firebase 身份验证异常时查看

701
01:05:43,680 --> 01:05:48,239
这段代码然后我们甚至还有一个 else 语句

702
01:05:48,239 --> 01:05:53,116
在那里，所以我们说如果代码不像我们处理的那样，它可能是另一个

703
01:05:53,116 --> 01:05:58,879
在这种情况下的代码也显示显示错误对话框或在这种情况下显示错误

704
01:05:58,879 --> 01:06:02,400
对话，我们也在做一个像

705
01:06:02,400 --> 01:06:05,756
通用的 catch 也是如此，所以我们需要有点像

706
01:06:05,756 --> 01:06:08,796
处理所有这些情况的异常

707
01:06:08,796 --> 01:06:14,000
firebase off 异常期间的未知代码和未知异常，因此

708
01:06:14,000 --> 01:06:17,680
我们将创建一个通用异常

709
01:06:17,680 --> 01:06:21,040
我要稍微改变一下屏幕布局

710
01:06:21,040 --> 01:06:24,796
嗯，我就去记笔记好了

711
01:06:24,796 --> 01:06:30,160
所以让我们在这里说通用异常

712
01:06:30,160 --> 01:06:35,275
嗯，我会带来

713
01:06:35,275 --> 01:06:40,639
这个今天也上来了，我要先带这个，所以

714
01:06:40,639 --> 01:06:44,239
让我们继续创建一个通用的身份验证异常，我将从中复制此代码

715
01:06:44,239 --> 01:06:47,756
在这里我要说通用身份验证异常

716
01:06:47,756 --> 01:06:50,480
好的，我们还需要做的是

717
01:06:50,480 --> 01:06:55,040
提供这个东西用户未登录

718
01:06:55,040 --> 01:07:00,400
例外，你现在会知道

719
01:07:00,400 --> 01:07:03,275
嗯，我的意思是你需要知道我们为什么

720
01:07:03,275 --> 01:07:07,040
实际上有使用或未登录异常和

721
01:07:07,040 --> 01:07:12,639
这将是一个例外，我们的 Firebase 提供商将能够

722
01:07:12,639 --> 01:07:15,199
扔如果

723
01:07:15,199 --> 01:07:21,275
例如，在注册该用户后，该用户为空

724
01:07:21,275 --> 01:07:26,000
所以假设我们告诉我们的身份验证提供者我们说注册一个用户

725
01:07:26,000 --> 01:07:30,639
这个电子邮件和密码，没有例外什么都没有发生

726
01:07:30,639 --> 01:07:34,639
所以我们的应用程序认为一切都按预期进行，但是

727
01:07:34,639 --> 01:07:38,239
如果我们访问的用户怎么办

728
01:07:38,239 --> 01:07:42,796
在这种情况下，我们的身份验证提供程序在 firebase 身份验证为空

729
01:07:42,796 --> 01:07:46,160
应该能够处理它并发送一个异常说哦我不能

730
01:07:46,160 --> 01:07:50,720
发现此用户或此用户未登录，所以让我们创建该异常为

731
01:07:50,720 --> 01:07:55,199
好吧，所以我只想说用户未登录异常，所以让我们

732
01:07:55,199 --> 01:07:58,080
只是说类实现

733
01:07:58,080 --> 01:08:02,000
异常正常，所以用户未登录异常

734
01:08:02,000 --> 01:08:06,720
我也要保存它

735
01:08:06,720 --> 01:08:10,879
好的，这是很多工作现在我们已经创建了所有这些文件哦，对不起

736
01:08:10,879 --> 01:08:13,756
也许你实际上并没有看到我写的我不喜欢的代码

737
01:08:13,756 --> 01:08:17,360
字幕一直在增加，但我也认为字幕非常重要，所以

738
01:08:17,360 --> 01:08:20,879
你总是知道我们在做什么，但是拥有这些的缺点

739
01:08:20,879 --> 01:08:24,319
屏幕左下角的标题是有时他们隐藏了什么

740
01:08:24,319 --> 01:08:27,680
我正在打字，所以我正在尽我所能

741
01:08:27,680 --> 01:08:31,756
抓住那些并抓住那个问题，如果我看到了

742
01:08:31,756 --> 01:08:34,720
发生了，我会像这样把屏幕打开，让你看到，但是

743
01:08:34,720 --> 01:08:39,275
有时我可能会想念我为此道歉所以让我们说

744
01:08:39,275 --> 01:08:43,275
现在我们已经实现了所有的异常

745
01:08:43,275 --> 01:08:47,199
正如您在标题中看到的那样，它说我们需要一个我们不应该的身份验证用户

746
01:08:47,199 --> 01:08:51,360
将firebase的用户暴露给用户界面，老实说，这是

747
01:08:51,360 --> 01:08:58,239
与我们的异常情况相同，ui代码根本不应该工作

748
01:08:58,239 --> 01:09:03,436
使用 firebase 的 ui 代码应该非常高级，并且从

749
01:09:03,436 --> 01:09:08,400
你的应用程序的其余部分，它甚至不应该知道它是怎么回事

750
01:09:08,400 --> 01:09:11,275
运作你只是给它不同

751
01:09:11,275 --> 01:09:15,199
提供者和服务，它应该不调用这些服务和提供者

752
01:09:15,199 --> 01:09:19,839
真的知道它们是如何联系在一起的，此时您可以看到我们的登录信息

753
01:09:19,839 --> 01:09:24,160
看看它就像我们进去的地方

754
01:09:24,160 --> 01:09:29,680
你可以在登录视图中看到这里，对我来说它在第 67 行，你可能在

755
01:09:29,680 --> 01:09:33,915
不同的线路，但我们在使用电子邮件和密码调用登录后

756
01:09:33,915 --> 01:09:36,559
我们也不应该做的功能

757
01:09:36,559 --> 01:09:39,839
但在那之后我们要做的是

758
01:09:39,839 --> 01:09:44,400
从firebase获取当前用户，这个用户是你可以看到的类型

759
01:09:44,400 --> 01:09:49,915
让我们进去看看它的类型是 user 所以如果我把类型放在这里

760
01:09:49,915 --> 01:09:54,955
命令点击它你会看到这个用户是你看到的firebase auth的一部分

761
01:09:54,955 --> 01:10:01,436
有趣的是，有一个名为 user 的类，所以我们都是我们也喜欢暴露一个

762
01:10:01,436 --> 01:10:05,839
firebase 用户到我们的用户界面，这不是一个好主意

763
01:10:05,839 --> 01:10:10,879
所以正如这里的标题所说，我们不应该将 firebase 的用户暴露给 ui，所以我们

764
01:10:10,879 --> 01:10:16,480
需要有我们自己的用户来抽象出功能

765
01:10:16,480 --> 01:10:21,915
或者firebase级别的当前用户还可以

766
01:10:21,915 --> 01:10:26,239
所以让我们继续这样做吧

767
01:10:26,239 --> 01:10:32,239
我们将在 lib services auth 中创建一个非用户 dart 文件，该文件名为

768
01:10:32,239 --> 01:10:36,239
关闭用户，所以我要删除或对不起我

769
01:10:36,239 --> 01:10:39,595
将关闭我创建的所有文件

770
01:10:39,595 --> 01:10:44,559
services auth 我将创建一个关闭用户

771
01:10:44,559 --> 01:10:50,955
所以我要说关闭 user.dark 而在这个关闭用户中，我们需要

772
01:10:50,955 --> 01:10:55,519
在这种情况下基本上开始使用firebase，所以我要去我的笔记

773
01:10:55,519 --> 01:10:58,796
只是为了确保我告诉你我打算做的一切

774
01:10:58,796 --> 01:11:03,680
告诉你好吧，让我们进入这里并导入

775
01:11:03,680 --> 01:11:09,116
firebase 它是用户导入包

776
01:11:09,116 --> 01:11:13,199
火力基地，它在

777
01:11:13,199 --> 01:11:18,000
我相信firebase auth，然后我们会说显示用户还可以，就像我一样

778
01:11:18,000 --> 01:11:23,040
之前提到过，这是确保您不暴露的好方法

779
01:11:23,040 --> 01:11:28,720
太多的包类到你当前的工作空间，除了你是什么

780
01:11:28,720 --> 01:11:33,360
说的是firebase auth是不是它可能是一个完整的飞镖文件

781
01:11:33,360 --> 01:11:37,116
结构可能有数千个课程，现在我夸大了，但很多

782
01:11:37,116 --> 01:11:41,915
类，但您只对用户类感兴趣，好吧

783
01:11:41,915 --> 01:11:45,040
所以你也可以说

784
01:11:45,040 --> 01:11:48,319
作为火力基地

785
01:11:48,319 --> 01:11:52,955
像这样关闭，然后你会说显示用户，这将允许你这样做，如果

786
01:11:52,955 --> 01:11:56,000
我说测试然后你就可以说

787
01:11:56,000 --> 01:12:00,000
firebaseauth.user 你也可以这样做，如果你

788
01:12:00,000 --> 01:12:04,639
例如，更喜欢在这种情况下为来自的用户添加前缀

789
01:12:04,639 --> 01:12:09,519
firebase 以及它来自您的实际位置也可以用作

790
01:12:09,519 --> 01:12:14,160
有些人可能喜欢它，我也喜欢，但我不打算在

791
01:12:14,160 --> 01:12:18,160
这个特定的文件，如果你想这样做的话

792
01:12:18,160 --> 01:12:21,360
我在这里做，所以您可以按照我提供的步骤进行操作

793
01:12:21,360 --> 01:12:25,199
在本课程中为您服务，而不会偏离

794
01:12:25,199 --> 01:12:30,160
从现在开始好吧，我们已经完成了

795
01:12:30,160 --> 01:12:33,199
将我们需要做的事情作为标题导入

796
01:12:33,199 --> 01:12:37,595
案例我们需要创建实际的类，所以让我们说类关闭用户

797
01:12:37,595 --> 01:12:45,275
在这里，我们需要一个名为 is email verify 现在记住的字段

798
01:12:45,275 --> 01:12:49,519
现在我们需要从我们的关闭用户那里知道该电子邮件是否是

799
01:12:49,519 --> 01:12:53,360
例如，如果您进入我们的登录视图，是否已验证

800
01:12:53,360 --> 01:12:56,796
你可以看到我们在这里有这段代码

801
01:12:56,796 --> 01:13:00,160
使用电子邮件和密码登录用户，然后立即获得

802
01:13:00,160 --> 01:13:04,559
用户和它对该用户所做的一切都说电子邮件已验证

803
01:13:04,559 --> 01:13:08,239
我们在注册视图中做同样的事情我相信所以让我们去

804
01:13:08,239 --> 01:13:12,080
注册视图，你可以在这里看到它说

805
01:13:12,080 --> 01:13:15,915
实际上，我们没有对已验证的电子邮件做任何事情，我们正在做的一切

806
01:13:15,915 --> 01:13:19,915
只是说发送电子邮件验证非常抱歉，所以它在登录

807
01:13:19,915 --> 01:13:25,680
screen 好的，所以让我们在这里进入我们的关闭用户并说它有一个名为的属性

808
01:13:25,680 --> 01:13:32,720
电子邮件验证没问题，所以我要说 final 而公牛是电子邮件

809
01:13:32,720 --> 01:13:36,639
你看到firebase已经实现了这个功能这个呃

810
01:13:36,639 --> 01:13:41,839
属性作为电子邮件验证我个人更喜欢调用布尔函数 boolean

811
01:13:41,839 --> 01:13:47,519
在这种情况下，getter 就像一个类的属性，只要我认为合适

812
01:13:47,519 --> 01:13:51,756
只是因为至少说用户 dot 对我来说更有意义

813
01:13:51,756 --> 01:13:55,680
电子邮件已验证，而不是说 user.email 已验证

814
01:13:55,680 --> 01:14:00,639
它只是让它在语法上更像是完整的，经过验证或

815
01:14:00,639 --> 01:14:04,319
这就是我们的原因

816
01:14:04,319 --> 01:14:07,915
分歧一点好吧

817
01:14:07,915 --> 01:14:12,480
现在你在这里看到这个，我们说你可以得到它的电子邮件验证

818
01:14:12,480 --> 01:14:17,199
Visual Studio 代码的帮助为最终字段创建构造函数

819
01:14:17,199 --> 01:14:20,080
即使您不想这样做，也可以随时手动输入

820
01:14:20,080 --> 01:14:25,839
您可以说用户自己已通过电子邮件验证对不起，这是已通过电子邮件验证

821
01:14:25,839 --> 01:14:31,436
并且因为这个类它只有一个你可以设置的属性

822
01:14:31,436 --> 01:14:34,955
初始化并且您不会更改它，因为它是最终字段

823
01:14:34,955 --> 01:14:40,796
对不起，你可以让你的构造函数成为 const

824
01:14:40,796 --> 01:14:45,275
再次对不起，如果可以的话也很好

825
01:14:45,275 --> 01:14:49,595
基本上让我们说不可变作为另一个尝试定义

826
01:14:49,595 --> 01:14:53,839
未定义我相信你实际上必须在这里导入基础

827
01:14:53,839 --> 01:14:59,519
现在不可变基本上是但在这里不可变我认为我们没有

828
01:14:59,519 --> 01:15:04,160
之前讨论过，但这就像一个注释告诉这个

829
01:15:04,160 --> 01:15:08,955
类和该类的任何子类将是不可变的，这意味着

830
01:15:08,955 --> 01:15:13,519
它们的内部结构在初始化时永远不会改变，所以如果你

831
01:15:13,519 --> 01:15:20,879
然后去创建例如我的关闭用户类并说扩展身份验证用户

832
01:15:20,879 --> 01:15:26,239
然后你会有一个公牛，嗯，让我们在这里说，你创建一个

833
01:15:26,239 --> 01:15:31,360
它的构造函数，所以让我们为它创建一个构造函数吧，太好了

834
01:15:31,360 --> 01:15:36,319
更喜欢声明什么是 const 好然后我们说 const 然后你说好

835
01:15:36,319 --> 01:15:39,839
我想要一个布尔标志在这里公牛是废话

836
01:15:39,839 --> 01:15:42,400
和嗯

837
01:15:42,400 --> 01:15:45,519
是的，公牛被封锁了

838
01:15:45,519 --> 01:15:49,116
现在你看到它说 null 而不是不可为 null 的实例 flab 但它必须

839
01:15:49,116 --> 01:15:53,839
被初始化让我们把它初始化为 false 并且它说不能定义一个

840
01:15:53,839 --> 01:15:57,595
cons 构造函数好的，那么我们不打算将它变成一个 cons 构造函数和

841
01:15:57,595 --> 01:16:01,756
现在你看到这里的小警告它说这个类或这个类

842
01:16:01,756 --> 01:16:06,720
继承自的类被标记为不可变，但它的一个或多个

843
01:16:06,720 --> 01:16:11,756
实例感觉不是最终的所以现在你明白什么是不可变的了

844
01:16:11,756 --> 01:16:17,116
告诉 dart 这个类及其所有子类需要是免疫不可变的

845
01:16:17,116 --> 01:16:22,319
他们不能有任何更改的字段，因此通过删除此字段，您将得到

846
01:16:22,319 --> 01:16:25,275
摆脱那个小警告，你可以做到这一点

847
01:16:25,275 --> 01:16:30,480
缺点和错误完全消失了所以现在你知道什么是不可变的了

848
01:16:30,480 --> 01:16:34,955
好的，好的，现在我们创建了

849
01:16:34,955 --> 01:16:38,796
在 cons 构造函数中为我们的关闭用户验证的电子邮件

850
01:16:38,796 --> 01:16:44,239
让我们转到下一点下一点，正如您在此处看到的那样

851
01:16:44,239 --> 01:16:50,400
说我们需要一个工厂构造函数来创建我们的

852
01:16:50,400 --> 01:16:55,436
来自 firebase 用户和工厂构造函数的 auth 用户非常有用

853
01:16:55,436 --> 01:17:00,720
为此，您假设对象 x 并且您想要

854
01:17:00,720 --> 01:17:06,000
从中创建一个对象 y ，而不是手动以某种方式粘合东西

855
01:17:06,000 --> 01:17:10,480
中间层说现在我拿对象 x 并添加一些废话和融合

856
01:17:10,480 --> 01:17:14,639
把它放在一起，然后把对象 y 你可以把责任放在对象 y 上

857
01:17:14,639 --> 01:17:19,116
并说你需要能够初始化自己或构造一个

858
01:17:19,116 --> 01:17:22,720
来自这个对象的你自己的实例，这就像一个典型的模式

859
01:17:22,720 --> 01:17:27,275
你会到处看到所以嗯到处都是但是在哪里

860
01:17:27,275 --> 01:17:31,839
你有能力做到这一点所以这就是我们现在要做的

861
01:17:31,839 --> 01:17:36,879
工厂构造函数所以假设我们这里有一个工厂构造函数

862
01:17:36,879 --> 01:17:42,319
我们会说关闭用户，我们会说从火力基地好的，正如标题所说的那样

863
01:17:42,319 --> 01:17:47,199
我们像这样把一个firebase用户带到这里，然后我们说我们会说什么

864
01:17:47,199 --> 01:17:52,239
在这里我们将创建一个我们自己的类的实例

865
01:17:52,239 --> 01:17:56,160
鉴于该用户还可以，所以假设我们创建

866
01:17:56,160 --> 01:18:00,796
这里有一个关闭用户和很多用户，它是电子邮件

867
01:18:00,796 --> 01:18:04,000
验证来自像这样验证的用户电子邮件

868
01:18:04,000 --> 01:18:07,116
好吧，所以这不应该是他们不应该那么难

869
01:18:07,116 --> 01:18:10,239
理解，所以这创造了这个进入

870
01:18:10,239 --> 01:18:15,680
您可以看到此构造函数，它采用电子邮件验证值

871
01:18:15,680 --> 01:18:20,239
firebase 用户并将其放在此类中，所以我们所做的只是我们

872
01:18:20,239 --> 01:18:24,239
就像复制了一个firebase用户和

873
01:18:24,239 --> 01:18:27,839
我们将其复制到我们自己的关闭用户中

874
01:18:27,839 --> 01:18:32,879
好的，所以我们不会暴露 firebase 的用户及其所有内容

875
01:18:32,879 --> 01:18:39,040
我们的用户界面的属性

876
01:18:39,040 --> 01:18:44,160
好吧，那是很多信息现在让我们来谈谈身份验证提供者

877
01:18:44,160 --> 01:18:46,639
我在本章开头提到

878
01:18:46,639 --> 01:18:52,080
正如您在 firebase 控制台中看到的那样，您将可以添加

879
01:18:52,080 --> 01:18:54,879
使用时为您的应用程序提供各种身份验证提供程序

880
01:18:54,879 --> 01:18:59,360
firebase 诸如 google 和 apple facebook

881
01:18:59,360 --> 01:19:03,199
还有更多像我们这样做的电子邮件和密码组合

882
01:19:03,199 --> 01:19:07,199
所有这些都是提供者，我们现在需要做的是创建一个

883
01:19:07,199 --> 01:19:14,160
alt 提供者类，它封装了我们可能添加的每个提供者

884
01:19:14,160 --> 01:19:19,519
未来并为他们创建一个漂亮的界面说我们的每个供应商

885
01:19:19,519 --> 01:19:24,559
应用程序可以使用应该符合这个特定的接口好吗

886
01:19:24,559 --> 01:19:29,116
所以让我们继续处理这个问题，我可以在这里看到我们要

887
01:19:29,116 --> 01:19:32,080
在 lib services auth 上创建该文件

888
01:19:32,080 --> 01:19:38,080
关闭提供程序，因此我们关闭了 lib 服务，但我们没有身份验证提供程序文件，所以

889
01:19:38,080 --> 01:19:46,319
让我们右键单击 auth 并说出提供者 dart

890
01:19:46,319 --> 01:19:49,680
去我的笔记

891
01:19:49,680 --> 01:19:53,839
所以我们接下来要做的是

892
01:19:53,839 --> 01:19:59,275
因为我们的off uh提供商将与我们合作

893
01:19:59,275 --> 01:20:02,239
嗯，例如

894
01:20:02,239 --> 01:20:05,360
我们将为我们的身份验证提供者提供的功能是

895
01:20:05,360 --> 01:20:10,559
实例一个获取当前用户的getter，所以这不是一个函数，它只是

896
01:20:10,559 --> 01:20:14,639
如果你看到让我去登录，我们实际上在这里做的方式是吸气剂

897
01:20:14,639 --> 01:20:18,559
查看，您将在此处的登录视图中看到

898
01:20:18,559 --> 01:20:22,955
目前的事情说firebase auth instance current user这是一个getter

899
01:20:22,955 --> 01:20:28,879
所以这是一个属性并返回firebase用户我们想要的是我们的

900
01:20:28,879 --> 01:20:34,080
auth provider 也能够为我们提供当前用户现在记住

901
01:20:34,080 --> 01:20:40,080
我们已经用我们自己的 auth 用户抽象了 firebase 用户，我们刚刚

902
01:20:40,080 --> 01:20:46,000
创建好了，所以我们需要的是这个抽象类，它可以返回一个

903
01:20:46,000 --> 01:20:51,839
我们关闭用户的实例没问题，因此我们需要将其导入关闭

904
01:20:51,839 --> 01:20:56,160
用户进入这个 dart 文件，所以我们只说导入

905
01:20:56,160 --> 01:20:59,275
将我创建的这个应用程序打包为

906
01:20:59,275 --> 01:21:02,080
你可以在标题中看到它叫做我的笔记

907
01:21:02,080 --> 01:21:08,955
所以让我们去我的笔记服务 auth 然后去 auth user 所以这就是

908
01:21:08,955 --> 01:21:13,116
如您在标题中看到的导入语句，我已经编写了 package xxx 和

909
01:21:13,116 --> 01:21:17,199
这就是您需要在这种情况下输入包裹名称的地方，因为我是我的

910
01:21:17,199 --> 01:21:20,796
笔记

911
01:21:20,796 --> 01:21:26,720
好的，现在我们去创建一个抽象类，所以我已经

912
01:21:26,720 --> 01:21:31,756
之前提到过两次，但我们的身份验证提供程序 dart 文件不会有

913
01:21:31,756 --> 01:21:36,239
真的没有任何逻辑

914
01:21:36,239 --> 01:21:40,955
抽象类虽然 dart 中的抽象类可以包含逻辑但是在这个

915
01:21:40,955 --> 01:21:44,559
如果我们的抽象类只是一个协议，或者你可能知道它为

916
01:21:44,559 --> 01:21:50,080
接口，或者你可能也知道它是一个抽象类，所以让我们继续吧

917
01:21:50,080 --> 01:21:55,040
并创建让我们说抽象类身份验证提供程序

918
01:21:55,040 --> 01:22:01,116
这样抽象类的创建就完成了，我们现在需要做的就是给它

919
01:22:01,116 --> 01:22:05,595
就像标题说的那样，可以返回当前关闭的用户

920
01:22:05,595 --> 01:22:10,879
我们要关闭用户并让当前用户正常

921
01:22:10,879 --> 01:22:14,480
所以我们说任何作者提供者是否可以使用电子邮件密码

922
01:22:14,480 --> 01:22:18,559
是否是 google auth provider 是否是 Apple facebook twitter

923
01:22:18,559 --> 01:22:22,955
无论它需要能够有选择地返回当前的当前

924
01:22:22,955 --> 01:22:26,080
经过身份验证的用户，这就是这个可选站点

925
01:22:26,080 --> 01:22:31,275
在这里可以，然后我们还需要做的是

926
01:22:31,275 --> 01:22:33,680
允许它

927
01:22:33,680 --> 01:22:39,680
能够让用户登录没问题，所以我们会说我们将拥有一个功能

928
01:22:39,680 --> 01:22:43,436
在未来完成

929
01:22:43,436 --> 01:22:48,955
并返回一个关闭用户，它说登录

930
01:22:48,955 --> 01:22:53,519
像这样没关系，现在我们必须想想这是什么

931
01:22:53,519 --> 01:22:58,400
在我们的例子中，登录实际上需要很好，它需要电子邮件和密码，所以让我们

932
01:22:58,400 --> 01:23:02,000
只需输入电子邮件和密码，我们认为每个作者提供者

933
01:23:02,000 --> 01:23:06,239
我们正在写作将有某种电子邮件和密码组合

934
01:23:06,239 --> 01:23:10,559
你可以说 id 和 password 但我只会用 email 和 password

935
01:23:10,559 --> 01:23:14,480
现在好了，所以让我们也制作这些必需的参数，所以我要走了

936
01:23:14,480 --> 01:23:18,239
把大括号放在这里，把大括号放在这里，我要说是必需的

937
01:23:18,239 --> 01:23:22,000
流电子邮件，然后是所需的流密码，例如

938
01:23:22,000 --> 01:23:24,559
没关系

939
01:23:24,559 --> 01:23:28,720
和该命令末尾的分号 s 将文件保存为如此黑暗

940
01:23:28,720 --> 01:23:35,436
格式化程序可以发挥它的魔力以及我们去的原因

941
01:23:35,436 --> 01:23:39,199
如果您再次进入我们的登录屏幕，请原谅作者

942
01:23:39,199 --> 01:23:43,839
在这里我们说用用户名和密码登录你可以看到它总是

943
01:23:43,839 --> 01:23:49,040
现在返回一个用户凭证你可能会想我怎么能总是返回一个

944
01:23:49,040 --> 01:23:53,116
如果当前的电子邮件和密码实际上不正确并且他们

945
01:23:53,116 --> 01:23:57,275
不属于有效用户firebase处理的方式是，如果

946
01:23:57,275 --> 01:24:01,680
你说用电子邮件和密码登录，如果你能抓住当前用户，如果他

947
01:24:01,680 --> 01:24:05,040
无法使用您提供的信息登录该用户返回

948
01:24:05,040 --> 01:24:09,360
否则它会失败并出现异常，这意味着只要

949
01:24:09,360 --> 01:24:13,275
你打电话给我，没有例外，如果有，我会给你用户凭证

950
01:24:13,275 --> 01:24:18,160
是一个例外，你需要处理它，所以这是避免的好方法

951
01:24:18,160 --> 01:24:23,199
拥有功能让我关闭关闭用户以及避免拥有的功能

952
01:24:23,199 --> 01:24:27,040
在你的返回用户上做这个选项，所以

953
01:24:27,040 --> 01:24:32,559
在你的函数中做你的工作返回用户并返回对象

954
01:24:32,559 --> 01:24:37,436
你承诺如果你不能这样做会抛出一个错误，所以你不必这样做

955
01:24:37,436 --> 01:24:43,595
这做这种可选的回报好吧

956
01:24:43,595 --> 01:24:48,480
对于登录功能，现在我们还需要一个可以创建

957
01:24:48,480 --> 01:24:52,480
用户以便想象它是用于注册或

958
01:24:52,480 --> 01:24:56,239
嗯，是的，我们还能叫它什么，呃，注册

959
01:24:56,239 --> 01:25:00,559
是的，所以我们称它为创建用户，所以我们说

960
01:25:00,559 --> 01:25:06,239
这也返回一个身份验证用户，我们称之为创建用户这样

961
01:25:06,239 --> 01:25:09,680
这也有所有这些参数所以我只是要复制和粘贴这个

962
01:25:09,680 --> 01:25:14,480
你不必这样做两次，最后一个分号

963
01:25:14,480 --> 01:25:20,080
好吧，守卫格式化程序做它的事情，然后让我们去吧

964
01:25:20,080 --> 01:25:24,879
并创建一个函数，允许我们然后注销用户，因为那是

965
01:25:24,879 --> 01:25:28,720
我们在应用程序的主用户界面中正在做什么

966
01:25:28,720 --> 01:25:32,319
如您在此处的标题中所见，注销它不会返回任何值

967
01:25:32,319 --> 01:25:37,680
只是一个未来的空白，所以我们说未来的空白就像那样注销

968
01:25:37,680 --> 01:25:42,879
好吧，这很简单，而且我们还需要一个函数

969
01:25:42,879 --> 01:25:47,040
可以发送电子邮件验证，所以这个也很简单，它只是一个

970
01:25:47,040 --> 01:25:52,839
未来无效，正如您在标题中看到的那样，我们称之为发送电子邮件

971
01:25:52,839 --> 01:25:57,519
验证没问题所以

972
01:25:57,519 --> 01:26:00,239
怎么样？

973
01:26:00,239 --> 01:26:03,360
正如我提到的，我们目前的办公室供应商是

974
01:26:03,360 --> 01:26:06,839
只是一个抽象类，所以它是

975
01:26:06,839 --> 01:26:11,519
为我们将要使用的任何身份验证提供程序指定一个接口

976
01:26:11,519 --> 01:26:16,400
添加到我们的应用程序中，但只是为了让您知道我们只是

977
01:26:16,400 --> 01:26:20,160
将添加一个电子邮件作者提供商好的

978
01:26:20,160 --> 01:26:23,839
或对不起firebase作者提供者

979
01:26:23,839 --> 01:26:28,720
但是这样通过创建一个以作者提供者为名称的抽象类

980
01:26:28,720 --> 01:26:32,080
然后你创建一个名为 firebase auth provider 的具体类

981
01:26:32,080 --> 01:26:36,559
将来能够扩展此功能并添加越来越多的身份验证提供程序

982
01:26:36,559 --> 01:26:40,955
这将遵循相同的界面，这就是目标

983
01:26:40,955 --> 01:26:46,000
但我们仅在本课程中将使用 firebase auth provider

984
01:26:46,000 --> 01:26:50,720
所以，呃，你知道，正如标题所说，继续创造

985
01:26:50,720 --> 01:26:56,080
在您的服务身份验证文件夹中创建一个名为 firebase 身份验证提供程序的文件

986
01:26:56,080 --> 01:27:00,720
右键单击此处，我​​会说 oops uh 并说新文件我要调用它

987
01:27:00,720 --> 01:27:05,199
firebase off dot provider.net

988
01:27:05,199 --> 01:27:09,360
现在让我们进去说，嗯，我要去看看我的笔记

989
01:27:09,360 --> 01:27:13,436
嗯，就像这样，好吧，所以这会是这样的

990
01:27:13,436 --> 01:27:19,915
本章中最有趣的部分，我们实际上要讲

991
01:27:19,915 --> 01:27:25,199
将 Firebase 身份验证的方式抽象到我们自己的提供者中，所以期待这个

992
01:27:25,199 --> 01:27:29,839
文件大小增加一点我可以看到我的笔记它会去

993
01:27:29,839 --> 01:27:36,000
100 行代码，但这也没关系，我们可以开始使用它

994
01:27:36,000 --> 01:27:39,040
正如你在标题中看到的，我们需要

995
01:27:39,040 --> 01:27:44,639
导入一些文件 auth user auth provider 并关闭我们需要的异常

996
01:27:44,639 --> 01:27:48,559
auth 用户，因为这个对不起实际上让我先

997
01:27:48,559 --> 01:27:52,080
解释为什么我们需要导入身份验证提供程序，因为我们的 firebase 身份验证

998
01:27:52,080 --> 01:27:56,080
provider 将是文件身份验证提供程序的具体实现

999
01:27:56,080 --> 01:27:59,360
或者我们刚刚创建的类身份验证提供程序，这就是原因

1000
01:27:59,360 --> 01:28:02,239
导入操作系统用户导入将是

1001
01:28:02,239 --> 01:28:05,116
因为正如您在身份验证提供程序中看到的那样

1002
01:28:05,116 --> 01:28:09,839
他们需要返回关闭用户的登录和创建用户功能，这就是为什么

1003
01:28:09,839 --> 01:28:13,595
我们需要导入用户，以便我们的提供者可以返回该用户的实例

1004
01:28:13,595 --> 01:28:16,480
好的，最后但并非最不重要的是，我们还需要

1005
01:28:16,480 --> 01:28:20,639
导入身份验证异常，因为请记住我们的 firebase 身份验证提供程序也在进行

1006
01:28:20,639 --> 01:28:23,680
抽象出所有的身份验证

1007
01:28:23,680 --> 01:28:28,080
否则会在 firebase 级别发生的错误和异常进入我们的

1008
01:28:28,080 --> 01:28:33,360
我们在这里创建的自己的例外 好的，让我走吧

1009
01:28:33,360 --> 01:28:38,160
提前并首先导入用户so包

1010
01:28:38,160 --> 01:28:44,319
这个应用程序叫我的笔记，我们有服务认证

1011
01:28:44,319 --> 01:28:49,116
然后我们已经关闭用户了，所以我要导入它

1012
01:28:49,116 --> 01:28:53,436
然后我要复制这个文件，这一行和下一个将是

1013
01:28:53,436 --> 01:28:57,040
关闭提供程序，正如您在我们的捕获中看到的那样

1014
01:28:57,040 --> 01:29:02,160
还必须导入身份验证异常

1015
01:29:02,160 --> 01:29:06,000
所以这是三个进口

1016
01:29:06,000 --> 01:29:09,680
现在因为我们有自己的进口

1017
01:29:09,680 --> 01:29:12,879
这个文件将直接与firebase对话，我们还需要导入

1018
01:29:12,879 --> 01:29:17,360
firebase 当然是这样，让我们​​继续导入

1019
01:29:17,360 --> 01:29:20,879
我将实际复制该代码，因此我不必输入所有代码

1020
01:29:20,879 --> 01:29:23,519
因为它有点无聊，但你可以看到

1021
01:29:23,519 --> 01:29:28,239
在字幕中，至少你需要什么来导入 firebase 并且你需要

1022
01:29:28,239 --> 01:29:32,480
也可以导入 firebase off 异常

1023
01:29:32,480 --> 01:29:36,720
太好了，这就是我们的进口产品

1024
01:29:36,720 --> 01:29:40,720
嗯，现在我们需要做的是创建实际的类和

1025
01:29:40,720 --> 01:29:43,915
嗯，如您所见，它将被称为 firebase all provider 和

1026
01:29:43,915 --> 01:29:48,400
实现身份验证提供程序，这是我们自己的类，所以让我们说 firebase

1027
01:29:48,400 --> 01:29:53,275
auth provider 实现了一个像这样的提供者，好吧，现在

1028
01:29:53,275 --> 01:29:56,480
你可以看到你得到一个错误，同样缺少我的具体实现

1029
01:29:56,480 --> 01:30:01,199
将更改屏幕的布局，以便您看到完整的代码

1030
01:30:01,199 --> 01:30:05,275
然后我们需要做的是实现你看到的那些功能

1031
01:30:05,275 --> 01:30:09,595
验证提供者抽象类的函数和吸气剂

1032
01:30:09,595 --> 01:30:14,239
说实现它的每个类也需要实现这些东西

1033
01:30:14,239 --> 01:30:18,639
所以你可以试着用手做这些事情，但我绝对

1034
01:30:18,639 --> 01:30:24,720
我我我根本不喜欢手工做事抱歉，所以我更喜欢

1035
01:30:24,720 --> 01:30:27,756
得到编辑的帮助来完成这些事情所以我只想说

1036
01:30:27,756 --> 01:30:31,839
命令点并使类firebase关闭抽象

1037
01:30:31,839 --> 01:30:36,639
创建五个缺少的覆盖好的，所以我们开始了，所以 Visual Studio 代码

1038
01:30:36,639 --> 01:30:39,756
在这里创建了所有这些功能，您可以在所有这些功能中看到它只是说

1039
01:30:39,756 --> 01:30:44,080
抛出未实现的错误很棒的东西

1040
01:30:44,080 --> 01:30:48,559
我要在这里减小字体的大小 回到

1041
01:30:48,559 --> 01:30:53,680
与我们之前的布局相同，所以我们需要做的第一件事

1042
01:30:53,680 --> 01:30:59,199
在这里，让我们继续实现这个当前用户好吧

1043
01:30:59,199 --> 01:31:03,680
所以这将有很多而不是很多但它会有一点

1044
01:31:03,680 --> 01:31:07,360
逻辑上的，所以我要这样做而不是用指针

1045
01:31:07,360 --> 01:31:12,559
让我们继续在这里尝试获取该用户，让我们说

1046
01:31:12,559 --> 01:31:17,680
您会看到我们现在的工作是获取 firebase 用户并将其关闭

1047
01:31:17,680 --> 01:31:22,239
用户记得我们的关闭用户有一个工厂构造函数，所以我们需要调用它

1048
01:31:22,239 --> 01:31:28,879
工厂构造函数可以，所以我们只是说最终用户等于 firebase off

1049
01:31:28,879 --> 01:31:32,080
我们的火力基地和身份验证

1050
01:31:32,080 --> 01:31:35,519
实例，然后我们说当前用户

1051
01:31:35,519 --> 01:31:40,319
然后我们说如果用户不为空

1052
01:31:40,319 --> 01:31:45,116
我们需要创建一个它的实例作为关闭用户所以我们只说return

1053
01:31:45,116 --> 01:31:54,319
从firebase用户关闭用户好吧，否则我们像这样返回null

1054
01:31:54,319 --> 01:31:58,319
如果firebase说有一个用户，那么我们会创建一个关闭用户，然后我们

1055
01:31:58,319 --> 01:32:02,559
把它还回去

1056
01:32:02,559 --> 01:32:06,400
好吧，对于当前用户来说，说实话并没有那么多代码

1057
01:32:06,400 --> 01:32:10,400
你现在我们需要做的就是保重

1058
01:32:10,400 --> 01:32:14,239
的创建用户，这是这里的功能

1059
01:32:14,239 --> 01:32:19,275
所以说实话，创建用户会有点厚

1060
01:32:19,275 --> 01:32:24,559
让我们继续，首先在

1061
01:32:24,559 --> 01:32:29,199
在这里，所以我喜欢总是在最后一个末尾附加一个逗号

1062
01:32:29,199 --> 01:32:33,199
我的函数的参数，这样当我做暗格式化程序时

1063
01:32:33,199 --> 01:32:37,839
或 dart 格式，它将把所有这些参数分解成它们自己的参数

1064
01:32:37,839 --> 01:32:41,519
线条还可以，因为在它看起来像这样之前，它在我眼中并不那么干净

1065
01:32:41,519 --> 01:32:44,720
至少这是一个偏好，好吧

1066
01:32:44,720 --> 01:32:50,160
在这里我们需要做的就是创建基本上 uh

1067
01:32:50,160 --> 01:32:55,275
一个有 uh firebase 的用户，所以我要把这整个东西放进去

1068
01:32:55,275 --> 01:33:01,360
在 try 块中，然后我们将捕获 firebase 异常

1069
01:33:01,360 --> 01:33:08,000
并且在 firebase off 异常捕获 e 好

1070
01:33:08,000 --> 01:33:11,519
所以就像那样，然后我们将有一个通用的

1071
01:33:11,519 --> 01:33:17,360
像这样在这里缓存块

1072
01:33:17,360 --> 01:33:21,839
好吧，现在我们需要在三态 main 中创建用户

1073
01:33:21,839 --> 01:33:25,275
声明我们需要实际告诉firebase我们要创建一个新的

1074
01:33:25,275 --> 01:33:30,000
用户所以让我们说firebase关闭

1075
01:33:30,000 --> 01:33:33,839
即时然后我们说用电子邮件和密码创建用户好吧，所以我们有

1076
01:33:33,839 --> 01:33:38,319
在这里发送电子邮件和密码，我们可以看到这些参数已经存在，所以我们

1077
01:33:38,319 --> 01:33:40,559
不必做任何事情

1078
01:33:40,559 --> 01:33:45,199
嗯，但我们需要在这里做的是你可以首先真正看到是的

1079
01:33:45,199 --> 01:33:48,480
函数需要返回一个值，我们会解决这个问题，所以不用担心

1080
01:33:48,480 --> 01:33:52,955
但我们还需要等待，因为请记住创建用户或

1081
01:33:52,955 --> 01:33:56,400
电子邮件密码不是立即返回的功能，这是一个

1082
01:33:56,400 --> 01:33:59,275
飞镖的绝妙之处在于

1083
01:33:59,275 --> 01:34:03,040
接口我们实际上并没有说这个函数必须是异步的，但是你

1084
01:34:03,040 --> 01:34:07,436
可以在这个具体的实现中使这个函数异步所以它是绝对的

1085
01:34:07,436 --> 01:34:11,436
美丽，所以异步不是函数签名的一部分，但它有

1086
01:34:11,436 --> 01:34:14,955
更多地与该函数的内部有关，所以为了调用它

1087
01:34:14,955 --> 01:34:19,199
带有await的函数你看看我们是否在这里放了一个权重我们得到了一个我们需要的错误

1088
01:34:19,199 --> 01:34:25,360
让这个函数异步好极了

1089
01:34:25,360 --> 01:34:30,955
好吧，在这样做之后，我们要做的是获取当前用户

1090
01:34:30,955 --> 01:34:35,839
如果当前用户在那里，那么我们将返回当前用户

1091
01:34:35,839 --> 01:34:40,239
创建用户或电子邮件和密码后的当前用户，没有例外

1092
01:34:40,239 --> 01:34:45,360
不在那里那是一个不好的迹象，我们需要返回我们的身份验证之一

1093
01:34:45,360 --> 01:34:48,879
称为用户未登录的异常关闭异常正常

1094
01:34:48,879 --> 01:34:52,720
所以我要关闭这个所以让我们进去说final

1095
01:34:52,720 --> 01:34:57,595
用户是获取或只是用户是当前用户

1096
01:34:57,595 --> 01:35:01,839
请记住，我们已经在这里为当前用户提供了一个吸气剂

1097
01:35:01,839 --> 01:35:04,639
好的，它只是获取当前用户

1098
01:35:04,639 --> 01:35:10,955
firebase 所以我们说这里是用户，如果用户在那里可用

1099
01:35:10,955 --> 01:35:15,360
不为空，则只返回用户

1100
01:35:15,360 --> 01:35:20,319
否则你应该抛出一个未找到的用户，或者我认为这就是我们所说的

1101
01:35:20,319 --> 01:35:23,756
用户未登录

1102
01:35:23,756 --> 01:35:28,559
身份验证异常正常

1103
01:35:28,559 --> 01:35:32,559
如果除此之外一切正常，那是为了创建用户

1104
01:35:32,559 --> 01:35:36,160
现在部分我们需要去我们的firebase auth

1105
01:35:36,160 --> 01:35:39,680
例外，我们需要处理一些事情

1106
01:35:39,680 --> 01:35:44,879
因此，如果您查看我们的注册视图中的位置

1107
01:35:44,879 --> 01:35:51,040
在这里，我们正在处理已在使用的弱密码电子邮件和无效电子邮件

1108
01:35:51,040 --> 01:35:55,595
所以让我们复制这三件事好吧实际上这四件事因为

1109
01:35:55,595 --> 01:35:59,275
我们那里也有一个 else 块

1110
01:35:59,275 --> 01:36:03,915
所以我要复制那个代码只是做同样的事情请去你的注册表

1111
01:36:03,915 --> 01:36:08,000
并将该代码复制回您的 Firebase 身份验证提供程序

1112
01:36:08,000 --> 01:36:11,756
firebase off 异常，你正在捕捉它

1113
01:36:11,756 --> 01:36:15,915
粘贴该代码，但删除与节目有关的所有内容

1114
01:36:15,915 --> 01:36:21,839
错误对话框没问题，所以至少我们有 if 和 else 语句没问题

1115
01:36:21,839 --> 01:36:26,080
像这样，所以你最终应该得到一个看起来像这样的代码

1116
01:36:26,080 --> 01:36:29,595
现在我们在哪里有一个弱密码

1117
01:36:29,595 --> 01:36:33,275
实际上会抛出我们自己的错误，所以我们会说 throw

1118
01:36:33,275 --> 01:36:38,080
弱密码关闭异常 这是一封已在使用的电子邮件 我们正在

1119
01:36:38,080 --> 01:36:42,000
已经开始发送电子邮件并使用身份验证

1120
01:36:42,000 --> 01:36:47,519
万一无效电子邮件抛出无效电子邮件异常，如果有任何

1121
01:36:47,519 --> 01:36:51,595
我们不知道的其他代码我们只是要抛出一个通用的身份验证

1122
01:36:51,595 --> 01:36:54,559
例外

1123
01:36:54,559 --> 01:36:59,839
并且如果有一个最终的捕获基本上意味着通过调用

1124
01:36:59,839 --> 01:37:03,915
如果有任何其他异常，请为用户创建带有电子邮件和密码的电子邮件

1125
01:37:03,915 --> 01:37:08,400
除了 firebase auth 异常，我们还需要处理它并抛出

1126
01:37:08,400 --> 01:37:13,360
那里也有一个通用的身份验证异常

1127
01:37:13,360 --> 01:37:19,040
很多代码，但希望这使我们的 ui 代码

1128
01:37:19,040 --> 01:37:23,360
更容易阅读好吧，所以我们这样做是为了一个好的目的

1129
01:37:23,360 --> 01:37:25,915
适合我们的好东西

1130
01:37:25,915 --> 01:37:30,720
创建用户我会摔倒创建用户呃如果它允许我折叠整个

1131
01:37:30,720 --> 01:37:35,360
创建用户poof，我也将折叠当前用户，所以这是一个

1132
01:37:35,360 --> 01:37:37,839
你能做或不能做的技术 只是你能做的把戏的技术

1133
01:37:37,839 --> 01:37:41,360
在你的编辑器中，如果它支持折叠和展开只是为了确保它

1134
01:37:41,360 --> 01:37:45,199
看起来更干净一点，因为现在您已经编写了创建用户

1135
01:37:45,199 --> 01:37:49,199
可能对您可能只想知道的所有细节不直接感兴趣

1136
01:37:49,199 --> 01:37:53,275
没关系

1137
01:37:53,275 --> 01:37:57,915
好的，接下来我们需要做的是实现发送电子邮件验证

1138
01:37:57,915 --> 01:38:01,436
所以让我们找到那个功能，我可以看到它就在这里发送电子邮件

1139
01:38:01,436 --> 01:38:04,400
验证我要向上滚动一点，所以你看

1140
01:38:04,400 --> 01:38:09,199
像那样我也会去我的笔记

1141
01:38:09,199 --> 01:38:14,559
所以我们需要做的是激励我们需要的电子邮件验证

1142
01:38:14,559 --> 01:38:18,955
也将其标记为异步，因为它将调用异步

1143
01:38:18,955 --> 01:38:23,116
在 firebase 上运行也可以，我们需要

1144
01:38:23,116 --> 01:38:26,955
在firebase用户上调用发送电子邮件验证功能记住

1145
01:38:26,955 --> 01:38:30,796
我们的用户没有我们的用户只有通过电子邮件验证的功能

1146
01:38:30,796 --> 01:38:36,239
属性所以在这里让我们获取firebase用户所以我要说用户

1147
01:38:36,239 --> 01:38:39,595
火力基地关闭

1148
01:38:39,595 --> 01:38:42,839
实例当前用户，我们说

1149
01:38:42,839 --> 01:38:50,319
如果用户不为空，那么我们调用该函数，所以我们说等待用户发送电子邮件

1150
01:38:50,319 --> 01:38:53,595
验证我记得我认为这是虚空的未来所以这就是为什么我们

1151
01:38:53,595 --> 01:38:58,879
对其进行加权，这就是为什么我们现在在这里有异步标签的原因

1152
01:38:58,879 --> 01:39:04,080
如果用户为零，那么我们只会说用户没有登录，你不能

1153
01:39:04,080 --> 01:39:08,080
向未登录的用户发送电子邮件验证，那么您

1154
01:39:08,080 --> 01:39:12,639
抛出用户未登录异常

1155
01:39:12,639 --> 01:39:17,519
好的，这就是我们的发送电子邮件验证

1156
01:39:17,519 --> 01:39:21,680
函数让我们也折叠这个函数

1157
01:39:21,680 --> 01:39:25,519
正如标题所说，我们看不到它的内部结构，现在我们需要走了

1158
01:39:25,519 --> 01:39:30,480
并实现登录登录与创建用户一样重要

1159
01:39:30,480 --> 01:39:34,480
首先在此处的密码参数和命令 s 的末尾放置一个逗号

1160
01:39:34,480 --> 01:39:38,796
为了保存它并在登录功能中，我们

1161
01:39:38,796 --> 01:39:41,756
将做一些与我们在注册表中所做的非常相似的事情

1162
01:39:41,756 --> 01:39:45,756
我可以通过尝试在笔记中看到的功能

1163
01:39:45,756 --> 01:39:50,319
然后我们在firebase off异常上说

1164
01:39:50,319 --> 01:39:53,360
并抓住 e

1165
01:39:53,360 --> 01:39:55,839
然后我们会说 catch

1166
01:39:55,839 --> 01:40:02,400
任何其他例外都可以，所以让我们进入这里然后从嗯开始

1167
01:40:02,400 --> 01:40:06,839
告诉firebase我们想用这些凭据登录所以让我们说

1168
01:40:06,839 --> 01:40:10,720
firebase auth 实例，然后我们说 uh

1169
01:40:10,720 --> 01:40:15,756
使用电子邮件和密码登录，所以那里有一个功能可以

1170
01:40:15,756 --> 01:40:19,839
我要在最后加一个分号，这样你就可以看到

1171
01:40:19,839 --> 01:40:22,480
代码没问题，这就是我们正在做的，但是

1172
01:40:22,480 --> 01:40:26,720
再次记住这些函数是异步的，所以你不能只调用它

1173
01:40:26,720 --> 01:40:31,199
功能并期望它能够工作 这是用户凭证的未来 好的，所以让

1174
01:40:31,199 --> 01:40:34,839
你的函数是异步的，然后等待这个

1175
01:40:34,839 --> 01:40:39,040
函数，所以我们将做一些与我们正在做的非常相似的事情

1176
01:40:39,040 --> 01:40:43,595
在创建用户中注册抱歉，因为我们说最终用户是

1177
01:40:43,595 --> 01:40:47,756
当前用户，我希望您能看到该代码是的，我可以

1178
01:40:47,756 --> 01:40:54,160
看到你可以在这个呃代码中看到所以我们将采用完全相同的

1179
01:40:54,160 --> 01:40:58,239
我们在 um create user 中编写的代码，所以我要扩展你

1180
01:40:58,239 --> 01:41:02,160
可以看到这里我要复制那个代码，你可以

1181
01:41:02,160 --> 01:41:06,796
做同样的事情我们正在做的只是确保在登录后在那里

1182
01:41:06,796 --> 01:41:12,400
当前用户是否可以复制该代码将折叠此然后我要带

1183
01:41:12,400 --> 01:41:16,480
登录并在使用电子邮件和密码登录后立即粘贴

1184
01:41:16,480 --> 01:41:20,080
那个代码没问题，所以这就是现在的那部分

1185
01:41:20,080 --> 01:41:24,080
您现在看到我们再次使用firebase auhexception来处理

1186
01:41:24,080 --> 01:41:29,595
我们做了创建所以让我们去你的登录视图

1187
01:41:29,595 --> 01:41:34,879
看看我们正在处理哪些异常以及哪些异常

1188
01:41:34,879 --> 01:41:39,595
我可以在这里看到我们正在处理这些我实际上要复制整个

1189
01:41:39,595 --> 01:41:44,160
登录视图中的代码您会看到 firebase off 异常用户名错误密码

1190
01:41:44,160 --> 01:41:49,680
等等，包括捕获任何其他异常块在这里复制

1191
01:41:49,680 --> 01:41:54,796
代码并将其带到您的 Firebase 身份验证提供商

1192
01:41:54,796 --> 01:41:57,756
并替换让我实际看看它的外观

1193
01:41:57,756 --> 01:42:02,559
是的

1194
01:42:02,559 --> 01:42:07,595
然后像我们以前一样卸下你的重量，老实说这个这个

1195
01:42:07,595 --> 01:42:10,955
只是说我们大谈特谈

1196
01:42:10,955 --> 01:42:14,639
嗯需要一些来自另一个地方的代码

1197
01:42:14,639 --> 01:42:18,796
带到这里，这样你的代码现在应该看起来像这样，所以它说 on firebase off

1198
01:42:18,796 --> 01:42:22,720
异常，我们正在处理用户未找到错误密码关闭异常

1199
01:42:22,720 --> 01:42:30,000
firebase 和一个通用的 catch 块没关系，所以在用户找不到的情况下

1200
01:42:30,000 --> 01:42:35,116
firebase office 会话我们要说 throw user not found alt 异常

1201
01:42:35,116 --> 01:42:38,796
在密码错误的情况下，我们会说 throw on password boss

1202
01:42:38,796 --> 01:42:42,000
异常和此处可能发生的任何其他情况

1203
01:42:42,000 --> 01:42:45,756
我们只是要抛出通用异常

1204
01:42:45,756 --> 01:42:50,559
在这里我们也会说 throw generic with exception

1205
01:42:50,559 --> 01:42:54,000
我真正喜欢做的是你看到

1206
01:42:54,000 --> 01:42:58,319
dart 在这种情况下还不能说我想忽略一个变量

1207
01:42:58,319 --> 01:43:01,915
你可以看到，在这个我们有一个问题的地方

1208
01:43:01,915 --> 01:43:05,839
我们实际上必须针对异常进行模式匹配，然后我们必须

1209
01:43:05,839 --> 01:43:09,519
为其分配一个名称，该名称在此函数中称为 e 所以如果我

1210
01:43:09,519 --> 01:43:13,040
键入 e，您可以看到它是一个对象，但是正如您在

1211
01:43:13,040 --> 01:43:16,160
这个函数我们实际上对 e 并不感兴趣，我们根本没有使用

1212
01:43:16,160 --> 01:43:20,480
所以在其他语言中可以像在javascript中一样忽略

1213
01:43:20,480 --> 01:43:25,756
python swift rust 可以忽略一个变量并说嘿

1214
01:43:25,756 --> 01:43:28,796
我对这个值不感兴趣，把一个叫做

1215
01:43:28,796 --> 01:43:33,040
下划线或您可以在艺术中做同样的事情的不同之处在于

1216
01:43:33,040 --> 01:43:36,796
在飞镖中，如果你说下划线，你实际上并没有忽略它，变量是

1217
01:43:36,796 --> 01:43:40,955
也在那里，但在这种情况下它只是称为下划线，所以你可以看到

1218
01:43:40,955 --> 01:43:45,915
你仍然可以在上面调用字符串，所以你可能想要这样做，或者你可能只是

1219
01:43:45,915 --> 01:43:49,275
不想管它，因为你可以看到它不给的分析器

1220
01:43:49,275 --> 01:43:53,275
你说是的，你的任何错误

1221
01:43:53,275 --> 01:43:57,199
模式匹配，但你没有使用它，所以这取决于你想怎么做

1222
01:43:57,199 --> 01:44:01,040
我喜欢这样做

1223
01:44:01,040 --> 01:44:05,199
哇，那是很多代码，或者更像是很多解释，所以让我们

1224
01:44:05,199 --> 01:44:08,796
去登录并折叠它，正如你在标题中看到的那样，现在我们必须采取

1225
01:44:08,796 --> 01:44:12,160
照顾注销功能和标题也说这个功能

1226
01:44:12,160 --> 01:44:16,559
需要是异步的，你知道为什么，因为我们要

1227
01:44:16,559 --> 01:44:22,796
在firebase上调用一个函数以处理注销

1228
01:44:22,796 --> 01:44:26,639
所以为了让用户被注销，用户应该实际存在所以让我们

1229
01:44:26,639 --> 01:44:31,116
只是说最终用户需要关闭firebase

1230
01:44:31,116 --> 01:44:34,559
实例，然后我们将说当前用户

1231
01:44:34,559 --> 01:44:40,879
我们说如果用户不为空并且它是用户登录呃注销它是什么

1232
01:44:40,879 --> 01:44:45,436
叫什么或者叫什么哦，我们必须告诉火力基地，所以我们

1233
01:44:45,436 --> 01:44:50,879
然后我们说firebase关闭实例注销

1234
01:44:50,879 --> 01:44:57,040
重量还可以，否则我们说不要扔用户

1235
01:44:57,040 --> 01:45:00,400
登录所以我们基本上在这里说你

1236
01:45:00,400 --> 01:45:04,480
如果该用户不存在或该用户不存在，则无法注销该用户

1237
01:45:04,480 --> 01:45:07,360
登录

1238
01:45:07,360 --> 01:45:11,040
好的很多代码很多描述但是

1239
01:45:11,040 --> 01:45:16,796
没关系，我们现在已经实现了一个 auth provider firebase auth provider

1240
01:45:16,796 --> 01:45:19,756
好的，这是一个具体的实现

1241
01:45:19,756 --> 01:45:24,480
auth provider now 正如标题所示，我们在这里

1242
01:45:24,480 --> 01:45:28,839
需要身份验证服务

1243
01:45:28,839 --> 01:45:33,116
嗯，现在什么是身份验证服务，我之前提到过一点，但是

1244
01:45:33,116 --> 01:45:38,239
身份验证服务也将实施身份验证提供程序

1245
01:45:38,239 --> 01:45:42,239
本身就是一个例子

1246
01:45:42,239 --> 01:45:47,519
身份验证提供程序也是如此，但正如您将在本章和

1247
01:45:47,519 --> 01:45:52,559
这个嗯课程的其余部分你会看到我们的

1248
01:45:52,559 --> 01:45:58,559
我们的身份验证服务实际上只是提供者本身，它是

1249
01:45:58,559 --> 01:46:02,639
暴露我们提供给它的提供者的所有功能

1250
01:46:02,639 --> 01:46:07,595
它不是，它目前绝对没有其他逻辑可以，但是

1251
01:46:07,595 --> 01:46:12,239
我们这样做的原因是为了让我告诉你你需要拥有

1252
01:46:12,239 --> 01:46:15,595
提供者，然后你需要有他们相互交谈的服务

1253
01:46:15,595 --> 01:46:20,480
然后此服务可以向您的用户界面展示更多价值

1254
01:46:20,480 --> 01:46:26,000
您的 ui 代码比提供者所做的通常是服务的情况

1255
01:46:26,000 --> 01:46:30,000
将其他一些供应商融合在一起 与少数人交谈

1256
01:46:30,000 --> 01:46:34,400
提供者，最后它将数据融合在一起并提供

1257
01:46:34,400 --> 01:46:40,160
在我们的情况下，现在向 ui 提供信息，但情况并非如此，好吧，我们的

1258
01:46:40,160 --> 01:46:46,319
firebit 我们的身份验证服务只会与我们给定的身份验证提供者交谈

1259
01:46:46,319 --> 01:46:50,796
并将其所有功能暴露给 ui，但我们正在做这个练习

1260
01:46:50,796 --> 01:46:55,595
你看到了如何抽象出各种功能的点点滴滴

1261
01:46:55,595 --> 01:47:00,480
从 ui 代码中，请记住这就是我们拥有身份验证服务的原因

1262
01:47:00,480 --> 01:47:06,080
我们很快就会创建好的，所以在这里的案例中作为标题让我们

1263
01:47:06,080 --> 01:47:10,720
继续在此处的 auth 文件夹中创建我们的奇怪服务，以便 auth 和

1264
01:47:10,720 --> 01:47:16,639
我要在这里创建一个新文件我只是将其称为所有服务

1265
01:47:16,639 --> 01:47:22,000
在这个 dart 文件中，我们需要创建开始创建我们的

1266
01:47:22,000 --> 01:47:26,400
auth service 好吧，对不起，我会在这里做笔记

1267
01:47:26,400 --> 01:47:30,559
那么我们在这里需要的是

1268
01:47:30,559 --> 01:47:34,720
导入一些我们需要导入我们的身份验证提供程序和关闭用户的东西，所以我

1269
01:47:34,720 --> 01:47:39,116
不再解释这个所以嗯打包我的笔记

1270
01:47:39,116 --> 01:47:44,000
我们有服务关闭，我们有，我们需要导入身份验证

1271
01:47:44,000 --> 01:47:47,680
提供者并复制这种代码，然后我

1272
01:47:47,680 --> 01:47:52,160
我相信要说新闻用户

1273
01:47:52,160 --> 01:47:54,955
所以嗯

1274
01:47:54,955 --> 01:48:00,160
所以让我们看看这里的字幕

1275
01:48:00,160 --> 01:48:03,680
像这样好的，所以我们现在需要尽可能地创建

1276
01:48:03,680 --> 01:48:09,360
看到我们需要创建一个也实现身份验证提供程序的身份验证服务好吧

1277
01:48:09,360 --> 01:48:11,275
所以嗯

1278
01:48:11,275 --> 01:48:14,559
如果我在这里查看标题，为什么身份验证服务是我提供的作者提供者

1279
01:48:14,559 --> 01:48:19,116
已经向您解释了这一点，但您可以看到它说但可以有更多逻辑

1280
01:48:19,116 --> 01:48:23,199
所以这就是原因，好吧，所以不要忘记，所以让我们去创建一个

1281
01:48:23,199 --> 01:48:28,955
此处所有服务的类，它实现了身份验证

1282
01:48:28,955 --> 01:48:33,680
提供者嗯抽象类好

1283
01:48:33,680 --> 01:48:37,595
现在你需要做的是你需要知道的是身份验证服务

1284
01:48:37,595 --> 01:48:42,080
本身不会被硬编码以使用 firebase auth 提供程序

1285
01:48:42,080 --> 01:48:46,160
它要做的是实际上从

1286
01:48:46,160 --> 01:48:48,879
你说好吧，我会暴露

1287
01:48:48,879 --> 01:48:52,160
从该身份验证提供程序到外部世界的功能

1288
01:48:52,160 --> 01:48:55,839
甚至可能在将数据返回给您之前更改该数据的能力，但在我们的

1289
01:48:55,839 --> 01:48:58,879
章，然后是本课程的其余部分

1290
01:48:58,879 --> 01:49:02,559
将向外界公开相同的身份验证提供程序功能，所以

1291
01:49:02,559 --> 01:49:08,080
让我们继续吧，正如标题所说，我们需要一个身份验证提供程序，我们只是

1292
01:49:08,080 --> 01:49:13,275
称它为提供者好吧，我们需要做的就是创建一个

1293
01:49:13,275 --> 01:49:17,360
此处为您的身份验证服务的构造函数，因此命令

1294
01:49:17,360 --> 01:49:21,360
点在 mac 或控制点 windows 和 linux 并说创建构造函数

1295
01:49:21,360 --> 01:49:24,080
final 字段并使其保持不变

1296
01:49:24,080 --> 01:49:28,955
好的，所以现在我们有了这个漂亮的小服务，它需要

1297
01:49:28,955 --> 01:49:32,480
提供者，但正如您所看到的，它说缺少具体的实现和

1298
01:49:32,480 --> 01:49:37,595
那是因为我们说我们的身份验证服务也是身份验证提供者，所以我们必须

1299
01:49:37,595 --> 01:49:43,680
实现这些身份验证提供程序类覆盖，所以让我们添加它们

1300
01:49:43,680 --> 01:49:48,319
也在这里，但是这次实现这些会容易得多

1301
01:49:48,319 --> 01:49:52,879
功能是因为我们的身份验证服务内部有一个提供者和

1302
01:49:52,879 --> 01:49:56,720
它所要做的就是公开

1303
01:49:56,720 --> 01:50:01,360
提供者在自己的实现中可以

1304
01:50:01,360 --> 01:50:03,436
所以嗯

1305
01:50:03,436 --> 01:50:06,879
正如标题还说我们需要委托给我们的

1306
01:50:06,879 --> 01:50:10,160
在我们这样做之前，我会做一个实际的提供者

1307
01:50:10,160 --> 01:50:13,436
在这里稍微清理一下，我建议你在某些地方也这样做

1308
01:50:13,436 --> 01:50:16,480
我们有多个参数让我们在末尾加一个逗号

1309
01:50:16,480 --> 01:50:20,559
最后一个参数在这里和那里繁荣

1310
01:50:20,559 --> 01:50:23,756
这就是我要做的命令

1311
01:50:23,756 --> 01:50:26,879
dart 格式化程序更好地格式化代码

1312
01:50:26,879 --> 01:50:31,275
让我们继续前进并公开我们的功能

1313
01:50:31,275 --> 01:50:36,319
提供者在我们的身份验证的具体实现中

1314
01:50:36,319 --> 01:50:44,080
提供者所以在这里我们说提供者点创建用户电子邮件和密码完美

1315
01:50:44,080 --> 01:50:50,480
对于当前用户，我们返回提供者的当前用户，我们说提供者

1316
01:50:50,480 --> 01:50:56,080
采用当前用户登录，然后公开

1317
01:50:56,080 --> 01:51:01,756
提供者登录功能我们说提供者使用该信息登录

1318
01:51:01,756 --> 01:51:08,480
对于我们的注销我们做同样的事情所以我会说供应商注销好吧

1319
01:51:08,480 --> 01:51:14,319
并且为了发送你，所以说提供商发送电子邮件

1320
01:51:14,319 --> 01:51:19,839
提供者和通知很棒的东西

1321
01:51:19,839 --> 01:51:25,040
如您所见，进展非常快

1322
01:51:25,040 --> 01:51:27,275
现在嗯

1323
01:51:27,275 --> 01:51:32,559
你看我们现在已经做了很多代码如果我们去如果我改变屏幕

1324
01:51:32,559 --> 01:51:36,639
布局稍微好一点，这样你就能更好地看到代码，然后我们开始吧

1325
01:51:36,639 --> 01:51:40,480
到我们的终端内置终端我绝对喜欢它在 Visual Studio 代码中

1326
01:51:40,480 --> 01:51:45,756
有一个集成终端，让我们看看我们的 git 状态

1327
01:51:45,756 --> 01:51:50,796
您会看到我们更改了登录视图，但也有一个全新的

1328
01:51:50,796 --> 01:51:56,400
此处的文件夹称为 lib 服务，因此如果您随后添加所有这些

1329
01:51:56,400 --> 01:52:01,839
并且要获得状态，您会看到我们实际上已经做了很多工作，所以

1330
01:52:01,839 --> 01:52:05,360
如果我增加你看到的大小，我们已经添加了所有异常身份验证提供程序

1331
01:52:05,360 --> 01:52:08,720
服务身份验证用户和 Firebase 身份验证提供者

1332
01:52:08,720 --> 01:52:13,199
加上现在登录视图中的更改

1333
01:52:13,199 --> 01:52:16,480
嗯实际上我不知道我们在登录视图中改变了什么

1334
01:52:16,480 --> 01:52:18,955
所以很有趣知道你是否去

1335
01:52:18,955 --> 01:52:22,400
登录视图我们做了什么我们在登录视图中改变了任何东西

1336
01:52:22,400 --> 01:52:26,639
因为此刻我真的不记得我们是否改变了什么特别的东西

1337
01:52:26,639 --> 01:52:31,839
在登录视图中，因此实际上会很有趣

1338
01:52:31,839 --> 01:52:35,519
看看我们做了什么，所以如果我在这里去我的终端

1339
01:52:35,519 --> 01:52:38,080
如果我发出这个命令，你可以看到

1340
01:52:38,080 --> 01:52:43,360
在这里，我将从登台环境中删除该登录视图

1341
01:52:43,360 --> 01:52:47,519
所以像这样粘贴在那里

1342
01:52:47,519 --> 01:52:52,080
我会说 git status 然后我会说 bit diff 我可以说好的

1343
01:52:52,080 --> 01:52:58,080
不同的是我在这里添加了firebase核心

1344
01:52:58,080 --> 01:53:02,480
我在

1345
01:53:02,480 --> 01:53:07,839
登录视图以及更改的内容

1346
01:53:07,839 --> 01:53:12,400
此导航器是否已被删除

1347
01:53:12,400 --> 01:53:16,080
这里有很多代码可能还没有从

1348
01:53:16,080 --> 01:53:20,000
上一章可能是这样，所以这可能是原因，但仅此而已

1349
01:53:20,000 --> 01:53:25,680
好吧，现在让我们开始吧，然后让我们进入下一个阶段

1350
01:53:25,680 --> 01:53:28,955
你可以看到我们已经做了很多工作让我们确保一切正常

1351
01:53:28,955 --> 01:53:32,796
这次提交好了，所以获取状态所有内容都添加到暂存中

1352
01:53:32,796 --> 01:53:37,199
环境那么我只会说 git commit

1353
01:53:37,199 --> 01:53:43,680
这次是消息和第八步，我将推动所有这些更改

1354
01:53:43,680 --> 01:53:46,720
并获得状态，我可以看到一切都很好

1355
01:53:46,720 --> 01:53:51,680
也让我们标记我们的代码，因为我相信前面的

1356
01:53:51,680 --> 01:53:55,680
章节我们没有标记任何东西，除了之前我们标记了那一步

1357
01:53:55,680 --> 01:54:00,160
七，那是第 22 章，我们在其中讨论了错误处理

1358
01:54:00,160 --> 01:54:03,756
注册表并在注册后进入下一个屏幕，所以我们没有

1359
01:54:03,756 --> 01:54:08,080
标记上一章中的任何内容，所以现在我们将标记内容作为第 8 步

1360
01:54:08,080 --> 01:54:13,756
所以让我们说 git tag step 8 我可以在这里拼写

1361
01:54:13,756 --> 01:54:18,796
如果你可以说 git log ，它也会推送标签，你会看到 get

1362
01:54:18,796 --> 01:54:23,040
第 8 步在那里 第 7 步每一步都有初始提交

1363
01:54:23,040 --> 01:54:27,680
这是第一步，如果你说 git tag 你会看到所有可用的标签

1364
01:54:27,680 --> 01:54:32,080
好吧，所以我们已经承诺并标记了我们已经完成了

1365
01:54:32,080 --> 01:54:35,680
本章有很多工作，我认为我们不需要把它拖下去

1366
01:54:35,680 --> 01:54:40,160
更长，因为是的，如果太长，可能会难以忍受

1367
01:54:40,160 --> 01:54:43,275
现在就像我们通常做的那样，这是传统

1368
01:54:43,275 --> 01:54:47,756
在进入下一章之前，我们为即将到来的事情做好准备

1369
01:54:47,756 --> 01:54:51,275
您可以在缓存中看到我们需要将现有代码迁移到使用

1370
01:54:51,275 --> 01:54:55,519
我们自己的身份验证服务 我们有身份验证服务

1371
01:54:55,519 --> 01:55:00,319
它抽象了提供者，我们有一个 firebase auth 提供者，但我们

1372
01:55:00,319 --> 01:55:04,796
仍然没有使用该代码，所以这正是我们将在

1373
01:55:04,796 --> 01:55:10,160
下一章，如果我在我的笔记中稍微看一下，我实际上可以看到

1374
01:55:10,160 --> 01:55:15,275
下一章也会很长，可能没有这一章那么长

1375
01:55:15,275 --> 01:55:18,559
也许你需要一杯咖啡或茶，所以

1376
01:55:18,559 --> 01:55:22,639
让我们这样做，事不宜迟，我们下一章见

1377
01:55:22,639 --> 01:55:26,480
大家好，欢迎来到 Flutter 课程的第 25 章

1378
01:55:26,480 --> 01:55:30,000
在上一章中，我们谈到了地球服务，这是一个相当大的

1379
01:55:30,000 --> 01:55:35,275
章节我们谈到清理确保我们的身份验证

1380
01:55:35,275 --> 01:55:40,080
相关代码位于我们创建身份验证的一个中心位置

1381
01:55:40,080 --> 01:55:43,756
provider firebase auth provider 然后我们创建

1382
01:55:43,756 --> 01:55:49,199
我们的身份验证服务，我们还确保

1383
01:55:49,199 --> 01:55:54,879
服务和提供者都符合提供的接口

1384
01:55:54,879 --> 01:56:01,756
我们用于身份验证的抽象类，所以我们称它们为关闭服务和

1385
01:56:01,756 --> 01:56:07,595
firebase 身份验证提供程序，然后我们的抽象类被称为身份验证提供程序

1386
01:56:07,595 --> 01:56:11,915
现在我们已经完成了所有这些工作，但我们还没有真正开始使用它

1387
01:56:11,915 --> 01:56:18,400
auth 服务，这就是我们在本章中要做的

1388
01:56:18,400 --> 01:56:21,595
嗯，我们要做的第一件事是

1389
01:56:21,595 --> 01:56:24,639
实际上确保我们可以轻松访问

1390
01:56:24,639 --> 01:56:28,559
我们的服务，嗯，你看到我们创建身份验证的方式

1391
01:56:28,559 --> 01:56:35,839
服务让我把代码带到这里，这样我们都可以看到

1392
01:56:35,839 --> 01:56:42,000
改变视觉工作室代码嗯布局一点点

1393
01:56:42,000 --> 01:56:46,639
然后让我们看看我们的 um 让我看看我是否可以调整它的大小

1394
01:56:46,639 --> 01:56:52,000
好吧，让我们在这里看看我们的身份验证服务，您可以通过这种方式看到

1395
01:56:52,000 --> 01:56:56,239
我们创建我们的关闭服务是它在它的初始化程序或构造函数中

1396
01:56:56,239 --> 01:57:01,756
但是你想称之为嗯它需要一个提供者所以我们能够

1397
01:57:01,756 --> 01:57:06,080
每次您想使用我们的身份验证服务时，我们实际上都会使用我们的身份验证服务

1398
01:57:06,080 --> 01:57:09,595
必须为它提供一个身份验证提供程序，在我们的例子中将是

1399
01:57:09,595 --> 01:57:13,680
它驻留在此处的firebase身份验证提供程序

1400
01:57:13,680 --> 01:57:17,116
所以这可能很麻烦，特别是如果你正在使用 firebase

1401
01:57:17,116 --> 01:57:21,680
每次你想使用它时，你的用户界面中都有很多，那么你需要说

1402
01:57:21,680 --> 01:57:25,680
auth service 初始化 auth 服务，然后初始化你的 firebase auth

1403
01:57:25,680 --> 01:57:30,239
提供者并将其提供给您的身份验证服务，以便

1404
01:57:30,239 --> 01:57:35,436
我们不想每次都这样做，这正是我们需要这样做的原因

1405
01:57:35,436 --> 01:57:40,239
开个工厂呃

1406
01:57:40,239 --> 01:57:44,319
初始化器，您可以在 uh 中看到

1407
01:57:44,319 --> 01:57:47,915
在字幕中，嗯，它说添加firebase

1408
01:57:47,915 --> 01:57:52,239
工厂到官员，这正是我们要在这里做的

1409
01:57:52,239 --> 01:57:56,955
所以让我们去我们的身份验证服务，因为代码是为您提供的，只需编写

1410
01:57:56,955 --> 01:57:59,595
它工厂，我要说 auth

1411
01:57:59,595 --> 01:58:04,400
firebase 中的服务点，因此负责

1412
01:58:04,400 --> 01:58:09,360
这个关闭服务的firebase工厂在这里或抱歉的责任

1413
01:58:09,360 --> 01:58:13,595
firebase 呃工厂在这里

1414
01:58:13,595 --> 01:58:17,915
在我们的关闭服务上是返回我们的身份验证服务的一个实例，它是

1415
01:58:17,915 --> 01:58:23,116
已经配置了 Firebase 身份验证提供程序，所以

1416
01:58:23,116 --> 01:58:27,595
然后我们会说它返回一个身份验证服务的实例

1417
01:58:27,595 --> 01:58:32,160
在屏幕上更改代码的布局，以便您可以更好地看到它

1418
01:58:32,160 --> 01:58:35,595
我们会说 firebase 嗯

1419
01:58:35,595 --> 01:58:42,879
auth provider 好的，那就是这样，嗯，现在你看到我有一个

1420
01:58:42,879 --> 01:58:45,680
Visual Studio 代码中的列，它告诉我代码的去向

1421
01:58:45,680 --> 01:58:51,116
甚至在他们的 uh dart 代码或颤振代码中破坏一些人

1422
01:58:51,116 --> 01:58:55,595
他们更喜欢在它的末尾加上一个逗号，以便它准备好接受新的

1423
01:58:55,595 --> 01:58:59,040
未来的参数，所以如果你这样做，那么嗯

1424
01:58:59,040 --> 01:59:02,796
dart 格式将把你的代码分解成多行准备好

1425
01:59:02,796 --> 01:59:06,319
如果这是您的偏好，您可以输入下一个参数，但我

1426
01:59:06,319 --> 01:59:09,756
在这里没有偏好，当我有一个参数时，我就这样离开

1427
01:59:09,756 --> 01:59:14,239
把它放在一行就可以了

1428
01:59:14,239 --> 01:59:20,559
在我们真正开始使用我们的身份验证服务之前，我们需要采取

1429
01:59:20,559 --> 01:59:25,275
回到主 dart 文件，如标题所示，所以你

1430
01:59:25,275 --> 01:59:29,436
要么去资源管理器，但我通常喜欢这样做的方式是使用命令 p

1431
01:59:29,436 --> 01:59:34,080
我说主要飞镖然后我去那里记住你是linux还是windows

1432
01:59:34,080 --> 01:59:38,559
那么你必须控制 p 好，所以让我们看看我们的主要 dar 文件

1433
01:59:38,559 --> 01:59:43,839
让我们看看我是否可以关闭这些地方 firebase off firebase provider

1434
01:59:43,839 --> 01:59:48,080
登录飞镖我们在那里改变了什么保存为

1435
01:59:48,080 --> 01:59:51,839
好吧，让我们现在回到主要内容，所以基本上我只是关闭了所有文件

1436
01:59:51,839 --> 01:59:55,839
呃，因为我只想把它们放在我们的文件中，所以标题是

1437
01:59:55,839 --> 02:00:02,160
在这里告诉你我们的菜单操作和注释视图现在已经展开

1438
02:00:02,160 --> 02:00:07,116
就在主 dart 文件中，这通常不是一个好主意，因为

1439
02:00:07,116 --> 02:00:10,160
您需要成为您需要的软件开发人员的一部分

1440
02:00:10,160 --> 02:00:15,360
确保您的代码是干净的，并且现在其他人很容易阅读

1441
02:00:15,360 --> 02:00:20,400
我不是说我的意思是我不是一个真正相信代码必须如此的人

1442
02:00:20,400 --> 02:00:23,680
很容易理解，即使你从街上随便抓一个人，他们

1443
02:00:23,680 --> 02:00:27,680
必须理解代码，因为有时您需要确保

1444
02:00:27,680 --> 02:00:32,239
查看您的代码的人具有一定的知识水平

1445
02:00:32,239 --> 02:00:35,680
但是话虽如此，您需要确保您的代码易于

1446
02:00:35,680 --> 02:00:40,000
理解并阅读，让我们确保菜单操作和

1447
02:00:40,000 --> 02:00:45,275
笔记视图被重构并且它们在正确的位置，而不仅仅是

1448
02:00:45,275 --> 02:00:50,480
在主 dart 文件中传播，以便标题表明我们要

1449
02:00:50,480 --> 02:00:56,319
将我们的菜单操作移动到 lib 中名为 enums 的新文件夹中

1450
02:00:56,319 --> 02:01:00,720
并且文件名将是菜单操作点 dart 和

1451
02:01:00,720 --> 02:01:04,639
标题有点不对，它不应该是黑暗的 10 它应该是飞镖

1452
02:01:04,639 --> 02:01:10,720
所以我要保存标题并将其重新显示出来，以便正确显示

1453
02:01:10,720 --> 02:01:16,239
文件扩展名，所以让我们去创建那个文件吧

1454
02:01:16,239 --> 02:01:21,199
我要在这里进入 lib 我要右键单击 lib 我要说新文件

1455
02:01:21,199 --> 02:01:24,720
在新文件中，我将输入 ins

1456
02:01:24,720 --> 02:01:28,480
并把它也提出来，让你看得更清楚

1457
02:01:28,480 --> 02:01:33,756
或者您在所有枚举中看到它，然后在菜单操作中看到它。好的

1458
02:01:33,756 --> 02:01:37,199
对不起，让我们去抓住那个菜单动作

1459
02:01:37,199 --> 02:01:42,400
从那里将其粘贴到此菜单操作中并保存该文件，好吧，不要

1460
02:01:42,400 --> 02:01:45,680
担心 main.dart 目前有问题，因为菜单操作没有

1461
02:01:45,680 --> 02:01:48,879
这里不再存在了，所以我们遇到了一些错误，没关系，我们要修复

1462
02:01:48,879 --> 02:01:54,319
那让我们现在去我们的嗯

1463
02:01:54,319 --> 02:01:59,360
再次到主暗文件，我们必须清理此注释视图，并作为

1464
02:01:59,360 --> 02:02:01,756
标题在我们要将其移入的情况下

1465
02:02:01,756 --> 02:02:06,639
lib views notes view 好的，我们已经有了可以记住的 views 文件夹

1466
02:02:06,639 --> 02:02:11,040
在我们要做的只是将此注释视图移动到它自己的文件之前

1467
02:02:11,040 --> 02:02:14,239
所以我要右键单击视图，我要说

1468
02:02:14,239 --> 02:02:18,796
笔记查看点飞镖

1469
02:02:18,796 --> 02:02:24,400
好吧，让我们去主守卫抓住笔记视图和它的状态，从那里开始

1470
02:02:24,400 --> 02:02:28,000
笔记查看有状态的小部件，我将抓住所有这些

1471
02:02:28,000 --> 02:02:31,436
我们甚至会

1472
02:02:31,436 --> 02:02:37,595
带上显示注销对话框并带上它

1473
02:02:37,595 --> 02:02:42,639
记下 2 并粘贴到那里，好吧，所以现在我们有很多问题，因为呃

1474
02:02:42,639 --> 02:02:48,160
正如我之前提到的那样，在一个空的飞镖文件中没有材料导入，所以我

1475
02:02:48,160 --> 02:02:52,639
现在要进行材料导入所以命令点并说导入库

1476
02:02:52,639 --> 02:02:56,239
包装花卉材料，这将解决那些进口问题

1477
02:02:56,239 --> 02:03:00,796
现在给你的那些错误这个文件没有它没有

1478
02:03:00,796 --> 02:03:04,796
导入了 uh 菜单操作，所以让我们也修复它

1479
02:03:04,796 --> 02:03:08,400
使用 Visual Studio 命令点并从 Visual Studio 代码中获得帮助

1480
02:03:08,400 --> 02:03:14,559
自动导入我们的菜单动作 dart 文件好吗

1481
02:03:14,559 --> 02:03:21,519
所以这也是固定的，现在在笔记视图中也记得现在也是

1482
02:03:21,519 --> 02:03:25,360
关闭firebase，我们将在本章中修复一些人，以便

1483
02:03:25,360 --> 02:03:29,519
note2 不是或我们的任何观点，他们都不会直接与之交谈

1484
02:03:29,519 --> 02:03:32,796
firebase 所以这将在本章结束时修复

1485
02:03:32,796 --> 02:03:36,955
但是现在让我们继续清理它并确保firebase auth

1486
02:03:36,955 --> 02:03:43,116
被导入并且还记得当我们注销时这里使用了登录路由

1487
02:03:43,116 --> 02:03:48,720
应用程序的主界面，因此当我们注销时，它会将我们发送回

1488
02:03:48,720 --> 02:03:53,040
登录路线，在我们的路线中定义

1489
02:03:53,040 --> 02:03:58,639
dart 文件在这里，所以让我们也导入它，对不起

1490
02:03:58,639 --> 02:04:02,639
好的，我们已经做了很多工作，我们现在已经完成了，所以我们完成了

1491
02:04:02,639 --> 02:04:07,116
所以我要保存这个notes view dot dart

1492
02:04:07,116 --> 02:04:09,915
现在我们需要回去

1493
02:04:09,915 --> 02:04:14,239
到主要飞镖并解决我们需要导入的这个问题

1494
02:04:14,239 --> 02:04:18,720
笔记视图呃从视觉工作室代码或你最喜欢的编辑器或

1495
02:04:18,720 --> 02:04:22,639
如果您的编辑器中没有此功能 如果您正在使用 vim 或

1496
02:04:22,639 --> 02:04:25,839
您可能只需要手动导入一些东西，而导入只是

1497
02:04:25,839 --> 02:04:31,436
您的应用程序视图的包名称注释视图好的，所以我要

1498
02:04:31,436 --> 02:04:34,160
从视觉工作室代码获得帮助来做到这一点

1499
02:04:34,160 --> 02:04:36,639
伟大的

1500
02:04:36,639 --> 02:04:39,680
所以嗯

1501
02:04:39,680 --> 02:04:43,199
现在让我们来看看我们之前实际上忘记的东西

1502
02:04:43,199 --> 02:04:46,879
章节嗯，你看，我们已经完成了我们的所有内容

1503
02:04:46,879 --> 02:04:51,275
关闭服务，如果您查看我们的身份验证服务，它几乎拥有所有

1504
02:04:51,275 --> 02:04:55,360
我们需要它的功能创建视图抱歉创建用户它有

1505
02:04:55,360 --> 02:04:59,915
当前用户已登录注销并发送电子邮件验证，但有一个

1506
02:04:59,915 --> 02:05:04,955
我们忘记的细节让我们去主要飞镖看看

1507
02:05:04,955 --> 02:05:09,839
你可以在这里看到我们的整个主要飞镖

1508
02:05:09,839 --> 02:05:15,436
就像主页构建功能是围绕我的未来构建器构建的

1509
02:05:15,436 --> 02:05:19,436
知道我说的是建立了很多也许我应该说它是旋转的 它正在旋转

1510
02:05:19,436 --> 02:05:24,480
围绕一个未来的构建器，它反过来初始化你看到它调用的firebase

1511
02:05:24,480 --> 02:05:29,519
firebase 初始化应用程序，现在我们想要远离我们的用户

1512
02:05:29,519 --> 02:05:33,275
直接与firebase交互的界面我们

1513
02:05:33,275 --> 02:05:37,915
还需要解决这个不应该去的用户界面

1514
02:05:37,915 --> 02:05:42,796
直接火力基地，理想情况下应该去我们的

1515
02:05:42,796 --> 02:05:47,436
停止服务，这就是标题所说的

1516
02:05:47,436 --> 02:05:55,040
所以现在让我们转到我们的身份验证提供者抽象类，让我们

1517
02:05:55,040 --> 02:05:58,000
关闭所有这些文件确保所有内容都已保存

1518
02:05:58,000 --> 02:06:02,559
让我们去我们的关闭供应商，并确保我们有一个功能

1519
02:06:02,559 --> 02:06:07,199
在那里，让我真正拿出我的笔记

1520
02:06:07,199 --> 02:06:12,720
说初始化所以我们要说未来无效

1521
02:06:12,720 --> 02:06:16,160
初始化好的记住现在我们已经添加了这个

1522
02:06:16,160 --> 02:06:19,756
对我们的身份验证提供程序起作用，我们将遇到问题，因为

1523
02:06:19,756 --> 02:06:24,720
他们目前符合的 firebase 身份验证提供程序和身份验证服务

1524
02:06:24,720 --> 02:06:28,879
作者提供者抽象类并向该抽象添加新功能

1525
02:06:28,879 --> 02:06:33,436
class 意味着我们会得到两个错误，表明这个函数

1526
02:06:33,436 --> 02:06:37,595
未在 firebase 身份验证提供程序和我们的身份验证服务中实现，因此我们

1527
02:06:37,595 --> 02:06:44,080
需要解决这些问题，您可以看到它们实际上在此处突出显示为红色

1528
02:06:44,080 --> 02:06:47,839
好的嗯

1529
02:06:47,839 --> 02:06:52,160
让我们转到下一个标题

1530
02:06:52,160 --> 02:06:57,040
我要摆脱那个底部视图所以它不会打扰我们所以我们走吧

1531
02:06:57,040 --> 02:07:00,955
现在您可以在 firebase auth 提供程序中看到并覆盖初始化和

1532
02:07:00,955 --> 02:07:05,275
使其异步并在firebase上调用初始化应用程序

1533
02:07:05,275 --> 02:07:10,160
所以为了做firebase初始化代码，我们需要看看

1534
02:07:10,160 --> 02:07:13,360
在我们的主要飞镖上，看看现在是如何完成的，你可以看到它是

1535
02:07:13,360 --> 02:07:17,595
称为firebase初始化应用程序，所以我要获取该代码，我建议

1536
02:07:17,595 --> 02:07:22,160
你做同样的事情我只是要复制代码来初始化应用程序

1537
02:07:22,160 --> 02:07:27,116
然后让我们去我们的firebase auth provider

1538
02:07:27,116 --> 02:07:30,639
并从 Visual Studio Code 或 android Studio 获得帮助以完成该操作

1539
02:07:30,639 --> 02:07:33,595
初始化函数缺少一个覆盖

1540
02:07:33,595 --> 02:07:37,839
我相信它会被添加到这里的某个地方

1541
02:07:37,839 --> 02:07:41,360
或者它没有去哪里

1542
02:07:41,360 --> 02:07:46,955
我们应该初始化一个缺失的混凝土

1543
02:07:46,955 --> 02:07:55,915
创建一个丢失的覆盖初始化我仍然没有看到丢失的

1544
02:07:55,915 --> 02:08:01,275
我会在这里自己做，future void 像这样初始化好吗

1545
02:08:01,275 --> 02:08:05,519
呃，我们要做的，正如名字所暗示的那样，它将是一个异步的

1546
02:08:05,519 --> 02:08:11,680
这里的功能，我们需要做的只是保存firebase初始化应用程序所以

1547
02:08:11,680 --> 02:08:14,796
嗯，我们会等待这个，就像

1548
02:08:14,796 --> 02:08:18,160
记住我们有我们需要有两个

1549
02:08:18,160 --> 02:08:22,796
在此处导入，一个用于 firebase，另一个用于默认 firebase

1550
02:08:22,796 --> 02:08:26,955
选项，所以让我们从 Visual Studio 代码中获得帮助来导入这些 Firebase

1551
02:08:26,955 --> 02:08:29,680
核心和进口

1552
02:08:29,680 --> 02:08:34,400
firebase options dark 文件，如果您还记得我们何时设置 firebase

1553
02:08:34,400 --> 02:08:39,199
最初是从 firebase cli 引入我们的应用程序的

1554
02:08:39,199 --> 02:08:42,955
is 不是我们自己创建的文件，除了它是 firebase cli

1555
02:08:42,955 --> 02:08:46,559
为我们创造了这个，好吧

1556
02:08:46,559 --> 02:08:50,480
现在这里它说对成员进行注释，这正是我们需要做的

1557
02:08:50,480 --> 02:08:53,116
让我们再说一遍

1558
02:08:53,116 --> 02:08:58,796
就像这样，现在我们已经初始化了我们作者的成员

1559
02:08:58,796 --> 02:09:01,915
firebase 作者提供者中的提供者，所以

1560
02:09:01,915 --> 02:09:05,756
基本上我们所说的是firebase auth提供者实现初始化

1561
02:09:05,756 --> 02:09:10,400
功能，它有实际的实现还可以

1562
02:09:10,400 --> 02:09:14,796
好吧，我们还有一个错误，那是在身份验证服务中，所以让我们开始吧

1563
02:09:14,796 --> 02:09:19,040
进行身份验证服务，我们将遇到完全相同的问题

1564
02:09:19,040 --> 02:09:23,275
在这里说缺少具体的实现，所以我要看看我能不能

1565
02:09:23,275 --> 02:09:27,756
获取 Visual Studio 代码以添加该实现并将其添加到此处

1566
02:09:27,756 --> 02:09:32,796
初始化好，所以在这里我们要做的就是

1567
02:09:32,796 --> 02:09:38,720
将此功能委托给实际的提供者，所以我们要说提供者

1568
02:09:38,720 --> 02:09:43,436
我们会说初始化就像那样，所以这很容易

1569
02:09:43,436 --> 02:09:45,839
一个，如果你不记得

1570
02:09:45,839 --> 02:09:48,955
上一章，或者你跳过了上一章，我不知道

1571
02:09:48,955 --> 02:09:52,239
如果你没有看过前一章，你是如何进入这一章的

1572
02:09:52,239 --> 02:09:56,639
强烈建议您这样做，我们提供关闭服务是有原因的

1573
02:09:56,639 --> 02:10:00,080
实现身份验证提供程序，其背后的原因是

1574
02:10:00,080 --> 02:10:05,756
通常，服务中的逻辑比它们的逻辑要多

1575
02:10:05,756 --> 02:10:09,756
如果一个服务有两个其他服务连接到

1576
02:10:09,756 --> 02:10:13,839
本身那么它实际上可能会从服务和其他

1577
02:10:13,839 --> 02:10:18,400
来自另一个服务的点点滴滴，并将它们与一些额外的逻辑融合在一起

1578
02:10:18,400 --> 02:10:23,199
这正是作者作为一个奇怪的提供者服务的原因，所以目标

1579
02:10:23,199 --> 02:10:27,915
对我们来说是让官员比作者提供者做更多的工作

1580
02:10:27,915 --> 02:10:32,160
尽管现在它所做的只是将其所有功能委托给

1581
02:10:32,160 --> 02:10:36,879
身份验证提供者，记住你也可以看到确保我的意思是如果你

1582
02:10:36,879 --> 02:10:41,519
不喜欢这个实现你可以例如删除它然后

1583
02:10:41,519 --> 02:10:46,480
基本上删除所有这些功能，这样做你只是说

1584
02:10:46,480 --> 02:10:50,000
身份验证服务包括一个关闭的提供者，这就是你正在做的，或者你可以

1585
02:10:50,000 --> 02:10:55,436
完全杀死你的服务，所以这取决于你，但如果你跟随

1586
02:10:55,436 --> 02:10:59,199
除了这门课程，我建议你保持原样

1587
02:10:59,199 --> 02:11:03,756
因为这是有道理的所以

1588
02:11:03,756 --> 02:11:07,839
好的，现在我们已经完成了，嗯，是时候

1589
02:11:07,839 --> 02:11:12,480
做一些清理工作，这是一个非常令人兴奋的部分，呃

1590
02:11:12,480 --> 02:11:17,360
章，因为我们现在有我们的身份验证服务和我们的 firebase 身份验证提供程序

1591
02:11:17,360 --> 02:11:22,559
此外，我们还有一个关闭服务的火力基地工厂，它允许我们

1592
02:11:22,559 --> 02:11:26,879
到我们代码中的任何地方，我们都可以说 autoservice.firebase

1593
02:11:26,879 --> 02:11:32,955
这样我们就可以访问我们的 um firebase auth provider

1594
02:11:32,955 --> 02:11:37,519
身份验证服务，所以它真的很神奇，你很快就会看到它

1595
02:11:37,519 --> 02:11:41,915
所以我要在这里关闭所有文件，确保所有文件都保存为

1596
02:11:41,915 --> 02:11:47,275
标题表示我将进入主要艺术文件

1597
02:11:47,275 --> 02:11:51,680
主飞镖，你可以看到它说删除

1598
02:11:51,680 --> 02:11:56,239
与firebase相关的所有内容并通过导入替换为身份验证服务

1599
02:11:56,239 --> 02:12:01,519
身份验证服务还可以，所以这样做的一种方法就是确保您去

1600
02:12:01,519 --> 02:12:06,000
从源头杀死它，这样你就可以在这里看到我们有两个 firebase 导入，如果

1601
02:12:06,000 --> 02:12:08,955
您删除了这两个 firebase 进口

1602
02:12:08,955 --> 02:12:13,519
我通常使用软件的首选方式是我尝试喜欢删除

1603
02:12:13,519 --> 02:12:17,756
从它的源头中得到一些东西，所以现在我已经删除了那些然后视觉工作室是

1604
02:12:17,756 --> 02:12:22,000
告诉我，嘿，你在两个需要修复的地方使用了 firebase

1605
02:12:22,000 --> 02:12:24,955
这是因为你没有进口那么我知道好吧

1606
02:12:24,955 --> 02:12:28,879
这是我必须进行重构的两个地方

1607
02:12:28,879 --> 02:12:31,116
所以你可以在这里看到它说firebase

1608
02:12:31,116 --> 02:12:34,480
初始化应用程序，我们需要确保我们不再这样做了

1609
02:12:34,480 --> 02:12:40,639
我们只想说在这种情况下我们的未来记住是嗯

1610
02:12:40,639 --> 02:12:45,436
这是身份验证服务，因为我还没有导入它，但视觉工作室是

1611
02:12:45,436 --> 02:12:49,040
提供自动导入它，所以我会说是的

1612
02:12:49,040 --> 02:12:52,879
嗯，它现在是自动导入的，但如果你不想，如果你正在工作

1613
02:12:52,879 --> 02:12:57,756
使用 vim 或其他一些不具备该功能的文本编辑器

1614
02:12:57,756 --> 02:13:01,360
可以将其导入

1615
02:13:01,360 --> 02:13:04,955
这种方式每个包你的包的名称

1616
02:13:04,955 --> 02:13:09,519
services off auth service dart 我只是注意到这是另一个

1617
02:13:09,519 --> 02:13:12,796
我现在要删除的 firebase 导入

1618
02:13:12,796 --> 02:13:17,595
对不起，现在我们想告诉您身份验证服务

1619
02:13:17,595 --> 02:13:22,559
因为我们使用的是firebase，所以我们要说auth service dot firebase and in

1620
02:13:22,559 --> 02:13:27,360
在这里，我们只是说初始化好，这样就可以完美地适应

1621
02:13:27,360 --> 02:13:32,955
在这里你可以看到我们正在使用firebase um

1622
02:13:32,955 --> 02:13:36,720
instance firebase auth instance current user 在这种情况下，我们将要

1623
02:13:36,720 --> 02:13:43,436
说呃关闭服务点我们的基础人员当前用户就像

1624
02:13:43,436 --> 02:13:48,559
好吧，现在记得奇怪，我在前面的章节中谈到了这个，但是

1625
02:13:48,559 --> 02:13:53,040
我更喜欢在单词 is 前加上布尔标志前缀

1626
02:13:53,040 --> 02:13:56,559
只要有意义，在这种情况下，您就可以看到 firebase 实现

1627
02:13:56,559 --> 02:14:00,400
已验证电子邮件，但我们已验证电子邮件，所以我要说的是电子邮件

1628
02:14:00,400 --> 02:14:03,519
可以这样验证

1629
02:14:03,519 --> 02:14:09,199
and s or control x and linux and windows a command is on mac on to save this file

1630
02:14:09,199 --> 02:14:12,319
现在看起来还不错，但我们不是

1631
02:14:12,319 --> 02:14:18,480
真的完成了，我们的登录视图也有问题

1632
02:14:18,480 --> 02:14:23,756
我的意思是问题不是错误或警告，而是我们正在使用的问题

1633
02:14:23,756 --> 02:14:29,595
firebase 直接，我们将在登录视图中直接进入 firebase auth

1634
02:14:29,595 --> 02:14:32,480
我们需要修复，因为您可以看到字幕系统登录视图删除

1635
02:14:32,480 --> 02:14:37,595
firebase 并用关闭服务替换好的

1636
02:14:37,595 --> 02:14:44,639
所以让我们去 uh 的源头并从

1637
02:14:44,639 --> 02:14:48,319
你的登录视图命令，现在你会看到我们有一个

1638
02:14:48,319 --> 02:14:55,116
这里有很多问题，一二三是的，就是这样，三三个地方

1639
02:14:55,116 --> 02:15:00,720
我们需要修复所以让我们继续修复那些地方

1640
02:15:00,720 --> 02:15:05,360
因为是的，嗯，这里有很多事情要处理，所以我们开始

1641
02:15:05,360 --> 02:15:08,879
此刻，我们说的是 firebase off 使用电子邮件即时登录

1642
02:15:08,879 --> 02:15:12,639
和密码，我们需要做的就是呃

1643
02:15:12,639 --> 02:15:18,319
取消我们的服务，所以我们会说 auth service 和

1644
02:15:18,319 --> 02:15:22,720
自动导入和身份验证服务具有 Firebase 身份验证

1645
02:15:22,720 --> 02:15:29,116
提供商，然后我们会说分配或我们说登录是的电子邮件

1646
02:15:29,116 --> 02:15:33,519
密码好的，所以我要按原样使用此代码

1647
02:15:33,519 --> 02:15:38,080
我没有把它们粘贴在这里

1648
02:15:38,080 --> 02:15:43,519
所以现在我们说auth service firebase login没问题

1649
02:15:43,519 --> 02:15:47,519
然后我们在这里看到我们正在获取当前用户和权限

1650
02:15:47,519 --> 02:15:51,595
现在获取当前用户的方法是停止服务

1651
02:15:51,595 --> 02:15:56,639
dot firebase 当前用户和验证的电子邮件应该是 ms 电子邮件

1652
02:15:56,639 --> 02:16:02,000
验证没问题，所以现在我们通过解决所有问题来解决这方面的问题

1653
02:16:02,000 --> 02:16:07,595
搜索而不是直接进入 firebase

1654
02:16:07,595 --> 02:16:13,116
好吧，那就是现在我们需要开始看看我们的错误

1655
02:16:13,116 --> 02:16:18,000
处理，你可以在这里看到我们在火力基地关闭

1656
02:16:18,000 --> 02:16:24,559
例外所以我们需要用各种 um 修复这些

1657
02:16:24,559 --> 02:16:28,160
其他异常处理不是firebase auth

1658
02:16:28,160 --> 02:16:32,000
例外，但现在记住我们有自己的

1659
02:16:32,000 --> 02:16:37,116
auth exception start 中的异常和

1660
02:16:37,116 --> 02:16:40,879
这些都来自例外，但我们是什么

1661
02:16:40,879 --> 02:16:43,519
要做的是我们会喜欢上

1662
02:16:43,519 --> 02:16:48,720
诸如此类的各种例外，您很快就会看到，所以我是

1663
02:16:48,720 --> 02:16:54,480
我要做的是我要接受这段代码并保持原样

1664
02:16:54,480 --> 02:16:59,360
像那样，我要添加新的声明所以

1665
02:16:59,360 --> 02:17:02,239
嗯，让我们照顾未找到的用户，所以我

1666
02:17:02,239 --> 02:17:06,480
会说用户未找到异常，你可以看到它说用户没有

1667
02:17:06,480 --> 02:17:09,595
found exception 是我们手动创建但未导入的异常

1668
02:17:09,595 --> 02:17:13,680
在这里，因为它在 auth exceptions dart 文件中，所以我要说

1669
02:17:13,680 --> 02:17:17,756
视觉工作室代码请完成并为我导入它好吗

1670
02:17:17,756 --> 02:17:24,879
所以说在这种情况下，我们必须做显示错误对话框所以抓住那个代码和

1671
02:17:24,879 --> 02:17:29,595
把它放在这里好吧，然后我们要说

1672
02:17:29,595 --> 02:17:33,915
我们还有什么密码错误

1673
02:17:33,915 --> 02:17:40,000
因为这就是我要说的关于错误密码的异常

1674
02:17:40,000 --> 02:17:45,199
然后进入这里，然后从这里抓取你的显示错误对话框

1675
02:17:45,199 --> 02:17:48,080
把它放在那里好吗

1676
02:17:48,080 --> 02:17:51,915
然后我们还需要打开

1677
02:17:51,915 --> 02:17:56,796
通用身份验证异常等通用身份验证异常

1678
02:17:56,796 --> 02:18:02,480
我们这样做显示错误我喜欢这里的方式

1679
02:18:02,480 --> 02:18:06,400
那么我们去把它带到这里，你可以看到通用错误关闭

1680
02:18:06,400 --> 02:18:10,160
例外，我们没有任何特定的类似信息，如任何 e 或任何东西

1681
02:18:10,160 --> 02:18:13,756
串起来，所以我们在这里要做的就是说我们要说

1682
02:18:13,756 --> 02:18:18,480
身份验证错误好吧，然后你需要去删除

1683
02:18:18,480 --> 02:18:22,000
其他 catch 块，所以你的代码应该

1684
02:18:22,000 --> 02:18:28,720
基本上看起来像这样还可以，所以一个 try 块，然后是三个

1685
02:18:28,720 --> 02:18:34,080
一个接一个的特殊异常处理

1686
02:18:34,080 --> 02:18:39,040
现在您的登录视图上的命令很棒，您应该不会有任何问题

1687
02:18:39,040 --> 02:18:44,559
登录视图，并且在您的登录视图中没有导入firebase

1688
02:18:44,559 --> 02:18:48,400
在主 dart 文件中，让我们确保没有 firebase

1689
02:18:48,400 --> 02:18:53,756
在这里导入 firebase 是的 firebase 是的 没有进口

1690
02:18:53,756 --> 02:18:57,595
firebase 很棒 [音乐]

1691
02:18:57,595 --> 02:19:02,239
正如标题现在所说，我们需要去注册视图并删除firebase

1692
02:19:02,239 --> 02:19:06,720
并用身份验证服务替换，因为我们现在已经完成了相同的练习

1693
02:19:06,720 --> 02:19:10,639
登录视图你现在应该基本上知道我们在注册视图中要做什么

1694
02:19:10,639 --> 02:19:14,080
我们将进行与在登录视图中所做的几乎完全相同的事情，除了

1695
02:19:14,080 --> 02:19:19,199
在注册表中从导入中删除 firebase 会得到我们遇到的所有错误

1696
02:19:19,199 --> 02:19:23,360
得到，在得到这些错误之后，我们将解决问题

1697
02:19:23,360 --> 02:19:27,040
在注册中，让我们继续做吧

1698
02:19:27,040 --> 02:19:30,955
让我们去我们的进口那里我们要进口的火力基地

1699
02:19:30,955 --> 02:19:35,756
删除它，现在我们可能有很多错误是的

1700
02:19:35,756 --> 02:19:39,595
那很好，让我们去解决我要去的问题

1701
02:19:39,595 --> 02:19:44,160
去我的笔记只是为了确保我遵循所有的

1702
02:19:44,160 --> 02:19:48,160
我应该告诉你的笔记

1703
02:19:48,160 --> 02:19:50,955
然后我们不使用电子邮件创建用户和

1704
02:19:50,955 --> 02:19:54,559
我们的身份验证服务器中的密码，所以我们只说所有服务

1705
02:19:54,559 --> 02:19:59,275
它没有被导入，所以让我们自动导入它 dot firebase，我们要

1706
02:19:59,275 --> 02:20:05,360
说标志，我们称之为什么创建用户电子邮件和密码

1707
02:20:05,360 --> 02:20:10,955
在最后一个参数的末尾获取代码并替换您的 Firebase 身份验证

1708
02:20:10,955 --> 02:20:16,796
使用我们的身份验证服务创建用户电子邮件和密码

1709
02:20:16,796 --> 02:20:19,436
好的，在我们得到的地方

1710
02:20:19,436 --> 02:20:25,595
用户让我们说 auth service firebase 我们会说 current

1711
02:20:25,595 --> 02:20:30,160
用户，现在我们已经发送电子邮件验证

1712
02:20:30,160 --> 02:20:34,160
但我认为我们称它为我们所说的其他东西

1713
02:20:34,160 --> 02:20:37,839
哦，我们没有实现发送电子邮件

1714
02:20:37,839 --> 02:20:43,756
验证还是我们让我去身份验证服务

1715
02:20:43,756 --> 02:20:46,879
然后发送电子邮件验证是的

1716
02:20:46,879 --> 02:20:51,360
就在那里，所以我要哦，我明白了，因为以前

1717
02:20:51,360 --> 02:20:55,199
发生的事情是firebase实现发送电子邮件

1718
02:20:55,199 --> 02:21:00,239
在用户级别进行验证，但我们没有，我们不再想要了

1719
02:21:00,239 --> 02:21:05,116
而我们的用户实际上没有这个功能

1720
02:21:05,116 --> 02:21:08,639
一个布尔标志，所以我们需要在这里做的是

1721
02:21:08,639 --> 02:21:13,116
会要求我们的服务发送电子邮件验证，所以我们会说

1722
02:21:13,116 --> 02:21:18,319
火灾和身份验证服务，这只是发送电子邮件验证

1723
02:21:18,319 --> 02:21:21,436
喜欢

1724
02:21:21,436 --> 02:21:24,796
好的，那么我们需要将这些异常修复为

1725
02:21:24,796 --> 02:21:27,839
好吧，因为正如您在登录视图中看到的那样，我们没有 firebase auth

1726
02:21:27,839 --> 02:21:32,000
在这种情况下出现异常，就像我们删除了 ui 一样

1727
02:21:32,000 --> 02:21:36,639
通过删除所有导入直接与firebase对话的能力所以现在我们

1728
02:21:36,639 --> 02:21:39,680
需要确保我们像在登录时一样处理异常

1729
02:21:39,680 --> 02:21:44,400
好吧，让我们继续说

1730
02:21:44,400 --> 02:21:47,040
嗯

1731
02:21:47,040 --> 02:21:50,639
每个密码，因为我认为这是我们处理的第一个密码

1732
02:21:50,639 --> 02:21:54,796
嗯，我的意思是你看到几乎整个屏幕现在都是红色的，这是其中之一

1733
02:21:54,796 --> 02:21:59,040
使用我在第一个中谈到的扩展的缺点

1734
02:21:59,040 --> 02:22:02,239
本课程中我使用扩展程序的章节

1735
02:22:02,239 --> 02:22:07,595
称为空气透镜和空气透镜扩展并扩大了所有的误差，

1736
02:22:07,595 --> 02:22:12,319
否则只会在扩展它们的线条旁边出现小图标

1737
02:22:12,319 --> 02:22:16,720
放到他们自己单独的行中，这有点让代码看起来有点

1738
02:22:16,720 --> 02:22:21,360
当您对代码进行重大更改但不这样做时，有时会生气

1739
02:22:21,360 --> 02:22:25,360
担心它只是看看你的语法，看看是的，我是

1740
02:22:25,360 --> 02:22:28,955
有点做正确的事我会尽快修复它所以不要被吓倒

1741
02:22:28,955 --> 02:22:34,480
在这里所有这些红旗都可以，或者这些红线

1742
02:22:34,480 --> 02:22:39,680
所以让我们处理弱密码异常现在它会有点

1743
02:22:39,680 --> 02:22:43,915
在这里安静点，然后抓住你的显示错误对话框

1744
02:22:43,915 --> 02:22:46,796
从那里开始，这是一周的密码

1745
02:22:46,796 --> 02:22:51,680
就这样放在这里，嗯

1746
02:22:51,680 --> 02:22:54,955
那么我们需要处理我们的

1747
02:22:54,955 --> 02:23:01,360
电子邮件已在使用中 电子邮件已在使用中 例外

1748
02:23:01,360 --> 02:23:05,519
然后我们将已经从电子邮件中获取代码并使用它只是一个

1749
02:23:05,519 --> 02:23:10,239
更短的对话放在那里好吧

1750
02:23:10,239 --> 02:23:15,275
像那样，我们也需要处理

1751
02:23:15,275 --> 02:23:22,319
无效的电子邮件，所以我要在这里说无效电子邮件关闭异常

1752
02:23:22,319 --> 02:23:27,595
让我们从无效电子邮件异常中获取代码

1753
02:23:27,595 --> 02:23:30,239
和

1754
02:23:30,239 --> 02:23:35,915
并且那部分也完成了，我们也需要在通用 als 上

1755
02:23:35,915 --> 02:23:40,480
异常，所以让我们进入这里，只说通用身份验证异常

1756
02:23:40,480 --> 02:23:45,040
让我们处理那个肩膀对话

1757
02:23:45,040 --> 02:23:49,436
实际上这就是我们为通用身份验证异常所做的，所以我要走了

1758
02:23:49,436 --> 02:23:53,519
抓住那个代码把它放在那里，因为通用关闭

1759
02:23:53,519 --> 02:23:59,360
例外我们不接受任何 e 所以我们不会说 on catch like e like

1760
02:23:59,360 --> 02:24:04,000
我们本可以做到这一点，但我们只是完全忽略了 e 和 in

1761
02:24:04,000 --> 02:24:07,839
在这里，我们只会说注册失败

1762
02:24:07,839 --> 02:24:10,955
然后让我们清理其余代码删除其他 cat 语句

1763
02:24:10,955 --> 02:24:14,720
好的，所以你的代码现在基本上看起来像这样干净，所以你有一个

1764
02:24:14,720 --> 02:24:19,756
尝试阻止，然后您说好的，我正在这里尝试此代码创建用户

1765
02:24:19,756 --> 02:24:24,160
如果发生弱密码身份验证异常，请执行此操作如果电子邮件已在使用中，请执行此操作

1766
02:24:24,160 --> 02:24:30,239
如果电子邮件无效，请执行此操作或任何其他身份验证异常，请执行此操作

1767
02:24:30,239 --> 02:24:34,879
它在我眼里看起来更干净，至少我们现在做的方式比我们以前的方式

1768
02:24:34,879 --> 02:24:39,275
在我们去firebase和firebase之前做这个

1769
02:24:39,275 --> 02:24:43,116
在firebase auth异常上执行此操作，否则执行此操作

1770
02:24:43,116 --> 02:24:47,519
所以现在我们唯一要做的就是通过我们的

1771
02:24:47,519 --> 02:24:54,839
身份验证服务和处理与身份验证相关的异常，仅此而已

1772
02:24:54,839 --> 02:25:00,480
好吧好吧，现在我们已经完成了我们的工作

1773
02:25:00,480 --> 02:25:04,480
您可以看到的寄存器我们需要去的寄存器中没有错误

1774
02:25:04,480 --> 02:25:08,720
注释视图如标题所示，所以我关闭

1775
02:25:08,720 --> 02:25:12,559
注册视图现在让我们打开我们的笔记视图

1776
02:25:12,559 --> 02:25:17,360
看看我们在用 firebase 和 notes 视图做什么，所以做同样的事情

1777
02:25:17,360 --> 02:25:22,319
我们之前将firebase删除为您的进口之一，因此您得到了

1778
02:25:22,319 --> 02:25:26,639
想法是对这里发生的事情以及我们如何使用的总体想法

1779
02:25:26,639 --> 02:25:30,796
firebase，我可以看到在笔记视图中使用 firebase 的唯一地方是

1780
02:25:30,796 --> 02:25:34,955
firebase off instance 注销很好，它只是一个地方，但我们必须

1781
02:25:34,955 --> 02:25:38,400
也解决这个问题，然后让我们走吧，对不起，我只是要去

1782
02:25:38,400 --> 02:25:43,915
调出我的笔记，嗯，我们在笔记视图中

1783
02:25:43,915 --> 02:25:48,319
好吧，那我们就去吧

1784
02:25:48,319 --> 02:25:52,160
在这里，我们要说出来

1785
02:25:52,160 --> 02:25:56,400
auth service 没问题，然后我们会说

1786
02:25:56,400 --> 02:26:00,400
注销我想我们会调用它，我们需要等待它好吧

1787
02:26:00,400 --> 02:26:03,436
像那样和

1788
02:26:03,436 --> 02:26:08,639
这很糟糕，所以我们现在可以做的是我们已经从那里移除了 firebase

1789
02:26:08,639 --> 02:26:13,275
好吧，我们走吧

1790
02:26:13,275 --> 02:26:16,480
正如标题所示，我们现在需要浏览整个应用程序并确保

1791
02:26:16,480 --> 02:26:21,360
一切都按预期工作，但在我们这样做之前让我们看看

1792
02:26:21,360 --> 02:26:26,639
在我们看来，并确保他们都没有导入 firebase，所以我可以看到登录

1793
02:26:26,639 --> 02:26:29,839
view 没有导入任何与 firebase 相关的东西，这意味着它没有使用

1794
02:26:29,839 --> 02:26:34,879
firebase 让我们去注释查看没有与 firebase 相关的导入

1795
02:26:34,879 --> 02:26:38,639
不使用 firebase 或至少不直接使用 firebase

1796
02:26:38,639 --> 02:26:43,915
请记住它正在使用 firebase 但通过我们的身份验证服务可以，所以没有从

1797
02:26:43,915 --> 02:26:49,915
firebase 也在这里，我们有我们的验证电子邮件视图，目前我

1798
02:26:49,915 --> 02:26:52,400
可以看到

1799
02:26:52,400 --> 02:26:57,040
验证电子邮件视图哦，我看到我们还没有清理我们的验证电子邮件视图

1800
02:26:57,040 --> 02:27:00,559
这也是我们需要做的，所以我们忘记了，让我们

1801
02:27:00,559 --> 02:27:05,275
让我们照顾好那好吧，让我们进去看看

1802
02:27:05,275 --> 02:27:10,160
也从此处删除此 Firebase 身份验证

1803
02:27:10,160 --> 02:27:15,595
我要去我的笔记这里

1804
02:27:15,595 --> 02:27:18,796
好的，现在让我们来看看

1805
02:27:18,796 --> 02:27:23,680
说呃发送电子邮件验证不应该在那里所以让我们就在那时

1806
02:27:23,680 --> 02:27:28,080
说熄火服务嗯

1807
02:27:28,080 --> 02:27:33,915
firebase 哎呀，firebase 是当前用户，我可以看到你看到

1808
02:27:33,915 --> 02:27:37,915
在这里，它使用当前用户只是发送电子邮件验证，但我们

1809
02:27:37,915 --> 02:27:41,199
不要再这样做了，我们只是因为发送电子邮件验证不是

1810
02:27:41,199 --> 02:27:44,480
当我们开发了我们的离线服务时，在用户级别上记住了

1811
02:27:44,480 --> 02:27:47,839
我们只会说发送电子邮件验证等待

1812
02:27:47,839 --> 02:27:50,720
好的，然后删除那两行代码

1813
02:27:50,720 --> 02:27:53,915
这只是获取用户并发送电子邮件验证删除

1814
02:27:53,915 --> 02:27:57,756
那些和回答你我没有计划

1815
02:27:57,756 --> 02:28:01,436
为此，我实际上可以在我的笔记中看到我没有

1816
02:28:01,436 --> 02:28:04,720
修复了验证电子邮件视图，这就是为什么我没有在标题中显示它

1817
02:28:04,720 --> 02:28:09,436
这完全没关系，我有时也必须即兴发挥，所以

1818
02:28:09,436 --> 02:28:14,400
然后让我们继续在它们中的文本按钮中显示重新启动为

1819
02:28:14,400 --> 02:28:18,559
你可以在这里看到只需要注销用户所以让我们说一下

1820
02:28:18,559 --> 02:28:23,839
服务基地注销并确保您等待

1821
02:28:23,839 --> 02:28:28,879
就可以了，就这样并删除这行代码，以便验证视图

1822
02:28:28,879 --> 02:28:32,879
现在也没有从 firebase 的任何进口

1823
02:28:32,879 --> 02:28:35,756
我相信那些是

1824
02:28:35,756 --> 02:28:39,519
我们所有的观点，除了主要的，让我们确保没有火力基地

1825
02:28:39,519 --> 02:28:44,080
这里的进口要么完美，所以现在我们已经完成了

1826
02:28:44,080 --> 02:28:47,915
在我们要进行热重启的情况下，我们可以做什么作为标题

1827
02:28:47,915 --> 02:28:52,559
在这里，让我们看看一切是否正常

1828
02:28:52,559 --> 02:28:56,720
我只想说在这里重新启动，让我们看看

1829
02:28:56,720 --> 02:29:01,116
应用程序的当前状态我将打开一个 firebase 控制台

1830
02:29:01,116 --> 02:29:06,080
去我的笔记应用程序这里认证，我可以看到我有两个

1831
02:29:06,080 --> 02:29:11,680
这里的用户还好，所以我要说 pixelityab.gmail.com

1832
02:29:11,680 --> 02:29:15,519
foob​​arbass，让我们说注册然后它

1833
02:29:15,519 --> 02:29:19,519
应该给我们一个错误，说电子邮件已经在使用中，所以电子邮件已经在使用中

1834
02:29:19,519 --> 02:29:25,756
使用 let's go in here 说 pixelityab gmail.combarbaz 我记得

1835
02:29:25,756 --> 02:29:30,639
前几章 这是一个已经验证了他的电子邮件地址的用户，所以

1836
02:29:30,639 --> 02:29:34,239
通过按登录，我们实际上应该转到应用程序的主用户界面，所以

1837
02:29:34,239 --> 02:29:38,720
注销应该像以前一样工作，然后让我们去

1838
02:29:38,720 --> 02:29:42,080
uh 并尝试使用该用户登录

1839
02:29:42,080 --> 02:29:45,519
那是我认为还没有

1840
02:29:45,519 --> 02:29:50,239
验证了他的电子邮件地址，这样你就可以看到我们将被发送到这里

1841
02:29:50,239 --> 02:29:53,839
验证电子邮件，然后我们可以按发送电子邮件验证，这反过来

1842
02:29:53,839 --> 02:29:59,680
然后将电子邮件发送给用户

1843
02:29:59,680 --> 02:30:04,879
那是很多信息，还有一些即兴版本

1844
02:30:04,879 --> 02:30:08,400
我没有计划的验证电子邮件视图的章节，所以这对我有好处

1845
02:30:08,400 --> 02:30:11,360
也知道有时我也会错过一些东西，但现在我们没有

1846
02:30:11,360 --> 02:30:14,955
在本章中谈论它时错过了它

1847
02:30:14,955 --> 02:30:17,199
现在让我们

1848
02:30:17,199 --> 02:30:21,595
结束本章我们已经做了很多，本章的主要目标是

1849
02:30:21,595 --> 02:30:24,400
现在我们已经实现了，因为我们想要

1850
02:30:24,400 --> 02:30:29,436
远离直接在我们的 ui 中使用 firebase 并远离使用

1851
02:30:29,436 --> 02:30:34,400
我们为与 firebase 相关的所有内容提供的身份验证服务已经实现

1852
02:30:34,400 --> 02:30:37,680
现在做得很好 我们需要做的就是我们正在做的

1853
02:30:37,680 --> 02:30:42,000
在其他章节中，我们需要呃提交和标记我们已经完成的所有代码

1854
02:30:42,000 --> 02:30:44,635
因为如果我们

1855
02:30:44,635 --> 02:30:50,319
由于某种原因丢失了所有这些代码，所以让我更改 um 的布局

1856
02:30:50,319 --> 02:30:54,400
屏幕在这里，我要制作

1857
02:30:54,400 --> 02:30:58,559
浏览大一点的编辑器，这样你会看得更清楚，我要走了

1858
02:30:58,559 --> 02:31:01,275
进入我在视觉工作室中非常喜欢的终端，称为

1859
02:31:01,275 --> 02:31:06,319
集成终端，您可以看到在上一章中我们已经提交

1860
02:31:06,319 --> 02:31:11,436
并将我们的代码标记为步骤 8 现在我们需要提交为步骤 9

1861
02:31:11,436 --> 02:31:15,040
首先让我们看看状态并添加所有

1862
02:31:15,040 --> 02:31:22,080
状态，我们说 git commit ，我们说第九步好吧

1863
02:31:22,080 --> 02:31:26,720
然后我们说 git tag

1864
02:31:26,720 --> 02:31:30,635
九个，我们首先推送我们的提交

1865
02:31:30,635 --> 02:31:34,635
我们说好的推税

1866
02:31:34,635 --> 02:31:39,275
好吧，这也被推动了，做得很好，我们完成了

1867
02:31:39,275 --> 02:31:43,680
这一章和我谈过的其他章节的情况一样

1868
02:31:43,680 --> 02:31:46,480
关于我们通常会在最后讨论下一章我们要做什么

1869
02:31:46,480 --> 02:31:50,080
的当前章节，所以我们完成了身份验证服务

1870
02:31:50,080 --> 02:31:56,480
工作正常，但我们没有一些测试

1871
02:31:56,480 --> 02:32:00,480
你看有三种不同类型的测试

1872
02:32:00,480 --> 02:32:06,160
你可以在颤振单元测试集成测试和小部件中编写

1873
02:32:06,160 --> 02:32:11,436
现在测试一个单元测试是你例如

1874
02:32:11,436 --> 02:32:17,199
试着取消你目前的服务然后你呃

1875
02:32:17,199 --> 02:32:22,559
只想说好的认证服务登录注册这样做这样做然后

1876
02:32:22,559 --> 02:32:27,199
鉴于这种情况，我希望您现在可以执行此操作，我们的身份验证服务正在运行

1877
02:32:27,199 --> 02:32:32,160
很好，但我们不能 100 确定它正在工作

1878
02:32:32,160 --> 02:32:36,400
应该如此，假设您在一个团队中工作，并且有

1879
02:32:36,400 --> 02:32:40,480
其他三个人和你在同一个代码库上工作，而你在

1880
02:32:40,480 --> 02:32:44,879
身份验证服务，然后您承诺每个人都审查代码或

1881
02:32:44,879 --> 02:32:49,199
我喜欢做我的代码的方式是配对程序或暴民程序，所以有

1882
02:32:49,199 --> 02:32:52,635
没有代码审查，因为每个人都在同时处理相同的代码

1883
02:32:52,635 --> 02:32:57,595
时间，所以这取决于您在团队中的工作方式，然后您发送

1884
02:32:57,595 --> 02:33:01,360
你的代码然后两周后一个新的开发者进来改变你的身份验证

1885
02:33:01,360 --> 02:33:05,040
service and to 并且他们改变了服务

1886
02:33:05,040 --> 02:33:09,436
这对他们来说很有意义，但是他们会破坏你的代码，所以也许例如

1887
02:33:09,436 --> 02:33:12,720
电子邮件验证屏幕停止工作，因为它们发生了变化

1888
02:33:12,720 --> 02:33:17,275
代码，使其不会按照您认为的方式执行逻辑

1889
02:33:17,275 --> 02:33:22,400
执行逻辑，这就是为什么我们需要测试来验证我们的

1890
02:33:22,400 --> 02:33:27,360
嗯，我们设计软件的方式其实是

1891
02:33:27,360 --> 02:33:32,319
呃是它应该执行它的工作的方式，这样它就不会丢失任何点

1892
02:33:32,319 --> 02:33:34,400
这就是我们在

1893
02:33:34,400 --> 02:33:39,040
下一章，嗯，吃点点心，我会看到的

1894
02:33:39,040 --> 02:33:44,239
你在下一章你好，欢迎来到第 26 章

1895
02:33:44,239 --> 02:33:47,519
上一章中的颤振课程你看到我们

1896
02:33:47,519 --> 02:33:52,955
开始在我们的用户界面代码中使用我们的身份验证服务，所以我们不是

1897
02:33:52,955 --> 02:33:57,436
直接对抗firebase，所以我们删除了所有

1898
02:33:57,436 --> 02:34:02,559
在我们的用户界面中导入到 firebase

1899
02:34:02,559 --> 02:34:08,720
登录注册主 dart 文件和 um 中的文件

1900
02:34:08,720 --> 02:34:13,040
注释视图并验证电子邮件视图

1901
02:34:13,040 --> 02:34:18,080
我们有一个很好的身份验证服务但是我们缺少的是一些

1902
02:34:18,080 --> 02:34:23,436
当我谈论时，测试和测试是我最喜欢的话题之一

1903
02:34:23,436 --> 02:34:27,680
软件开发，因为它们使您的代码更加健壮

1904
02:34:27,680 --> 02:34:30,879
不仅仅是编写代码并将其留在

1905
02:34:30,879 --> 02:34:34,319
在那里，我知道一些软件开发人员可能

1906
02:34:34,319 --> 02:34:38,635
把事情看成黑白的，说你必须有代码或

1907
02:34:38,635 --> 02:34:43,756
你不必有代码，但我更像是一个灰色的人

1908
02:34:43,756 --> 02:34:47,040
认为你必须现实一些，如果你是为了

1909
02:34:47,040 --> 02:34:51,519
例如在黑客马拉松中为自己编写一个应用程序，例如

1910
02:34:51,519 --> 02:34:55,595
在你的时间压力下，你只想把事情做好

1911
02:34:55,595 --> 02:35:00,160
如果您参加黑客马拉松，那不是编写单元测试的正确位置

1912
02:35:00,160 --> 02:35:04,239
但是如果你和一家公司合作，他们和你写作是有报酬的

1913
02:35:04,239 --> 02:35:08,080
好的软件，你也得到报酬来编写你的测试，以确保

1914
02:35:08,080 --> 02:35:10,400
一切正常，尤其是如果您是后端

1915
02:35:10,400 --> 02:35:13,275
开发人员软件，例如前端开发人员

1916
02:35:13,275 --> 02:35:20,080
那么您需要确保您的代码经过正确测试，以便

1917
02:35:20,080 --> 02:35:23,915
我要在这里调出标题

1918
02:35:23,915 --> 02:35:29,915
关于为什么我们实际上需要测试，尤其是单元测试

1919
02:35:29,915 --> 02:35:34,400
嗯，我们稍后会讨论不同类型的测试，但是

1920
02:35:34,400 --> 02:35:39,199
让我们谈谈单元测试，嗯，我在

1921
02:35:39,199 --> 02:35:43,275
就像上一章关于什么是单元测试的结尾

1922
02:35:43,275 --> 02:35:47,519
以及为什么我们需要它们，对我来说，拥有一个单位的主要原因

1923
02:35:47,519 --> 02:35:52,319
测试是为了确保如果您认为这里是我们留下的身份验证提供程序

1924
02:35:52,319 --> 02:35:57,680
它的状态很好 它工作正常

1925
02:35:57,680 --> 02:36:02,319
它正在工作，但是如果新的开发人员进入项目并且

1926
02:36:02,319 --> 02:36:06,319
尝试更改一些代码，使其适用于她或他

1927
02:36:06,319 --> 02:36:10,080
但是无意中更改它会更改代码，因此它对我们不起作用

1928
02:36:10,080 --> 02:36:15,199
我们打算这样做的方式，这就是为什么这就是我们的原因之一

1929
02:36:15,199 --> 02:36:18,796
进行单元测试，嗯，这就是我们要做的

1930
02:36:18,796 --> 02:36:23,275
本章，我完全理解，如果你正在看这个

1931
02:36:23,275 --> 02:36:27,595
当然，你可能正坐在一个安静的地方，一个安静的房间，你正在

1932
02:36:27,595 --> 02:36:31,116
自己看这门课这是聊天我想你看的机会

1933
02:36:31,116 --> 02:36:35,116
一群人的这门课程相当苗条，所以

1934
02:36:35,116 --> 02:36:38,480
嗯，很可能你只是跟着课程走，你正在尝试

1935
02:36:38,480 --> 02:36:41,519
编写应用程序或将其发布到应用商店或游戏商店并播放

1936
02:36:41,519 --> 02:36:43,360
如此存放

1937
02:36:43,360 --> 02:36:47,275
也许您对确保您的身份验证服务实际上不是很感兴趣

1938
02:36:47,275 --> 02:36:51,360
经过测试，我完全理解，但我基本上是在设计这门课程

1939
02:36:51,360 --> 02:36:55,519
对于那些试图成为优秀软件开发人员的人来说，如果你是

1940
02:36:55,519 --> 02:36:58,796
正如我所提到的，就像我开发这门课程的角色之一

1941
02:36:58,796 --> 02:37:02,635
因为是设计师，所以如果你是设计师，没有 Flutter 的背景

1942
02:37:02,635 --> 02:37:07,199
您可能也有兴趣为您的应用程序编写测试

1943
02:37:07,199 --> 02:37:11,275
尤其是如果您的目标是进入一个更大的组织并实际获得

1944
02:37:11,275 --> 02:37:14,879
作为 Flutter 开发人员或软件开发人员的工作

1945
02:37:14,879 --> 02:37:18,955
鉴于此背景，您应该知道什么是测试，什么是单元测试

1946
02:37:18,955 --> 02:37:25,199
集成测试是什么，例如小部件测试是什么？

1947
02:37:25,199 --> 02:37:30,319
现在我还需要提到有一种叫做 tdd 或测试的东西

1948
02:37:30,319 --> 02:37:34,635
驱动发展和真正的正确道路

1949
02:37:34,635 --> 02:37:38,720
做测试驱动开发是首先

1950
02:37:38,720 --> 02:37:42,879
编写测试，然后你在我们正在做的那一刻编写你的软件

1951
02:37:42,879 --> 02:37:47,040
恰恰相反，因为我不想让事情复杂化，因为我们要去

1952
02:37:47,040 --> 02:37:49,839
因为我有这个，正如我所说的，我为可能的人设计了这门课程

1953
02:37:49,839 --> 02:37:53,116
Flutter 开发或软件开发的新手，所以喜欢去

1954
02:37:53,116 --> 02:37:56,879
直接进入测试开发测试驱动开发再编写

1955
02:37:56,879 --> 02:38:00,635
我们的关闭服务可能会使事情变得更加复杂

1956
02:38:00,635 --> 02:38:04,400
为了简单起见，我们编写了代码，然后我们正在编写测试，但就是这样

1957
02:38:04,400 --> 02:38:09,199
你知道如果你听到人们谈论 tdd 测试

1958
02:38:09,199 --> 02:38:13,360
驱动开发他们的意思是你编写测试并在

1959
02:38:13,360 --> 02:38:17,595
编写测试你得出的接口如何

1960
02:38:17,595 --> 02:38:21,275
您实际上正在为其编写测试的课程应该看起来像

1961
02:38:21,275 --> 02:38:24,879
使用类，所以有测试驱动的开发

1962
02:38:24,879 --> 02:38:29,915
非常重要，我们应该知道如何使用它，如果你是

1963
02:38:29,915 --> 02:38:34,080
在软件开发组织工作，你应该做测试

1964
02:38:34,080 --> 02:38:38,559
开发测试驱动开发如果时间允许并且如果

1965
02:38:38,559 --> 02:38:42,955
嗯，所有的限制都在正确的地方让你实际进行测试和

1966
02:38:42,955 --> 02:38:48,480
正如我所说，我看东西更像不是黑白的

1967
02:38:48,480 --> 02:38:52,879
视力更像是灰色视力我说你应该做测试但是

1968
02:38:52,879 --> 02:38:56,796
又是完全取决于你和你的情况

1969
02:38:56,796 --> 02:39:01,839
你在里面，所以要知道 tdd 是什么，那

1970
02:39:01,839 --> 02:39:05,436
进行测试驱动开发的正确方法是你首先编写你的

1971
02:39:05,436 --> 02:39:09,199
测试然后你编写接口和

1972
02:39:09,199 --> 02:39:14,319
测试实际执行测试的代码有很多

1973
02:39:14,319 --> 02:39:19,199
呃有很多关于 tdd 的在线资源以及它的实际含义

1974
02:39:19,199 --> 02:39:24,400
它也应该使用 tdd flutter 所以我强烈建议你看看

1975
02:39:24,400 --> 02:39:28,879
在这些资源上，也许在你经历过这个之后

1976
02:39:28,879 --> 02:39:33,275
章节和完成测试的基础知识

1977
02:39:33,275 --> 02:39:38,239
现在，你看我们这门课有时间限制，因为这门课不能去

1978
02:39:38,239 --> 02:39:43,275
先上几百个小时，嗯，因为我可能不会

1979
02:39:43,275 --> 02:39:48,239
能够投入这么多时间，我知道这门课程已经超过 20

1980
02:39:48,239 --> 02:39:53,116
几个小时的时间，但这将花费很多时间

1981
02:39:53,116 --> 02:39:58,239
如果您想涵盖所有内容以及所有不同类型的测试

1982
02:39:58,239 --> 02:40:02,635
为了简单和制作而颤动

1983
02:40:02,635 --> 02:40:06,160
确保您遵循本课程而不会下车并获得

1984
02:40:06,160 --> 02:40:10,080
害怕我们要做的所有测试我会给你喜欢的

1985
02:40:10,080 --> 02:40:13,756
基础知识，我会给你你需要的构建块

1986
02:40:13,756 --> 02:40:17,915
为了以后能够自己进行并编写越来越多的测试

1987
02:40:17,915 --> 02:40:20,319
所以我只知道我们的原因

1988
02:40:20,319 --> 02:40:23,756
将本章专门用于测试是为了确保每个人都理解

1989
02:40:23,756 --> 02:40:28,160
测试非常重要，但我们不会有很多很多

1990
02:40:28,160 --> 02:40:34,796
几个小时只是为了专注于测试虽然这是一个非常重要的主题

1991
02:40:34,796 --> 02:40:40,400
现在让我们谈谈我在结尾中提到的不同类型的测试

1992
02:40:40,400 --> 02:40:44,559
上一章，但我会在这里提一下，以防你跳了

1993
02:40:44,559 --> 02:40:48,635
在我不推荐的那一章，如果你谈论

1994
02:40:48,635 --> 02:40:52,239
Flutter中不同类型的测试你应该知道有单元

1995
02:40:52,239 --> 02:40:57,839
测试小部件测试和集成测试，让我们快速谈谈

1996
02:40:57,839 --> 02:41:02,720
这些不同类型的测试是什么？

1997
02:41:02,720 --> 02:41:05,756
让我们来谈谈类实例的概念假设你已经

1998
02:41:05,756 --> 02:41:10,239
创建了一个名为 auth service 的类，对我们来说就是这种情况，您想要

1999
02:41:10,239 --> 02:41:15,275
为这个类写一些测试现在这个类在它自己的内部是非常孤立的

2000
02:41:15,275 --> 02:41:19,436
自己喜欢它是它有一组功能功能功能，它有一个

2001
02:41:19,436 --> 02:41:22,720
getter 调用当前用户，如果你不记得，让我只是

2002
02:41:22,720 --> 02:41:30,400
把它带到屏幕上，这样你就看得更清楚了，所以让我们去我们的身份验证服务吧

2003
02:41:30,400 --> 02:41:34,796
它符合并实现了 auth 提供者 它有一个构造函数 它有一个

2004
02:41:34,796 --> 02:41:38,160
工厂构造函数也在这里，它具有所有功能

2005
02:41:38,160 --> 02:41:43,360
由身份验证提供程序提供，因为它实现了身份验证提供程序，所以我要

2006
02:41:43,360 --> 02:41:46,319
实际上增加尺寸，以便您看得更清楚

2007
02:41:46,319 --> 02:41:51,756
所以嗯，这是一个独立的单元，所以它是一个

2008
02:41:51,756 --> 02:41:58,400
与身份验证提供程序对话的隔离代码，然后它给了我们

2009
02:41:58,400 --> 02:42:02,480
基本上反映了该作者提供者的功能，其中

2010
02:42:02,480 --> 02:42:06,955
案例是在firebase案例中是firebase auth提供者所以

2011
02:42:06,955 --> 02:42:10,720
它没有太多的功能，但它的功能足够好

2012
02:42:10,720 --> 02:42:13,915
为了对其进行测试，实际上测试它很重要

2013
02:42:13,915 --> 02:42:18,080
确保没有人在没有咨询的情况下无意中更改此代码

2014
02:42:18,080 --> 02:42:22,160
与我们在一起或不喜欢，并确保他们的更改不会中断

2015
02:42:22,160 --> 02:42:25,915
我们的代码，所以这是单元测试，所以你有一个代码单元你有一段

2016
02:42:25,915 --> 02:42:30,796
代码隔离，您想测试那段代码并确保

2017
02:42:30,796 --> 02:42:36,000
该代码中的不同功能正在按应有的方式工作，因此

2018
02:42:36,000 --> 02:42:38,839
就像单元测试的一般概念

2019
02:42:38,839 --> 02:42:45,519
现在是一个小部件测试，顾名思义，它是您作为软件的一种方式

2020
02:42:45,519 --> 02:42:49,436
开发人员，以使其成为您作为软件开发人员的一种方式

2021
02:42:49,436 --> 02:42:54,080
确保您的小部件（如您正在创建的 ui）正在作为轮班工作

2022
02:42:54,080 --> 02:42:59,595
例如，如果您的应用程序中有登录视图

2023
02:42:59,595 --> 02:43:04,720
这个登录视图允许用户点击一个按钮来登录和

2024
02:43:04,720 --> 02:43:07,519
你在用户界面中说没问题，我会确保你一按

2025
02:43:07,519 --> 02:43:11,040
登录按钮，直到用户登录，这

2026
02:43:11,040 --> 02:43:15,360
登录按钮应该被禁用好吧，这是你认为的一段逻辑

2027
02:43:15,360 --> 02:43:18,635
关于好主意，你把代码放在那里

2028
02:43:18,635 --> 02:43:22,080
但是你如何测试它如何确保登录按钮保持不变

2029
02:43:22,080 --> 02:43:27,756
在登录成功之前禁用，这就是小部件测试的用武之地

2030
02:43:27,756 --> 02:43:34,480
玩所以小部件测试有点像端到端测试

2031
02:43:34,480 --> 02:43:40,720
我们的意思是您的小部件可能正在与您的服务和您的

2032
02:43:40,720 --> 02:43:42,955
供应商所以

2033
02:43:42,955 --> 02:43:45,595
您的小部件，例如登录小部件

2034
02:43:45,595 --> 02:43:49,595
或者按下登录按钮后的登录屏幕会调用你的

2035
02:43:49,595 --> 02:43:53,519
服务在这种情况下是身份验证服务，它将进入此登录

2036
02:43:53,519 --> 02:43:57,116
函数这个登录函数又会与提供者交谈

2037
02:43:57,116 --> 02:44:01,595
提供者反过来将与 firebase 代码交谈，而 firebase 代码又将

2038
02:44:01,595 --> 02:44:06,160
与 firebase 后端交谈，以便您看到图层正在堆叠 ui 是

2039
02:44:06,160 --> 02:44:11,595
这里按钮在 ui 上 ui 正在与 auth 服务交谈

2040
02:44:11,595 --> 02:44:16,400
此处身份验证服务正在与提供者正在与之交谈的提供者交谈

2041
02:44:16,400 --> 02:44:19,680
firebase firebase 正在与 firebase 后端对话，也许是后端

2042
02:44:19,680 --> 02:44:22,239
也在与其他一些服务商谈，所以

2043
02:44:22,239 --> 02:44:27,915
这是端对端 这是一端 而另一端就在这里 所以

2044
02:44:27,915 --> 02:44:31,680
您基本上是通过编写小部件测试来进行端到端测试

2045
02:44:31,680 --> 02:44:37,275
一种方法没问题，所以这是小部件测试，其他的东西是集成测试

2046
02:44:37,275 --> 02:44:40,879
您会看到集成测试是您需要的地方

2047
02:44:40,879 --> 02:44:46,000
实例有一个服务，在这种情况下我们有 auth 服务和 auth

2048
02:44:46,000 --> 02:44:50,955
在这种情况下，服务是身份验证服务构造函数或工厂构造函数

2049
02:44:50,955 --> 02:44:56,400
正在与 firebase 交谈，所以如果您以确切的方式测试我们的关闭服务

2050
02:44:56,400 --> 02:44:59,360
你去说 auth service firebase

2051
02:44:59,360 --> 02:45:02,559
然后您针对此身份验证服务发出命令

2052
02:45:02,559 --> 02:45:06,559
firebase 你创建一个用户 你用你注销的用户登录 你发送一个

2053
02:45:06,559 --> 02:45:10,319
电子邮件验证，如果你正在做这些测试，你是

2054
02:45:10,319 --> 02:45:15,116
实际上是在做集成测试，所以你是因为你要确保

2055
02:45:15,116 --> 02:45:19,915
该代码也可以端到端工作，但不涉及用户界面，所以

2056
02:45:19,915 --> 02:45:21,915
呃但是

2057
02:45:21,915 --> 02:45:25,839
我提到我的意思是你现在正在考虑如果测试身份验证服务怎么办

2058
02:45:25,839 --> 02:45:29,275
方式是集成测试你怎么在开头说

2059
02:45:29,275 --> 02:45:32,955
我们要进行单元测试的章节

2060
02:45:32,955 --> 02:45:38,080
这就是我们现在需要讨论的，因为你在这个单元测试中看到

2061
02:45:38,080 --> 02:45:40,796
我们将在本章中进行的练习，我们实际上不会调用

2062
02:45:40,796 --> 02:45:45,756
firebase 我们将调用我们将做一些称为模拟的事情

2063
02:45:45,756 --> 02:45:50,239
我不知道我是否真的在这里提到了一些东西

2064
02:45:50,239 --> 02:45:54,319
是的，我可以看到稍后我实际上要谈论嘲笑

2065
02:45:54,319 --> 02:45:58,000
用英语嘲讽可能意味着你在取笑某人

2066
02:45:58,000 --> 02:46:02,796
不是这个，我们在这里谈论的嘲笑有点像你

2067
02:46:02,796 --> 02:46:08,480
模仿 um 一个真正的服务，所以想象一下你有 auth 服务关闭

2068
02:46:08,480 --> 02:46:12,080
服务有一个火力基地工厂与火力基地对话，它转而与

2069
02:46:12,080 --> 02:46:15,436
firebase 代码，然后与后端对话，我们将摆脱所有

2070
02:46:15,436 --> 02:46:20,239
该管道并说我们将测试服务，但我们将给予

2071
02:46:20,239 --> 02:46:23,915
它是另一个提供者 我们的提供者

2072
02:46:23,915 --> 02:46:28,720
控制你看到火，firebase auth provider里面有很多代码，所以

2073
02:46:28,720 --> 02:46:31,915
我们可以进去让我们进入firebase auth provider

2074
02:46:31,915 --> 02:46:36,480
它直接与 firebase 对话，但如果我们可以创建一个

2075
02:46:36,480 --> 02:46:41,519
auth provider 符合 auth provider 然后写了很多逻辑

2076
02:46:41,519 --> 02:46:46,720
在该身份验证提供程序中并将该作者提供程序提供给身份验证服务

2077
02:46:46,720 --> 02:46:50,879
现在突然之间，我们有了一个身份验证服务，将他的所有任务委托给

2078
02:46:50,879 --> 02:46:54,000
这个模拟嗯

2079
02:46:54,000 --> 02:46:58,559
我们控制其代码的身份验证提供程序，因此我们确切知道登录的内容

2080
02:46:58,559 --> 02:47:01,360
将要做什么 我们确切地知道注销将要做什么或登录并

2081
02:47:01,360 --> 02:47:04,400
根据您喜欢使用的术语锁定它

2082
02:47:04,400 --> 02:47:06,955
所以我们将在本章中做什么

2083
02:47:06,955 --> 02:47:11,360
是在嘲笑，我很快就会解释，所以让我们跳过那个

2084
02:47:11,360 --> 02:47:13,680
现在

2085
02:47:13,680 --> 02:47:16,319
好的嗯

2086
02:47:16,319 --> 02:47:20,480
接下来我们需要讨论的是开发依赖项

2087
02:47:20,480 --> 02:47:24,559
如果您来自节点背景 如果您使用过 nodejs

2088
02:47:24,559 --> 02:47:30,319
或者表达你已经知道 npm 是节点包管理器

2089
02:47:30,319 --> 02:47:34,559
你知道那里有什么开发依赖项

2090
02:47:34,559 --> 02:47:39,756
如果您来自 ios 背景，则对开发人员的依赖并不多

2091
02:47:39,756 --> 02:47:42,480
对你诚实，除非你来自 ios 开发

2092
02:47:42,480 --> 02:47:45,595
背景然后你知道当你编写测试时那些测试框架

2093
02:47:45,595 --> 02:47:50,400
等你带入你的测试目标里面有他们自己的目标所以

2094
02:47:50,400 --> 02:47:54,480
如果您不是来自任何国家，它们不会随最终产品一起发货

2095
02:47:54,480 --> 02:47:57,040
那些背景，你只想知道什么是开发依赖

2096
02:47:57,040 --> 02:48:01,915
现在解释一下，如果我们去

2097
02:48:01,915 --> 02:48:07,199
我们的流行规范 yaml 你会看到我们在这里有一个部分

2098
02:48:07,199 --> 02:48:11,839
称为依赖项，目前我们依赖于各种库

2099
02:48:11,839 --> 02:48:16,319
例如 firebase core firebase auth cloud firestore 和

2100
02:48:16,319 --> 02:48:20,400
firebase 分析这些是我们的依赖项或库

2101
02:48:20,400 --> 02:48:24,080
带入我们的应用程序，如果您认为这是我们的

2102
02:48:24,080 --> 02:48:27,915
应用程序这些是进来的各种库，然后我们在

2103
02:48:27,915 --> 02:48:30,879
结束实际上在这个 um 结束时

2104
02:48:30,879 --> 02:48:34,480
当然我们会把我们的应用程序发送到应用商店和谷歌游戏商店

2105
02:48:34,480 --> 02:48:38,955
当我们创建我们的应用程序以发送到这些各自的商店时，我们

2106
02:48:38,955 --> 02:48:44,160
将应用程序和所有依赖项捆绑在一起并发送

2107
02:48:44,160 --> 02:48:48,635
作为各自 um 的完整二进制文件

2108
02:48:48,635 --> 02:48:52,239
应用商店，但是你也有一个部分在这里

2109
02:48:52,239 --> 02:48:55,756
您的流行规范 yaml 称为 def 依赖项

2110
02:48:55,756 --> 02:49:01,595
现在开发依赖项是您使用并带入您的依赖项

2111
02:49:01,595 --> 02:49:05,040
仅在您的开发过程中应用

2112
02:49:05,040 --> 02:49:08,720
应用程序意味着当您发布您的应用程序时，这是一个使用的术语

2113
02:49:08,720 --> 02:49:10,559
说当你创建

2114
02:49:10,559 --> 02:49:14,160
应用程序并将其发布到相应的应用程序商店，例如

2115
02:49:14,160 --> 02:49:18,080
查看然后这些依赖项实际上并没有打包在你的

2116
02:49:18,080 --> 02:49:22,319
应用程序，因此它们仅在您开发应用程序时位于您的应用程序中

2117
02:49:22,319 --> 02:49:25,519
并且一旦您将其打包并发送以进行发布，那么那些

2118
02:49:25,519 --> 02:49:28,879
依赖项不会被打包到应用程序中

2119
02:49:28,879 --> 02:49:37,756
所以这些是开发依赖项

2120
02:49:37,756 --> 02:49:41,275
现在让我们去我们的

2121
02:49:41,275 --> 02:49:45,436
在这里测试，你可以在这里看到我们需要带

2122
02:49:45,436 --> 02:49:49,360
测试我们的

2123
02:49:49,360 --> 02:49:52,635
进入我们的颤振应用程序，以确保我们可以实际运行我们的测试

2124
02:49:52,635 --> 02:49:56,480
所以你会看到这里已经包含了颤振测试我要给你看

2125
02:49:56,480 --> 02:50:00,000
您需要在终端中发出的命令才能手动执行

2126
02:50:00,000 --> 02:50:02,879
同样，如果我们进入这里并且只是

2127
02:50:02,879 --> 02:50:09,680
输入flutter pop添加测试开发

2128
02:50:09,680 --> 02:50:12,559
好的

2129
02:50:12,559 --> 02:50:18,480
它正在做一个流行音乐到那里好吧这项工作现在完成了现在让我们拥有

2130
02:50:18,480 --> 02:50:22,480
看看这里，你可以看到现在我们有一个开发者

2131
02:50:22,480 --> 02:50:26,720
称为 test 的依赖项，这就是您将其引入应用程序的方式

2132
02:50:26,720 --> 02:50:31,595
这个命令，所以我要再次提出它，这样你就可以看到它颤动 pop add

2133
02:50:31,595 --> 02:50:37,199
测试和破折号开发如果正如我所说，如果你是一个节点

2134
02:50:37,199 --> 02:50:40,796
node.js 开发者，你会从 npm 知道这一点

2135
02:50:40,796 --> 02:50:46,160
d 将其作为开发要求或依赖项添加到您的

2136
02:50:46,160 --> 02:50:50,319
申请所以我不会假设你带来了

2137
02:50:50,319 --> 02:50:53,519
在这个测试包到你的应用程序中，使用我的命令

2138
02:50:53,519 --> 02:50:57,839
在终端中为您提供这里，所以如果您查看您的弹回 yaml

2139
02:50:57,839 --> 02:51:02,239
文件，所以如果您查看您的流行规范 yaml 文件，我将把它记下来

2140
02:51:02,239 --> 02:51:06,480
在 dev 依赖项中，那么你应该只在你的内部有这个测试包

2141
02:51:06,480 --> 02:51:10,160
dev 依赖项，如果您看到它被带入依赖项部分

2142
02:51:10,160 --> 02:51:14,319
不正确它不应该在那里，那是因为你可能错过了

2143
02:51:14,319 --> 02:51:19,915
在你的颤振弹出添加测试命令的末尾添加破折号开发，所以如果

2144
02:51:19,915 --> 02:51:23,360
你这样做然后测试将被添加到

2145
02:51:23,360 --> 02:51:30,000
依赖项，这是不正确的，因此请确保修复该错误

2146
02:51:30,000 --> 02:51:36,720
好的，让我们进入下一部分，如果你提出你的问题，现在就讨论这个

2147
02:51:36,720 --> 02:51:41,116
explorer 你会注意到，如果你去你的测试文件夹，整个测试

2148
02:51:41,116 --> 02:51:45,360
此时文件夹标记为红色，并且

2149
02:51:45,360 --> 02:51:50,000
呃实际上它不像电子邮件那样被标记为红色

2150
02:51:50,000 --> 02:51:54,955
用红色渲染这就是我的意思所以它可能是嗯也许

2151
02:51:54,955 --> 02:52:00,080
以错误的语气听到，所以如果你进去，那个文件夹被读取了，然后

2152
02:52:00,080 --> 02:52:04,160
如果您单击这个称为小部件测试的文件，该文件也是

2153
02:52:04,160 --> 02:52:07,595
red 这里有很多错误实际上没有它有一个错误，因为它正在创建

2154
02:52:07,595 --> 02:52:10,239
有个东西叫我的应用程序

2155
02:52:10,239 --> 02:52:13,915
我们需要在这里做的，因为我们不需要你看到的这个现有的测试

2156
02:52:13,915 --> 02:52:17,839
这个测试是在我们创建我们需要的 Flutter 应用程序时为我们创建的

2157
02:52:17,839 --> 02:52:22,160
摆脱它好吧，让我们进入这里并右键单击它，然后说

2158
02:52:22,160 --> 02:52:27,839
删除并且该文件已经消失了，所以这是我们拥有的第一件事

2159
02:52:27,839 --> 02:52:31,360
在这里做和折叠这个跳跃文件夹

2160
02:52:31,360 --> 02:52:35,040
好吧，现在我们需要在这里做一个标题

2161
02:52:35,040 --> 02:52:40,955
表示我们需要创建一个名为 auth test dot dart 的新文件 OK

2162
02:52:40,955 --> 02:52:47,756
所以让我们继续在测试文件夹下执行此操作

2163
02:52:47,756 --> 02:52:52,480
让我继续，现在在测试文件夹下右键单击并执行此操作

2164
02:52:52,480 --> 02:52:56,480
说新文件，然后取消测试飞镖

2165
02:52:56,480 --> 02:52:59,595
好的

2166
02:52:59,595 --> 02:53:04,635
好的，我们需要在这个关闭测试中做的事情现在开始这个功能

2167
02:53:04,635 --> 02:53:10,635
完全是空的所以让我们先在这里添加一个主函数

2168
02:53:10,635 --> 02:53:14,796
像这样，只要我们在这里添加 main 函数，你就可以看到 dart 是

2169
02:53:14,796 --> 02:53:18,400
足够智能，可以在这里为我们提供运行和调试功能，这就是

2170
02:53:18,400 --> 02:53:22,160
显示在 Visual Studio 代码中我认为 android Studio 也做同样的事情

2171
02:53:22,160 --> 02:53:27,275
我不认为 vim 是可用的，它可能是 vim 是时间和时间

2172
02:53:27,275 --> 02:53:31,680
再次让我惊讶于所有这些令人惊叹的功能

2173
02:53:31,680 --> 02:53:36,239
呃，但取决于工具或文本编辑器或

2174
02:53:36,239 --> 02:53:39,756
您正在使用的 id 可能会有所不同，但不用担心，我们是

2175
02:53:39,756 --> 02:53:43,519
实际上不会点击这些东西，所以如果你没有看到这些东西

2176
02:53:43,519 --> 02:53:47,199
在您的文本编辑器中，您不必担心

2177
02:53:47,199 --> 02:53:49,839
所以现在我们已经完成了

2178
02:53:49,839 --> 02:53:54,400
添加测试包，因为我们已经导入了依赖于我们的测试包

2179
02:53:54,400 --> 02:53:58,400
还需要导入它所以让我们在这里说导入

2180
02:53:58,400 --> 02:54:03,275
并摆脱左侧的这个编辑器抱歉资源管理器，我是

2181
02:54:03,275 --> 02:54:07,116
会说如果我们导入一个名为 test 的包

2182
02:54:07,116 --> 02:54:14,080
里面有一个文件叫做 test start 所以现在我们准备好了

2183
02:54:14,080 --> 02:54:18,319
好吧，现在你明白了

2184
02:54:18,319 --> 02:54:22,720
你可能没有注意到它，但我已经运行了这个应用程序

2185
02:54:22,720 --> 02:54:26,635
在我的实际安卓手机上，就像我们在上一章中所做的那样，所以我从来没有

2186
02:54:26,635 --> 02:54:30,319
无缘无故杀死了这个应用程序，它总是在那个android上运行

2187
02:54:30,319 --> 02:54:36,239
电话我总是可以用 scr cpy 调出它，所以我可以在这里看到

2188
02:54:36,239 --> 02:54:40,239
但是运行没有问题

2189
02:54:40,239 --> 02:54:44,319
记住前面的章节之一 前面的第一章之一

2190
02:54:44,319 --> 02:54:48,635
我们谈到了在我们的应用程序中添加 firebase 我认为这是第五章

2191
02:54:48,635 --> 02:54:53,680
或者六，当我们引入firebase时，我们需要在课程的早期阶段

2192
02:54:53,680 --> 02:54:56,559
我们需要终止应用程序，这意味着我们需要终止

2193
02:54:56,559 --> 02:54:59,756
应用程序并从头开始运行它

2194
02:54:59,756 --> 02:55:03,360
取决于一些依赖实际上不，我不认为这取决于你什么时候

2195
02:55:03,360 --> 02:55:06,879
在您的项目中引入新的依赖项，您需要始终确保

2196
02:55:06,879 --> 02:55:10,796
你重建你的项目，所以你不能做热重载和热重启，因为

2197
02:55:10,796 --> 02:55:14,879
其中一些依赖项实际上需要您的应用程序

2198
02:55:14,879 --> 02:55:18,160
从头开始编译，然后

2199
02:55:18,160 --> 02:55:22,796
然后被带入您的二进制文件，因此不会进行热重载和热重启

2200
02:55:22,796 --> 02:55:26,796
实际上喜欢能够带来那些依赖

2201
02:55:26,796 --> 02:55:30,796
但至少进入你的颤振应用程序所以我需要你做什么

2202
02:55:30,796 --> 02:55:36,879
就是停止执行你的程序然后让我们进去保存这些

2203
02:55:36,879 --> 02:55:42,879
改变然后让我们说 main.dart

2204
02:55:42,879 --> 02:55:47,839
让我们在不调试的情况下运行应用程序，看看这是否

2205
02:55:47,839 --> 02:55:50,955
也将在正确的设备上正确启动应用程序

2206
02:55:50,955 --> 02:55:55,199
我可以看到是的，它将在正确的设备上运行它我更改了

2207
02:55:55,199 --> 02:55:59,436
屏幕布局也在这里

2208
02:55:59,436 --> 02:56:06,400
我们就等着这个毕业带完成它的工作吧

2209
02:56:06,400 --> 02:56:09,595
这可能需要一些时间，具体取决于您对

2210
02:56:09,595 --> 02:56:13,275
在这种情况下，我们为我们的应用程序引入了一个名为 testing 的全新包

2211
02:56:13,275 --> 02:56:16,319
应用程序，所以它需要时间，那就是

2212
02:56:16,319 --> 02:56:20,559
完全没问题

2213
02:56:20,559 --> 02:56:26,319
我现在可以看到它已经运行我们的代码没有问题了

2214
02:56:26,319 --> 02:56:33,116
本章的内容我认为我们不需要带有 scr cpy 的 um 设备 if

2215
02:56:33,116 --> 02:56:36,559
您正在使用 ios 模拟器，如果您使用的是模拟器，我认为您不需要它

2216
02:56:36,559 --> 02:56:39,360
我认为你也不需要它，所以我们可以摆脱它，所以我们不需要

2217
02:56:39,360 --> 02:56:42,239
必须在屏幕上显示它，但请记住我的应用程序仍在运行

2218
02:56:42,239 --> 02:56:44,319
可以，然后呢

2219
02:56:44,319 --> 02:56:48,955
嗯，让我在这里摆脱这个摆脱小部件检查器摆脱

2220
02:56:48,955 --> 02:56:54,955
main dart，让我们在这里访问我们的 auth test dart 文件

2221
02:56:54,955 --> 02:56:59,199
好的，现在我们还需要解决一件事

2222
02:56:59,199 --> 02:57:04,480
在我们开始编写测试之前，这里有这个小功能

2223
02:57:04,480 --> 02:57:11,116
如果我在这里提出关闭用户，我们的 auth 用户中的小家伙

2224
02:57:11,116 --> 02:57:16,080
你会看到它有我们离开的方式是我们添加了一个

2225
02:57:16,080 --> 02:57:21,680
嗯，我们向这个关闭用户的不可变类添加了一个成员变量，这里称为

2226
02:57:21,680 --> 02:57:25,360
已验证的电子邮件以及我们构建此身份验证用户的方式（如果您看到）

2227
02:57:25,360 --> 02:57:30,160
在这里，我们说用户只要给我们这个威廉，所以如果从里面的任何地方

2228
02:57:30,160 --> 02:57:34,080
你的功能，你有

2229
02:57:34,080 --> 02:57:37,199
如果您想从应用程序内部的任何位置创建一个

2230
02:57:37,199 --> 02:57:41,595
关闭用户的实例，您可能会这样做关闭用户，然后您必须

2231
02:57:41,595 --> 02:57:47,040
通过该布尔值已通过电子邮件验证，但是您会看到

2232
02:57:47,040 --> 02:57:50,955
参数没有名字它只是一个真或假

2233
02:57:50,955 --> 02:57:56,239
如果我作为一名程序员看到 auth 用户真明显或假我不明白什么

2234
02:57:56,239 --> 02:58:00,400
这对或错是什么意思这是否意味着身份验证用户

2235
02:58:00,400 --> 02:58:03,680
已开启 已关闭 是什么意思

2236
02:58:03,680 --> 02:58:10,879
因为 dart 能够为您提供所需的命名参数，并且

2237
02:58:10,879 --> 02:58:14,319
意味着您不会在这里传递 true ，而是

2238
02:58:14,319 --> 02:58:21,915
被迫注销用户他的电子邮件验证真假

2239
02:58:21,915 --> 02:58:25,915
所以为了做到这一点，正如标题所示，我们需要去做

2240
02:58:25,915 --> 02:58:29,199
所需的参数，这样做的方法是

2241
02:58:29,199 --> 02:58:33,756
像这样将它包裹在大括号中，然后在它前面加上

2242
02:58:33,756 --> 02:58:38,955
关键字是必需的，所以在你完成那个和这个之后

2243
02:58:38,955 --> 02:58:43,436
功能不再起作用，因为缺少此参数，所以

2244
02:58:43,436 --> 02:58:47,756
它已通过电子邮件验证，我们将通过

2245
02:58:47,756 --> 02:58:51,839
这个值就在那里好吧，让我们移动那个删除

2246
02:58:51,839 --> 02:58:55,436
这个功能，所以现在我们已经实现了我们所说的

2247
02:58:55,436 --> 02:58:58,160
要做

2248
02:58:58,160 --> 02:59:01,595
现在，嗯，因为你知道我们不会，我们会

2249
02:59:01,595 --> 02:59:05,360
实际上，您可能认为没关系，我们已将此参数更改为 required

2250
02:59:05,360 --> 02:59:09,360
那么我们代码中的所有错误都在哪里，为什么没有任何错误，这就是一个

2251
02:59:09,360 --> 02:59:13,116
到目前为止我们所做的一切以及我们已经抽象出来的美好事物

2252
02:59:13,116 --> 02:59:18,720
很多代码，现在代码更加健壮了，因为在我们的内部没有任何地方

2253
02:59:18,720 --> 02:59:24,319
应用程序我们实际上是在创建我们的用户，除了这个工厂函数

2254
02:59:24,319 --> 02:59:28,400
我们唯一需要解决的地方是电子邮件验证是在这个工厂内

2255
02:59:28,400 --> 02:59:31,680
功能对我来说很美，因为

2256
02:59:31,680 --> 02:59:36,720
通过将必需的参数添加到它没有的类来做类似激烈的事情

2257
02:59:36,720 --> 02:59:42,796
打破任何东西，所以我们很好

2258
02:59:42,796 --> 02:59:47,199
好吧，嗯，这就是我提到的重点

2259
02:59:47,199 --> 02:59:52,879
以前我们需要一个模拟供应商

2260
02:59:52,879 --> 02:59:57,595
为了做一个模拟作者提供者，我需要更多地了解什么

2261
02:59:57,595 --> 03:00:02,239
模拟是以及为什么我们需要它们，你在软件中看到

2262
03:00:02,239 --> 03:00:06,720
我们在测试方面尤其如此，甚至在应用程序架构级别或

2263
03:00:06,720 --> 03:00:10,720
软件架构师架构级别我们有一种称为依赖关系的东西

2264
03:00:10,720 --> 03:00:14,000
注入依赖注入

2265
03:00:14,000 --> 03:00:18,559
只是快速解释一下它与我们的身份验证服务非常相似让我们有一个

2266
03:00:18,559 --> 03:00:24,559
在这里查看我们的关闭服务，您看到关闭服务取决于身份验证提供程序

2267
03:00:24,559 --> 03:00:30,080
这不仅仅是假设它的身份验证提供者总是火力基地

2268
03:00:30,080 --> 03:00:34,879
它为firebase提供了一个工厂，但它没有对此做出假设

2269
03:00:34,879 --> 03:00:38,559
嘿，我总是被锁定到 firebase auth provider

2270
03:00:38,559 --> 03:00:43,680
这是依赖注入，所以这个关闭服务依赖于使用的提供者

2271
03:00:43,680 --> 03:00:47,275
我们是一个常量构造函数初始化器

2272
03:00:47,275 --> 03:00:50,879
将提供者注入其中

2273
03:00:50,879 --> 03:00:55,040
简而言之就是软件开发中的依赖注入

2274
03:00:55,040 --> 03:00:58,559
您可以详细了解它，但我们没有时间

2275
03:00:58,559 --> 03:01:03,436
嗯，所以什么是模拟，模拟非常

2276
03:01:03,436 --> 03:01:07,040
非常好地与依赖注入携手并进

2277
03:01:07,040 --> 03:01:11,360
在这种情况下，您可以看到我们有一个关闭服务正在镜像

2278
03:01:11,360 --> 03:01:15,680
您可以注入其提供者的功能

2279
03:01:15,680 --> 03:01:17,915
但是我们在

2280
03:01:17,915 --> 03:01:22,000
时刻被称为 firebase 如果我们创建一个

2281
03:01:22,000 --> 03:01:27,595
我们可以完全控制的全新供应商

2282
03:01:27,595 --> 03:01:32,000
确保它符合并实现身份验证提供程序，我们可以确保

2283
03:01:32,000 --> 03:01:35,756
它实现了身份验证提供者实现的所有功能

2284
03:01:35,756 --> 03:01:40,955
并覆盖所有这些，但我们自己有一些特殊的逻辑

2285
03:01:40,955 --> 03:01:45,915
模拟身份验证提供程序，然后我们将将此身份验证提供程序提供给

2286
03:01:45,915 --> 03:01:51,436
我们的 auth 服务，然后让 auth 服务发挥它的魔力，并镜像所有

2287
03:01:51,436 --> 03:01:58,000
提供者的那些功能，所以我们要模拟一个关闭的提供者和

2288
03:01:58,000 --> 03:02:03,519
将其提供到我们的身份验证服务中，这就是模拟的时候

2289
03:02:03,519 --> 03:02:09,680
当你创建一个新函数或一个类然后你

2290
03:02:09,680 --> 03:02:13,116
然后可以将其注入另一个

2291
03:02:13,116 --> 03:02:18,400
放置然后测试另一个地方好吗

2292
03:02:18,400 --> 03:02:22,879
所以让我们进入我们在这里的非测试飞镖文件，我要去

2293
03:02:22,879 --> 03:02:31,275
command 就可以了，让我们去创建我们的小东西，就像模拟提供者一样

2294
03:02:31,275 --> 03:02:35,839
所以我要进去，我只想说类模拟提供者和

2295
03:02:35,839 --> 03:02:39,915
建议你做同样的事情，这家伙会实施

2296
03:02:39,915 --> 03:02:44,955
嗯，身份验证提供程序可以自动导入

2297
03:02:44,955 --> 03:02:48,720
我们还好就这样

2298
03:02:48,720 --> 03:02:51,595
现在我们需要做的就是得到

2299
03:02:51,595 --> 03:02:55,519
模拟提供程序以实现所有功能

2300
03:02:55,519 --> 03:03:00,160
身份验证提供程序应用程序抽象类要求我们实现，所以我

2301
03:03:00,160 --> 03:03:04,955
去命令 dot 并恭敬地询问 Visual Studio 代码

2302
03:03:04,955 --> 03:03:09,275
创建这六个缺失的覆盖非常感谢 Visual Studio 代码

2303
03:03:09,275 --> 03:03:14,160
让我们的生活更轻松好吗

2304
03:03:14,160 --> 03:03:19,519
现在我们需要做的就是完成这个模拟身份验证提供者的繁重工作

2305
03:03:19,519 --> 03:03:25,595
这意味着继续为身份验证提供程序创建功能

2306
03:03:25,595 --> 03:03:28,480
我知道代码现在完全是巨大的，所以我要

2307
03:03:28,480 --> 03:03:32,080
稍微减小尺寸，以便您看到更多代码

2308
03:03:32,080 --> 03:03:37,680
所以让我们继续处理这里的第一个函数，即 create

2309
03:03:37,680 --> 03:03:41,040
用户好，现在你看到了

2310
03:03:41,040 --> 03:03:45,040
我们要做的是如果你记得

2311
03:03:45,040 --> 03:03:50,000
我们的身份验证提供程序有一个名为 initialize all 的函数

2312
03:03:50,000 --> 03:03:53,680
现在当我们在

2313
03:03:53,680 --> 03:03:59,519
firebase 的上下文 firebase 内部有这个概念

2314
03:03:59,519 --> 03:04:03,519
是否已初始化，但是当我们创建模拟身份验证时

2315
03:04:03,519 --> 03:04:09,040
提供者在哪里我们还没有跟踪我们的模拟功能是否

2316
03:04:09,040 --> 03:04:12,160
身份验证提供程序是否实际初始化

2317
03:04:12,160 --> 03:04:18,720
我们只有一个初始化函数，但是如果有人调用 create user on

2318
03:04:18,720 --> 03:04:24,400
我们的模拟身份验证提供者还没有初始化提供者，那就是

2319
03:04:24,400 --> 03:04:29,199
我们现在需要做什么，所以让我们继续跟踪它

2320
03:04:29,199 --> 03:04:34,160
所以我们在这里要做的是我们只是说 var 已初始化

2321
03:04:34,160 --> 03:04:39,519
以ok开头是错误的，我说下划线的原因是

2322
03:04:39,519 --> 03:04:44,480
初始化是因为嗯，这几乎使这个属性

2323
03:04:44,480 --> 03:04:49,199
对我们的模拟提供商私有，因此我们向外界表明

2324
03:04:49,199 --> 03:04:52,559
嘿，您不应该从此属性中读取或写入此属性

2325
03:04:52,559 --> 03:04:55,680
财产

2326
03:04:55,680 --> 03:05:00,635
好的，现在完成了，让我们为这个属性创建一个小吸气剂，这样

2327
03:05:00,635 --> 03:05:05,680
当我们测试我们的模拟身份验证提供程序时，我们实际上可以说

2328
03:05:05,680 --> 03:05:10,319
嘿，你初始化了吗，我们还可以为模拟创建一个测试

2329
03:05:10,319 --> 03:05:14,559
我们实际上要做的身份验证提供程序是在我们创建

2330
03:05:14,559 --> 03:05:19,199
模拟身份验证提供程序最初不应初始化，但之后

2331
03:05:19,199 --> 03:05:24,000
对其调用初始化然后我们进行测试以确保初始化标志

2332
03:05:24,000 --> 03:05:28,319
设置为 true 所以让我们为了做到这一点，我们需要能够阅读这是

2333
03:05:28,319 --> 03:05:32,879
初始化标志让我们继续为它创建一个布尔 getter，我们称之为

2334
03:05:32,879 --> 03:05:38,080
它已初始化它已初始化，我们只是返回

2335
03:05:38,080 --> 03:05:41,680
在那里初始化

2336
03:05:41,680 --> 03:05:46,080
好吧，现在让我们进入我们的创建用户我是

2337
03:05:46,080 --> 03:05:49,199
将在该参数的末尾添加一个逗号我也将采用

2338
03:05:49,199 --> 03:05:52,955
在登录结束时自由创建和添加逗号

2339
03:05:52,955 --> 03:05:57,839
功能，这是仅有的两个地方

2340
03:05:57,839 --> 03:06:01,436
这需要在其参数列表的末尾有一个逗号，所以现在飞镖

2341
03:06:01,436 --> 03:06:06,319
格式化程序能够更好地格式化代码

2342
03:06:06,319 --> 03:06:11,680
好吧，让我们去创建用户现在你在创建用户中看到我几乎

2343
03:06:11,680 --> 03:06:14,796
我们在这里编写的这些功能，例如登录发送电子邮件

2344
03:06:14,796 --> 03:06:20,080
验证我们需要确保这个模拟身份验证提供程序已经

2345
03:06:20,080 --> 03:06:24,796
初始化，所以如果你调用这些，我们实际上会抛出一个异常

2346
03:06:24,796 --> 03:06:29,040
需要初始化而没有初始化模拟身份验证的函数

2347
03:06:29,040 --> 03:06:36,720
首先提供者，所以让我们在这里定义一个 um 一个异常

2348
03:06:36,720 --> 03:06:40,720
所以让我看看我是否把它写在某个地方

2349
03:06:40,720 --> 03:06:45,275
不，所以让我们进去，只是说上课

2350
03:06:45,275 --> 03:06:49,275
非迷你初始化异常

2351
03:06:49,275 --> 03:06:53,199
实现异常，所以你应该知道这一点

2352
03:06:53,199 --> 03:06:56,955
之前和现在是空的

2353
03:06:56,955 --> 03:07:00,955
好的，所以我们需要在这里做的，我们需要

2354
03:07:00,955 --> 03:07:06,879
只是说如果它没有被初始化就被初始化

2355
03:07:06,879 --> 03:07:11,756
然后抛出未初始化的异常

2356
03:07:11,756 --> 03:07:14,080
好的

2357
03:07:14,080 --> 03:07:17,595
所以这是一个 if 语句它是一个单行这就是为什么我们不真的

2358
03:07:17,595 --> 03:07:20,796
在这里打破它，否则你把花括号放在这里然后做

2359
03:07:20,796 --> 03:07:24,635
扔在那里，但如果仅此而已，您也可以使用单行 if 语句

2360
03:07:24,635 --> 03:07:28,000
如果这就是你正在做的只是一行代码

2361
03:07:28,000 --> 03:07:31,519
好吧，老实说，我有点喜欢这些单行 if 语句

2362
03:07:31,519 --> 03:07:36,720
如果没有初始化模拟身份验证提供程序，我希望你能得到这个

2363
03:07:36,720 --> 03:07:41,756
抛出那个特殊的异常，我们要做的就是我们

2364
03:07:41,756 --> 03:07:46,080
假装创建用户好吧，所以我们只想说

2365
03:07:46,080 --> 03:07:50,080
例如，如果您在 firebase 上调用 create 用户，它可能需要执行

2366
03:07:50,080 --> 03:07:54,160
与firebase后端交谈，所以这需要一些时间，所以让我们构建

2367
03:07:54,160 --> 03:07:58,879
在这里稍等一下，我们要做的就是

2368
03:07:58,879 --> 03:08:02,559
说未来并删除

2369
03:08:02,559 --> 03:08:06,400
在这里你必须将持续时间传递给它，所以我们说 const duration

2370
03:08:06,400 --> 03:08:11,199
秒，他们做到了

2371
03:08:11,199 --> 03:08:17,275
我相信就是这样让我们在这里说一个并记住

2372
03:08:17,275 --> 03:08:22,559
如果我去移动它的未来延迟它是一个函数签名它返回一个

2373
03:08:22,559 --> 03:08:27,839
动态的未来，所以通过创造一个未来，你实际上并没有在等待它

2374
03:08:27,839 --> 03:08:32,839
所以让我们将我们的函数标记为异步，让我们等待它

2375
03:08:32,839 --> 03:08:40,000
好的，现在要做的是确保

2376
03:08:40,000 --> 03:08:43,360
嗯，这个创建用户实际上返回了一个

2377
03:08:43,360 --> 03:08:48,480
作者用户，但也记得在 firebase 嗯，或者我实际上不知道是否

2378
03:08:48,480 --> 03:08:52,400
firebase 是这样工作的，但是通过创建一个用户我们要做什么

2379
03:08:52,400 --> 03:08:58,796
在我们的模拟身份验证提供程序中，实际上该用户也可以登录

2380
03:08:58,796 --> 03:09:02,080
所以假设你看到登录返回

2381
03:09:02,080 --> 03:09:06,635
也是 auth 用户的未来，所以在这个创建用户结束时，我们将

2382
03:09:06,635 --> 03:09:10,080
让我们的生活更轻松，只返回登录结果，所以让我们

2383
03:09:10,080 --> 03:09:12,720
说返回并登录

2384
03:09:12,720 --> 03:09:17,595
当此电子邮件和密码正常时

2385
03:09:17,595 --> 03:09:23,040
所以这是一个非常愚蠢且非常简单的创建用户的模拟实现

2386
03:09:23,040 --> 03:09:27,756
它本身会做三件事检查以确保您已初始化，如果

2387
03:09:27,756 --> 03:09:30,879
你没有初始化它会引发异常

2388
03:09:30,879 --> 03:09:37,436
它做了一个模拟呃一秒钟的等待只是为了喜欢假的做一个 api 调用和

2389
03:09:37,436 --> 03:09:40,955
它所做的第三件事是它以相同的方式调用登录函数

2390
03:09:40,955 --> 03:09:45,519
邮箱和密码，并返回登录结果，以便获取

2391
03:09:45,519 --> 03:09:49,275
它的关闭用户

2392
03:09:49,275 --> 03:09:54,559
好的，现在我们需要模拟当前用户，所以

2393
03:09:54,559 --> 03:09:59,040
我们如何做到这一点 我们如何获得您看到的当前用户

2394
03:09:59,040 --> 03:10:03,199
firebase 有能力跟踪当前用户，但我们该怎么做

2395
03:10:03,199 --> 03:10:07,275
我们现在不能把这个功能委托给firebase，所以

2396
03:10:07,275 --> 03:10:12,796
我们还需要在这里创建一个身份验证用户，所以让我们去阻止模拟身份验证

2397
03:10:12,796 --> 03:10:17,915
提供者就在那里被初始化或低于它没有

2398
03:10:17,915 --> 03:10:22,319
重要的地方我会在上面做我会说用户

2399
03:10:22,319 --> 03:10:27,040
像这样，如果你做一个飞镖，你会在远处看到

2400
03:10:27,040 --> 03:10:32,400
成员变量默认情况下是可选的，它是空的，所以它没有值，所以你不要

2401
03:10:32,400 --> 03:10:35,915
必须真的去说不，你可以看到它说不明确

2402
03:10:35,915 --> 03:10:40,635
将变量初始化为不好的分析器

2403
03:10:40,635 --> 03:10:44,000
我没有我们要在内部管理的用户，我是

2404
03:10:44,000 --> 03:10:48,796
实际上要用下划线作为前缀，以便将其标记为

2405
03:10:48,796 --> 03:10:52,080
私有函数作为私有成员变量

2406
03:10:52,080 --> 03:10:59,595
然后在当前用户中简单地返回该用户，这样就可以了

2407
03:10:59,595 --> 03:11:01,595
现在完美

2408
03:11:01,595 --> 03:11:06,160
我们需要去处理初始化函数让我们看看我们是否可以

2409
03:11:06,160 --> 03:11:11,040
找到它登录这里是初始化

2410
03:11:11,040 --> 03:11:12,955
所以我们唯一要做的

2411
03:11:12,955 --> 03:11:18,239
我们要假装等待的初始化器，只需等待一秒钟

2412
03:11:18,239 --> 03:11:25,519
然后将 r 初始化标志设置为 true 所以让我们获取这个权重代码

2413
03:11:25,519 --> 03:11:30,319
从我们的创建用户函数中，然后将其初始化，然后说

2414
03:11:30,319 --> 03:11:34,000
等待并使您的函数异步，然后我们将

2415
03:11:34,000 --> 03:11:37,360
等等，我们只是说初始化

2416
03:11:37,360 --> 03:11:43,519
是真的，所以这很容易

2417
03:11:43,519 --> 03:11:48,635
那么我们的模拟作者提供者中最丰富的部分实际上是

2418
03:11:48,635 --> 03:11:54,080
登录功能，因为它不是在登录，而是在登录

2419
03:11:54,080 --> 03:11:58,635
注册函数正在使用的函数还是我们说的创建

2420
03:11:58,635 --> 03:12:02,239
用户创建用户，因此功能也是

2421
03:12:02,239 --> 03:12:05,756
记录它正在调用登录功能，所以我们

2422
03:12:05,756 --> 03:12:10,239
需要真正测试此功能以确保其正常工作

2423
03:12:10,239 --> 03:12:13,839
正如我之前在大多数这些功能中提到的，当我们需要确保

2424
03:12:13,839 --> 03:12:17,436
我们的模拟身份验证提供程序在调用这些函数之前进行初始化

2425
03:12:17,436 --> 03:12:22,796
他们所以让我们去抓取这段代码，你会看到它说是否已初始化并带来

2426
03:12:22,796 --> 03:12:27,839
该代码也在我们的登录功能中，所以这是我们要做的第一件事

2427
03:12:27,839 --> 03:12:30,879
现在要做

2428
03:12:30,879 --> 03:12:36,319
我们还将在登录功能中构建一些虚假功能

2429
03:12:36,319 --> 03:12:40,879
只是这样我们就可以为他们编写测试，因为你在现实世界中看到你

2430
03:12:40,879 --> 03:12:45,116
可能有很多很多真实的逻辑

2431
03:12:45,116 --> 03:12:49,915
在您的身份验证提供商和身份验证服务中，但我们没有那么真实

2432
03:12:49,915 --> 03:12:53,519
现在的逻辑，因为我们的应用程序现在非常小，所以我们要

2433
03:12:53,519 --> 03:12:58,559
在我们的 mod 提供程序中构建一些虚假功能，然后在我们的模拟中抱歉

2434
03:12:58,559 --> 03:13:03,040
身份验证提供程序，然后我们将编写测试来测试那些

2435
03:13:03,040 --> 03:13:07,519
场景，以便您了解模拟，您还将了解编写测试

2436
03:13:07,519 --> 03:13:12,000
对于那些模拟，这就是本章的全部目的

2437
03:13:12,000 --> 03:13:14,720
所以我们接下来要做的是

2438
03:13:14,720 --> 03:13:18,319
会说如果和所以我们要编一个电子邮件

2439
03:13:18,319 --> 03:13:21,519
我们不喜欢我们会说如果电子邮件是

2440
03:13:21,519 --> 03:13:27,595
嗯 fooatvar.com 然后抛出用户未找到异常好吗

2441
03:13:27,595 --> 03:13:31,275
因此，如果您尝试使用此电子邮件地址登录，我们只会说用户

2442
03:13:31,275 --> 03:13:36,635
没有找到好的，如果密码

2443
03:13:36,635 --> 03:13:40,879
与 foobar 密码不同的是 foobar

2444
03:13:40,879 --> 03:13:46,796
我们会说从异常中抛出错误的密码所以

2445
03:13:46,796 --> 03:13:51,275
记住登录本身，如果我们去我们的

2446
03:13:51,275 --> 03:13:56,400
firebase auth provider 所以去这个文件 firebase auth provider dart 它有

2447
03:13:56,400 --> 03:14:00,239
那些功能，例如，如果您查看登录信息，它具有功能

2448
03:14:00,239 --> 03:14:03,915
像处理用户未找到错误密码通用身份验证异常等

2449
03:14:03,915 --> 03:14:07,116
我们正在做的是我们正在创建某种类似的模拟

2450
03:14:07,116 --> 03:14:12,000
但我们将其锁定到特定的电子邮件和密码

2451
03:14:12,000 --> 03:14:16,319
好的，这是密码，我们不喜欢 bar.com 上 foo 的电子邮件，我们

2452
03:14:16,319 --> 03:14:21,199
现在不喜欢 foobar 的密码

2453
03:14:21,199 --> 03:14:24,559
我们现在也将在这里删除未实现的错误

2454
03:14:24,559 --> 03:14:30,000
案例让我们创建一个用户，所以我们会说用户是和关闭用户

2455
03:14:30,000 --> 03:14:34,720
并且它是电子邮件验证我们只是说真或者我们只是说假所以我们

2456
03:14:34,720 --> 03:14:39,116
说当您尝试登录时，我们只是说电子邮件验证是错误的

2457
03:14:39,116 --> 03:14:42,879
现在我们已经创建了一个用户，让我们将它分配给我们的用户

2458
03:14:42,879 --> 03:14:46,559
像这样，因为记住我们有一个名为的私有字段

2459
03:14:46,559 --> 03:14:52,239
下划线用户，我们只是这样保持它

2460
03:14:52,239 --> 03:14:56,400
然后我们会这样做，因为记住我们需要返回该身份验证的未来

2461
03:14:56,400 --> 03:15:05,680
用户然后我们说返回值等于我们的用户这样的未来

2462
03:15:05,680 --> 03:15:10,635
这就是我们的登录功能

2463
03:15:10,635 --> 03:15:14,480
所以这是相当多的工作，但我认为

2464
03:15:14,480 --> 03:15:19,275
希望你能理解我们在那里所做的事情

2465
03:15:19,275 --> 03:15:23,839
现在我们必须看看注销功能，注销功能将有

2466
03:15:23,839 --> 03:15:28,796
还有一些代码，所以嗯，它不仅仅是会说好的，我

2467
03:15:28,796 --> 03:15:32,239
正如我之前提到的那样注销，我们需要确保

2468
03:15:32,239 --> 03:15:35,915
模拟提供程序已初始化，因此让我们将代码带入此处

2469
03:15:35,915 --> 03:15:40,635
繁荣好吧，我们还需要确保如果你想注销你已经

2470
03:15:40,635 --> 03:15:44,239
实际上之前登录过所以让我们说如果

2471
03:15:44,239 --> 03:15:49,839
嗯，如果用户为空，我能找到我的钥匙吗

2472
03:15:49,839 --> 03:15:55,915
然后抛出 uh user not found off 异常好吗

2473
03:15:55,915 --> 03:15:59,199
否则我们要做的就是等待

2474
03:15:59,199 --> 03:16:04,080
所以让我们在假装等待之前找到一个等待代码

2475
03:16:04,080 --> 03:16:09,839
只需一秒钟，我们也将设置我们的用户

2476
03:16:09,839 --> 03:16:13,839
为 null 我们只是说当前用户不是你可以看到的

2477
03:16:13,839 --> 03:16:18,239
抱怨我们正在使用重量但让我在这里说

2478
03:16:18,239 --> 03:16:21,595
就像那样异步然后错误消失

2479
03:16:21,595 --> 03:16:26,480
因为如果您将注销功能标记为异步，那么您可以等待未来

2480
03:16:26,480 --> 03:16:30,559
注销也很容易说我是否已初始化

2481
03:16:30,559 --> 03:16:34,480
为了让我退出，需要有一个用户，然后我要

2482
03:16:34,480 --> 03:16:38,559
假等待一秒钟，然后我将该用户设置为 null 如此简单的 pc

2483
03:16:38,559 --> 03:16:41,040
好的

2484
03:16:41,040 --> 03:16:45,680
现在让我们模拟我们的电子邮件验证码

2485
03:16:45,680 --> 03:16:49,116
所以同样的事情所以你现在应该熟悉这个让我们确保

2486
03:16:49,116 --> 03:16:52,955
我们已经初始化了，我要从房间里获取一个代码

2487
03:16:52,955 --> 03:16:55,275
未实现的错误实际上让我们离开它

2488
03:16:55,275 --> 03:16:58,720
至少现在让我们把它放在那里好吧

2489
03:16:58,720 --> 03:17:03,360
然后在发送电子邮件验证期间

2490
03:17:03,360 --> 03:17:08,080
我们要做的是你看到当我们登录时我们说呃让我们有一个

2491
03:17:08,080 --> 03:17:11,680
看我们说的登录默认用户邮箱验证的邮箱

2492
03:17:11,680 --> 03:17:16,160
是错误的，但在发送发送电子邮件验证后，我们将翻转

2493
03:17:16,160 --> 03:17:19,436
突然间我要在你的电子邮件之外说“哦”的那面旗帜

2494
03:17:19,436 --> 03:17:22,635
验证了哪个不太现实但

2495
03:17:22,635 --> 03:17:27,116
这就是我们现在正在嘲笑的逻辑，好吧，记住一个身份验证

2496
03:17:27,116 --> 03:17:29,519
用户呃在这里

2497
03:17:29,519 --> 03:17:35,275
有一个并且它的电子邮件已验证它像你一样只读它是一个常数你不能

2498
03:17:35,275 --> 03:17:39,275
改变它只是因为我们有一个可选用户

2499
03:17:39,275 --> 03:17:43,116
我们的模拟身份验证提供者并不意味着我们可以直接说用户是

2500
03:17:43,116 --> 03:17:48,400
email 验证为 true 我们无法写入，因此我们需要重写整个用户

2501
03:17:48,400 --> 03:17:50,955
可以，然后呢

2502
03:17:50,955 --> 03:17:55,839
在检查您是否已初始化之后，我们正在做的就是说

2503
03:17:55,839 --> 03:17:59,680
如果让我们让用户真正成为最终用户

2504
03:17:59,680 --> 03:18:03,436
这是让我们获取您当前的用户，然后我们

2505
03:18:03,436 --> 03:18:10,480
说如果用户为空并抛出用户未找到所以我们的

2506
03:18:10,480 --> 03:18:14,400
发送电子邮件验证码确保您已登录

2507
03:18:14,400 --> 03:18:17,680
在您发送电子邮件验证或至少您注册之前

2508
03:18:17,680 --> 03:18:21,040
你的用户还好，嗯

2509
03:18:21,040 --> 03:18:24,955
好的，那么我们要做的是创建

2510
03:18:24,955 --> 03:18:29,199
一个新用户我们说新用户是一个关闭用户并且他的电子邮件验证是真实的

2511
03:18:29,199 --> 03:18:33,839
这一次，然后我们将其设置为我们的当前用户，所以我们说当前用户

2512
03:18:33,839 --> 03:18:39,199
是新用户，然后我们将其删除并制作

2513
03:18:39,199 --> 03:18:44,400
我们确定我们的代码也是异步的

2514
03:18:44,400 --> 03:18:47,595
这是用于发送电子邮件和验证

2515
03:18:47,595 --> 03:18:50,879
所以你看确实需要一段时间，但实际上我们已经

2516
03:18:50,879 --> 03:18:55,436
现在编写了一个模拟身份验证提供程序，它有自己的代码并且有自己的

2517
03:18:55,436 --> 03:19:00,000
初始化等好吧，现在我们需要做的是

2518
03:19:00,000 --> 03:19:06,000
实际上谈论测试所以嗯

2519
03:19:06,000 --> 03:19:12,080
让我们看看是的，嗯，什么是测试组，什么是

2520
03:19:12,080 --> 03:19:16,955
测试你看到如果你认为测试是或至少

2521
03:19:16,955 --> 03:19:22,160
单元测试作为测试其他代码段的代码段

2522
03:19:22,160 --> 03:19:26,080
你可能认为好吧，我要为创建用户写一个测试

2523
03:19:26,080 --> 03:19:29,839
在这里，我要为当前用户编写一个测试，我要为其编写测试

2524
03:19:29,839 --> 03:19:34,000
初始化登录等等等等现在所有这些都是常见的并且他们很友善

2525
03:19:34,000 --> 03:19:39,040
相关的，他们都在测试模拟身份验证提供程序，这就是测试组

2526
03:19:39,040 --> 03:19:45,360
在你的测试功能中为你的测试和测试套件中的颤振抱歉

2527
03:19:45,360 --> 03:19:50,239
佛罗里达，您实际上可以将您的测试功能分组到一个具有

2528
03:19:50,239 --> 03:19:55,436
name 然后你可以让 Flutter 为你运行整个测试组

2529
03:19:55,436 --> 03:20:02,160
这就是测试组的用途，所以现在我们需要做的是进入

2530
03:20:02,160 --> 03:20:07,275
我们的主要测试功能就在那里，基本上创建一个组，然后添加

2531
03:20:07,275 --> 03:20:12,955
provider 里面，所以让我们继续，然后输入 group

2532
03:20:12,955 --> 03:20:17,595
在这里我们只是说模拟身份验证没问题

2533
03:20:17,595 --> 03:20:20,955
让我们在这里将第二个参数作为函数

2534
03:20:20,955 --> 03:20:23,915
就像那样，现在你应该有这样的代码，所以基本上你

2535
03:20:23,915 --> 03:20:28,000
创建了一个测试组，你可以看到 Visual Studio 代码告诉我哦

2536
03:20:28,000 --> 03:20:32,160
你可以运行这个组，所以我们要把我们所有的模拟

2537
03:20:32,160 --> 03:20:36,239
该组内的身份验证测试可以

2538
03:20:36,239 --> 03:20:40,559
正如标题所说，我们要做的第一件事就是创建我们的

2539
03:20:40,559 --> 03:20:46,319
我们的模拟 aus 提供者的一个实例，所以让我们继续说一个 final

2540
03:20:46,319 --> 03:20:51,199
提供者就是这样的模拟提供者

2541
03:20:51,199 --> 03:20:53,360
可以，然后呢

2542
03:20:53,360 --> 03:20:57,595
现在我们有了，所以现在我们要开始多汁的部分了

2543
03:20:57,595 --> 03:21:00,239
我对此感到非常高兴，因为我们已经做了很多基础工作

2544
03:21:00,239 --> 03:21:02,879
只是为了本章的这一点

2545
03:21:02,879 --> 03:21:07,199
所以现在我们要写我们的第一个测试，你可以看到标题说测试

2546
03:21:07,199 --> 03:21:11,116
提供者被初始化 提供者不应该被初始化开始

2547
03:21:11,116 --> 03:21:14,239
你看我们从一个

2548
03:21:14,239 --> 03:21:18,720
一个断言，我们说根据我们的实现方式，我们已经

2549
03:21:18,720 --> 03:21:23,680
实现了我们的模拟身份验证提供程序，它不应该被初始化

2550
03:21:23,680 --> 03:21:26,879
所以我们只是通过创建一个模拟身份验证实例来确保

2551
03:21:26,879 --> 03:21:31,275
提供者它被初始化为布尔 getter

2552
03:21:31,275 --> 03:21:36,080
应该返回 false 如果它返回 true 我们将失败我们的测试所以

2553
03:21:36,080 --> 03:21:39,360
这意味着如果有人稍后偷偷进入代码并说哦

2554
03:21:39,360 --> 03:21:43,116
默认情况下这是真的，那么测试将失败，所有开发人员都在

2555
03:21:43,116 --> 03:21:46,319
团队会收到通知的

2556
03:21:46,319 --> 03:21:50,000
所以让我们创建我们的第一个测试方法

2557
03:21:50,000 --> 03:21:54,400
在颤振中创建测试是你开始输入测试好了

2558
03:21:54,400 --> 03:21:58,080
在这种情况下你给它起个名字我会说不应该

2559
03:21:58,080 --> 03:22:03,915
被初始化为以ok开头，所以这就是名字，然后你会

2560
03:22:03,915 --> 03:22:08,160
为它提供一个在进行测试时执行的函数

2561
03:22:08,160 --> 03:22:13,116
在这里你可以说你可以使用一个名为expect的函数

2562
03:22:13,116 --> 03:22:18,239
你说作家提供者已初始化

2563
03:22:18,239 --> 03:22:23,360
一开始就应该是假的 所以

2564
03:22:23,360 --> 03:22:28,400
这是我们编写的第一个测试，所以测试函数然后你写一个名字

2565
03:22:28,400 --> 03:22:33,595
然后它是一个要执行的函数，在那里你可以使用各种风格的

2566
03:22:33,595 --> 03:22:38,635
期望功能，你会看到期望有各种不同的风格

2567
03:22:38,635 --> 03:22:41,199
所以现在我们只期待简单的

2568
03:22:41,199 --> 03:22:46,160
初始化标志为假好的

2569
03:22:46,160 --> 03:22:52,879
现在我们必须做的下一个测试是字幕案例测试记录

2570
03:22:52,879 --> 03:22:57,360
在初始化之前，提供者应该抛出而不是初始化

2571
03:22:57,360 --> 03:22:59,756
例外所以

2572
03:22:59,756 --> 03:23:03,756
基本上我们所说的是根据注销功能

2573
03:23:03,756 --> 03:23:07,756
如果它没有首先初始化，则应该无法注销，所以我们实际上是

2574
03:23:07,756 --> 03:23:11,915
测试这行代码没问题，以确保没有人只是无意

2575
03:23:11,915 --> 03:23:16,000
将其注释掉或无意中删除了我们不需要的所有内容

2576
03:23:16,000 --> 03:23:21,199
对，所以让我们测试一下功能，所以让我们说测试我

2577
03:23:21,199 --> 03:23:24,239
去看看我的笔记，看看我在那里命名了什么

2578
03:23:24,239 --> 03:23:28,319
如果没有初始化就无法注销，现在你知道了

2579
03:23:28,319 --> 03:23:31,595
作为测试功能的第二个参数，您需要提供一个功能

2580
03:23:31,595 --> 03:23:34,160
所以呃括号

2581
03:23:34,160 --> 03:23:38,559
然后是大括号，在这里我们要说

2582
03:23:38,559 --> 03:23:42,559
期待，现在我们正在使用这种新风格

2583
03:23:42,559 --> 03:23:46,239
期望在这里我只想说提供商注销

2584
03:23:46,239 --> 03:23:54,239
在调用这个注销函数时，我们实际上希望期待一个异常

2585
03:23:54,239 --> 03:23:59,839
所以你可以在这里使用一个非常好的 uh catch

2586
03:23:59,839 --> 03:24:04,160
被称为 throws a 你可以看到 throws a 是一个匹配器

2587
03:24:04,160 --> 03:24:08,635
它会将注销功能的结果与您提供的任何内容相匹配

2588
03:24:08,635 --> 03:24:12,955
在这里，你说 throws a 然后你期望

2589
03:24:12,955 --> 03:24:18,000
这里有一个例外，您会看到 const 类型匹配器

2590
03:24:18,000 --> 03:24:21,756
高度匹配器只会说未初始化

2591
03:24:21,756 --> 03:24:26,400
例外所以我要输入这个然后我要告诉你我是什么

2592
03:24:26,400 --> 03:24:30,879
基本上在这里做看看我通过 jose const 做了什么

2593
03:24:30,879 --> 03:24:35,436
blah blah blah huh 看起来也不错

2594
03:24:35,436 --> 03:24:41,519
让我们看看为什么类型管理器不提取方法 cons 我可能会抛出

2595
03:24:41,519 --> 03:24:45,915
在这里搞砸了一些东西

2596
03:24:45,915 --> 03:24:50,559
所以让我们看看这里发生了什么，所以我们在这里告诉期望的是

2597
03:24:50,559 --> 03:24:54,480
说执行注销功能和

2598
03:24:54,480 --> 03:24:59,756
我们现在正在针对一个叫做 a 的东西测试该函数的结果

2599
03:24:59,756 --> 03:25:05,116
matcher 和 matcher 是因为你在这里看到你不能说这个结果

2600
03:25:05,116 --> 03:25:08,879
应该是一个例外，因为你要做什么是你要创造

2601
03:25:08,879 --> 03:25:11,839
一个不是该异常的实例

2602
03:25:11,839 --> 03:25:15,436
这不是在这里测试你的功能的好方法你说

2603
03:25:15,436 --> 03:25:19,756
您正在匹配调用它获得的注销功能的结果

2604
03:25:19,756 --> 03:25:25,839
预期类型，如您所见，类型匹配器是如果您进入它，您可以看到

2605
03:25:25,839 --> 03:25:31,275
是一个匹配器还可以，所以这就是你所期望的

2606
03:25:31,275 --> 03:25:37,756
函数可以抛出异常

2607
03:25:37,756 --> 03:25:42,000
好的，有很多信息，现在我们需要在测试后做什么

2608
03:25:42,000 --> 03:25:45,839
我们只需要确保我们可以实际初始化我们的功能

2609
03:25:45,839 --> 03:25:49,116
模拟提供者我要带一点代码

2610
03:25:49,116 --> 03:25:52,635
在这里让你看得更清楚

2611
03:25:52,635 --> 03:25:54,720
所以现在让我们

2612
03:25:54,720 --> 03:25:58,796
进入这里说测试，让我看看它应该能够被初始化

2613
03:25:58,796 --> 03:26:02,080
应该可以初始化

2614
03:26:02,080 --> 03:26:06,480
并在这里创建一个空函数然后我们要做的就是

2615
03:26:06,480 --> 03:26:11,436
说等待提供者点初始化像这样

2616
03:26:11,436 --> 03:26:14,955
记住就像你的飞镖代码中的任何地方一样，你可以让你的

2617
03:26:14,955 --> 03:26:19,199
只需将 async 放在大括号之前就可以实现异步功能，所以

2618
03:26:19,199 --> 03:26:22,400
它不是函数签名的一部分，它只是告诉飞镖

2619
03:26:22,400 --> 03:26:26,635
在这个函数里面我要异步执行一些代码

2620
03:26:26,635 --> 03:26:30,955
所以在初始化我们然后在初始化之后，如果你看一下代码

2621
03:26:30,955 --> 03:26:35,040
我们做了初始化它只是做了一个呃

2622
03:26:35,040 --> 03:26:39,040
和一秒的权重，然后它设置的标志被初始化为真

2623
03:26:39,040 --> 03:26:44,239
我们可以通过读取这个 boolean getter 来读取那个标志，所以让我们说吧

2624
03:26:44,239 --> 03:26:48,000
提供者初始化，然后我们会说期望

2625
03:26:48,000 --> 03:26:52,000
在此之后提供者被初始化标志为真

2626
03:26:52,000 --> 03:26:57,915
好吧，这样一个很容易

2627
03:26:57,915 --> 03:27:02,559
所以在我们完成所有这些之后，您会看到已初始化并正在执行初始化

2628
03:27:02,559 --> 03:27:06,160
实际上不会为我们创建用户，所以让我们确定一下

2629
03:27:06,160 --> 03:27:10,955
初始化我们的提供者，用户不是所以让我们说测试

2630
03:27:10,955 --> 03:27:15,436
初始化后用户应该为空

2631
03:27:15,436 --> 03:27:20,000
空函数，然后让我们期待用户

2632
03:27:20,000 --> 03:27:22,796
当前用户是已知的，所以让我们说期望

2633
03:27:22,796 --> 03:27:27,275
提供者当前用户应该知道它是正确的

2634
03:27:27,275 --> 03:27:32,080
易于阅读，几乎就像阅读英语一样

2635
03:27:32,080 --> 03:27:35,680
就是这样了

2636
03:27:35,680 --> 03:27:39,436
现在我们要做的是做一些我想要的异步测试

2637
03:27:39,436 --> 03:27:43,040
你也要看到这个，因为它非常重要，现在假设你是

2638
03:27:43,040 --> 03:27:47,116
我们要测试，因为标题告诉您测试所需的时间

2639
03:27:47,116 --> 03:27:50,635
初始化我们可以在这种情况下测试超时，所以

2640
03:27:50,635 --> 03:27:57,680
我们要做的是在这里查看我们的初始化代码，让我们看看

2641
03:27:57,680 --> 03:28:02,160
此刻这里的初始化函数正在等待一秒钟什么

2642
03:28:02,160 --> 03:28:06,319
我们将在我们的测试中做只是为了使用你如何测试

2643
03:28:06,319 --> 03:28:10,796
超时以及如何在未来测试例如 api 调用

2644
03:28:10,796 --> 03:28:15,275
在这里做一些异步测试，超时说明我们的测试

2645
03:28:15,275 --> 03:28:19,360
如果在我们的提供者上初始化需要更多时间，则应该失败

2646
03:28:19,360 --> 03:28:25,915
比 x 秒数好吧，所以现在让我们进去说 test um

2647
03:28:25,915 --> 03:28:29,839
应该可以初始化

2648
03:28:29,839 --> 03:28:34,319
在不到两秒钟的时间内，好的，一个空的功能是

2649
03:28:34,319 --> 03:28:39,756
异步的，就像现在的那个空的身体

2650
03:28:39,756 --> 03:28:45,199
我们在这里要做的是等待

2651
03:28:45,199 --> 03:28:49,595
关于提供者的初始化没问题

2652
03:28:49,595 --> 03:28:53,595
并且在初始化之后，我们也会期待 is initialize 标志

2653
03:28:53,595 --> 03:28:57,839
就像那样是真的，但是我们要

2654
03:28:57,839 --> 03:29:01,680
使用我们测试的一个新参数，称为超时

2655
03:29:01,680 --> 03:29:06,796
现在 timeout 将为它提供一个恒定的超时时间

2656
03:29:06,796 --> 03:29:11,199
持续时间这么长，在这种情况下，我们只是

2657
03:29:11,199 --> 03:29:13,915
要说两秒钟，我想我们在这里有一个额外的参数

2658
03:29:13,915 --> 03:29:18,879
宪法超时参数零预期发现了什么

2659
03:29:18,879 --> 03:29:25,595
缺点时间，然后在这里秒，并避免在这里缺点好的，所以这是非常

2660
03:29:25,595 --> 03:29:29,436
简单地说，我们说我们创建了一个测试，它调用

2661
03:29:29,436 --> 03:29:35,040
在我们的提供者上初始化函数，并确保该函数返回

2662
03:29:35,040 --> 03:29:40,480
在超时过去之前到测试上下文，所以在内部这个测试

2663
03:29:40,480 --> 03:29:45,275
您提供超时的功能将创建一个小计时器和

2664
03:29:45,275 --> 03:29:49,199
然后它会在调用

2665
03:29:49,199 --> 03:29:52,080
函数这个函数在这里让我告诉你

2666
03:29:52,080 --> 03:29:55,915
就在这里

2667
03:29:55,915 --> 03:30:01,040
正在进行并完成其工作，它将终止其结果处理

2668
03:30:01,040 --> 03:30:06,080
只要超时基本上过去了，所以在这种情况下，我们的初始化函数

2669
03:30:06,080 --> 03:30:10,879
如果在此期间无法完成这项工作，将需要一秒钟的时间来处理这项工作

2670
03:30:10,879 --> 03:30:16,720
这两秒钟的超时测试将失败，所以现在你知道了

2671
03:30:16,720 --> 03:30:19,915
如何测试它

2672
03:30:19,915 --> 03:30:24,955
所以让我们进入这里，现在测试我们的中间部分

2673
03:30:24,955 --> 03:30:30,080
如您所见，正在创建用户的提供者我们必须进行测试以确保

2674
03:30:30,080 --> 03:30:34,559
创建用户实际上委托给我们的登录功能，我们必须测试

2675
03:30:34,559 --> 03:30:38,160
所有边缘情况都可以

2676
03:30:38,160 --> 03:30:42,839
所以让我们继续做吧让我们说我们测试

2677
03:30:42,839 --> 03:30:49,275
呃创建用户应该委托嗯委托

2678
03:30:49,275 --> 03:30:53,436
登录功能，在这里我们要创建

2679
03:30:53,436 --> 03:30:57,040
一个异步函数

2680
03:30:57,040 --> 03:31:00,239
正确需要做的是创造这个

2681
03:31:00,239 --> 03:31:03,436
基本上，如果您记得创建用户没有自己的内部逻辑

2682
03:31:03,436 --> 03:31:06,879
它只是调用登录，但登录有这个美丽的逻辑，首先测试

2683
03:31:06,879 --> 03:31:09,915
美食吧

2684
03:31:09,915 --> 03:31:14,319
任何密码都应该抛出这个错误用户未发现异常所以

2685
03:31:14,319 --> 03:31:17,915
让我们测试一下那个场景好吧让我们进去吧

2686
03:31:17,915 --> 03:31:25,360
并说最终的不良电子邮件用户是提供商创建

2687
03:31:25,360 --> 03:31:27,680
呃

2688
03:31:27,680 --> 03:31:32,796
作家哦，我们没有我们的供应商吗

2689
03:31:32,796 --> 03:31:38,160
哦，我已经添加了这个测试我很抱歉我已经添加了这个测试我相信在结束时

2690
03:31:38,160 --> 03:31:42,160
这整个测试组我应该在这里添加它所以如果你做了同样的

2691
03:31:42,160 --> 03:31:46,000
错误我很抱歉这是我的错你应该解决这个问题并做出

2692
03:31:46,000 --> 03:31:50,796
确保您的测试位于可以访问提供者的同一组中，以便

2693
03:31:50,796 --> 03:31:56,000
然后我要说提供者，所以最终的坏电子邮件用户是

2694
03:31:56,000 --> 03:32:01,595
呃提供商创建用户电子邮件是 fooatbar.com

2695
03:32:01,595 --> 03:32:04,796
密码可以是任何密码

2696
03:32:04,796 --> 03:32:10,000
逗号分号确保 dart 格式化程序正确地格式化您的代码，然后呢

2697
03:32:10,000 --> 03:32:14,480
我们需要确定坏用户是什么时候

2698
03:32:14,480 --> 03:32:19,275
基本上返回给我们那么它实际上应该包含一个未找到的用户

2699
03:32:19,275 --> 03:32:23,275
例外所以让我们继续说期望

2700
03:32:23,275 --> 03:32:29,275
实际上是一个糟糕的电子邮件用户

2701
03:32:29,275 --> 03:32:32,319
抛出一个常量

2702
03:32:32,319 --> 03:32:36,080
类型匹配器

2703
03:32:36,080 --> 03:32:42,400
该用户没有发现这样的异常

2704
03:32:42,400 --> 03:32:45,436
好吧，让我们看看，我

2705
03:32:45,436 --> 03:32:50,000
也必须在这里关闭它，所以我们基本上是在说调用

2706
03:32:50,000 --> 03:32:55,360
错误的电子邮件用户使用该特定电子邮件创建用户应该抛出一个

2707
03:32:55,360 --> 03:32:58,955
用户未发现异常并记住您可能会认为我们已经测试过

2708
03:32:58,955 --> 03:33:02,319
这之前还没有，但那是在

2709
03:33:02,319 --> 03:33:06,635
在这里让我们看看实际上不，我们还没有测试过

2710
03:33:06,635 --> 03:33:09,595
在它之前，我们已经测试过这个东西，所以很抱歉，所以我们已经

2711
03:33:09,595 --> 03:33:12,796
测试了很多，是的，我们还没有测试过这个特殊情况，所以

2712
03:33:12,796 --> 03:33:16,080
好吧，现在我们已经测试过了，现在让我们测试一下

2713
03:33:16,080 --> 03:33:20,319
这种情况下密码错误 fubar 的密码，你看我们有

2714
03:33:20,319 --> 03:33:24,796
我们的模拟提供程序中用于登录功能的逻辑让我们测试这个场景

2715
03:33:24,796 --> 03:33:29,839
现在让我们测试这段代码，我们应该把错误的密码抛出异常，好吧，所以

2716
03:33:29,839 --> 03:33:34,400
让我们进去说final

2717
03:33:34,400 --> 03:33:40,559
我可以看到您看不到代码，所以密码错误的用户是提供者并创建

2718
03:33:40,559 --> 03:33:45,915
电子邮件的用户让我们说 bar.com 上的某人，密码是

2719
03:33:45,915 --> 03:33:50,000
fubar，那是我们不喜欢的密码，记住了，好吧

2720
03:33:50,000 --> 03:33:53,915
现在我们从这里复制代码然后我们说

2721
03:33:53,915 --> 03:34:00,559
该密码用户应该抛出一个名为错误密码的异常

2722
03:34:00,559 --> 03:34:06,480
关闭异常好吧，所以我们也测试了那个场景

2723
03:34:06,480 --> 03:34:12,239
现在我们实际上应该测试积极的情况，所以让我们继续吧

2724
03:34:12,239 --> 03:34:18,955
并说最终用户正在等待提供者，我们说创建用户

2725
03:34:18,955 --> 03:34:23,040
好吧，一封电子邮件将是

2726
03:34:23,040 --> 03:34:27,519
foo 和密码将是 bar 记住我们的模拟身份验证提供程序是

2727
03:34:27,519 --> 03:34:32,559
没有实际测试电子邮件是否是正确的电子邮件

2728
03:34:32,559 --> 03:34:36,955
firebase 正在这样做，但模拟提供商没有这样做

2729
03:34:36,955 --> 03:34:41,275
我们可以提供任何电子邮件 foo 和密码栏，它只会

2730
03:34:41,275 --> 03:34:45,275
接受它，只要它不是密码不是 foobar 并且只要

2731
03:34:45,275 --> 03:34:52,955
因为电子邮件不是footbar.com 好的，现在让我们确保

2732
03:34:52,955 --> 03:34:59,040
然后将该用户分配给我们的身份验证提供者的当前用户

2733
03:34:59,040 --> 03:35:04,559
所以让我们期待身份验证提供商提供对不起提供商的当前用户

2734
03:35:04,559 --> 03:35:09,595
实际上等于这个用户好吧，因为嗯

2735
03:35:09,595 --> 03:35:13,519
这就是我们在创建用户时所做的，记住我们创建用户委托这个

2736
03:35:13,519 --> 03:35:17,595
工作到登录，然后登录在内部将当前用户设置为

2737
03:35:17,595 --> 03:35:21,915
他们刚刚创建好的用户，这就是我们现在正在测试的场景

2738
03:35:21,915 --> 03:35:27,519
这里的代码行没问题，就是这样

2739
03:35:27,519 --> 03:35:30,635
嗯，那么我们需要做的就是

2740
03:35:30,635 --> 03:35:33,595
确保只需创建一个我们的用户

2741
03:35:33,595 --> 03:35:38,559
在这里做的是电子邮件验证功能抱歉是电子邮件

2742
03:35:38,559 --> 03:35:45,436
我们的auth用户的验证um参数默认设置为false记住

2743
03:35:45,436 --> 03:35:49,680
这里设置的登录功能是电子邮件验证假让我们

2744
03:35:49,680 --> 03:35:54,080
测试该功能没问题，所以我们只说期望

2745
03:35:54,080 --> 03:35:58,319
我们使用电子邮件验证为虚假的用户

2746
03:35:58,319 --> 03:36:02,160
哇，那是很多

2747
03:36:02,160 --> 03:36:06,400
代码对你说实话，我希望你得到我提到的一切

2748
03:36:06,400 --> 03:36:10,559
现在我们已经完成了，让我们测试一下

2749
03:36:10,559 --> 03:36:14,955
电子邮件验证功能 呃，让我们看看我们

2750
03:36:14,955 --> 03:36:19,436
实际上在电子邮件验证中做了你看到我们没有这个功能

2751
03:36:19,436 --> 03:36:22,319
初始化然后我们取当前用户，如果

2752
03:36:22,319 --> 03:36:26,720
当前用户为空然后我们说用户未找到异常然后我们创建一个

2753
03:36:26,720 --> 03:36:32,000
新用户的电子邮件验证为真，然后我们将该用户设置为

2754
03:36:32,000 --> 03:36:38,160
当前用户，这就是发送电子邮件验证码的作用

2755
03:36:38,160 --> 03:36:40,400
现在你知道什么时候了

2756
03:36:40,400 --> 03:36:43,436
当颤动然后运行我们的代码时，它将按顺序运行它们，所以它是

2757
03:36:43,436 --> 03:36:47,199
只是从上到下然后你记得

2758
03:36:47,199 --> 03:36:51,275
在我们测试电子邮件验证之前，我们实际上是在测试创建用户

2759
03:36:51,275 --> 03:36:56,239
反过来调用登录函数，所以因为我们要保持我们的

2760
03:36:56,239 --> 03:36:59,680
提供者这创建用户调用登录功能

2761
03:36:59,680 --> 03:37:05,040
确保当前用户实际设置并且未通过电子邮件验证，因此我们可以

2762
03:37:05,040 --> 03:37:08,000
指望那好吧，所以让我们说

2763
03:37:08,000 --> 03:37:13,040
我们测试，我们说登录用户应该能够

2764
03:37:13,040 --> 03:37:19,199
得到验证 呃 登录用户应该可以

2765
03:37:19,199 --> 03:37:23,199
得到验证没问题，然后在这里有一个空函数

2766
03:37:23,199 --> 03:37:28,480
嗯，就是这样，所以在这里我们说供应商发送

2767
03:37:28,480 --> 03:37:33,199
电子邮件验证没问题，最终用户是提供商

2768
03:37:33,199 --> 03:37:36,559
用户呃

2769
03:37:36,559 --> 03:37:39,915
当前用户这样

2770
03:37:39,915 --> 03:37:45,915
我们现在确保当前用户不为空，所以我们说期望用户

2771
03:37:45,915 --> 03:37:52,239
不是呃或者是期望用户不是空的

2772
03:37:52,239 --> 03:37:55,756
如您所见，这是一个很棒的匹配器，您可以将某些东西与之匹配，所以

2773
03:37:55,756 --> 03:38:00,720
你说不应该这样好吧

2774
03:38:00,720 --> 03:38:05,595
然后我们还需要确保设置了这个用户的 uh 验证

2775
03:38:05,595 --> 03:38:08,796
所以它的电子邮件验证应该是真的然后我们说期望，我们会得到一个

2776
03:38:08,796 --> 03:38:14,080
错误现在您会看到用户已通过电子邮件验证它应该是真的

2777
03:38:14,080 --> 03:38:16,879
好的，你可以看到你在这里得到一个错误，说用户是可选的，但是

2778
03:38:16,879 --> 03:38:19,915
我们要在这里做一个星号说

2779
03:38:19,915 --> 03:38:25,519
对我们快速强制强制

2780
03:38:25,519 --> 03:38:30,319
现在我们应该做的最后一个测试我们作为标题说测试注销

2781
03:38:30,319 --> 03:38:33,360
并登录，这是正常情况，应该可以正常工作让我们

2782
03:38:33,360 --> 03:38:37,360
为它创建一个测试，所以我们只说测试

2783
03:38:37,360 --> 03:38:41,275
我们将调用它应该能够注销并再次登录应该

2784
03:38:41,275 --> 03:38:47,275
能够注销并再次登录

2785
03:38:47,275 --> 03:38:51,595
和一个异步函数 so 和一个分号在最后

2786
03:38:51,595 --> 03:38:55,275
所以我们在这里要做的就是说

2787
03:38:55,275 --> 03:38:59,040
注销并登录，然后我们获取当前用户，我们只需确保

2788
03:38:59,040 --> 03:39:04,239
你不是空的，所以让我们说等待提供者

2789
03:39:04,239 --> 03:39:08,635
注销，我们说等待提供商登录

2790
03:39:08,635 --> 03:39:14,239
仅包含用户名和密码的电子邮件

2791
03:39:14,239 --> 03:39:19,839
就这样好吧，或者只是发送电子邮件，因为我们实际上并没有验证

2792
03:39:19,839 --> 03:39:25,436
我们的模拟作者提供者中的身份验证提供者中的电子邮件和密码

2793
03:39:25,436 --> 03:39:30,160
然后我们要获取当前用户，所以我们说最终用户是提供者

2794
03:39:30,160 --> 03:39:34,160
当前用户，我们只是确保该用户不为人所知，所以让我们说

2795
03:39:34,160 --> 03:39:42,000
期望用户不为空，这是内置的方法

2796
03:39:42,000 --> 03:39:46,879
颤振测试好吧，那是很多工作，我

2797
03:39:46,879 --> 03:39:51,116
为你坚持这一章而自豪

2798
03:39:51,116 --> 03:39:55,595
我们谈了很多关于测试的事情，你需要经历很多事情

2799
03:39:55,595 --> 03:39:58,720
材料，您还需要自己学习不同类型的

2800
03:39:58,720 --> 03:40:03,040
事情和不同风格的期望和谈论期望我有点

2801
03:40:03,040 --> 03:40:06,796
期待你自己去阅读这些东西

2802
03:40:06,796 --> 03:40:10,000
并在您自己的时间了解它们

2803
03:40:10,000 --> 03:40:15,756
现在是我们需要运行测试的激动人心的部分，所以让我更改屏幕布局

2804
03:40:15,756 --> 03:40:19,519
让我们进入我们的终端

2805
03:40:19,519 --> 03:40:23,199
让我们增加尺寸和

2806
03:40:23,199 --> 03:40:27,360
那么让我们打破这个，你可以看到你可以

2807
03:40:27,360 --> 03:40:32,319
通过说颤振测试并提供该路径来告诉颤振运行您的测试

2808
03:40:32,319 --> 03:40:37,360
你的测试，所以现在颤动将继续并发布并通过那些

2809
03:40:37,360 --> 03:40:41,040
一一测试

2810
03:40:41,040 --> 03:40:45,360
让我们看看我们得到的结果

2811
03:40:45,360 --> 03:40:50,000
你可以看到它为所有这些测试提供了同样的时间，它说明了一切

2812
03:40:50,000 --> 03:40:54,955
测试通过了，我只是想在继续之前强调这一点，我们做了一个

2813
03:40:54,955 --> 03:41:00,080
很多测试我已经手动准备了这些测试，以确保它们

2814
03:41:00,080 --> 03:41:04,400
实际上在我们的身份验证提供程序中测试了重要的功能，但是我已经

2815
03:41:04,400 --> 03:41:07,680
非常仔细地编写测试以确保

2816
03:41:07,680 --> 03:41:12,000
他们在工作时，情况并非如此

2817
03:41:12,000 --> 03:41:16,879
现实生活中的事情，如果你做对了，你的测试应该会失败

2818
03:41:16,879 --> 03:41:22,239
测试应该无法开始，然后你需要去写你的并修复

2819
03:41:22,239 --> 03:41:26,720
你的逻辑如果你做的事情更正确你应该写你的测试

2820
03:41:26,720 --> 03:41:31,519
首先什么都行不通，然后你应该去写你的逻辑来适应

2821
03:41:31,519 --> 03:41:35,915
这些测试和期望只是因为这些测试正确通过

2822
03:41:35,915 --> 03:41:40,160
现在我知道我们内心充满喜悦我们说哦一切都过去了一切都很好

2823
03:41:40,160 --> 03:41:45,436
但实际上通常情况并非如此

2824
03:41:45,436 --> 03:41:48,400
所以我们做了很多工作让我们像我们一样做

2825
03:41:48,400 --> 03:41:54,955
通常会保持传统，让我们投入我们的工作，并标记它

2826
03:41:54,955 --> 03:41:59,756
然后让我们说 git status 来查看状态很多事情发生了变化

2827
03:41:59,756 --> 03:42:04,160
嘿，点击添加 git 状态

2828
03:42:04,160 --> 03:42:07,756
好的，我们将把它作为第 10 步提交

2829
03:42:07,756 --> 03:42:13,680
我们要在这里说 get push 它将把我们的提交推送到 github

2830
03:42:13,680 --> 03:42:18,239
然后我们得到标签以及第10步

2831
03:42:18,239 --> 03:42:24,000
并推税

2832
03:42:24,000 --> 03:42:28,635
传统，因为它是我们经常谈论的这个呃哲学课程中的传统

2833
03:42:28,635 --> 03:42:31,680
在结束当前章节之前，我们将在下一章中做什么

2834
03:42:31,680 --> 03:42:34,319
章节，所以你可以看到缓存已经说让我们为下一章做好准备

2835
03:42:34,319 --> 03:42:38,480
章我们需要一个数据库来存储用户注释在你使用之前或者如果我们使用

2836
03:42:38,480 --> 03:42:44,080
用于存储的火力基地现在你看到我们现在不是

2837
03:42:44,080 --> 03:42:48,319
实际上在没有节点的任何地方写任何东西

2838
03:42:48,319 --> 03:42:52,400
用户甚至不能创建新节点，但是如果我们想给

2839
03:42:52,400 --> 03:42:55,680
用户创建新节点然后删除这些节点并更新的能力

2840
03:42:55,680 --> 03:43:00,796
那些节点和 uh 首先我们要存储

2841
03:43:00,796 --> 03:43:05,040
这些节点位于应用程序内部的本地数据库中，因此您将在

2842
03:43:05,040 --> 03:43:08,635
下一章关于 sqlite

2843
03:43:08,635 --> 03:43:12,955
和本地数据库以及如何将它们与 firebase 一起使用

2844
03:43:12,955 --> 03:43:18,480
抱歉以及如何在最新章节中使用它们

2845
03:43:18,480 --> 03:43:22,635
在后面的章节中，我们将改变这个逻辑，所以我们不会使用 sql

2846
03:43:22,635 --> 03:43:26,879
精简版呃，但我相信任何开发人员呃

2847
03:43:26,879 --> 03:43:30,480
如果你喜欢我不能说任何开发人员，但如果你是

2848
03:43:30,480 --> 03:43:33,436
您应该熟悉的前端开发人员或后端开发人员

2849
03:43:33,436 --> 03:43:36,480
数据库，这正是我们要做的

2850
03:43:36,480 --> 03:43:40,480
在下一章中，请吃点点心，我会在

2851
03:43:40,480 --> 03:43:44,796
下一章你好，欢迎来到第 27 章

2852
03:43:44,796 --> 03:43:48,000
前几章中的 flasa 课程

2853
03:43:48,000 --> 03:43:51,839
谈论我们的用户界面，我们也一直在

2854
03:43:51,839 --> 03:43:56,239
看看我们的服务和

2855
03:43:56,239 --> 03:44:00,480
我们也花了一些时间来创造一些

2856
03:44:00,480 --> 03:44:04,955
测试我们的服务和提供者直到现在我们已经

2857
03:44:04,955 --> 03:44:08,559
一直在谈论从一个屏幕到另一个屏幕的逻辑

2858
03:44:08,559 --> 03:44:13,680
其他 uh 与 firebase 等集成，但我们实际上还没有谈到

2859
03:44:13,680 --> 03:44:18,400
将用户创建的内容存储在我们的应用程序中或某些内部

2860
03:44:18,400 --> 03:44:22,239
一种云服务，我们将在本章中做些什么

2861
03:44:22,239 --> 03:44:27,756
我们要讨论 sql lite 并将用户生成的内容存储在

2862
03:44:27,756 --> 03:44:33,839
这种情况下，用户现在在 sqlite 内生成节点

2863
03:44:33,839 --> 03:44:37,360
我要了解 sqlite 是什么，但首先让我们看看

2864
03:44:37,360 --> 03:44:41,436
本章的标题，如您所见，上面写着 crotlocal storage for

2865
03:44:41,436 --> 03:44:44,319
你们中那些以前是软件开发人员并且熟悉的人

2866
03:44:44,319 --> 03:44:48,480
人群你可以跳过本章的这一部分

2867
03:44:48,480 --> 03:44:53,360
不熟悉 crowdcrot 代表创建读取更新和删除这些是

2868
03:44:53,360 --> 03:44:58,559
任何开发人员都会对其执行的四个非常基本的操作

2869
03:44:58,559 --> 03:45:04,319
数据，例如，如果您是烧瓶或 django 开发人员 node express um

2870
03:45:04,319 --> 03:45:08,879
开发人员，您可能已经熟悉这些，因为

2871
03:45:08,879 --> 03:45:13,839
您可能正在使用某种数据库 mysql 或 sqlite

2872
03:45:13,839 --> 03:45:17,199
嗯，您将数据存储在那里，您只是在处理数据

2873
03:45:17,199 --> 03:45:21,116
并且您熟悉作物一词，但如果您不熟悉它

2874
03:45:21,116 --> 03:45:25,360
把它想象成 c 是你在创造

2875
03:45:25,360 --> 03:45:30,559
数据库中的某种对象，例如

2876
03:45:30,559 --> 03:45:35,275
您阅读的用户生成的注释当然希望能够

2877
03:45:35,275 --> 03:45:38,635
例如，在我们应用程序的主用户界面中读取该数据

2878
03:45:38,635 --> 03:45:41,839
可能要读取数据库的全部内容

2879
03:45:41,839 --> 03:45:45,519
不是全部内容，而是至少在用户为该特定内容生成的注释中

2880
03:45:45,519 --> 03:45:50,080
用户所以那是人群中的 r 然后你有你

2881
03:45:50,080 --> 03:45:54,955
它代表更新嗯或者它不代表更新它意味着更新

2882
03:45:54,955 --> 03:45:59,436
因为 u 是更新的第一个字母，所以更新是例如如果我有

2883
03:45:59,436 --> 03:46:02,796
已经在此应用程序中生成了一个节点，我想去更改

2884
03:46:02,796 --> 03:46:06,160
那个节点的内容然后就是 crod 中的 u

2885
03:46:06,160 --> 03:46:11,839
最后但并非最不重要的是你有 d 这是删除 um 并作为它的名字

2886
03:46:11,839 --> 03:46:15,595
基本上代表你允许用户能够删除

2887
03:46:15,595 --> 03:46:20,635
他们自己从数据库中生成的内容，所以

2888
03:46:20,635 --> 03:46:24,080
我们在这门课程中要做的是

2889
03:46:24,080 --> 03:46:29,595
说说sqlite是数据库还是c

2890
03:46:29,595 --> 03:46:33,756
库和在 c um 中创建的库

2891
03:46:33,756 --> 03:46:37,680
这使我们可以将 c 视为一种程序员语言

2892
03:46:37,680 --> 03:46:42,559
允许我们现在将数据存储在文件中，如果您来自类似的地方

2893
03:46:42,559 --> 03:46:46,879
后端世界，如果你在里面用 python 编程的话

2894
03:46:46,879 --> 03:46:50,319
django 你已经熟悉了，因为 sqlite 是默认数据库

2895
03:46:50,319 --> 03:46:55,595
这将在 django 中提供给你，我相信还有一个烧瓶正在使用

2896
03:46:55,595 --> 03:46:59,275
sqlite 默认情况下非常类似于

2897
03:46:59,275 --> 03:47:03,519
django 但如果你不熟悉 sqlite

2898
03:47:03,519 --> 03:47:07,756
我在这里准备了一个网站吗？我的意思是我还没有准备好我已经准备好的网站

2899
03:47:07,756 --> 03:47:11,116
刚打开网站所以嗯

2900
03:47:11,116 --> 03:47:15,436
所以你可以在这里看到我会在这里增加字体的大小，你可以看到

2901
03:47:15,436 --> 03:47:19,275
sqlite是一个c语言库，实现了一个小型快速自包含

2902
03:47:19,275 --> 03:47:23,360
高可靠全功能sql数据库引擎sqlite是最

2903
03:47:23,360 --> 03:47:29,199
世界上用过的数据库引擎很好，只是将sqlite视为数据库

2904
03:47:29,199 --> 03:47:33,519
我们将在我们的应用程序中使用的引擎，它不是

2905
03:47:33,519 --> 03:47:40,319
是内置在 um flutter 里面的，我们将不得不使用一个所谓的插件来实现它

2906
03:47:40,319 --> 03:47:44,080
嗯，但这也没关系，我的意思是不多

2907
03:47:44,080 --> 03:47:49,199
语言支持与数据库对话，并且原生支持

2908
03:47:49,199 --> 03:47:51,839
嗯，但我们会到达那里，我们会到达那里

2909
03:47:51,839 --> 03:47:56,160
点好吧，现在让我们谈谈我们实际上是怎样的

2910
03:47:56,160 --> 03:48:00,239
将与 sqlite 集成并开始，所以我假设你

2911
03:48:00,239 --> 03:48:04,480
难道你以前从未使用过 sqlite 或者你没有使用过任何

2912
03:48:04,480 --> 03:48:07,595
之前的数据库类型，您正在尝试学习如何做到这一点，所以

2913
03:48:07,595 --> 03:48:10,720
这就是我从本课程开始时的假设，所以如果

2914
03:48:10,720 --> 03:48:14,400
您已经是经验丰富的开发人员，您确切了解 school sql light 的工作原理

2915
03:48:14,400 --> 03:48:18,160
您可能想跳过本章的这一部分并喜欢更多

2916
03:48:18,160 --> 03:48:22,080
多汁的部分，我们实际上与漂浮物内部的同等光线整合在一起

2917
03:48:22,080 --> 03:48:25,756
应用程序所以让我关闭这个 um 或者让我们

2918
03:48:25,756 --> 03:48:29,360
保持打开状态，我现在要谈论的是

2919
03:48:29,360 --> 03:48:34,720
um 一个程序 一个名为 db browser for sql 的免费程序

2920
03:48:34,720 --> 03:48:40,400
lite 你看到 sqlite 允许你我的意思是如果你想到

2921
03:48:40,400 --> 03:48:44,239
sql lite 有不同的组件，首先你有你的数据库，它只是一个

2922
03:48:44,239 --> 03:48:49,519
位于磁盘上的文件，然后您将拥有 sqlite

2923
03:48:49,519 --> 03:48:54,879
可以从此文件读取并写入此文件的引擎，这就是

2924
03:48:54,879 --> 03:48:59,199
引擎，然后这个引擎应该在某个地方运行，所以它要么运行

2925
03:48:59,199 --> 03:49:03,360
在一个应用程序中，比如我在这里提到的一个用于 sql 的 db 浏览器

2926
03:49:03,360 --> 03:49:08,319
轻巧，所以 sqlite 就像烘焙到该应用程序中一样，或者您也可以带来

2927
03:49:08,319 --> 03:49:12,080
sql light 进入你的终端，这样你就可以真正与 sql lite 交谈

2928
03:49:12,080 --> 03:49:15,839
来自终端内的数据库，或者如果您已经安装

2929
03:49:15,839 --> 03:49:20,160
django 在您的计算机上，然后您可以使用 django 以与 sql 集成

2930
03:49:20,160 --> 03:49:25,040
iso sqlite 是与 sqlite 文件对话的引擎

2931
03:49:25,040 --> 03:49:30,400
呃，这是你的数据库，但是这个引擎应该在它的某个地方运行

2932
03:49:30,400 --> 03:49:35,040
不仅仅是一个可执行文件，就像你在这里说的那样，你现在必须拥有这个文件

2933
03:49:35,040 --> 03:49:40,160
就像是续集光引擎基本上所在的某种容器

2934
03:49:40,160 --> 03:49:42,796
然后当我们谈论我们的颤振应用程序时，我们将带来这个

2935
03:49:42,796 --> 03:49:47,595
引擎进入颤振应用程序，因此我们的应用程序可以与该数据库进行对话，但是

2936
03:49:47,595 --> 03:49:52,559
现在我们来看一个名为 db browser for lite db browser 的程序

2937
03:49:52,559 --> 03:49:56,720
因为 sql lite 是免费的，我相信它是一个开源程序让我们搜索

2938
03:49:56,720 --> 03:49:59,436
为此我要说

2939
03:49:59,436 --> 03:50:04,839
sqlite的db浏览器，我们最终在这个

2940
03:50:04,839 --> 03:50:09,199
网站和嗯，你可以看到 db 浏览器的官方主页

2941
03:50:09,199 --> 03:50:12,720
sqlite，这就是程序的样子

2942
03:50:12,720 --> 03:50:18,000
嗯，我不确定是不是我现在可以看到它实际上可用于 windows mac

2943
03:50:18,000 --> 03:50:21,595
os 如果它也可用于 linux 那就太棒了

2944
03:50:21,595 --> 03:50:24,000
嗯，是的

2945
03:50:24,000 --> 03:50:27,915
它似乎可用，你实际上可以使用 snap 所以

2946
03:50:27,915 --> 03:50:31,275
太好了，所以如果你像我一样使用 ubuntu

2947
03:50:31,275 --> 03:50:33,915
现在不在这台机器上，但如果你在 ubuntu 上，你实际上可以使用

2948
03:50:33,915 --> 03:50:38,160
snapstore 甚至 debian 任何类型的操作系统 linux 空间操作

2949
03:50:38,160 --> 03:50:44,879
具有 snapstore 的系统，即使在 arch linux 上也非常棒

2950
03:50:44,879 --> 03:50:49,915
好吧，在你使用 apt 的 debian 上，这很好，但无论如何，它是可用的

2951
03:50:49,915 --> 03:50:56,160
对于 windows linux 和 mac os 所以我需要你基本上去 sqlite 浏览器或

2952
03:50:56,160 --> 03:51:02,319
db browser 因为它被称为 db browser for sqlite 如果你去我需要的主页

2953
03:51:02,319 --> 03:51:05,839
找到这个网站，让我改变屏幕布局

2954
03:51:05,839 --> 03:51:09,680
你看得更清楚，我需要你下载这个程序

2955
03:51:09,680 --> 03:51:14,080
好的，我已经在我的电脑上下载了，所以我要关闭它

2956
03:51:14,080 --> 03:51:18,239
safari 窗口，我将为您带来 sqlite 的 db 浏览器，因为它看起来

2957
03:51:18,239 --> 03:51:21,595
就像在我的电脑上我唯一改变的东西

2958
03:51:21,595 --> 03:51:25,839
这里的界面是我把字体从13改成了20

2959
03:51:25,839 --> 03:51:30,796
不是因为我不喜欢数字 13。这与它无关，但它是

2960
03:51:30,796 --> 03:51:37,915
只是我认为对于这门课程来说，20 是一个更好的字体大小

2961
03:51:37,915 --> 03:51:44,160
好吧，我们现在要做什么，嗯，让我谈谈吧

2962
03:51:44,160 --> 03:51:47,839
我们数据库的结构以及我们将如何设置它

2963
03:51:47,839 --> 03:51:52,000
如果您考虑一下我们是如何创建用户界面的，这里是用户

2964
03:51:52,000 --> 03:51:58,000
界面如果我们去这里你可以看到我们可以注册不同的用户所以

2965
03:51:58,000 --> 03:52:02,720
然后我们有一个用户实体或用户表，我们将称之为

2966
03:52:02,720 --> 03:52:07,360
然后我们也有我们将允许

2967
03:52:07,360 --> 03:52:11,436
在我们的数据库中创建这些用户，所以想象一下我们将拥有

2968
03:52:11,436 --> 03:52:15,360
某种表 我们数据库中的某种实体，专用于

2969
03:52:15,360 --> 03:52:19,436
users 和 users 可能只会拥有

2970
03:52:19,436 --> 03:52:21,915
他们将拥有什么他们是

2971
03:52:21,915 --> 03:52:27,436
将有一个 id 和一个电子邮件，以便您在创建时记住

2972
03:52:27,436 --> 03:52:32,879
当您向 firebase 注册用户时，您总是会得到一个用户标识符，所以

2973
03:52:32,879 --> 03:52:38,160
我们将在我们的数据库中存储该 id 和用户的电子邮件

2974
03:52:38,160 --> 03:52:41,839
好的，所以我们不会存储不是绝对的用户密码

2975
03:52:41,839 --> 03:52:46,160
no-no 好的，所以来自 firebase 的用户 ID 和

2976
03:52:46,160 --> 03:52:50,635
我们将存储在数据库中的电子邮件地址

2977
03:52:50,635 --> 03:52:55,756
而且我们将有另一张桌子和

2978
03:52:55,756 --> 03:53:00,796
我们数据库中的另一个表专门用于注释，以便在我登录时作为用户

2979
03:53:00,796 --> 03:53:04,000
我应该能够创建自己的笔记和这些笔记的应用程序

2980
03:53:04,000 --> 03:53:09,519
应该有点像绑定到并且喜欢他们应该粘在我的用户身上，所以如果我的

2981
03:53:09,519 --> 03:53:14,080
用户在数据库中我应该能够有笔记，如果我的用户被删除

2982
03:53:14,080 --> 03:53:17,199
所有这些笔记也应该从数据库中删除，所以很友好

2983
03:53:17,199 --> 03:53:21,915
对于那些熟悉后端开发的人来说就像一个级联

2984
03:53:21,915 --> 03:53:25,199
所以这就像我们的结构

2985
03:53:25,199 --> 03:53:30,000
将为我们的数据库进行设置，因此在我们的笔记中我可以看到

2986
03:53:30,000 --> 03:53:35,199
我们的笔记表我们实际上将有一个用户ID

2987
03:53:35,199 --> 03:53:39,756
该表中的整数，喜欢绑定

2988
03:53:39,756 --> 03:53:43,680
每个节点对象都指向创建它的用户，但我们会到达那里，所以不要

2989
03:53:43,680 --> 03:53:47,275
担心它，所以我要摆脱它

2990
03:53:47,275 --> 03:53:50,879
放在这里，这样我们就看不到了

2991
03:53:50,879 --> 03:53:55,360
现在我们需要做的是开始测试所以我们要创建一个简单的数据库

2992
03:53:55,360 --> 03:53:59,595
数据库并开始在那里创建一些表好吧，所以我需要你做什么

2993
03:53:59,595 --> 03:54:03,756
只是按下新数据库，我将把它保存在我的桌面上

2994
03:54:03,756 --> 03:54:09,116
让我们称之为测试好吧，我要按下

2995
03:54:09,116 --> 03:54:14,559
保存按钮就在那里好吧你可以看到现在我们创建了一个

2996
03:54:14,559 --> 03:54:19,756
数据库，我们在这里有一个表它看起来不太好我的意思是它不是

2997
03:54:19,756 --> 03:54:23,040
渲染得很好，因为我改变了屏幕上的字体

2998
03:54:23,040 --> 03:54:26,796
但你我想你能明白吗

2999
03:54:26,796 --> 03:54:30,720
所以我们需要做的是正如标题所说我们需要创建一个表

3000
03:54:30,720 --> 03:54:36,319
呼叫用户好的，所以请在此处的表格部分进入