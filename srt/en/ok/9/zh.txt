1
00:06:58,552 --> 00:07:02,639
我们不会再返回数据库节点了，我们会说

2
00:07:02,639 --> 00:07:07,280
返回一个云节点，这里我们期望一个类型的参数

3
00:07:07,280 --> 00:07:12,960
可以选择传递给我们的路由的云节点

4
00:07:12,960 --> 00:07:15,440
在这里我们不打算合作

5
00:07:15,440 --> 00:07:18,960
您在这里看到我们之前与数据库用户一起工作，因为我们的

6
00:07:18,960 --> 00:07:22,800
应用程序实际上是在本地数据库中创建新用户，并且

7
00:07:22,800 --> 00:07:27,920
谢天谢地，将笔记与这些用户相关联，现在我们要

8
00:07:27,920 --> 00:07:32,719
既然我们使用的是 firestore um 数据库，我们就不必玩了

9
00:07:32,719 --> 00:07:37,512
用户不再是因为记住用户已经由 firebase 管理

10
00:07:37,512 --> 00:07:40,480
所以我们能做的就是删除那个所有者

11
00:07:40,480 --> 00:07:45,192
完全，现在我们等待我们的节点服务和

12
00:07:45,192 --> 00:07:49,920
我们只是说创建新节点，然后我们需要一个所有者用户 ID 并记住这一点

13
00:07:49,920 --> 00:07:55,512
所有者用户 id 将是实际当前用户的用户 id 所以让我们说

14
00:07:55,512 --> 00:08:00,800
最终用户 id 是当前用户 dot id 好的

15
00:08:00,800 --> 00:08:07,192
然后在这里我们只是说用户ID没问题，我们将那个笔记存储在这里

16
00:08:07,192 --> 00:08:10,719
正如我们之前所做的那样，我们根本没有更改该代码，然后我们

17
00:08:10,719 --> 00:08:17,192
看到新笔记也需要退回

18
00:08:17,192 --> 00:08:21,359
所以现在我们需要修复新节点的创建，这就是

19
00:08:21,359 --> 00:08:24,640
我们已经这样做了，所以不应该有一个单独的点

20
00:08:24,640 --> 00:08:29,192
标题，所以我们已经完成了，现在没有任何事情需要处理

21
00:08:29,192 --> 00:08:34,159
我们现在还需要注意删除您在离开时记得的笔记

22
00:08:34,159 --> 00:08:38,000
如果节点的文本超出节点创建视图

23
00:08:38,000 --> 00:08:43,511
是空的，我们实际上从数据库中删除了那个节点，现在和现在

24
00:08:43,511 --> 00:08:48,319
我们需要前往我们的节点服务并使用新的删除它

25
00:08:48,319 --> 00:08:51,832
称为删除节点的函数，让我们看看它需要什么

26
00:08:51,832 --> 00:09:00,159
参数它需要一个文档ID，这是我们节点的文档ID

27
00:09:00,159 --> 00:09:04,872
所以这是删除笔记，现在我们有另一个非常有用的功能

28
00:09:04,872 --> 00:09:09,760
保存笔记的功能，当我们走出屏幕时，如果

29
00:09:09,760 --> 00:09:13,832
如果该注释的文本不为空，请注意

30
00:09:13,832 --> 00:09:17,760
与删除节点非常相似，但它会做相反的事情以确保

31
00:09:17,760 --> 00:09:21,439
节点存在，并且如果设置了文本编辑控制器的文本

32
00:09:21,439 --> 00:09:25,192
它不是空的，意味着设置了文本

33
00:09:25,192 --> 00:09:30,231
然后我们更新当前节点，然后让我们等待它，在这里我们只是说

34
00:09:30,231 --> 00:09:32,872
更新节点

35
00:09:32,872 --> 00:09:37,760
文档 ID 将成为我们的注释的那些新参数

36
00:09:37,760 --> 00:09:42,399
文档ID和这里的文字让我们看看

37
00:09:42,399 --> 00:09:46,800
哦，我们必须在里面放一个逗号，然后我们就可以走了

38
00:09:46,800 --> 00:09:54,800
所以如果文本不为空函数，则更新保存节点

39
00:09:54,800 --> 00:09:58,551
好的，现在我们需要转到我们的笔记列表视图

40
00:09:58,551 --> 00:10:01,279
我将在我的笔记中做同样的事情

41
00:10:01,279 --> 00:10:04,000
打扰一下

42
00:10:04,000 --> 00:10:09,600
让我们继续做吧，我们这里有什么错误吗？是的，我可以

43
00:10:09,600 --> 00:10:13,359
看到我收到更新说明错误，我真的不知道问题出在哪里

44
00:10:13,359 --> 00:10:17,439
实际上是让我们看看需要文档 ID 好，我可以

45
00:10:17,439 --> 00:10:21,511
看到这也是我们需要更新的内容，所以让我们转到您的文本

46
00:10:21,511 --> 00:10:25,511
控制器侦听器功能以及更新

47
00:10:25,511 --> 00:10:28,960
那里的注释也可以看到它正在这样做

48
00:10:28,960 --> 00:10:35,511
现在我们现在必须说更新笔记，我们有一个笔记文档ID，然后

49
00:10:35,511 --> 00:10:39,600
我们有文字，所以请确保您已处理好文字

50
00:10:39,600 --> 00:10:44,319
控制器侦听器功能以及

51
00:10:44,319 --> 00:10:46,872
嗯

52
00:10:46,872 --> 00:10:51,192
我只是确保这正是我们在笔记中所做的

53
00:10:51,192 --> 00:10:54,079
好吧好吧

54
00:10:54,079 --> 00:10:57,832
所以那是退了一步，嗯，现在让我们去做吧

55
00:10:57,832 --> 00:11:02,000
底部屏幕说让我们去我们的笔记列表查看嗯

56
00:11:02,000 --> 00:11:06,231
笔记列表视图，正如您目前所看到的，我们正在处理一个列表

57
00:11:06,231 --> 00:11:10,399
数据库注释，我们不想再这样做了，我们实际上想要工作

58
00:11:10,399 --> 00:11:15,359
使用可迭代对象，因为这就像 firebase 实际工作的默认方式

59
00:11:15,359 --> 00:11:18,319
它适用于眼部问题它不适用于列表所以

60
00:11:18,319 --> 00:11:22,319
和 iterables 实际上更好，因为它们就像惰性列表，所以让我们

61
00:11:22,319 --> 00:11:27,511
将其更改为这样的云节点的可迭代对象，并且我们也更改了我们的

62
00:11:27,511 --> 00:11:33,600
如果我可以拼写，节点回调将成为云节点，而且我们也必须这样做

63
00:11:33,600 --> 00:11:36,800
导入这个，所以我只是要导入云节点，这样错误就会消失

64
00:11:36,800 --> 00:11:40,872
我要从那里删除这个 uh import 语句

65
00:11:40,872 --> 00:11:45,119
现在，当您使用眼部问题时，您不能像我们在做的那样做下标

66
00:11:45,119 --> 00:11:51,279
在这里你必须说对象元素然后你有你的索引，那就是

67
00:11:51,279 --> 00:11:54,800
几乎我们在这里所做的，所以现在如果你在你的

68
00:11:54,800 --> 00:11:59,680
节点回调，您将此更改从列表更改为可迭代，然后更改此

69
00:11:59,680 --> 00:12:04,000
从数据库节点到云节点，并将此功能从

70
00:12:04,000 --> 00:12:08,439
元素添加的下标，那么您的笔记中不应有任何错误

71
00:12:08,439 --> 00:12:13,119
listview.dart 文件

72
00:12:13,119 --> 00:12:18,079
现在我们要做一些更有趣的改变

73
00:12:18,079 --> 00:12:22,079
确保我们的应用程序在云中按预期工作

74
00:12:22,079 --> 00:12:24,640
贮存

75
00:12:24,640 --> 00:12:32,000
让我们像这里一样去笔记查看笔记视图，你现在会看到

76
00:12:32,000 --> 00:12:36,479
嗯实际上我可以在这里看到我的笔记

77
00:12:36,479 --> 00:12:39,832
我们必须在这里做一些更新，因为我们不打算与

78
00:12:39,832 --> 00:12:42,551
节点服务不再存在，因为它不存在

79
00:12:42,551 --> 00:12:46,231
但我们必须做出一项更大的改变

80
00:12:46,231 --> 00:12:50,159
正如您在现金抵消中看到的那样，移除未来的建设者

81
00:12:50,159 --> 00:12:54,640
为什么这里是未来的建设者现在的样子

82
00:12:54,640 --> 00:12:59,439
你可以看到未来的建设者实际的未来是获取或创建一个用户，但做

83
00:12:59,439 --> 00:13:04,079
我们真的需要那个了，答案显然是否定的，因为

84
00:13:04,079 --> 00:13:07,680
以前我们使用此功能构建器在我们的数据库中创建用户

85
00:13:07,680 --> 00:13:11,119
这样我们就可以将笔记与该用户相关联

86
00:13:11,119 --> 00:13:16,231
但是从现在开始我们要去firestore，呃

87
00:13:16,231 --> 00:13:21,511
云存储，像您的应用程序中的用户一样的用户由 firebase 管理

88
00:13:21,511 --> 00:13:26,479
本身，因此您不必在这种意义上创建它们，当用户

89
00:13:26,479 --> 00:13:29,832
已登录并登陆您的应用程序的主界面

90
00:13:29,832 --> 00:13:34,551
firebase 用户已经存在，因此您无需执行任何操作，因此我们需要

91
00:13:34,551 --> 00:13:39,439
删除这个未来的建设者，所以我只是要按命令点就可以了

92
00:13:39,439 --> 00:13:43,039
有时 Visual Studio 代码实际上可以帮助删除它，但是

93
00:13:43,039 --> 00:13:46,800
目前这没有帮助，所以在这种情况下我要做什么

94
00:13:46,800 --> 00:13:50,872
你可以看到我想在这里抓住这个流构建器

95
00:13:50,872 --> 00:13:55,359
只需在没有返回语句的情况下获取流构建器即可

96
00:13:55,359 --> 00:13:59,511
并找到那个流构建器视觉工作室代码的结尾对我很有帮助

97
00:13:59,511 --> 00:14:03,511
很好地用这条线在这里说这是流构建器的结束所以我

98
00:14:03,511 --> 00:14:08,231
从字面上看就是这样做，然后把它剪掉，所以现在

99
00:14:08,231 --> 00:14:12,079
你最终应该得到的是你未来的建设者，看起来像

100
00:14:12,079 --> 00:14:17,119
这个然后我基本上会像这样杀死那个未来的建造者好吧

101
00:14:17,119 --> 00:14:22,159
然后将您的流构建器粘贴到您未来构建器的位置

102
00:14:22,159 --> 00:14:27,279
以前所以现在你的身体就是你的身体

103
00:14:27,279 --> 00:14:31,511
你的脚手架应该只是流构建器，所以基本上我们只是

104
00:14:31,511 --> 00:14:36,872
摆脱未来的建设者好吧

105
00:14:36,872 --> 00:14:41,600
所以这就是我们需要做的就是确保我们在这里

106
00:14:41,600 --> 00:14:47,192
不使用我们不会公开您从现在开始看到的用户电子邮件，当我们

107
00:14:47,192 --> 00:14:52,319
create and notes read notes et cetera we're going to use a user id the user's

108
00:14:52,319 --> 00:14:58,399
标识符，所以我们不会与我们的 um 一起处理电子邮件，所以

109
00:14:58,399 --> 00:15:01,680
我也要去我的笔记，对不起，所以嗯

110
00:15:01,680 --> 00:15:05,680
因为屏幕底部的标题表示让我们去改变

111
00:15:05,680 --> 00:15:10,479
这是用户 ID，我们将停止服务

112
00:15:10,479 --> 00:15:15,359
firebase 当前用户，然后我们会得到 id 好的，这就是我们的用户

113
00:15:15,359 --> 00:15:21,039
id，剩下的就是我们的历史了

114
00:15:21,039 --> 00:15:26,231
需要确保这个视图现在适用于我们的

115
00:15:26,231 --> 00:15:30,399
新的节点服务，所以让我们从这里删除这个导入

116
00:15:30,399 --> 00:15:35,600
现在让我们说这个笔记服务它是一个火力云存储所以我们

117
00:15:35,600 --> 00:15:40,159
会说firebase云存储，在这里我们只是添加它

118
00:15:40,159 --> 00:15:44,079
初始化我们说的firebase云存储，呃

119
00:15:44,079 --> 00:15:48,800
如果你没记错的话，它现在是一个单例，所以我们不会创建新的

120
00:15:48,800 --> 00:15:54,231
实例基本上是这样做的，尽管看起来我们正在这样做

121
00:15:54,231 --> 00:15:58,640
所以现在在我们的流构建器中，我们要做的不是全部

122
00:15:58,640 --> 00:16:01,279
不再像我们要说的那样做笔记

123
00:16:01,279 --> 00:16:04,551
所有注释，但我们将传递所有者用户

124
00:16:04,551 --> 00:16:10,800
id 和该所有者用户 id 记住我们将其存储为 getter 调用用户 id

125
00:16:10,800 --> 00:16:16,319
对于我们在这里的所有笔记，请记住，所有笔记都会给我们一个

126
00:16:16,319 --> 00:16:20,079
眼部问题 如果我把鼠标移到那里 你会发现这是眼部问题

127
00:16:20,079 --> 00:16:24,000
云节点所以它不再是一个列表所以让我们说我很麻烦

128
00:16:24,000 --> 00:16:29,680
它是这里的一个云节点

129
00:16:29,680 --> 00:16:32,720
我可以看到它在抱怨

130
00:16:32,720 --> 00:16:36,960
找不到云节点，所以我要像这样导入云节点

131
00:16:36,960 --> 00:16:41,511
在这里删除后，我们还需要确保我们调用新的

132
00:16:41,511 --> 00:16:44,511
说删除节点，在这种情况下，我们只是说

133
00:16:44,511 --> 00:16:48,551
node.document id 没问题

134
00:16:48,551 --> 00:16:52,800
所以这似乎工作正常

135
00:16:52,800 --> 00:16:57,832
但我们在这里得到的是 firebase 云存储节点服务类型的子类型

136
00:16:57,832 --> 00:17:01,832
我们在哪里得到那个错误让我们

137
00:17:01,832 --> 00:17:07,192
看看我们能不能在这里找到节点 2 没关系

138
00:17:07,192 --> 00:17:10,231
那是因为我们可能不必进行热重启和热重启

139
00:17:10,231 --> 00:17:14,720
可以杀死我的 scr cpy，我可以看到它做到了，但这也很好，我是

140
00:17:14,720 --> 00:17:19,119
会像这样调出 scr cpy

141
00:17:19,119 --> 00:17:22,159
我要

142
00:17:22,159 --> 00:17:26,319
这样做，我现在要从头开始运行应用程序，这是

143
00:17:26,319 --> 00:17:29,680
仅仅因为我的意思是这是您应用程序中的状态管理，因为

144
00:17:29,680 --> 00:17:35,600
我们之前有一个节点服务，我们进行了热重载，但全部热重载

145
00:17:35,600 --> 00:17:39,039
突然说哎呀这个曾经是节点的节点服务

146
00:17:39,039 --> 00:17:42,479
服务不再是节点服务它是一个火力云存储所以应该

147
00:17:42,479 --> 00:17:45,760
我用它，所以它就像

148
00:17:45,760 --> 00:17:49,119
状态残留有点像留在你的应用程序和你

149
00:17:49,119 --> 00:17:53,439
在您进行热重启之前无法清理它并且当我进行热重启时我

150
00:17:53,439 --> 00:17:58,000
scr cpy 有问题，所以我无能为力

151
00:17:58,000 --> 00:18:01,039
那个问题，但让我们从头开始运行应用程序并制作

152
00:18:01,039 --> 00:18:06,960
确保一切正常，现在我可以看到我已经登录

153
00:18:06,960 --> 00:18:11,832
进入应用程序，我没有笔记好吗

154
00:18:11,832 --> 00:18:15,600
让我调出下一个 uh 的标题

155
00:18:15,600 --> 00:18:19,279
谈论的话题，所以我们现在需要什么，你可以看到笔记消失了，

156
00:18:19,279 --> 00:18:23,511
这是一个好兆头，因为这意味着我们已经远离了我们的

157
00:18:23,511 --> 00:18:27,832
胯部存储，现在我们没有阅读胯部的那些笔记

158
00:18:27,832 --> 00:18:32,319
存储空间所以让我们去创建一些笔记所以我

159
00:18:32,319 --> 00:18:35,912
想在这里按加号按钮，我只想说注意

160
00:18:35,912 --> 00:18:39,912
第一，所以如果我在这里按下后退按钮，我可以看到第一节点

161
00:18:39,912 --> 00:18:43,600
出现在这里，让我们再创建一个，让我们说注释编号

162
00:18:43,600 --> 00:18:47,680
两个伟大的音符一号和二号如果

163
00:18:47,680 --> 00:18:52,551
我按这个数字二，然后将其更改为注意数字三，你可以看到

164
00:18:52,551 --> 00:18:56,319
这些更改会立即生效

165
00:18:56,319 --> 00:19:01,511
所以让我从这个用户注销，让我们用我真的不知道的身份登录

166
00:19:01,511 --> 00:19:07,279
在我用这个用户登录之前我是用哪个用户登录的，我可以看到

167
00:19:07,279 --> 00:19:09,832
那个用户没有笔记我只想说

168
00:19:09,832 --> 00:19:16,079
van dot的第一个音符出去然后说run dots

169
00:19:16,079 --> 00:19:20,551
第二个音符然后出去，所以现在如果我从这里注销

170
00:19:20,551 --> 00:19:26,960
one.user 在这里，如果我说我想用另一个用户登录

171
00:19:26,960 --> 00:19:30,399
所以像这样我可以看到我的注释一和三是

172
00:19:30,399 --> 00:19:33,279
显示在这里，所以我只能说第一个和第二个注释

173
00:19:33,279 --> 00:19:38,800
如果我从该用户注销并使用 vanbot 再次登录，我应该是

174
00:19:38,800 --> 00:19:42,159
能够看到van dot的笔记

175
00:19:42,159 --> 00:19:47,511
通过 barbaz 很棒，所以现在似乎可以正常工作

176
00:19:47,511 --> 00:19:51,600
我们能做什么我的意思是，如果你和我一样，你很好奇这些数据是如何产生的

177
00:19:51,600 --> 00:19:55,760
实际上存储在firebase中，我们可以这样做，所以让我打开一个窗口

178
00:19:55,760 --> 00:20:02,231
在这里说控制台，让我们继续我们的项目

179
00:20:02,231 --> 00:20:07,912
firebase 控制台，让我们进去吧

180
00:20:07,912 --> 00:20:12,319
我们的数据库，让我们在这里看看

181
00:20:12,319 --> 00:20:16,800
看到有四个文件每个用户每个人两个文件，你

182
00:20:16,800 --> 00:20:21,600
可以看到这两个具有相同的用户 ID，那就是货车用户

183
00:20:21,600 --> 00:20:27,279
您可以看到它以 a 和 c 以及它们拥有的其他两个节点开头

184
00:20:27,279 --> 00:20:33,119
另一个用于像素性 av 的用户 id 记住这个 a 和 c 用户我们能做什么

185
00:20:33,119 --> 00:20:37,760
现在要做的实际上是进入身份验证部分并查看

186
00:20:37,760 --> 00:20:41,511
在此供应商用户处，您可以看到用户 ID a 和 c

187
00:20:41,511 --> 00:20:46,399
另一个用户实际上有 erd 所以如果我们回到 firestore 看看

188
00:20:46,399 --> 00:20:50,640
你可以看到由像素创建的最后两个音符

189
00:20:50,640 --> 00:20:55,511
他们的用户 id 是 erd 你可以在这里看到

190
00:20:55,511 --> 00:20:59,760
非常好，恭喜我们已经能够摆脱两章了

191
00:20:59,760 --> 00:21:06,720
本地 uh crud 存储到 firebase 巨大的饲料做得很好

192
00:21:06,720 --> 00:21:10,720
我们现在需要做的是我是我们，就像我们通常在其他章节中所做的那样，我们是

193
00:21:10,720 --> 00:21:15,511
将提交我们的工作并对其进行标记，因此我将对

194
00:21:15,511 --> 00:21:23,760
在此处筛选并在此处获取 Visual Studio 代码

195
00:21:23,760 --> 00:21:27,439
让尺寸稍微大一点，但没关系

196
00:21:27,439 --> 00:21:33,600
让我们看看我们的日志，我们可以看到最后一步是第 19 步。

197
00:21:33,600 --> 00:21:38,640
让我们做一个 git status 并且有很多文件被修改了，没什么新的

198
00:21:38,640 --> 00:21:42,319
所以我只想说 git add all git commit

199
00:21:42,319 --> 00:21:47,039
第 20 步并按此

200
00:21:47,039 --> 00:21:50,960
让我们看看我们的日志，我们现在有第 19 步和第 20 步，如果你看

201
00:21:50,960 --> 00:21:56,640
在我们的标签中，我们最多可以到第 19 步，包括第 19 步。所以让我们

202
00:21:56,640 --> 00:22:02,960
将此标记为第 20 步，然后推送我们的标签

203
00:22:02,960 --> 00:22:06,399
好吧，这很好，就像传统一样，在结束时

204
00:22:06,399 --> 00:22:11,119
每一章我都会讨论我们在接下来的章节中要讨论的内容

205
00:22:11,119 --> 00:22:16,231
嗯，我们现在谈了很多

206
00:22:16,231 --> 00:22:20,159
允许用户在应用程序中存储自己的笔记，但

207
00:22:20,159 --> 00:22:24,640
如果他允许用户也分享这些笔记会更有趣

208
00:22:24,640 --> 00:22:28,960
他们认识的人 关于他们认识的人，例如朋友或

209
00:22:28,960 --> 00:22:33,600
一个家庭成员，这就是我们下一章要讨论的内容

210
00:22:33,600 --> 00:22:37,912
分享笔记，所以我会在那里见到你你好，欢迎来到第 38 章

211
00:22:37,912 --> 00:22:42,159
在前面的章节中，我们一直在讨论如何使用 Flutter 课程

212
00:22:42,159 --> 00:22:46,640
我们将我们的笔记与我们的 firestore 数据库同步，以及我们如何阅读

213
00:22:46,640 --> 00:22:51,439
那些笔记回来并更新它们真的很有趣也能够

214
00:22:51,439 --> 00:22:54,399
分享我们的笔记，这正是我们要处理的

215
00:22:54,399 --> 00:22:57,760
为了做到这一点，我们需要使用一个

216
00:22:57,760 --> 00:23:03,119
名为 share plus 和 share plus 的插件是一个插件插件，因为我已经

217
00:23:03,119 --> 00:23:07,832
现在提到，所以它不是一个包扩展现有包的包

218
00:23:07,832 --> 00:23:13,832
将 Flutter 功能推向新高度 一个插件采用了一条全新的路线

219
00:23:13,832 --> 00:23:16,399
基本上

220
00:23:16,399 --> 00:23:19,912
嗯，远远超出了扑腾的范围

221
00:23:19,912 --> 00:23:25,680
内部可以交付并且需要开发插件的数据包

222
00:23:25,680 --> 00:23:28,399
打扰一下开发人员或一组开发人员

223
00:23:28,399 --> 00:23:31,359
它需要专门为

224
00:23:31,359 --> 00:23:34,960
该插件想要支持的各种平台，例如 ios android 所以

225
00:23:34,960 --> 00:23:39,832
开发人员必须按顺序为 ios 为 android web 等编写一些代码

226
00:23:39,832 --> 00:23:42,960
让该插件在这些平台上工作

227
00:23:42,960 --> 00:23:47,192
现在在这里我们将使用share plus插件，share plus插件是

228
00:23:47,192 --> 00:23:52,479
由颤振社区开发，所以我们将在这里看看

229
00:23:52,479 --> 00:23:56,551
是进入pubdev

230
00:23:56,551 --> 00:24:00,640
所以我现在就去做

231
00:24:00,640 --> 00:24:07,119
原谅我的喉咙，在 pub dev 我们要搜索 uh share plus

232
00:24:07,119 --> 00:24:09,912
完成之后，你会看到你最终会来到这里，它是由一个

233
00:24:09,912 --> 00:24:13,511
经过验证的开发人员名为fluttercommunity.dev，因此您可以点击

234
00:24:13,511 --> 00:24:17,760
您可以在此处获得有关开发人员的更多信息

235
00:24:17,760 --> 00:24:22,399
你可以看到它支持 android ios linux mac os web 和 windows 那又怎样

236
00:24:22,399 --> 00:24:27,600
你能要求更多吗，所以这是一个免费的套餐，你可以

237
00:24:27,600 --> 00:24:32,231
在您的应用程序中使用，您可以看到您需要做的只是让我们

238
00:24:32,231 --> 00:24:36,551
去ins安装，你看到你不得不说flutter pop

239
00:24:36,551 --> 00:24:40,720
添加分享加，这正是我们要做的

240
00:24:40,720 --> 00:24:44,960
现在在我们的应用程序中，所以我要把我们的应用程序带到这里

241
00:24:44,960 --> 00:24:49,039
让我们再一次原谅我

242
00:24:49,039 --> 00:24:53,912
在我们的终端中，我将在这里重新安排一些事情

243
00:24:53,912 --> 00:24:56,720
好吧其实也许我也可以这样做

244
00:24:56,720 --> 00:25:01,439
我们以前做过的事情，所以让我增加这个的大小

245
00:25:01,439 --> 00:25:05,511
终端，以便您看得更清楚，所以让我们做同样的事情

246
00:25:05,511 --> 00:25:11,359
文档中提到 so flutter pub ad share plus so flutter

247
00:25:11,359 --> 00:25:14,960
操作广告份额加

248
00:25:14,960 --> 00:25:18,720
这个份额加上因为它是一个全新的

249
00:25:18,720 --> 00:25:21,439
您要添加到应用程序中的插件非常重要

250
00:25:21,439 --> 00:25:25,279
基本上重建您的应用程序，否则它将不可用

251
00:25:25,279 --> 00:25:30,800
好的，所以你可以做的是清理然后重建这是

252
00:25:30,800 --> 00:25:36,399
清理对于 ios 尤其重要，因为有时当您添加

253
00:25:36,399 --> 00:25:42,000
新插件嗯，因为颤振使用可可豆荚

254
00:25:42,000 --> 00:25:47,192
处理 ios 依赖项，那么您的构建可能不会

255
00:25:47,192 --> 00:25:50,800
实际上能够接受新的依赖，所以做一个很重要

256
00:25:50,800 --> 00:25:56,159
干净但对于 android 这通常不是问题所以我只是要去

257
00:25:56,159 --> 00:26:00,479
对不起，我只是要重建应用程序，看看一切是否正常

258
00:26:00,479 --> 00:26:04,640
按预期工作，所以我要在这里停止应用程序

259
00:26:04,640 --> 00:26:09,680
我只是要确保颤振选择设备正在使用我的

260
00:26:09,680 --> 00:26:15,039
android 电话，然后我要去 main dart 说

261
00:26:15,039 --> 00:26:19,912
在没有调试的情况下运行运行它说我们有一些错误所以

262
00:26:19,912 --> 00:26:24,399
让我们看看我们是否可以在这里修复这些错误

263
00:26:24,399 --> 00:26:28,159
好的分享加插件，我可以看到我们现在已经遇到了问题

264
00:26:28,159 --> 00:26:33,192
在我们的应用程序中，所以也许这就是为什么你必须做一个清洁所以让我们继续吧

265
00:26:33,192 --> 00:26:35,439
我要去终点站，我要说

266
00:26:35,439 --> 00:26:38,800
扑干净

267
00:26:38,800 --> 00:26:41,359
好的，这将清理 xcode

268
00:26:41,359 --> 00:26:44,231
工作区，希望它也能清理安卓，所以我只是

269
00:26:44,231 --> 00:26:49,511
要说flutter clean android

270
00:26:49,511 --> 00:26:52,000
你的意思是这些中的任何一个我没有写干净吗

271
00:26:52,000 --> 00:26:58,399
我写得很清楚，很干净的android哦，它在做同样的事情，好吧

272
00:26:58,399 --> 00:27:06,399
所以我会颤抖，让我们说pop get

273
00:27:06,399 --> 00:27:11,279
所以这将重建我们所有的依赖

274
00:27:11,279 --> 00:27:16,720
所以我们现在开始这些错误已经消失了，所以你可能不得不

275
00:27:16,720 --> 00:27:21,832
颤抖干净，我试图在不使用它的情况下逃脱，但我是

276
00:27:21,832 --> 00:27:26,231
最终被迫在主要飞镖中如此，我只想说

277
00:27:26,231 --> 00:27:29,680
在没有调试的情况下运行，这只是需要时间去

278
00:27:29,680 --> 00:27:33,279
scr cpy 我只是要把 scr cpy 带到

279
00:27:33,279 --> 00:27:37,039
屏幕也很快我会确保我可以访问这个

280
00:27:37,039 --> 00:27:40,159
电话，因为我经常玩 wi-fi

281
00:27:40,159 --> 00:27:44,079
和这个 android 手机上的热点，所以有时我实际上并没有

282
00:27:44,079 --> 00:27:47,760
有无线网络

283
00:27:47,760 --> 00:27:54,079
好的，这似乎正在运行，这是呃，那部安卓手机，我可以

284
00:27:54,079 --> 00:27:58,399
看到颤振应用程序正在尝试运行，能够很好地运行它并且

285
00:27:58,399 --> 00:28:02,872
在那部手机上，所以我们已经完成了我们已经完成了清洁

286
00:28:02,872 --> 00:28:06,960
并重建，这样很好

287
00:28:06,960 --> 00:28:12,479
我们要处理的第一件事是禁止共享 mt 笔记

288
00:28:12,479 --> 00:28:17,832
你看看你是否在笔记屏幕上，例如你甚至没有

289
00:28:17,832 --> 00:28:20,720
在你的笔记中写了任何你不应该分享的笔记

290
00:28:20,720 --> 00:28:25,119
和任何人在一起，因为那里只是空文本，所以让我们继续吧

291
00:28:25,119 --> 00:28:29,912
我们需要通过对话来处理这种情况

292
00:28:29,912 --> 00:28:34,479
我们将在这个文件夹中创建这个对话

293
00:28:34,479 --> 00:28:37,912
再次对不起，我今天说了很多，这就是为什么我的喉咙

294
00:28:37,912 --> 00:28:42,960
给我一些麻烦，所以让我们去下面的 lib 实用程序

295
00:28:42,960 --> 00:28:46,960
我们要创建的对话不能共享空节点对话好的

296
00:28:46,960 --> 00:28:52,720
呃让我在这里稍微改变一下屏幕布局

297
00:28:52,720 --> 00:28:57,192
我们在那里的观点和我们的服务

298
00:28:57,192 --> 00:29:00,159
所以让我们看看我们有什么不变的同义词扩展服务

299
00:29:00,159 --> 00:29:05,192
实用程序和视图，但我们没有所以是的，我们有实用程序，我们有

300
00:29:05,192 --> 00:29:09,359
对话，所以我们必须创建一个新文件让我们说新文件，我要

301
00:29:09,359 --> 00:29:15,192
说不能共享空节点对话框飞镖

302
00:29:15,192 --> 00:29:19,511
你会记得，我们已经有一个

303
00:29:19,511 --> 00:29:23,439
通用对话所以我要做的是我要说未来

304
00:29:23,439 --> 00:29:28,000
的 void 所以函数签名将

305
00:29:28,000 --> 00:29:31,680
看起来像这样，因为我在屏幕底部向您展示所以让我们说显示

306
00:29:31,680 --> 00:29:35,600
不能分享空笔记对话这是一个很长的名字

307
00:29:35,600 --> 00:29:40,319
然后它返回它需要一个构建上下文，所以构建上下文上下文

308
00:29:40,319 --> 00:29:44,079
没关系，那么我们将在此做些什么

309
00:29:44,079 --> 00:29:49,359
功能是返回我们的通用对话框，这是

310
00:29:49,359 --> 00:29:53,279
我真的很自豪我们可以创造并且我们正在使用它这么多

311
00:29:53,279 --> 00:29:57,039
现在很多时候令人难以置信，所以我们实际上有一个对话框实现

312
00:29:57,039 --> 00:30:01,511
在整个应用程序中，我们只是重用它，它是真正通用的

313
00:30:01,511 --> 00:30:05,279
真的很好，所以让我们在这里假设我们

314
00:30:05,279 --> 00:30:10,960
返回我们的通用显示通用对话框

315
00:30:10,960 --> 00:30:14,479
它还将导入它对我来说它在实用程序对话框中通用

316
00:30:14,479 --> 00:30:17,439
对话框，因此如果您的

317
00:30:17,439 --> 00:30:22,872
编辑器不允许您自动导入，因此上下文已经存在

318
00:30:22,872 --> 00:30:27,119
标题我们只会说分享内容我会说你

319
00:30:27,119 --> 00:30:31,832
不能分享一个空的笔记好吗

320
00:30:31,832 --> 00:30:35,760
它的选项生成器记住它是一个应该返回的函数

321
00:30:35,760 --> 00:30:39,680
嗯一张地图，在地图上我们要

322
00:30:39,680 --> 00:30:44,319
说它有一个实际上没有任何价值的按钮

323
00:30:44,319 --> 00:30:49,600
所以这将使它成为一个返回 void 或 a

324
00:30:49,600 --> 00:30:53,680
当我们在这里称呼它时，虚无的未来

325
00:30:53,680 --> 00:30:58,800
好的，现在创建了这个文件，我们要做的是去

326
00:30:58,800 --> 00:31:02,399
添加该按钮，您可以在创建更新注释视图中看到它添加一个图标

327
00:31:02,399 --> 00:31:06,872
按钮到应用栏的操作，所以我也要去我的笔记和

328
00:31:06,872 --> 00:31:11,279
创建更新，让我们继续添加它

329
00:31:11,279 --> 00:31:14,960
按钮，我们开始

330
00:31:14,960 --> 00:31:18,319
我可以看到我们正在使用共享图标，所以我要减小

331
00:31:18,319 --> 00:31:22,159
这个字体现在很大

332
00:31:22,159 --> 00:31:26,960
再迈一步，我想你仍然可以看到它的样子我的意思是我可以看到

333
00:31:26,960 --> 00:31:30,720
视频输出视频它应该仍然可见，即使我已经减少了

334
00:31:30,720 --> 00:31:35,039
大小所以让我去这里带来 scr cpy 我是

335
00:31:35,039 --> 00:31:39,192
将关闭这个 Safari 窗口

336
00:31:39,192 --> 00:31:43,912
让我们去创建更新笔记视图，我们已经有这个按钮了

337
00:31:43,912 --> 00:31:47,511
我相信让我们看看顶部是否有任何按钮

338
00:31:47,511 --> 00:31:50,720
不，我们实际上不是这样

339
00:31:50,720 --> 00:31:55,439
在我们的应用栏中，让我们在这里和你创建一个叫做动作的东西

340
00:31:55,439 --> 00:31:59,760
可以看到它是一个小部件列表，在这里我们只说图标按钮

341
00:31:59,760 --> 00:32:03,832
不按压力，我们只是将其留空，对于它的图标，我们就走了

342
00:32:03,832 --> 00:32:12,319
说 const icon 并且我们将使用图标共享

343
00:32:12,319 --> 00:32:15,912
从那里删除这个括号，然后放

344
00:32:15,912 --> 00:32:21,439
像这样好吧，现在我们有这个图标图标按钮，如果我按下

345
00:32:21,439 --> 00:32:25,760
在这些现有笔记中的任何一个上，我们应该能够看到一点点分享

346
00:32:25,760 --> 00:32:29,832
按钮在这里的那一刻它没有做任何事情，因为它正在按下是

347
00:32:29,832 --> 00:32:34,551
空的，但我们现在要对那个程序进行编程

348
00:32:34,551 --> 00:32:39,039
所以让我们获取当前节点的当前文本，所以让我们说这个

349
00:32:39,039 --> 00:32:44,551
等于我们的文本控制器的文本，我们要说 if note

350
00:32:44,551 --> 00:32:47,600
不为空并且

351
00:32:47,600 --> 00:32:52,872
文本 um 实际上让我们检查 null

352
00:32:52,872 --> 00:32:57,359
和文字或实际上

353
00:32:57,359 --> 00:33:03,192
或者这个文本是空的，那么我们将显示我们刚刚的新对话

354
00:33:03,192 --> 00:33:07,912
实施了，所以我们只是说我们等待演出不能

355
00:33:07,912 --> 00:33:12,872
那个叫show的函数是什么不能uh

356
00:33:12,872 --> 00:33:17,760
我们在不能共享空笔记中做到了，所以我只是要复制它的名字

357
00:33:17,760 --> 00:33:21,039
然后进入这里并粘贴它

358
00:33:21,039 --> 00:33:25,600
现在我将使用 Visual Studio 代码为我进行自动导入

359
00:33:25,600 --> 00:33:29,760
所以它需要一个构建上下文，在这里我将传递上下文并

360
00:33:29,760 --> 00:33:33,192
你可以看到它在抱怨我在一个未按下的内部使用了一个重量

361
00:33:33,192 --> 00:33:37,192
不是异步的函数，所以我只是要使这个函数异步好

362
00:33:37,192 --> 00:33:40,551
否则我们要做的是我们将使用共享

363
00:33:40,551 --> 00:33:45,760
并分享它来自share plus，它可以自动导入好的，所以我

364
00:33:45,760 --> 00:33:49,912
还要导入它，在这里我只想说分享那个文本

365
00:33:49,912 --> 00:33:55,039
真的就这么简单，所以让我们进入这里，我要创建

366
00:33:55,039 --> 00:33:58,551
一个新的笔记，你可以看到它没有我要写的文字

367
00:33:58,551 --> 00:34:03,039
按下分享按钮，现在我们看到了，我们看到了我们美丽的小宝贝

368
00:34:03,039 --> 00:34:07,279
对话说你不能分享一个空笔记太棒了，如果我出去

369
00:34:07,279 --> 00:34:11,439
那个笔记被删除了，但是如果我去一个笔记

370
00:34:11,439 --> 00:34:14,960
在这里有文本，例如 van dot 的第二个音符或 vandal 的第一个音符

371
00:34:14,960 --> 00:34:18,872
我要去 van.firstnode 然后如果我按下分享按钮然后

372
00:34:18,872 --> 00:34:24,872
在这种情况下，我将看到 android 的默认共享

373
00:34:24,872 --> 00:34:28,551
工作表或您想如何称呼它以及在 ios 上您将看到

374
00:34:28,551 --> 00:34:33,511
默认的 ios 共享活动，所以这差不多，所以我们没有

375
00:34:33,511 --> 00:34:37,600
要做的远不止这些，实际上调用是 share.share 所以你可以看到

376
00:34:37,600 --> 00:34:42,159
当你拖入一个插件尤其是一个插件时，它是如此简单

377
00:34:42,159 --> 00:34:46,479
来自经过验证的开发人员，尤其是来自 Flutter 社区或 Flutter 团队的开发人员

378
00:34:46,479 --> 00:34:51,760
或者黑暗的开发团队自己都很好，所以那是为了

379
00:34:51,760 --> 00:34:56,231
分享没有比这更多的了，我们不必拖延

380
00:34:56,231 --> 00:35:00,000
在这一章，让我们继续这个传统

381
00:35:00,000 --> 00:35:06,399
我们要去 呃 提交我们的工作 所以我要在这里做一些洗牌

382
00:35:06,399 --> 00:35:11,359
将摆脱 scrcpy 增加大小

383
00:35:11,359 --> 00:35:15,039
屏幕和字体，让您看得更清楚

384
00:35:15,039 --> 00:35:19,039
那么让我们去我们的终端

385
00:35:19,039 --> 00:35:24,720
我要看看我们在上一章提交的 git 日志

386
00:35:24,720 --> 00:35:30,720
第 20 步，我们也标记为第 20 步。在这种情况下，我们只执行第 21 步

387
00:35:30,720 --> 00:35:36,159
所以获取状态我们有很多新东西所以如果我说在这里获取状态你

388
00:35:36,159 --> 00:35:41,600
在这里也可以看到一个新文件，所以让我们提交为

389
00:35:41,600 --> 00:35:46,960
第 21 步并推送我们的提交

390
00:35:46,960 --> 00:35:51,600
我会去标记它并说第21步

391
00:35:51,600 --> 00:35:56,551
然后我们也推送我们的标签，好吧，完美，就是这样，如果你说 git

392
00:35:56,551 --> 00:36:00,800
status 现在我们不应该有任何未提交的文件

393
00:36:00,800 --> 00:36:05,192
做得很好所以我们接下来要做什么

394
00:36:05,192 --> 00:36:10,720
章节非常非常令人兴奋，我们将深入研究一个块和

395
00:36:10,720 --> 00:36:14,159
如果你之前是 Flutter 开发者

396
00:36:14,159 --> 00:36:18,079
知道什么是块，或者你可能听说过它并且你想了解它

397
00:36:18,079 --> 00:36:21,680
如果您不是 Flutter 开发人员，那么下一章非常适合您

398
00:36:21,680 --> 00:36:27,192
从之前你可能不知道什么是块，但是我会解释更多

399
00:36:27,192 --> 00:36:30,551
我会在本章的最后，我不会详细介绍

400
00:36:30,551 --> 00:36:35,680
下一章但我们要谈的是此刻我们的 ui 是如何

401
00:36:35,680 --> 00:36:41,119
我们的不同观点是否实际上直接与我们的服务一起使用，所以我们

402
00:36:41,119 --> 00:36:45,439
有一些服务，例如可以在 um 中存储东西

403
00:36:45,439 --> 00:36:49,760
在 firestore 数据库中，我们也有一些类似的服务

404
00:36:49,760 --> 00:36:53,600
对于我们的身份验证，按下登录按钮时的 uis 我们将

405
00:36:53,600 --> 00:36:57,600
关闭服务和关闭服务将直接返回给我们

406
00:36:57,600 --> 00:37:00,720
ui这是工作它很好但是

407
00:37:00,720 --> 00:37:03,511
有更好的方法来做到这一点，那就是通过

408
00:37:03,511 --> 00:37:09,600
将我们的用户界面逻辑与我们的业务逻辑分开，确保

409
00:37:09,600 --> 00:37:15,192
我们的用户界面正在做它最了解的最好的事情，那就是画东西

410
00:37:15,192 --> 00:37:19,119
屏幕，但在处理逻辑等方面

411
00:37:19,119 --> 00:37:23,039
进行 api 调用等 ui 不应该对此了解太多

412
00:37:23,039 --> 00:37:27,912
用户界面应该只是将其目的传达给我们将要处理的某种层

413
00:37:27,912 --> 00:37:31,359
使用块库在我们的应用程序中创建，该层将决定

414
00:37:31,359 --> 00:37:35,359
好的，按下此按钮后，我实际上必须执行此业务逻辑

415
00:37:35,359 --> 00:37:38,159
所以我实际上对下一个非常兴奋

416
00:37:38,159 --> 00:37:41,912
章节所以如果你想吃点点心

417
00:37:41,912 --> 00:37:46,479
我会在那里见到你你好，欢迎来到这个颤振课程的第 39 章

418
00:37:46,479 --> 00:37:49,439
呃上一章最后我们讲到

419
00:37:49,439 --> 00:37:52,479
在本章中我们将要讨论的

420
00:37:52,479 --> 00:37:57,680
块库，这是 Flutter 的热门话题

421
00:37:57,680 --> 00:38:01,439
开发者喜欢如果你是一个 Flutter 开发者并且你刚刚经历过

422
00:38:01,439 --> 00:38:06,079
在您的应用程序中使用 vanilla set state 您可能已经

423
00:38:06,079 --> 00:38:10,960
之前听说过块库和量子比特

424
00:38:10,960 --> 00:38:14,159
你不是以前的颤振开发者，我实际上认为

425
00:38:14,159 --> 00:38:17,119
参加这门课程的大多数人可能还没有被吓倒

426
00:38:17,119 --> 00:38:20,720
以前的参与者，所以你可能没有听说过阻塞

427
00:38:20,720 --> 00:38:25,192
呃之前，所以我将通过解释什么来开始这一章

428
00:38:25,192 --> 00:38:29,359
块库是我们为什么需要它

429
00:38:29,359 --> 00:38:33,600
您看到我们目前创建应用程序的方式是，我们

430
00:38:33,600 --> 00:38:38,720
从我们的 ui 代码直接调用我们的不同服务，以便

431
00:38:38,720 --> 00:38:41,119
与数据交互

432
00:38:41,119 --> 00:38:49,279
用户界面非常了解业务逻辑，因此例如

433
00:38:49,279 --> 00:38:52,399
创建或获取现有节点功能

434
00:38:52,399 --> 00:38:56,720
当我们实际去创建一个已经是单词的新节点时，我们拥有

435
00:38:56,720 --> 00:39:01,439
事实上，如果你最终来到这里，我希望有一个用户在场

436
00:39:01,439 --> 00:39:05,279
在应用程序内部，因此用户应该登录，这就是

437
00:39:05,279 --> 00:39:09,359
一个示例 一个 ui 组件被感知的示例

438
00:39:09,359 --> 00:39:13,912
逻辑我们应用程序的业务逻辑，所以他们应该

439
00:39:13,912 --> 00:39:16,800
否则彼此非常分开

440
00:39:16,800 --> 00:39:23,439
但他们现在不是所以什么是块块是一个嗯是一个

441
00:39:23,439 --> 00:39:26,872
我们将很快将其拖入我们的应用程序的库，您也会看到

442
00:39:26,872 --> 00:39:32,000
是第三方库调用我相信它是由一家名为的公司创建的

443
00:39:32,000 --> 00:39:35,832
很好的冒险vgv

444
00:39:35,832 --> 00:39:39,600
并且有各种各样的 Flutter 开发人员和软件工程师

445
00:39:39,600 --> 00:39:45,192
不断努力以提高块库的质量

446
00:39:45,192 --> 00:39:48,872
这是一个将引入我们的应用程序并使用块的依赖项

447
00:39:48,872 --> 00:39:53,279
我的意思是在内部使用流和流流控制器的库

448
00:39:53,279 --> 00:39:57,760
并期货已经内置在颤振中的东西，但这就像去

449
00:39:57,760 --> 00:40:01,680
到一个新的水平，使事情更抽象，这样我们的应用程序就不是

450
00:40:01,680 --> 00:40:07,359
直接依赖其业务逻辑与 ui 混杂

451
00:40:07,359 --> 00:40:09,832
所以

452
00:40:09,832 --> 00:40:14,479
我们需要块库的原因只是为了确保我们的 ui 只是

453
00:40:14,479 --> 00:40:19,832
处理 ui 的呈现，剩下的就离开了

454
00:40:19,832 --> 00:40:23,439
业务逻辑层的东西

455
00:40:23,439 --> 00:40:27,359
打扰一下

456
00:40:27,359 --> 00:40:34,079
所以这就是我们需要块的原因，我们很快就会在我们的应用程序中使用它

457
00:40:34,079 --> 00:40:37,912
对不起，如果那被阻止了，那是什么

458
00:40:37,912 --> 00:40:44,231
您在其内部看到的颤振块是一个非常简单的库

459
00:40:44,231 --> 00:40:48,800
与流和流控制器一起使用，因此它允许您

460
00:40:48,800 --> 00:40:52,159
实例将数据从这里传递到那里并让监听器监听

461
00:40:52,159 --> 00:40:55,912
流中发生的变化，所以它只能在非常低的情况下工作

462
00:40:55,912 --> 00:41:01,359
然而，当你来到你的 ui 层时，水平流的东西

463
00:41:01,359 --> 00:41:04,800
你还记得我提到过那个块可以让你分开你的

464
00:41:04,800 --> 00:41:08,720
来自您的用户界面的业务逻辑

465
00:41:08,720 --> 00:41:11,760
它使用流和流控制器处理业务逻辑

466
00:41:11,760 --> 00:41:16,479
futures 但是当涉及到 ui 部分时，为了粘合这个业务逻辑

467
00:41:16,479 --> 00:41:21,192
使用 ui 它需要能够使用颤振

468
00:41:21,192 --> 00:41:23,359
所以与流一起工作的部分和

469
00:41:23,359 --> 00:41:28,720
流控制器使用 dart OK 和 dart 异步组件，但是

470
00:41:28,720 --> 00:41:32,720
它想要与你的用户界面粘合的部分需要颤抖

471
00:41:32,720 --> 00:41:36,720
世界还好，图书馆本身就是

472
00:41:36,720 --> 00:41:41,279
称为flutter block所以fl block分为两个独立的库一个

473
00:41:41,279 --> 00:41:45,912
是负责业务逻辑等的块，另一个是

474
00:41:45,912 --> 00:41:50,399
可以调用颤振块，但不要担心，我会经历

475
00:41:50,399 --> 00:41:57,039
一步一步地与你一起学习，这样你就可以学会这些

476
00:41:57,039 --> 00:42:00,000
打扰一下

477
00:42:00,000 --> 00:42:02,720
所以我们将在本章中做什么

478
00:42:02,720 --> 00:42:06,000
将有它实际上与我们无关

479
00:42:06,000 --> 00:42:10,000
应用程序我们一直在使用笔记应用程序，在本章中，我们将

480
00:42:10,000 --> 00:42:12,960
实际上会像字面意思一样稍微破坏我们的应用程序

481
00:42:12,960 --> 00:42:16,079
将我们应用程序的主页替换为

482
00:42:16,079 --> 00:42:20,231
全新的应用程序并不可怕我向你保证我们所做的改变

483
00:42:20,231 --> 00:42:26,399
要做的可能只是仅限于 main.dark 文件

484
00:42:26,399 --> 00:42:30,231
我们要做的是创建一个

485
00:42:30,231 --> 00:42:34,872
如果您以前使用过颤振并且您已经使用过

486
00:42:34,872 --> 00:42:37,511
开始考虑也许搬到

487
00:42:37,511 --> 00:42:42,000
块，您实际上可能已经访问了块库的文档页面，并且

488
00:42:42,000 --> 00:42:44,960
您已经在其中看到了一个计数器应用程序，其中有加号和减号

489
00:42:44,960 --> 00:42:48,479
按钮，您可以增加和减少屏幕上显示的值，以便

490
00:42:48,479 --> 00:42:51,832
这就像基本的计数器应用程序

491
00:42:51,832 --> 00:42:55,680
但在这个例子中，我将向你展示我们将把这个例子

492
00:42:55,680 --> 00:42:59,511
下一个级别并使用块库，我将介绍所有

493
00:42:59,511 --> 00:43:04,231
本章将向您介绍块库的基础知识，但我们将把它带到

494
00:43:04,231 --> 00:43:08,960
下一级并允许用户在屏幕上输入一些值

495
00:43:08,960 --> 00:43:14,640
然后可以从当前值中添加或减去值

496
00:43:14,640 --> 00:43:18,872
应用程序存储的值，所以它有点像计数器应用程序

497
00:43:18,872 --> 00:43:22,231
用户可以在其中实际输入需要添加到

498
00:43:22,231 --> 00:43:25,680
以前的帐户或需要从以前的帐户中减去所以

499
00:43:25,680 --> 00:43:29,912
这就是我们简单的计数器应用程序和什么之间的区别

500
00:43:29,912 --> 00:43:34,000
块库计数器应用程序在其文档中

501
00:43:34,000 --> 00:43:38,479
给你介绍一下

502
00:43:38,479 --> 00:43:43,359
让我在这里提出这个标题，我们将讨论一下

503
00:43:43,359 --> 00:43:50,319
一个块的各种组成部分，我非常清楚

504
00:43:50,319 --> 00:43:55,511
我在本章中所说的一切，直到我们到达这个例子的地方是

505
00:43:55,511 --> 00:43:58,960
非常抽象，因为它是

506
00:43:58,960 --> 00:44:03,192
从字面上看只是理论我喜欢在这里教你理论

507
00:44:03,192 --> 00:44:08,720
我个人在理论方面很糟糕，就像我在学校里没有出类拔萃一样

508
00:44:08,720 --> 00:44:15,119
理论所以我很清楚你们中的很多人可能也有同样的情况

509
00:44:15,119 --> 00:44:18,640
或者也许在同一条船上，我不擅长理论，没关系

510
00:44:18,640 --> 00:44:21,439
我会快速解释这些，然后我们会去实现，所以你

511
00:44:21,439 --> 00:44:25,439
可以把它付诸实践，所以对于那些对理论感兴趣的人来说

512
00:44:25,439 --> 00:44:29,511
我现在要向你解释块库的不同部分

513
00:44:29,511 --> 00:44:32,159
所以这里是第一个

514
00:44:32,159 --> 00:44:36,479
块库的组件是一个名为块的类

515
00:44:36,479 --> 00:44:43,600
现在块真的它是一个容器想象一个类你添加的一个类

516
00:44:43,600 --> 00:44:50,000
事件和你添加到它的每个事件都可以产生一个状态，所以方式

517
00:44:50,000 --> 00:44:57,039
块的作用在于它是一个以状态开头的类，因此它的输出

518
00:44:57,039 --> 00:45:02,551
总是一个状态，例如一个状态可以被记录在一个状态可以被记录

519
00:45:02,551 --> 00:45:04,960
出状态可能是

520
00:45:04,960 --> 00:45:10,159
错误屏幕所以想象一下应用程序的不同状态

521
00:45:10,159 --> 00:45:16,479
所以这是输入对不起输出输入是你的事件所以

522
00:45:16,479 --> 00:45:20,551
在你将要发展的街区中，你将拥有

523
00:45:20,551 --> 00:45:25,119
例如，您说使用此用户名和密码登录的输入

524
00:45:25,119 --> 00:45:29,511
使用此用户名或此电子邮件和密码注册哦，我忘记了

525
00:45:29,511 --> 00:45:33,832
我的密码，这是我的电子邮件，所以这些是你要参加的活动

526
00:45:33,832 --> 00:45:38,872
生产并给你的块，然后你的块然后看它自己的

527
00:45:38,872 --> 00:45:42,960
内部并说哦，在当前事件是什么之前，这个状态是什么，然后我

528
00:45:42,960 --> 00:45:51,039
将产生一个新状态，这就是块类的内部

529
00:45:51,039 --> 00:45:55,359
现在当你有一个街区课的时候我们要

530
00:45:55,359 --> 00:45:59,760
该块类的子类，那么您实际上需要创建一个实例

531
00:45:59,760 --> 00:46:04,551
块类，你将使用称为块提供程序的东西来做到这一点

532
00:46:04,551 --> 00:46:09,511
就像它的名字一样，它是一个创建 um 的类

533
00:46:09,511 --> 00:46:15,680
它为你创建一个块实例，然后它会允许你做一些事情

534
00:46:15,680 --> 00:46:18,551
用那个块

535
00:46:18,551 --> 00:46:22,399
我会看看我是否真的可以

536
00:46:22,399 --> 00:46:25,832
显示你阻止提供者呃

537
00:46:25,832 --> 00:46:32,832
也许我们可以在这里打开一扇窗户，我会

538
00:46:32,832 --> 00:46:39,760
这么说像brarry一样阻止你现在看不到我的屏幕，但我

539
00:46:39,760 --> 00:46:43,600
答应你我很快就会给你看所以这是呃

540
00:46:43,600 --> 00:46:46,872
块库的主页，所以我会

541
00:46:46,872 --> 00:46:51,119
增加字体大小，以便您也可以看到它

542
00:46:51,119 --> 00:46:56,079
所以让我们继续吧，你会看到它是由非常好的企业赞助的

543
00:46:56,079 --> 00:47:00,640
流和梅多我不确定我可能已经屠杀了

544
00:47:00,640 --> 00:47:05,511
这个名字现在我为此道歉，但是如果你看

545
00:47:05,511 --> 00:47:09,912
块的各个部分然后你会看到让我们看看

546
00:47:09,912 --> 00:47:14,720
如果我可以在这里为您找到块提供商

547
00:47:14,720 --> 00:47:18,551
它可能在文档中，所以我要开始，然后

548
00:47:18,551 --> 00:47:23,439
我要看看块包块，让我们看看提供者是否

549
00:47:23,439 --> 00:47:27,119
你可以在这里找到提供商

550
00:47:27,119 --> 00:47:31,511
块 uh 架构命名约定

551
00:47:31,511 --> 00:47:36,479
开始是不是有什么东西在里面我有一个

552
00:47:36,479 --> 00:47:40,000
现在有点问题实际上找到了块

553
00:47:40,000 --> 00:47:45,359
提供者所以让我们搜索它块提供者

554
00:47:45,359 --> 00:47:49,119
然后我们就到这里了

555
00:47:49,119 --> 00:47:52,159
我的意思是这不是最好的

556
00:47:52,159 --> 00:47:54,640
现在的文档说实话，我们不想寻找

557
00:47:54,640 --> 00:47:58,551
博客提供商就在这里，但正如您所看到的，它说这是一个颤抖

558
00:47:58,551 --> 00:48:02,720
为它的孩子提供一个块的小部件，所以这就是你的工作方式

559
00:48:02,720 --> 00:48:08,000
使用块提供程序，因此它会为您创建块实例，然后它将

560
00:48:08,000 --> 00:48:13,119
允许你把孩子还给我，有点像建筑商，但不是真的

561
00:48:13,119 --> 00:48:15,680
好的

562
00:48:15,680 --> 00:48:20,359
所以这是块提供者，正如我提到的，你总是可以去块

563
00:48:20,359 --> 00:48:24,551
library.dev 网站以获取更多信息

564
00:48:24,551 --> 00:48:29,511
关于块并阅读其文档

565
00:48:29,511 --> 00:48:33,511
所以你需要知道的下一个组件是

566
00:48:33,511 --> 00:48:36,872
阻止监听器所以

567
00:48:36,872 --> 00:48:41,760
什么是块侦听器，因为它的名称表明块侦听器只允许

568
00:48:41,760 --> 00:48:46,000
你去勾搭一个嗯我会看看我们是否有一个

569
00:48:46,000 --> 00:48:50,079
阻止侦听器我可以看到我们在此应用程序中有一个博客侦听器

570
00:48:50,079 --> 00:48:52,960
我们要开发，所以你很快就会了解它，但是一个块

571
00:48:52,960 --> 00:48:57,039
监听器，顾名思义，它监听块状态的变化

572
00:48:57,039 --> 00:49:01,192
就是这样，你可以做一些副作用，所以显示一个新屏幕

573
00:49:01,192 --> 00:49:05,039
实例或显示错误消息，这些都是副作用，所以你

574
00:49:05,039 --> 00:49:09,119
可以用块监听器做到这一点

575
00:49:09,119 --> 00:49:14,231
现在让我们看看块生成器是如何使用你的块状态更改的

576
00:49:14,231 --> 00:49:21,119
为您提供一个小部件，以便我们有一个块提供者，对不起

577
00:49:21,119 --> 00:49:26,079
我们讨论了块提供者，然后它基本上给你机会

578
00:49:26,079 --> 00:49:28,000
创建嗯

579
00:49:28,000 --> 00:49:34,960
现在在这个孩子里面有一个孩子，然后你可以提供一个创建块构建器

580
00:49:34,960 --> 00:49:39,279
监听你的块内的变化然后它允许你构建新的

581
00:49:39,279 --> 00:49:44,399
基于这些更改的小部件，因此它非常像未来的构建器或

582
00:49:44,399 --> 00:49:48,079
就像我会说的流构建器，我们已经使用了流构建器，所以你

583
00:49:48,079 --> 00:49:52,720
应该知道它们是如何工作的，但这只是理论，所以嗯

584
00:49:52,720 --> 00:49:58,079
当我们实际构建我们的应用程序时，我将更多地谈论这些

585
00:49:58,079 --> 00:50:01,760
所以毕竟我们也有一个块

586
00:50:01,760 --> 00:50:06,231
消费者和块消费者是什么，它结合了我实际写的

587
00:50:06,231 --> 00:50:10,079
在这里，它结合了块监听器和块构建器，因此是块消费者

588
00:50:10,079 --> 00:50:15,119
监听块内发生的变化，然后它会允许你做

589
00:50:15,119 --> 00:50:18,720
既是一个副作用，它还允许您创建一个小部件来显示

590
00:50:18,720 --> 00:50:21,600
用户可以根据这些更改

591
00:50:21,600 --> 00:50:26,479
再说一次，我不想在呃理论中过多地讨论细节，因为

592
00:50:26,479 --> 00:50:30,872
取决于你如何学习新事物理论可能不是你的强项

593
00:50:30,872 --> 00:50:38,000
就像它不适合我一样，所以对你来说可能是浪费时间

594
00:50:38,000 --> 00:50:43,439
所以让我们继续并开始在我们的项目中添加我们的依赖项，所以我要走了

595
00:50:43,439 --> 00:50:49,119
将我们的笔记应用程序带到屏幕上

596
00:50:49,119 --> 00:50:54,872
稍微调整一下大小，这样我们也有 scr cpy 的位置

597
00:50:54,872 --> 00:50:59,600
正如我所看到的，我们在这里有 scr cpy，这是我们的应用程序

598
00:50:59,600 --> 00:51:02,960
好的，应用程序当前正在运行

599
00:51:02,960 --> 00:51:05,832
那么我们要做的就是

600
00:51:05,832 --> 00:51:10,720
继续说flutter pop add block，然后说flutter pop add flutter block

601
00:51:10,720 --> 00:51:14,079
所以让我们继续增加尺寸

602
00:51:14,079 --> 00:51:21,832
然后我要去终端说flutter pop add walk

603
00:51:21,832 --> 00:51:26,000
所以它会做它的工作

604
00:51:26,000 --> 00:51:30,079
它添加了一个依赖项，我只想说颤振中心

605
00:51:30,079 --> 00:51:34,231
堵塞

606
00:51:34,231 --> 00:51:38,640
好吧，这是一个包裹，所以它不是真的

607
00:51:38,640 --> 00:51:43,439
一个插件，我不相信它是一个插件，我认为它是一个包，所以它

608
00:51:43,439 --> 00:51:47,680
对我们来说，在这里停止我们的应用程序并说

609
00:51:47,680 --> 00:51:50,551
扑干净

610
00:51:50,551 --> 00:51:56,319
清理我们要说的应用程序 fire pub get

611
00:51:56,319 --> 00:52:02,000
这可能就足够了，所以它会做它的工作

612
00:52:02,000 --> 00:52:07,039
然后我们要去然后我们要去我们的主要飞镖

613
00:52:07,039 --> 00:52:11,912
文件，然后说运行运行而不进行调试，这将只是

614
00:52:11,912 --> 00:52:16,231
如果您在 android 上运行，或者它将使用 xcode 构建，则构建更大

615
00:52:16,231 --> 00:52:22,319
为了构建你的 ios 应用程序，所以

616
00:52:22,319 --> 00:52:25,600
我现在就让它做它的事情所以

617
00:52:25,600 --> 00:52:30,551
让我们等着吧，现在构建完成了，我可以看到

618
00:52:30,551 --> 00:52:34,640
应用程序在屏幕上运行没有问题，所以

619
00:52:34,640 --> 00:52:38,551
我们下一步需要做的是做一些戏剧性的事情，那就是

620
00:52:38,551 --> 00:52:42,800
注释掉我们的主页，因为我们要用另一个来替换我们的主页

621
00:52:42,800 --> 00:52:47,192
将使用块的主页，因此听起来可能很吓人，但没那么吓人

622
00:52:47,192 --> 00:52:51,439
我向你保证，让我们在这里进入你的主要飞镖

623
00:52:51,439 --> 00:52:55,832
选择主页，因为它就在那里，然后将其注释掉

624
00:52:55,832 --> 00:53:01,119
我们将再次创建一个新的有状态小部件，我们称之为主页，所以

625
00:53:01,119 --> 00:53:08,000
stf 和主页 这是一个有状态小部件的原因是因为我们需要一个

626
00:53:08,000 --> 00:53:12,399
文本编辑控制器，正如我提到的我们将如何正确地做这个例子

627
00:53:12,399 --> 00:53:16,720
现在学习块是创建一个为您提供文本字段的应用程序

628
00:53:16,720 --> 00:53:21,760
您可以输入一个数字，我们从零值开始

629
00:53:21,760 --> 00:53:26,872
在我们的区块中，所以区块会保留一个数字，然后当你和我们

630
00:53:26,872 --> 00:53:33,192
将创建两个事件，一个是递增事件，一个是递减事件，并且

631
00:53:33,192 --> 00:53:36,960
所以当我们然后给我们的块增加事件

632
00:53:36,960 --> 00:53:40,640
然后我们想在文本字段中获取当前值，所以如果我们开始

633
00:53:40,640 --> 00:53:45,119
零，然后我在这个文本字段中输入五，然后按增量按钮

634
00:53:45,119 --> 00:53:51,511
然后我希望将五个添加到当前状态为 0。

635
00:53:51,511 --> 00:53:56,399
所以结果将是 5。下次我将输入 10，然后按减量，这样

636
00:53:56,399 --> 00:54:02,319
减量将是 10，然后是 5 减 10，所以我们最终得到减 -5

637
00:54:02,319 --> 00:54:04,551
这就是我们要创建的用户界面

638
00:54:04,551 --> 00:54:08,640
为此我们需要这个主页，它有状态的原因是因为我们

639
00:54:08,640 --> 00:54:14,479
需要从我们的文本编辑控制器中获取该文本

640
00:54:14,479 --> 00:54:17,680
这就是我们的新主页 如果我现在

641
00:54:17,680 --> 00:54:21,912
在此处按 command s 我们的屏幕将变黑，因为这

642
00:54:21,912 --> 00:54:25,511
是一个没有信息的主页没有脚手架什么都没有

643
00:54:25,511 --> 00:54:28,231
正确的

644
00:54:28,231 --> 00:54:32,872
所以现在让我们来谈谈我们要称之为的绝对美

645
00:54:32,872 --> 00:54:38,319
正如我提到的，你看到的计数器状态每个块都有两个非常

646
00:54:38,319 --> 00:54:44,960
重要的属性一个是它的状态，另一个是一个事件一个事件

647
00:54:44,960 --> 00:54:49,192
进入块，状态是从块中出来的东西，所以

648
00:54:49,192 --> 00:54:54,079
state 顾名思义，描述了你的块的状态

649
00:54:54,079 --> 00:54:58,079
因此，如果您考虑一下我们的期望

650
00:54:58,079 --> 00:55:02,800
from our block 是一个简单的整数，可以，所以我们可以

651
00:55:02,800 --> 00:55:07,680
假设我们的块的输出是整数，或者我们可以定义一个环绕的状态

652
00:55:07,680 --> 00:55:12,319
那个整数，所以这正是我们现在要做的

653
00:55:12,319 --> 00:55:16,159
所以让我们继续说我们有一个摘要

654
00:55:16,159 --> 00:55:20,319
类，我们称之为计数器状态

655
00:55:20,319 --> 00:55:24,872
然后在这里我们有一个名为 value 的最终整数，然后我们将创建

656
00:55:24,872 --> 00:55:30,960
像这样的初始化器，这就是我们的计数器

657
00:55:30,960 --> 00:55:35,912
如果您愿意，您也可以将其标记为不可变的，所以让我们这样做

658
00:55:35,912 --> 00:55:39,279
让我在这里稍微改变一下屏幕布局，这样你就可以看到代码了

659
00:55:39,279 --> 00:55:45,192
更好，这就像我们块的基本状态 好吧，我们实际上不会

660
00:55:45,192 --> 00:55:50,872
按原样使用状态，我们将为您创建两个子状态

661
00:55:50,872 --> 00:55:55,439
现在很快就会看到

662
00:55:55,439 --> 00:55:59,511
因为我们要在中间创建一个文本字段，就像这个屏幕一样

663
00:55:59,511 --> 00:56:03,832
然后用户可以在此文本字段中输入几乎任何文本

664
00:56:03,832 --> 00:56:07,832
让我们假设只是普通文本甚至不是整数，所以用户只是说

665
00:56:07,832 --> 00:56:11,511
hello world 然后按下加号按钮 在这种情况下我们应该做什么

666
00:56:11,511 --> 00:56:17,600
加按钮情节加上诸如将 hello world 添加到之前的值之类的东西

667
00:56:17,600 --> 00:56:22,479
五意味着什么，所以我们要把我们的状态划分为一个有效的状态和一个

668
00:56:22,479 --> 00:56:26,960
无效状态，然后以两种不同的方式将其呈现给用户，所以让我们

669
00:56:26,960 --> 00:56:32,159
继续创建一个名为的类，正如我提到的那样，柜台留在那里

670
00:56:32,159 --> 00:56:36,960
有效，所以我将实际获取该代码

671
00:56:36,960 --> 00:56:40,720
所以我们不必自己输入，你很快就会看到

672
00:56:40,720 --> 00:56:45,119
在这里，我们有一个有效的计数器状态扩展了我们的计数器状态，这就是

673
00:56:45,119 --> 00:56:50,640
一个，我们有一个常量构造函数，它说好的，给我一个有效的值

674
00:56:50,640 --> 00:56:55,119
值，然后我将用该值调用我的超级类

675
00:56:55,119 --> 00:57:02,551
好的，这是一个有效的状态，现在让我们创建一个无效的状态

676
00:57:02,551 --> 00:57:07,760
所以让我们说上课我要带上正确的标题

677
00:57:07,760 --> 00:57:10,640
以及无效状态

678
00:57:10,640 --> 00:57:17,832
假设计数器状态无效数字扩展计数器状态

679
00:57:17,832 --> 00:57:23,439
在这种情况下，我们希望这个状态实际上包含某种 um

680
00:57:23,439 --> 00:57:27,439
实际上使我们的状态无效的值，所以我只想说

681
00:57:27,439 --> 00:57:31,680
value 是一个字符串，我们在这里称它为无效值好吗

682
00:57:31,680 --> 00:57:37,680
我会说 const 让我们在这里创建一个初始化器

683
00:57:37,680 --> 00:57:42,551
这里有一些必需的参数，我们只是呃

684
00:57:42,551 --> 00:57:46,551
像这样，所以在这种情况下，我们将创建两个必需的参数，一个是

685
00:57:46,551 --> 00:57:50,960
导致错误或导致我们块的状态为的无效值

686
00:57:50,960 --> 00:57:56,159
无效，另一个将是必需参数的必需参数

687
00:57:56,159 --> 00:58:00,479
之前的值，因为我们实际上可能需要

688
00:58:00,479 --> 00:58:04,551
以前的值 uh 或其他东西，或者可能像 ui 需要

689
00:58:04,551 --> 00:58:08,479
向用户显示它，所以如果这是我们块的输出，则状态

690
00:58:08,479 --> 00:58:14,399
记住是输出也许然后用户界面实际上在我试图加上你好

691
00:58:14,399 --> 00:58:18,640
有五个的世界他可能想使用这个先前的值来填充那个文本

692
00:58:18,640 --> 00:58:22,079
字段或再次填充 ui 并打个招呼

693
00:58:22,079 --> 00:58:25,279
嗯你输入的这个值是无效的

694
00:58:25,279 --> 00:58:28,800
但之前的值是这个，所以我只是要展示一下，好吧，那就是

695
00:58:28,800 --> 00:58:31,439
为什么我们需要以前的值，在这里我们得到一个错误，因为我们没有

696
00:58:31,439 --> 00:58:40,079
调用 super 让我们用之前的值调用 super

697
00:58:40,079 --> 00:58:44,800
好的，这是我们的计数器状态无效号码好的，所以我们已经创建了

698
00:58:44,800 --> 00:58:51,680
我们的两个状态 uh 来自反状态 不可变抽象类

699
00:58:51,680 --> 00:58:55,039
好吧，让我们继续创建我们的

700
00:58:55,039 --> 00:58:58,720
计数器事件并记住计数器事件非常

701
00:58:58,720 --> 00:59:03,039
类似于 state 所以首先我们实际上必须定义一个事件

702
00:59:03,039 --> 00:59:06,960
让我们继续像这样定义那个事件

703
00:59:06,960 --> 00:59:09,832
你可以看到它是一个名为 counter event 的抽象类，它只是

704
00:59:09,832 --> 00:59:13,912
包含一个值，所以它只是说来自 ui 的字符串可以

705
00:59:13,912 --> 00:59:16,640
直接进入柜台烤箱就是这样

706
00:59:16,640 --> 00:59:22,551
让我们也让它实际上是不可变的

707
00:59:22,551 --> 00:59:28,000
我们要做的是为增量创建一个事件

708
00:59:28,000 --> 00:59:32,319
所以让我们说类增量值

709
00:59:32,319 --> 00:59:36,000
嗯或增量事件

710
00:59:36,000 --> 00:59:39,439
扩展计数器事件好

711
00:59:39,439 --> 00:59:43,680
在这里我们只会说 const 创建一个常量

712
00:59:43,680 --> 00:59:48,720
它的构造函数，我们只是在这里获取一个值，所以一个字符串值和它

713
00:59:48,720 --> 00:59:53,832
应该只是去超级就是这样我们需要做的就是抓住

714
00:59:53,832 --> 00:59:58,479
这个事件以及创建一个减量事件

715
00:59:58,479 --> 01:00:03,832
所以让我们在这里称这个减量

716
01:00:03,832 --> 01:00:09,119
像这样一次又一次地记住事件是我们需要触发的东西

717
01:00:09,119 --> 01:00:14,079
可以从 ui 发送到块，所以我们要打包这些增量

718
01:00:14,079 --> 01:00:17,760
事件和递减事件与用户在

719
01:00:17,760 --> 01:00:23,359
ui 然后将其发送到块，您很快就会看到

720
01:00:23,359 --> 01:00:28,231
所以让我们现在继续做这个应用程序的主要部分，这是我们的

721
01:00:28,231 --> 01:00:33,439
块，这样做的方法是创建一个类，如果我可以拼写类

722
01:00:33,439 --> 01:00:38,319
并说罐头块扩展块，你会看到它现在会自动

723
01:00:38,319 --> 01:00:42,159
为我导入它，因为我们之前没有导入块

724
01:00:42,159 --> 01:00:46,319
现在让我们看看这里的某个地方是否导入了块，那就是包

725
01:00:46,319 --> 01:00:49,600
如果您的编辑器不允许您自动导入，则阻止阻止，您将不得不这样做

726
01:00:49,600 --> 01:00:53,279
手动对不起

727
01:00:53,279 --> 01:00:58,231
所以创建块的方法是首先定义该块的状态，例如

728
01:00:58,231 --> 01:01:03,359
什么类型的状态它有抱歉的事件首先我们从计数器开始

729
01:01:03,359 --> 01:01:08,231
事件然后计数器状态还可以，所以如果您查看块的定义

730
01:01:08,231 --> 01:01:12,079
类本身你可以看到两个参数是或两个泛型类型

731
01:01:12,079 --> 01:01:15,912
是事件和状态，所以我们在这里说我们的事件

732
01:01:15,912 --> 01:01:21,511
是计数器事件类型，我们的状态是计数器状态类型

733
01:01:21,511 --> 01:01:26,079
就是这样，然后让我们继续说我们有一个计数器块

734
01:01:26,079 --> 01:01:30,720
那是构造函数，它的作用是必须调用 super

735
01:01:30,720 --> 01:01:36,399
你看，我们的超级实际上需要初始状态，所以

736
01:01:36,399 --> 01:01:41,680
每个块都必须有一个初始状态，那就是当你通过你的超级好

737
01:01:41,680 --> 01:01:45,832
所以我们要做的是我们会说我们从一个有效的值开始

738
01:01:45,832 --> 01:01:50,319
值为 0。所以我们说 const

739
01:01:50,319 --> 01:01:54,000
计数器状态有效，我们从 0 开始

740
01:01:54,000 --> 01:01:56,832
像那样

741
01:01:56,832 --> 01:02:01,039
好吧，那是我们的

742
01:02:01,039 --> 01:02:07,359
让我们看看那里发生了什么对我来说似乎很好是的

743
01:02:07,359 --> 01:02:13,511
好的，这就是那里的初始化程序，现在我们需要做的实际上是抓取

744
01:02:13,511 --> 01:02:17,511
这些事件来的时候记得用户界面会

745
01:02:17,511 --> 01:02:21,680
呃基本上把这些事件传递给我们，所以用户界面会说这是一个增量

746
01:02:21,680 --> 01:02:25,192
具有此值的事件这是具有此值的减量事件，因此我们

747
01:02:25,192 --> 01:02:30,079
需要抓住那些我们怎么做，有一个函数调用在

748
01:02:30,079 --> 01:02:35,279
块本身，你可以使用，所以我们要说的增量值

749
01:02:35,279 --> 01:02:39,511
对不起增量事件，然后它给你两个参数所以

750
01:02:39,511 --> 01:02:44,800
如果您查看 on 它的函数签名，您实际上会看到它

751
01:02:44,800 --> 01:02:50,640
给你事件和发射，所以让我们在这里只写事件

752
01:02:50,640 --> 01:02:53,832
发出，在这里我们创建一个新函数

753
01:02:53,832 --> 01:03:00,079
把分号放在最后，这就是我们处理增量值的方式

754
01:03:00,079 --> 01:03:04,479
同样，我们要做的就是减少所以让我们复制并粘贴它

755
01:03:04,479 --> 01:03:11,439
在这里，只是说减量好吧，所以我们现在在这里做什么

756
01:03:11,439 --> 01:03:15,832
记住现在发生的事件是一个增量事件，因为我们确实

757
01:03:15,832 --> 01:03:19,832
在增量事件上说所以我们然后我们会得到那个

758
01:03:19,832 --> 01:03:25,760
我们事件中的整数，所以请记住我们的增量事件实际上有

759
01:03:25,760 --> 01:03:30,551
是计数器事件类型，然后它的值是字符串类型，所以我们要

760
01:03:30,551 --> 01:03:37,680
尝试将其解析为整数，好吧，所以我们要说最终整数是

761
01:03:37,680 --> 01:03:43,119
int tri parse 我们将说事件点值

762
01:03:43,119 --> 01:03:48,399
像这样，尝试解析是一个整数函数

763
01:03:48,399 --> 01:03:52,640
将尝试，因为它的名称表明它将尝试解析给定的字符串并

764
01:03:52,640 --> 01:03:58,159
尝试将其设为整数，如果不能，则该整数将为空

765
01:03:58,159 --> 01:04:02,551
所以让我们说如果你在这里如果整数

766
01:04:02,551 --> 01:04:06,800
不是这样的

767
01:04:06,800 --> 01:04:12,079
然后我们在这里放一个else，在else的情况下实际上是这样

768
01:04:12,079 --> 01:04:16,551
这意味着嘿，你给了我们一些我们无法解析为整数的东西

769
01:04:16,551 --> 01:04:20,720
我们该怎么处理它然后我们将使用我们的发射

770
01:04:20,720 --> 01:04:26,000
emit 是一个独立的函数，您会看到它是一个发射器，然后您可以

771
01:04:26,000 --> 01:04:30,640
把你的状态传出去，所以我真的用自己的方式吓到了自己

772
01:04:30,640 --> 01:04:35,439
手指所以你有你有你有你的嗯这个

773
01:04:35,439 --> 01:04:40,872
现在你想创建一个状态并将其传递出去，这就是你的做法

774
01:04:40,872 --> 01:04:45,680
发射没问题，所以我们会在这种情况下说

775
01:04:45,680 --> 01:04:50,231
如果我们得到 uh if 实际上让我们做整数 null 如果我们

776
01:04:50,231 --> 01:04:53,600
got null 我们将在这里处理错误

777
01:04:53,600 --> 01:04:57,600
对此感到抱歉，所以如果我们没有得到我们要做的就是我们要发射

778
01:04:57,600 --> 01:05:02,399
计数器状态无效数字

779
01:05:02,399 --> 01:05:07,600
我们有无效值和以前的值

780
01:05:07,600 --> 01:05:13,680
所以无效的值是在此处传递给我们的值，您会看到事件

781
01:05:13,680 --> 01:05:17,511
价值所以让我们说这就是 event.value

782
01:05:17,511 --> 01:05:21,912
并且下一个参数是前一个值，前一个值总是

783
01:05:21,912 --> 01:05:26,231
存储在您的状态中，所以让我实际进行一些清理

784
01:05:26,231 --> 01:05:30,319
在这里，你可以更好地看到代码在这里逗号所以让我们看看发生了什么

785
01:05:30,319 --> 01:05:35,359
在这里你看到我们正在发射，所以我们在我们的块之外发送一个状态

786
01:05:35,359 --> 01:05:41,359
所以我们说给定一个增量事件，其中值的整数

787
01:05:41,359 --> 01:05:46,960
无法解析为整数，我们正在发出一个新状态，说嘿

788
01:05:46,960 --> 01:05:50,960
您在此事件中的值无效

789
01:05:50,960 --> 01:05:55,192
所以这是无效值，我们之前的值是

790
01:05:55,192 --> 01:06:02,551
存储在我们的状态中，因此您可以访问所有您可以访问的功能

791
01:06:02,551 --> 01:06:08,000
你当前的状态，然后再发出一个新的，这就是前一个

792
01:06:08,000 --> 01:06:13,600
状态内部的值，如果我们真的可以抓取一个整数

793
01:06:13,600 --> 01:06:17,912
我们要发出一个新的值一个新的状态，我们要说计数器

794
01:06:17,912 --> 01:06:21,279
状态有效

795
01:06:21,279 --> 01:06:25,912
我们会说我们取当前状态的值加上它

796
01:06:25,912 --> 01:06:29,439
像这样的整数对

797
01:06:29,439 --> 01:06:35,511
像那样，这是为了增加

798
01:06:35,511 --> 01:06:39,279
正如你猜想的那样，我将删除这个逗号

799
01:06:39,279 --> 01:06:42,399
顺便说一句，这让我有点恼火，并且递减它非常类似于

800
01:06:42,399 --> 01:06:47,039
增量，所以我只是要复制此代码并删除此减量一

801
01:06:47,039 --> 01:06:50,319
然后再粘贴一次增量然后这次我就走了

802
01:06:50,319 --> 01:06:53,832
把它改成这样的递减就好了

803
01:06:53,832 --> 01:06:57,600
而对于大幅减少，你唯一要做的就是改变这个

804
01:06:57,600 --> 01:07:04,319
加到减，没关系

805
01:07:04,319 --> 01:07:11,279
哇很多工作很多工作所以现在让我们继续我们的

806
01:07:11,279 --> 01:07:15,359
主页在这里现在我们基本上已经得到了块

807
01:07:15,359 --> 01:07:18,479
下来，所以块应该像呃一样工作

808
01:07:18,479 --> 01:07:24,079
正如我们想要的那样，现在让我们进入这个主页

809
01:07:24,079 --> 01:07:30,319
我们在这里创建并创建我们的文本编辑控制器

810
01:07:30,319 --> 01:07:35,912
所以为此我只想说迟到的决赛

811
01:07:35,912 --> 01:07:40,720
文本编辑控制器，我们称之为控制器，我可以在这里看到

812
01:07:40,720 --> 01:07:46,872
让我们进入初始化状态并覆盖 dispose 函数好吧

813
01:07:46,872 --> 01:07:50,640
我会带上代码给你看

814
01:07:50,640 --> 01:07:54,479
我要把它提出来，所以在它的状态下，我们要实例化

815
01:07:54,479 --> 01:07:58,000
我们的控制器，所以这不是什么新鲜事，你已经在很多人之前做过了

816
01:07:58,000 --> 01:08:01,439
次，在这里我们要处理掉那个

817
01:08:01,439 --> 01:08:05,192
控制

818
01:08:05,192 --> 01:08:10,720
嗯，太棒了，那部分已经完成了，所以我们现在需要在我们的内部做

819
01:08:10,720 --> 01:08:16,551
构建函数我们将基本上我们必须创建 um

820
01:08:16,551 --> 01:08:20,079
我们的主用户界面，所以我要带上标题，你可以看到我们有

821
01:08:20,079 --> 01:08:26,551
使用块提供者和块消费者所以现在在构建函数中我们

822
01:08:26,551 --> 01:08:31,760
只有一个容器，所以让我们不要做一个容器，说好的，我们想要

823
01:08:31,760 --> 01:08:36,079
创建一个块，我们也想确保之后的一切

824
01:08:36,079 --> 01:08:39,600
return 语句可以访问该块，因此我们需要块提供程序，所以

825
01:08:39,600 --> 01:08:43,760
假设块提供者和块提供者在

826
01:08:43,760 --> 01:08:47,600
正如您在此处看到的那样，颤振块包，我们还没有导入它，所以

827
01:08:47,600 --> 01:08:52,399
让我们现在在创建中导入它

828
01:08:52,399 --> 01:08:56,960
参数我们得到一个上下文，你会看到我可以得到 Visual Studio 代码来完成

829
01:08:56,960 --> 01:09:00,551
这对我来说，它说我会给你上下文，你会给我一个障碍

830
01:09:00,551 --> 01:09:06,231
所以我会说好吧，我会考虑上下文，我会在这里创建一个计数器块

831
01:09:06,231 --> 01:09:09,439
好的，这是第一个参数，然后我们

832
01:09:09,439 --> 01:09:12,960
在这里出现错误只是因为我们没有在这里提供孩子所以如果我

833
01:09:12,960 --> 01:09:18,640
说这里的孩子是你好世界的文字

834
01:09:18,640 --> 01:09:22,872
然后按 command s 然后我们就可以看到 hello world 好了，所以在这里我们的

835
01:09:22,872 --> 01:09:27,119
然后任务是创建一个脚手架，所以让我们创建我们的脚手架

836
01:09:27,119 --> 01:09:32,079
通常像我们通常做的那样，对于我们的应用栏

837
01:09:32,079 --> 01:09:35,439
让我们在这里创建一个应用栏并说应用栏

838
01:09:35,439 --> 01:09:39,680
标题是 const 什么都看不到，因为

839
01:09:39,680 --> 01:09:47,511
文档到处都是缺点文本，我要说的是测试

840
01:09:47,511 --> 01:09:52,159
好的，现在我们有一个博客提供程序，它创建了我们的计数器实例

841
01:09:52,159 --> 01:09:55,832
块，然后我们有一个脚手架，上面显示了一个漂亮的应用栏

842
01:09:55,832 --> 01:10:00,800
屏幕没问题，就像底部屏幕的标题一样

843
01:10:00,800 --> 01:10:04,640
提到我们的孩子，我们街区的孩子

844
01:10:04,640 --> 01:10:09,511
provider 是一个脚手架，但在脚手架本身内部，我们有 body

845
01:10:09,511 --> 01:10:15,279
对于身体，我们将创建一个块消费者，所以记住一个

846
01:10:15,279 --> 01:10:19,680
阻止消费者是

847
01:10:19,680 --> 01:10:24,159
块侦听器和块构建器的组合

848
01:10:24,159 --> 01:10:29,680
我们在这里需要一个块消费者，其原因在于每个

849
01:10:29,680 --> 01:10:33,511
按下我们即将开发的加号或减号按钮

850
01:10:33,511 --> 01:10:37,912
我们要清除文本字段中的文本

851
01:10:37,912 --> 01:10:42,640
所以这是一个副作用，所以我们说好的，只要有

852
01:10:42,640 --> 01:10:46,159
一个从我们的块中出来的新状态我们想要清除一些东西所以这是一个

853
01:10:46,159 --> 01:10:50,399
当你想做一个与 like 无关的副作用时发出信号

854
01:10:50,399 --> 01:10:55,359
一个业务逻辑或这样的，那就是你的听众

855
01:10:55,359 --> 01:10:59,192
所以我们说我们需要一个块监听器，但我们也想要

856
01:10:59,192 --> 01:11:03,192
实例能够有一个构建器，所以我们想要构建我们的

857
01:11:03,192 --> 01:11:06,551
ui 基于块的当前状态

858
01:11:06,551 --> 01:11:10,720
那是块生成器，所以如果你需要一个块监听器在你的任何地方

859
01:11:10,720 --> 01:11:15,680
如果您是应用程序和块生成器，则需要改为使用块使用者

860
01:11:15,680 --> 01:11:19,912
如果您需要它们在同一级别，那么块消费者组合块

861
01:11:19,912 --> 01:11:27,832
侦听器和块生成器，这就是我们在此使用块消费者的原因

862
01:11:27,832 --> 01:11:31,279
阻止消费者它会说好的我在操作什么块所以我只是

863
01:11:31,279 --> 01:11:35,039
会说你在柜台上操作然后它说我是什么状态

864
01:11:35,039 --> 01:11:39,912
操作，我们要说计数器状态

865
01:11:39,912 --> 01:11:44,640
让我们看看他们是否有货柜台

866
01:11:44,640 --> 01:11:48,960
你可以我的意思是我不是在编造这些东西存在于

867
01:11:48,960 --> 01:11:52,079
如果您也去阻止消费者，请提供文档

868
01:11:52,079 --> 01:11:57,039
让我们在这里看看它是怎么说的

869
01:11:57,039 --> 01:12:01,912
那就是 b 这里 b 对我来说意味着块和

870
01:12:01,912 --> 01:12:05,439
s 是状态，所以不太清楚，因为它与很多

871
01:12:05,439 --> 01:12:08,872
泛型，但您可以阅读有关该内容的文档

872
01:12:08,872 --> 01:12:14,319
所以让我们进去看看

873
01:12:14,319 --> 01:12:18,399
并且它抱怨某些命名参数不存在，如您所见

874
01:12:18,399 --> 01:12:22,872
命名参数监听器是必需的，所以让我们继续说监听器

875
01:12:22,872 --> 01:12:27,832
我将获得 Visual Studio 代码来帮助我清理它以及任何

876
01:12:27,832 --> 01:12:33,600
新事件或对我们博客产生的任何新状态表示抱歉，我想清除我们的

877
01:12:33,600 --> 01:12:37,359
文本编辑控制器，所以我们只说文本控制器

878
01:12:37,359 --> 01:12:40,319
呃 我们叫它什么 我们叫它

879
01:12:40,319 --> 01:12:43,600
控制器是的，所以我们要说控制器

880
01:12:43,600 --> 01:12:47,439
clear 所以我们要清除文本字段中显示的文本

881
01:12:47,439 --> 01:12:51,192
很快就可以了，那么我们需要构建器功能

882
01:12:51,192 --> 01:12:54,551
这个构建器函数，你会看到

883
01:12:54,551 --> 01:12:59,680
它会给你当前状态，你需要返回一个小部件好

884
01:12:59,680 --> 01:13:04,319
所以我们要做的是首先我们要抓住

885
01:13:04,319 --> 01:13:09,279
喜欢嗯，看看是否有一个无效的值，所以

886
01:13:09,279 --> 01:13:14,800
让我们说最终的无效值是，我们要说如果这个状态

887
01:13:14,800 --> 01:13:19,359
是计数器状态无效数

888
01:13:19,359 --> 01:13:22,960
带问号，所以我们在这里使用特纳，我们会说得到

889
01:13:22,960 --> 01:13:28,720
状态 uh 让我把代码 uh 无效值

890
01:13:28,720 --> 01:13:33,192
否则我们会说空字符串所以

891
01:13:33,192 --> 01:13:38,872
如果我在这里说无效值，你可以看到它现在是一个字符串

892
01:13:38,872 --> 01:13:43,359
说实话，这背后的原因是我们可以

893
01:13:43,359 --> 01:13:47,039
基本显示

894
01:13:47,039 --> 01:13:52,479
给用户的一点错误信息应该有一个无效的值，所以如果我

895
01:13:52,479 --> 01:13:56,079
如果我在文本字段中输入了一些信息而不是数字

896
01:13:56,079 --> 01:14:00,640
我已经进入 hello world 然后我们的块产生一个计数器状态

897
01:14:00,640 --> 01:14:05,279
无效数字我们将向用户显示一个错误，这个错误将会

898
01:14:05,279 --> 01:14:09,600
下次用户在文本中输入有效数字时消失

899
01:14:09,600 --> 01:14:12,872
字段没问题，所以我们将使用一个我们以前没有使用过的新小部件

900
01:14:12,872 --> 01:14:18,479
称为可见性，这种可见性将基于是否存在

901
01:14:18,479 --> 01:14:23,279
无效状态与否，所以你很快就会看到实际上我们将如何

902
01:14:23,279 --> 01:14:28,000
实现它，让我们开始吧，就像我们的建设者的主要一样

903
01:14:28,000 --> 01:14:34,000
返回值创建一个列好，列必须有孩子

904
01:14:34,000 --> 01:14:37,039
对，所以我们要做的是首先

905
01:14:37,039 --> 01:14:41,832
显示一个文本字段对不起这里的文本所以让我们说文本

906
01:14:41,832 --> 01:14:46,872
我们会说当前值等于这个状态值

907
01:14:46,872 --> 01:14:51,119
好的，这将是我们的当前值

908
01:14:51,119 --> 01:14:59,511
状态，如果我执行命令，您会看到它说当前值为 0。

909
01:14:59,511 --> 01:15:04,479
所以这是当前值然后我们要做的是继续前进

910
01:15:04,479 --> 01:15:09,760
创建一个可见性小部件，以防万一

911
01:15:09,760 --> 01:15:14,319
当前状态是计数器状态无效数字将显示错误

912
01:15:14,319 --> 01:15:18,231
给用户的消息，假设我们要控制它的可见性

913
01:15:18,231 --> 01:15:21,600
使用可见性小部件的错误消息

914
01:15:21,600 --> 01:15:26,960
像这样，它的childband将会是

915
01:15:26,960 --> 01:15:31,359
一个说明无效输入的文本，然后我们将

916
01:15:31,359 --> 01:15:36,231
如您所见，在此处添加无效值，因为我们在那里构建了它

917
01:15:36,231 --> 01:15:40,399
已经和你看到的可见性标志我们有

918
01:15:40,399 --> 01:15:44,872
返回一个布尔值，好吧，我们怎么知道

919
01:15:44,872 --> 01:15:48,551
我们必须展示

920
01:15:48,551 --> 01:15:53,439
这个小部件具有可见性，如果可以的话

921
01:15:53,439 --> 01:15:57,912
抓住你的状态并说好吧这个状态实际上是反状态

922
01:15:57,912 --> 01:16:02,399
无效的数字，所以我们只说状态

923
01:16:02,399 --> 01:16:07,439
是计数器状态无效的数字，就这样好吗，所以我们就是这样抓取的

924
01:16:07,439 --> 01:16:11,439
抓住那个隐形，你现在可以看到它不是

925
01:16:11,439 --> 01:16:15,192
即使我们放一些也可以显示

926
01:16:15,192 --> 01:16:19,279
嗯实际上让我说不是

927
01:16:19,279 --> 01:16:22,960
然后保存它，你现在会看到它说输入无效，所以它只是

928
01:16:22,960 --> 01:16:26,640
显示在那里没问题，但如果你说状态是那么它会

929
01:16:26,640 --> 01:16:32,799
消失是因为当前状态不是无效数字

930
01:16:32,799 --> 01:16:37,191
好的，这是为了可见性，现在让我们添加我们的文本字段

931
01:16:37,191 --> 01:16:40,551
所以用户实际上可以在 ui 中输入一些信息，所以让我们

932
01:16:40,551 --> 01:16:43,191
说文本字段作为我们要的第一个参数

933
01:16:43,191 --> 01:16:46,871
说控制器是我们的控制器

934
01:16:46,871 --> 01:16:49,760
好的，我们要做的是

935
01:16:49,760 --> 01:16:53,832
会给它一个提示文本，所以我们说装饰是一个 const 输入

936
01:16:53,832 --> 01:16:57,512
像这样的装饰我要把代码放在

937
01:16:57,512 --> 01:17:01,760
屏幕上高一点，所以对于提示文本，我只是要去

938
01:17:01,760 --> 01:17:04,959
在这里说输入和编号

939
01:17:04,959 --> 01:17:10,000
像这样好吧，也让我们强制执行键盘类型

940
01:17:10,000 --> 01:17:14,551
呃文本输入类型的数字

941
01:17:14,551 --> 01:17:18,159
好吧，但也要记住，如果你哎呀

942
01:17:18,159 --> 01:17:21,512
控制器还没有初始化真的我以为我们初始化了

943
01:17:21,512 --> 01:17:26,959
控制器是的，也许你必须做一个热重启

944
01:17:26,959 --> 01:17:31,680
我们走了，所以现在我们在这里输入了一个数字，好吧

945
01:17:31,680 --> 01:17:36,871
好东西现在好了，这就是我要说的，即使我们有一个

946
01:17:36,871 --> 01:17:39,832
这里的文本字段，我们实际上说键盘应该是数字

947
01:17:39,832 --> 01:17:43,512
但我仍然可以在这里粘贴非数字，所以如果我喜欢使用

948
01:17:43,512 --> 01:17:48,639
在android中粘贴功能或者这就是我们无效的原因

949
01:17:48,639 --> 01:17:52,871
状态以防其他人实际输入另一个值，除了

950
01:17:52,871 --> 01:17:56,719
一个数字，您还可以使用 Flutter 中的输入格式化程序

951
01:17:56,719 --> 01:18:02,159
例如，为了避免用户在

952
01:18:02,159 --> 01:18:05,191
您的文本字段，但这是我们不打算讨论的另一个主题

953
01:18:05,191 --> 01:18:08,551
在本章中讨论

954
01:18:08,551 --> 01:18:11,760
那么我们要做的是我们将有两个文本按钮

955
01:18:11,760 --> 01:18:17,440
递增和递减所以让我们在这个文本字段之后创建一行

956
01:18:17,440 --> 01:18:21,191
一行就像一列的对立面，而一列显示那些

957
01:18:21,191 --> 01:18:24,551
一个接一个的垂直组件 一行创建它的

958
01:18:24,551 --> 01:18:28,079
组件水平从左到右和左说语言和

959
01:18:28,079 --> 01:18:30,319
从右到左

960
01:18:30,319 --> 01:18:33,360
我相信说右侧说语言

961
01:18:33,360 --> 01:18:40,319
我认为实际上行改变它是呃它至少应该改变是呃

962
01:18:40,319 --> 01:18:43,832
它如何根据语言排列组件，但我不太确定

963
01:18:43,832 --> 01:18:49,440
那让我们说它有孩子

964
01:18:49,440 --> 01:18:56,319
并且是两个文本按钮，现在没有按下是空的

965
01:18:56,319 --> 01:19:01,680
嗯，它是个孩子，它只是说 cons text just

966
01:19:01,680 --> 01:19:06,719
像这样减去 好的 所以这是第一个 这是第一个按钮

967
01:19:06,719 --> 01:19:11,832
然后对于下一个，我将复制此文本按钮，我将

968
01:19:11,832 --> 01:19:17,280
把它贴在这里，在这里我只想说加

969
01:19:17,280 --> 01:19:22,551
好的，所以当点击减号按钮时，我想传达这一点

970
01:19:22,551 --> 01:19:29,120
信息到我们的块，所以我想说抓住控制器文本并制作

971
01:19:29,120 --> 01:19:33,912
确保你发送这个增量它在哪里

972
01:19:33,912 --> 01:19:39,191
将事件增加到块，所以我们需要抓住我们的块

973
01:19:39,191 --> 01:19:44,959
我们如何做到这一点的方法是使用一个方便的函数

974
01:19:44,959 --> 01:19:48,959
优秀的优秀企业创造了优秀的人

975
01:19:48,959 --> 01:19:53,680
上下文，它被称为读取，在这里你实际上可以说我想要

976
01:19:53,680 --> 01:20:00,399
像这样阅读我的计数器块可以这样你就可以访问你的块

977
01:20:00,399 --> 01:20:04,159
由块提供者创建的

978
01:20:04,159 --> 01:20:08,719
所以让我们继续，在这里让我们说在我们阅读之后我们想要添加一个新的

979
01:20:08,719 --> 01:20:14,479
像这样的事件，我们想添加一个增量事件，其值为

980
01:20:14,479 --> 01:20:16,719
我们的controller.txt

981
01:20:16,719 --> 01:20:20,639
喜欢这样没关系，所以这就是您将事件发送到您的

982
01:20:20,639 --> 01:20:24,479
阻止和同样的事情，因为我们真的很抱歉这应该是

983
01:20:24,479 --> 01:20:30,639
减量所以让我们说这样的减量，我们复制相同的代码和

984
01:20:30,639 --> 01:20:35,040
我们将它作为未按下的按钮带到我们的增量函数中，而不是

985
01:20:35,040 --> 01:20:39,120
减量然后我们要说增量

986
01:20:39,120 --> 01:20:44,231
对，完美，好吧，现在让我们看看，让我们测试一下

987
01:20:44,231 --> 01:20:48,719
这个应用程序所以目前我们现在的当前值为零，如果我按下

988
01:20:48,719 --> 01:20:51,760
如您所见，加号按钮表示输入无效

989
01:20:51,760 --> 01:20:56,399
好的，但如果我说 2 并按下加号按钮，你可以看到

990
01:20:56,399 --> 01:21:01,040
如果我在此处打招呼，则在此处输入 2 的值

991
01:21:01,040 --> 01:21:06,000
我按减号，它说哦无效输入你好世界是无效的，因为你

992
01:21:06,000 --> 01:21:10,231
可以看到它清除了这个文本，那是因为这里有这个监听器

993
01:21:10,231 --> 01:21:14,000
呃这个监听器，因为块消费者也是块监听器记住

994
01:21:14,000 --> 01:21:17,040
所以它是一个块监听器和一个块 uh 的组合

995
01:21:17,040 --> 01:21:21,760
建设者，所以这是明确的工作和部分

996
01:21:21,760 --> 01:21:27,360
正在处理这个无效输入的事情是这样的，如果当前

997
01:21:27,360 --> 01:21:31,680
state 是一个无效的数字，那么这将变得可见，但如果当前

998
01:21:31,680 --> 01:21:35,912
state 不是一个无效的数字，所以假设三四加二

999
01:21:35,912 --> 01:21:39,912
这将是三六，那么当前状态实际上不是无效的

1000
01:21:39,912 --> 01:21:44,159
number is uh 当前状态应该是

1001
01:21:44,159 --> 01:21:49,040
有效它应该是计数器状态有效，所以可见性隐藏了

1002
01:21:49,040 --> 01:21:54,399
错误信息，所以这就是我的意思是嗯

1003
01:21:54,399 --> 01:21:57,760
如果你能在本章中坚持我，非常祝贺你

1004
01:21:57,760 --> 01:22:02,159
非常沉重，我知道这是一个非常沉重且非常喜欢技术的章节

1005
01:22:02,159 --> 01:22:07,191
谈了很多关于业务逻辑，但如果你不明白，请相信我

1006
01:22:07,191 --> 01:22:10,799
我讲的大部分你只需要练习

1007
01:22:10,799 --> 01:22:15,280
我不是天才，没有人知道如何使用块或类似的东西

1008
01:22:15,280 --> 01:22:19,512
天才每个人都有实践 把它付诸实践 自己做

1009
01:22:19,512 --> 01:22:23,040
应用程序完成了这个测试，然后创建这个计数器应用程序，我

1010
01:22:23,040 --> 01:22:27,760
刚创建的尽量不要看我写或重写的代码

1011
01:22:27,760 --> 01:22:31,912
在这只是试着从你的记忆中记住这些东西

1012
01:22:31,912 --> 01:22:36,399
经过锻炼和练习，练习和练习，你会得到它，你

1013
01:22:36,399 --> 01:22:40,399
将了解状态是什么 你将了解事件是什么

1014
01:22:40,399 --> 01:22:44,871
什么是块并阅读文档，你最终会得到这个我保证

1015
01:22:44,871 --> 01:22:47,280
你那个

1016
01:22:47,280 --> 01:22:52,000
按照传统，我们现在要呃，因为我们完成了我们在舞会上承诺的

1017
01:22:52,000 --> 01:22:55,832
本章我们将去提交我们的代码

1018
01:22:55,832 --> 01:23:00,799
所以让我稍微改变一下屏幕布局然后去呃

1019
01:23:00,799 --> 01:23:06,231
终端并增加大小摆脱crcpy

1020
01:23:06,231 --> 01:23:10,319
最后让我们看看我们的日志

1021
01:23:10,319 --> 01:23:14,799
章节我们提交了第 21 步，所以让我们看看 git status

1022
01:23:14,799 --> 01:23:18,479
并且只有一些东西改变了所以让我们添加所有东西然后说 git

1023
01:23:18,479 --> 01:23:24,551
提交第 22 步，让我们继续追逐

1024
01:23:24,551 --> 01:23:28,551
然后我只想说 git commits sorry it's

1025
01:23:28,551 --> 01:23:32,551
一个标签来查看我们的最后一个标签，我可以看到它是 21。

1026
01:23:32,551 --> 01:23:40,079
所以让我们将其标记为步骤 22 并说 git push tags

1027
01:23:40,079 --> 01:23:47,120
好了，现在步骤 22 也已标记并准备就绪

1028
01:23:47,120 --> 01:23:50,719
所以会发生什么这也是一个传统

1029
01:23:50,719 --> 01:23:52,871
我们在每一章的结尾都会谈论我们需要什么

1030
01:23:52,871 --> 01:23:55,680
在下一章讨论以及我们需要在下一章讨论什么

1031
01:23:55,680 --> 01:24:00,079
是，我们将我们的身份验证过程转换为使用块所以

1032
01:24:00,079 --> 01:24:04,231
我们现在谈过我们已经行动了我们实际上得到了我们的授权

1033
01:24:04,231 --> 01:24:07,680
我们应用程序中的逻辑，那是我们的身份验证服务，我不知道你是否

1034
01:24:07,680 --> 01:24:11,680
记得以前，但我们需要转换此身份验证服务

1035
01:24:11,680 --> 01:24:15,360
阻止，所以我们实际上是这样的

1036
01:24:15,360 --> 01:24:20,000
将我们关于块的知识投入使用并将其与我们所拥有的相结合

1037
01:24:20,000 --> 01:24:24,000
已经开发以使我们的应用程序更好，我们的逻辑不是这样

1038
01:24:24,000 --> 01:24:28,871
在 ui 中随处可见，所以如果你想喝点茶点茶

1039
01:24:28,871 --> 01:24:32,319
或者咖啡，我们下一章见大家好，欢迎来到

1040
01:24:32,319 --> 01:24:36,319
这封信课程的第 40 章 在我们之前的章节中我们一直在讨论

1041
01:24:36,319 --> 01:24:41,832
关于 um 我们的 aus 流程以及存储 um

1042
01:24:41,832 --> 01:24:48,079
用户注释到 Firestore 数据库中，在上一章中，我们还

1043
01:24:48,079 --> 01:24:55,360
谈到了block，所以我很清楚block可能是一个令人生畏的嗯

1044
01:24:55,360 --> 01:25:00,079
一些开发人员的主题，并且开始使用块可能只是

1045
01:25:00,079 --> 01:25:03,680
被认为是一个额外的步骤，你

1046
01:25:03,680 --> 01:25:07,360
认为你不需要，但我可以向你保证，当你得到

1047
01:25:07,360 --> 01:25:10,079
更多地进入专业软件开发

1048
01:25:10,079 --> 01:25:14,639
这可能不是你的目标，我完全意识到这一点，但是当

1049
01:25:14,639 --> 01:25:17,912
你会越来越了解专业的软件开发

1050
01:25:17,912 --> 01:25:23,120
您需要分离产品的各个层，并且

1051
01:25:23,120 --> 01:25:27,120
例如，您正在处理的表示层

1052
01:25:27,120 --> 01:25:31,912
在屏幕上向用户显示内容实际上不必说话

1053
01:25:31,912 --> 01:25:37,120
直接使用您的身份验证，或者例如您的身份验证层

1054
01:25:37,120 --> 01:25:42,159
不一定必须完全依赖于应用程序的其他部分，所以

1055
01:25:42,159 --> 01:25:46,799
块将允许您以非常简洁的方式

1056
01:25:46,799 --> 01:25:51,832
将应用程序的各个 uh 层分离为它们自己的关注点

1057
01:25:51,832 --> 01:25:56,079
因此，服务将只关注服务，然后

1058
01:25:56,079 --> 01:26:01,191
你的用户界面将只关心用户界面等等等等等等

1059
01:26:01,191 --> 01:26:05,191
嗯，如果你在开始之前真的可以这样做，那可能是有益的

1060
01:26:05,191 --> 01:26:09,912
章去上一章，也许再看一遍，甚至

1061
01:26:09,912 --> 01:26:15,600
用块练习自己，我明白我肯定知道

1062
01:26:15,600 --> 01:26:20,399
我们在上一章看到的块库网站

1063
01:26:20,399 --> 01:26:24,159
很多例子，我强烈建议你看看其中的一些

1064
01:26:24,159 --> 01:26:28,479
至少示例，并自己开发和实施这些示例

1065
01:26:28,479 --> 01:26:33,280
下注以更好地了解区块的实际含义以及方式

1066
01:26:33,280 --> 01:26:37,760
你应该使用它，所以如果你已经照顾好它并且你

1067
01:26:37,760 --> 01:26:42,639
像块的基础知识一样理解，那么我们就是我们应该很好去

1068
01:26:42,639 --> 01:26:47,360
对于这一章，让我提出标题是什么

1069
01:26:47,360 --> 01:26:51,280
我们实际上将在本章中做你看到我们拥有我们的方式

1070
01:26:51,280 --> 01:26:54,079
目前的应用是我们有我们的

1071
01:26:54,079 --> 01:26:57,760
身份验证服务和我们的身份验证服务让我带上

1072
01:26:57,760 --> 01:27:01,191
到这里的屏幕上，让我们快速看一下，如果

1073
01:27:01,191 --> 01:27:04,479
我去我们的身份验证服务，你会看到我们有

1074
01:27:04,479 --> 01:27:07,280
这里有很多函数函数

1075
01:27:07,280 --> 01:27:11,040
创建用户，我们有，我们正在公开

1076
01:27:11,040 --> 01:27:16,399
当前用户我们有登录注销和电子邮件验证并初始化

1077
01:27:16,399 --> 01:27:22,399
现在这一切都很好，但是我们很原始，因为它的用户界面是

1078
01:27:22,399 --> 01:27:26,799
从字面上调用我们的身份验证服务，以防万一

1079
01:27:26,799 --> 01:27:32,639
turn 正在调用一个提供者，例如我们的 um

1080
01:27:32,639 --> 01:27:36,231
firebase provider author provider 所以如果你进入这里你会看到firebase auth

1081
01:27:36,231 --> 01:27:40,000
提供者，那是直接与firebase交谈，所以

1082
01:27:40,000 --> 01:27:44,159
在某种程度上你可以说用户界面几乎直接与

1083
01:27:44,159 --> 01:27:47,512
firebase 它只是通过一些功能来到达 firebase 但那是

1084
01:27:47,512 --> 01:27:52,079
它在做什么，所以我们在本章要做的就是

1085
01:27:52,079 --> 01:27:55,600
尝试确保我们的身份验证是

1086
01:27:55,600 --> 01:28:00,000
背后一层block意思是所有与逻辑有关的东西

1087
01:28:00,000 --> 01:28:06,399
身份验证隐藏在我们将要取消块的层后面

1088
01:28:06,399 --> 01:28:09,760
所以这将是我们的禁区，所以就像你记得的那样

1089
01:28:09,760 --> 01:28:15,440
上一章每个块都有两个参数一个是什么

1090
01:28:15,440 --> 01:28:21,440
块内有什么，输入什么，输出什么

1091
01:28:21,440 --> 01:28:27,040
块的输入是您的事件，因此您可以传递例如您的 ui

1092
01:28:27,040 --> 01:28:31,600
按下一个按钮，然后你将一个事件传递给一个打包的事件

1093
01:28:31,600 --> 01:28:36,799
我们调用我们的身份验证事件，您将使用任何参数打包它

1094
01:28:36,799 --> 01:28:42,231
该特定事件是必需的 您需要您参加该事件

1095
01:28:42,231 --> 01:28:46,231
然后你把它交给你的身份验证锁然后你的关闭块就会有一些

1096
01:28:46,231 --> 01:28:51,360
是时候处理你了，记得我们有这些关于函数的函数

1097
01:28:51,360 --> 01:28:56,551
当我们谈到我们的柜台时，你的 uh on your blocks

1098
01:28:56,551 --> 01:29:01,832
在命令事件等上增加事件，所以这些是进来的事件

1099
01:29:01,832 --> 01:29:06,231
我们将从我们的 ui 中打包这些事件并将它们传递给我们的关闭

1100
01:29:06,231 --> 01:29:10,159
块然后我们的块将有一些时间自己处理

1101
01:29:10,159 --> 01:29:14,231
那些事件并基于它拥有的那些事件

1102
01:29:14,231 --> 01:29:19,600
它已收到并根据其当前状态将输出相同的

1103
01:29:19,600 --> 01:29:22,871
state 或者它会输出一个新的 state 所以

1104
01:29:22,871 --> 01:29:28,639
事件进来，状态出去，关闭块位于中间，所以事件

1105
01:29:28,639 --> 01:29:33,600
街区外和庄园，这是我们将要开发的三个组成部分

1106
01:29:33,600 --> 01:29:36,871
在这一章当中

1107
01:29:36,871 --> 01:29:39,600
所以让我们继续

1108
01:29:39,600 --> 01:29:44,159
照顾我们的状态并再次记住状态，正如它的名字所表明的那样

1109
01:29:44,159 --> 01:29:49,360
您已登录或已注销的身份验证状态

1110
01:29:49,360 --> 01:29:53,680
您也可能因错误而被注销，请记住，因此您要么已登录

1111
01:29:53,680 --> 01:29:57,120
登录或注销时出现错误，因此

1112
01:29:57,120 --> 01:30:02,479
我们将开始研究这些关闭状态所以我们首先需要做什么

1113
01:30:02,479 --> 01:30:05,191
是创建一个文件，如标题所示

1114
01:30:05,191 --> 01:30:10,639
在唇语服务身份验证阻止状态下，所以

1115
01:30:10,639 --> 01:30:13,680
让我在这里对屏幕进行一些改组

1116
01:30:13,680 --> 01:30:17,191
可能会稍微减小字体大小，因为它只是巨大的方式

1117
01:30:17,191 --> 01:30:22,079
现在是现在所以也许这个字体更好一点

1118
01:30:22,079 --> 01:30:25,040
我要把visual studio studio代码放在那里

1119
01:30:25,040 --> 01:30:30,159
到左边然后我要把 scr cpy 带到右边

1120
01:30:30,159 --> 01:30:34,319
好的，所以我要关闭我在这里的所有这些标签，我们是如何离开的

1121
01:30:34,319 --> 01:30:38,799
上一章中的应用程序，让我们在 lib 中继续，让我们

1122
01:30:38,799 --> 01:30:42,799
看看我们在这里有什么我们有 lib 并且我们有服务

1123
01:30:42,799 --> 01:30:47,191
在服务下，我们已经有身份验证，但我们没有一个名为 block 的文件夹

1124
01:30:47,191 --> 01:30:50,479
目前我们有身份验证提供者等

1125
01:30:50,479 --> 01:30:54,479
所以让我们开始吧，在这里创建一个新文件并说块

1126
01:30:54,479 --> 01:30:58,551
斜线 auth state 像这样的 dot dart

1127
01:30:58,551 --> 01:31:03,440
好的，这就是我们的关闭状态

1128
01:31:03,440 --> 01:31:07,191
现在，如果你还记得上一章我们谈到

1129
01:31:07,191 --> 01:31:10,479
计数器块嗯

1130
01:31:10,479 --> 01:31:16,551
通常状态是不可变的，并且它们也像通用的

1131
01:31:16,551 --> 01:31:21,360
声明你块中的所有其他状态

1132
01:31:21,360 --> 01:31:25,512
继承自通常是一个抽象的不可变类

1133
01:31:25,512 --> 01:31:30,231
这意味着它几乎是一个几乎没有任何逻辑的类

1134
01:31:30,231 --> 01:31:35,280
一个常量构造函数，但它本身并没有做任何事情，所以它

1135
01:31:35,280 --> 01:31:41,440
只是在规定，嘿，从这个隔离区出来的每个状态都是

1136
01:31:41,440 --> 01:31:46,231
这种类型可以，所以让我们继续创建我们的关闭状态

1137
01:31:46,231 --> 01:31:50,551
所以也许我实际上应该增加该字体的大小

1138
01:31:50,551 --> 01:31:56,000
所以我们要开始写我们的

1139
01:31:56,000 --> 01:32:00,719
如您所见，我们将在 auth state.dart 文件中对其进行编码

1140
01:32:00,719 --> 01:32:06,079
所以我要继续说抽象类身份验证状态好

1141
01:32:06,079 --> 01:32:10,000
让我们也为它创建一个常量构造函数，以防万一

1142
01:32:10,000 --> 01:32:13,512
我们的州也需要有一个常量构造函数，所以这就是

1143
01:32:13,512 --> 01:32:16,079
您可能已经习惯的模式

1144
01:32:16,079 --> 01:32:20,399
通过创建抽象类，如果你有喜欢的子类符合

1145
01:32:20,399 --> 01:32:23,440
你的抽象类和那些子类实际上想要拥有

1146
01:32:23,440 --> 01:32:27,120
常量构造函数，那么你需要有一个常量构造函数

1147
01:32:27,120 --> 01:32:31,680
抽象类，以便这些子类实际上可以调用该 const

1148
01:32:31,680 --> 01:32:36,639
抽象类中的构造函数，否则你将无法拥有

1149
01:32:36,639 --> 01:32:40,231
子类的常量构造函数，例如，如果我说

1150
01:32:40,231 --> 01:32:43,600
抽象类等等

1151
01:32:43,600 --> 01:32:49,120
扩展关闭状态，如果我这样说 const blah 你可以看到它说

1152
01:32:49,120 --> 01:32:53,040
常量构造函数不能调用非常量超构造函数并且

1153
01:32:53,040 --> 01:32:56,719
是我通常为我创建一个 cons 构造函数的原因

1154
01:32:56,719 --> 01:33:02,639
国家和事件的嗯课程

1155
01:33:02,639 --> 01:33:05,440
好的

1156
01:33:05,440 --> 01:33:10,639
好的，现在我们的抽象类处于关闭状态，现在让我们让它不可变

1157
01:33:10,639 --> 01:33:14,479
为此我们需要导入材料，或者实际上它是基础，让我们

1158
01:33:14,479 --> 01:33:19,191
在这种情况下从基金会导入，我们可以说显示不可变

1159
01:33:19,191 --> 01:33:23,832
我们可以那样做吗是的，效果也很好

1160
01:33:23,832 --> 01:33:29,040
所以这就是我们有一个通用的关闭状态所以实际上我不是这个意思

1161
01:33:29,040 --> 01:33:33,440
泛型就像一个飞镖泛型，我只是指一个抽象类

1162
01:33:33,440 --> 01:33:37,760
每个其他关闭状态都可以符合

1163
01:33:37,760 --> 01:33:43,360
好吧，所以我们基本上是低的，我的意思是我们有很多州，所以

1164
01:33:43,360 --> 01:33:47,280
我只是要开始做，做，创造那些关闭状态，一个

1165
01:33:47,280 --> 01:33:50,319
例如，在您进行身份验证时

1166
01:33:50,319 --> 01:33:54,399
而你让我们说你是

1167
01:33:54,399 --> 01:33:57,680
您刚刚打开了应用程序，然后我们基本上需要告诉我们的

1168
01:33:57,680 --> 01:34:02,959
身份验证 um 提供程序，它是 firebase 以在其运行时对其进行初始化

1169
01:34:02,959 --> 01:34:08,231
这样做然后我们的身份验证状态处于加载或初始化状态

1170
01:34:08,231 --> 01:34:11,512
不管你怎么称呼它，但我们需要有一个状态

1171
01:34:11,512 --> 01:34:15,040
向应用程序表明身份验证正在发生一些事情

1172
01:34:15,040 --> 01:34:19,440
进程，它正在加载中，所以让我们继续定义

1173
01:34:19,440 --> 01:34:26,871
那我们就说关闭状态加载就像那样扩展关闭状态

1174
01:34:26,871 --> 01:34:31,191
这也可以有一个 const 构造函数所以让我们这样说

1175
01:34:31,191 --> 01:34:35,191
好的，这就是加载状态，我们可以

1176
01:34:35,191 --> 01:34:39,440
实际使用加载状态，我相信我们实际上会使用它

1177
01:34:39,440 --> 01:34:43,191
例如，当用户刚刚打开应用程序并且

1178
01:34:43,191 --> 01:34:48,319
应用程序正在初始化，我们也可以使用它，例如

1179
01:34:48,319 --> 01:34:52,551
您点击登录按钮以登录应用程序，我们正在

1180
01:34:52,551 --> 01:34:58,479
与firebase通信，这也是一种加载状态

1181
01:34:58,479 --> 01:35:02,799
所以你很快就会看到这些状态是非常重要的

1182
01:35:02,799 --> 01:35:07,280
对我们正在发生的各种事件或各种状态作出反应

1183
01:35:07,280 --> 01:35:11,040
离块

1184
01:35:11,040 --> 01:35:14,319
所以假设我们有加载状态让我们只是

1185
01:35:14,319 --> 01:35:19,120
定义一个登录状态，这样当用户已经登录到我们的

1186
01:35:19,120 --> 01:35:23,440
那么应用程序就是它自己的独立状态，所以让我们继续说

1187
01:35:23,440 --> 01:35:28,159
关闭状态登录并扩展关闭状态

1188
01:35:28,159 --> 01:35:32,799
现在这很重要

1189
01:35:32,799 --> 01:35:36,639
您已登录应用程序 应用程序实际需要什么

1190
01:35:36,639 --> 01:35:41,120
我们很好，当您登录时，应用程序需要我们提供的唯一东西

1191
01:35:41,120 --> 01:35:46,079
与用户一起是我们要去我们的身份验证提供者的那一刻的当前用户

1192
01:35:46,079 --> 01:35:50,639
和/或我们的身份验证服务并获取当前用户，但如果我们要移动

1193
01:35:50,639 --> 01:35:55,440
结束并阻止我们的整个身份验证过程，然后它会做更多

1194
01:35:55,440 --> 01:36:00,399
感觉我们要获取已登录到应用程序的当前用户

1195
01:36:00,399 --> 01:36:05,760
从我们的身份验证块的当前状态来看，这对我来说是真的

1196
01:36:05,760 --> 01:36:10,159
美丽，因为它确保我们可以分开

1197
01:36:10,159 --> 01:36:14,479
通过在

1198
01:36:14,479 --> 01:36:16,799
中间所以

1199
01:36:16,799 --> 01:36:20,871
我的意思是它的名字听起来像是你在阻止用户界面

1200
01:36:20,871 --> 01:36:25,680
但这不是块如何写成 bloc 它不是块所以

1201
01:36:25,680 --> 01:36:29,440
但这就是我们需要做的所以让我们说我们有决赛

1202
01:36:29,440 --> 01:36:33,280
如果您正在使用 vim，它将自动为我导入它

1203
01:36:33,280 --> 01:36:37,280
linux 或者如果你使用 subline 它不能自动导入东西

1204
01:36:37,280 --> 01:36:41,912
那么你需要自动你需要自己导入用户好

1205
01:36:41,912 --> 01:36:45,832
因此，假设登录状态或始终带有自身

1206
01:36:45,832 --> 01:36:50,079
当前登录的用户还可以，所以我们只会说用户，我要

1207
01:36:50,079 --> 01:36:54,079
然后为这个类创建一个常量构造函数，这反过来又是

1208
01:36:54,079 --> 01:36:58,639
会在关闭状态下自动为我们造成

1209
01:36:58,639 --> 01:37:04,000
这就是我们的登录状态现在假设我们要定义

1210
01:37:04,000 --> 01:37:08,871
也是注销状态，但也是我们想要的

1211
01:37:08,871 --> 01:37:11,600
嗯，我们

1212
01:37:11,600 --> 01:37:16,479
实际上，在我们退出之前，也许我们必须谈谈登录

1213
01:37:16,479 --> 01:37:21,120
当您今天尝试在我们的应用程序中登录用户时，如果我们去我们的

1214
01:37:21,120 --> 01:37:26,319
登录视图你会看到按下按钮登录然后我们正在做一个

1215
01:37:26,319 --> 01:37:29,832
尝试大量的 auth service firebase login 所以我们真的要朝着

1216
01:37:29,832 --> 01:37:34,719
直接firebase，然后如果出现任何问题，那么我们就像用户一样

1217
01:37:34,719 --> 01:37:39,120
没有发现异常错误密码关闭异常所以我们正在处理我们的

1218
01:37:39,120 --> 01:37:44,639
这种方式的例外以及我们现在需要用 uh fire with 执行此操作的方式

1219
01:37:44,639 --> 01:37:50,231
块是我们需要产生一个你看到的用户界面只需要与之交谈的状态

1220
01:37:50,231 --> 01:37:55,040
那个块所以它说嘿块这是一个事件去登录

1221
01:37:55,040 --> 01:37:58,231
然后它说然后一个博客会做一些处理然后

1222
01:37:58,231 --> 01:38:02,479
也许它说哦不正确的用户不正确的电子邮件

1223
01:38:02,479 --> 01:38:09,120
或密码错误或其他任何需要是它自己的状态所以

1224
01:38:09,120 --> 01:38:13,512
在登录过程中发生异常的地方

1225
01:38:13,512 --> 01:38:18,959
这是一个状态登录失败，我们将称之为登录失败，所以 ui

1226
01:38:18,959 --> 01:38:22,799
然后将对该特定状态做出反应以显示

1227
01:38:22,799 --> 01:38:26,959
向用户发送一条错误消息，就像我们今天所做的那样

1228
01:38:26,959 --> 01:38:32,399
让我们继续说下课状态登录

1229
01:38:32,399 --> 01:38:36,719
失败，我们将延长关闭状态

1230
01:38:36,719 --> 01:38:39,512
在这里，我们要做的是

1231
01:38:39,512 --> 01:38:44,719
登录失败，我们需要携带该状态的实际异常

1232
01:38:44,719 --> 01:38:49,120
导致失败，所以让我们在这里说异常异常，就像我们一样

1233
01:38:49,120 --> 01:38:53,600
当您登录时，我们正在携带用户，我们携带异常

1234
01:38:53,600 --> 01:38:58,639
如果您无法登录，也请与我们联系，这就是您应该考虑的方式

1235
01:38:58,639 --> 01:39:03,832
好吧，所以您的州应该随身携带所有信息 ui 或

1236
01:39:03,832 --> 01:39:08,871
该博客的消费者需要才能能够

1237
01:39:08,871 --> 01:39:11,832
满足其要求

1238
01:39:11,832 --> 01:39:15,440
所以在这种情况下无法登录

1239
01:39:15,440 --> 01:39:19,680
用户界面将需要发生的实际异常，以便它可以

1240
01:39:19,680 --> 01:39:23,680
打开它或做一些 if 语句，看看它是什么类型的异常

1241
01:39:23,680 --> 01:39:28,000
并向用户显示正确的正确消息

1242
01:39:28,000 --> 01:39:32,959
所以让我们继续，然后定义它，因为我们预计会出现异常

1243
01:39:32,959 --> 01:39:37,191
在这里我也将在这里创建一个常量构造函数

1244
01:39:37,191 --> 01:39:39,680
像那样哦，实际上我们在这里收到了警告

1245
01:39:39,680 --> 01:39:43,360
说更喜欢在实际上是不可变的类上声明 cons 构造函数

1246
01:39:43,360 --> 01:39:51,040
美丽 是 抱歉 不断 太棒了 好吧 那是我们的登录失败

1247
01:39:51,040 --> 01:39:55,120
那么我们需要的是你还记得我的意思是因为我们有我们的

1248
01:39:55,120 --> 01:39:59,440
counter block uh in here 和我们之前做的 counter 应用

1249
01:39:59,440 --> 01:40:03,512
我无法向您展示应用程序的用户界面，但如果您能回忆起什么

1250
01:40:03,512 --> 01:40:08,719
我们还有一个问题是，如果您尝试使用某个用户登录，而该用户的电子邮件不是

1251
01:40:08,719 --> 01:40:12,871
当他们真正打算做我们正在做的事情时得到验证

1252
01:40:12,871 --> 01:40:16,639
我们将用户发送到需求验证视图或其他东西

1253
01:40:16,639 --> 01:40:22,000
我们称它为假设让我们看到非常验证电子邮件视图，所以我们发送了

1254
01:40:22,000 --> 01:40:27,360
用户查看此视图​​，我们还需要生成该状态，因此

1255
01:40:27,360 --> 01:40:33,280
当用户按下登录按钮并且我们的关闭块意识到嘿这个

1256
01:40:33,280 --> 01:40:38,399
用户确实存在，但在这里她还没有验证他们的电子邮件地址，那么我们是

1257
01:40:38,399 --> 01:40:43,360
会产生一个状态告诉你用户界面，嘿，这个用户需要验证他们的

1258
01:40:43,360 --> 01:40:47,360
信息所以让我们继续执行它

1259
01:40:47,360 --> 01:40:52,719
我们要说类身份验证状态需要验证

1260
01:40:52,719 --> 01:40:57,832
扩展状态好吧，然后在这里我们就抓住这个

1261
01:40:57,832 --> 01:41:02,639
作为这样的缺点构造函数

1262
01:41:02,639 --> 01:41:06,639
就是这样，在这样做之后，现在我们有了

1263
01:41:06,639 --> 01:41:12,319
登录和登录失败我们需要验证并且我们已经加载

1264
01:41:12,319 --> 01:41:15,680
说明我们是否正在例如进行 api 调用

1265
01:41:15,680 --> 01:41:18,871
花一些时间，我们需要的另一个状态也是

1266
01:41:18,871 --> 01:41:22,639
如果您处于注销状态，则注销，那么我们需要生成它

1267
01:41:22,639 --> 01:41:28,159
让我们说下班，嗯，为什么一切都是黄色的

1268
01:41:28,159 --> 01:41:31,280
班级状态已注销

1269
01:41:31,280 --> 01:41:34,871
好的，这将扩展偏移量为

1270
01:41:34,871 --> 01:41:38,959
那么让我们创建一个常量构造函数

1271
01:41:38,959 --> 01:41:44,551
就像这样很好，所以当你注销时注销你是

1272
01:41:44,551 --> 01:41:47,360
注销 注销状态实际上不需要携带任何东西

1273
01:41:47,360 --> 01:41:51,191
它本身不必携带当前登录的用户或任何东西或

1274
01:41:51,191 --> 01:41:55,512
即使是firebase中的当前用户，即使您有匿名用户

1275
01:41:55,512 --> 01:41:58,479
我们的应用程序的注销状态不必自己携带

1276
01:41:58,479 --> 01:42:02,799
一切都好，最后但并非最不重要的是，我们也必须

1277
01:42:02,799 --> 01:42:08,479
定义我们的注销错误，因此在注销时您还可以

1278
01:42:08,479 --> 01:42:12,719
遇到一些错误，例如如果火力基地出于某种原因试图

1279
01:42:12,719 --> 01:42:16,871
进行 api 调用并且该 api 调用不成功，那么它将给出

1280
01:42:16,871 --> 01:42:21,760
我们是一个错误，所以让我们也定义一下，让我们说你看到我们的类

1281
01:42:21,760 --> 01:42:26,799
已经有登录失败了，让我们去实际复制它，然后

1282
01:42:26,799 --> 01:42:30,079
在这里和这里粘贴它而不是登录我只是去

1283
01:42:30,079 --> 01:42:34,719
说注销失败并复制该名称并将其放入辅音中

1284
01:42:34,719 --> 01:42:39,280
构造函数也很棒，所以我们有一个两个

1285
01:42:39,280 --> 01:42:42,551
三四五六

1286
01:42:42,551 --> 01:42:46,719
嗯关闭状态，所以看起来真的

1287
01:42:46,719 --> 01:42:49,680
好，所以我们的身份验证状态现在定义好了

1288
01:42:49,680 --> 01:42:54,319
请同时保存此文件

1289
01:42:54,319 --> 01:42:58,799
现在我们需要定义你看到的输入

1290
01:42:58,799 --> 01:43:03,040
states 是我们即将编写的 off 块的输出

1291
01:43:03,040 --> 01:43:07,832
off 块我们还没有写，但这些已经是现在的输出了

1292
01:43:07,832 --> 01:43:13,600
输入是否在我们的关闭输入中想象我们必须考虑什么 ui 是什么

1293
01:43:13,600 --> 01:43:19,600
用户界面实际上会调用，所以用户界面将发送数据包

1294
01:43:19,600 --> 01:43:23,832
到这个块，这些数据包是事件，所以我们需要做

1295
01:43:23,832 --> 01:43:28,319
确保事件可以与他们一起包含数据

1296
01:43:28,319 --> 01:43:33,760
ui 可以打包并发送到我们的关闭块，例如在登录时

1297
01:43:33,760 --> 01:43:38,871
事件可以吗，我们就说关闭事件登录它应该包含什么

1298
01:43:38,871 --> 01:43:43,760
应该是邮箱和密码，注销后就可以了

1299
01:43:43,760 --> 01:43:47,120
好的，这是一个注销事件它应该包含什么

1300
01:43:47,120 --> 01:43:50,479
不，这没什么，它只是一个注销事件，它甚至不应该提供

1301
01:43:50,479 --> 01:43:54,319
电子邮件和密码它应该从当前登录的用户注销

1302
01:43:54,319 --> 01:43:58,719
应用程序，所以我们需要考虑事件和

1303
01:43:58,719 --> 01:44:03,600
他们的消费者以及州和他们的消费者，所以你必须打包

1304
01:44:03,600 --> 01:44:08,551
足够的信息进入你的状态和你的事件

1305
01:44:08,551 --> 01:44:14,479
这样您博客的消费者实际上都可以收到足够的信息

1306
01:44:14,479 --> 01:44:18,799
并能够打包足够的信息以发送给您的身份验证

1307
01:44:18,799 --> 01:44:24,231
让我们开始你的街区好吧，现在我们需要做的就是走

1308
01:44:24,231 --> 01:44:30,719
并在 lib services auth block off state 中定义我们的 auth 事件

1309
01:44:30,719 --> 01:44:34,159
我们已经写了我们的关闭状态，所以我要关闭那个文件，让我们

1310
01:44:34,159 --> 01:44:39,760
进入同一个名为blocking here的文件夹，您会看到lib services auth block

1311
01:44:39,760 --> 01:44:44,159
我们将创建一个名为 auth event 的新文件，所以右键单击新文件关闭

1312
01:44:44,159 --> 01:44:49,360
事件和标记

1313
01:44:49,360 --> 01:44:53,760
好的，现在我们有我们的关闭活动，我们需要做一些非常相似的事情

1314
01:44:53,760 --> 01:44:57,440
对于我们对关闭状态所做的事情，我们需要定义

1315
01:44:57,440 --> 01:45:03,280
一个 um 一个超类 一个抽象类

1316
01:45:03,280 --> 01:45:08,231
基本上吞没了所有其他 um auth 事件，所以每个

1317
01:45:08,231 --> 01:45:12,079
我们应用程序中的 auth 事件将属于这种类型，所以让我们说

1318
01:45:12,079 --> 01:45:17,760
不可变的，我们还无法访问它，所以让我们嗯

1319
01:45:17,760 --> 01:45:20,832
让我现在就写吧让我们抽象一下

1320
01:45:20,832 --> 01:45:26,000
事件类和一个常量构造函数，你现在

1321
01:45:26,000 --> 01:45:29,512
知道我们为什么要创造

1322
01:45:29,512 --> 01:45:34,719
一个不可变的来自我们已经完成的基础，所以导入不可变

1323
01:45:34,719 --> 01:45:39,600
好吧呃

1324
01:45:39,600 --> 01:45:42,319
哦，使用显示

1325
01:45:42,319 --> 01:45:46,639
对不起，我编程了很多语言 python 和 rust 和 swift 和

1326
01:45:46,639 --> 01:45:50,959
你把它命名为 javascript 所以有时候我脑子里有点乱

1327
01:45:50,959 --> 01:45:53,832
进口所以嗯

1328
01:45:53,832 --> 01:45:56,959
在不同的地方有很多不同的方式来处理重要的事情

1329
01:45:56,959 --> 01:46:02,719
语言，所以我有时会把它们混在一起，所以现在我们有我们的澳大利亚活动

1330
01:46:02,719 --> 01:46:08,719
这是一个不可变的抽象类，所以现在我们需要从 ui 中获取它

1331
01:46:08,719 --> 01:46:13,280
想要初始化你现在看到的我们的身份验证让我们看看我们实际上是什么

1332
01:46:13,280 --> 01:46:17,912
在我们的主 dart 文件中，这只是我们有一个

1333
01:46:17,912 --> 01:46:20,799
看，你可以在这里看到

1334
01:46:20,799 --> 01:46:25,680
这就是计数器块，但如果你记得的话，我们之前是怎么做到的

1335
01:46:25,680 --> 01:46:31,512
在我们的主页中，我们在加载整个主页时说

1336
01:46:31,512 --> 01:46:36,959
auth service firebase initialize 所以这是来自 ui 的信号，需要

1337
01:46:36,959 --> 01:46:41,191
现在去我们的身份验证块说嘿初始化你自己

1338
01:46:41,191 --> 01:46:48,551
让我们定义那个信号或事件让我们说身份验证事件初始化

1339
01:46:48,551 --> 01:46:52,399
延长活动 [音乐]

1340
01:46:52,399 --> 01:46:57,832
它没有参数，就像你在主要飞镖中看到的那样，它实际上只是一个

1341
01:46:57,832 --> 01:47:01,512
函数被调用，所以我们要用一个没有

1342
01:47:01,512 --> 01:47:06,231
参数，但它有一个常数

1343
01:47:06,231 --> 01:47:11,680
没关系，我们现在有我们的身份验证事件初始化

1344
01:47:11,680 --> 01:47:16,231
我们还需要一个用于登录的身份验证事件，正如我提到的那样，它非常

1345
01:47:16,231 --> 01:47:19,912
很简单，只需要一个电子邮件和密码，所以让我们继续说

1346
01:47:19,912 --> 01:47:25,040
关闭事件登录是这样的

1347
01:47:25,040 --> 01:47:30,871
或使用大写 i 扩展事件登录

1348
01:47:30,871 --> 01:47:35,191
我们需要在这里传递两个参数让我们说final

1349
01:47:35,191 --> 01:47:39,191
字符串电子邮件，我们还需要一个密码，所以让我们

1350
01:47:39,191 --> 01:47:43,912
只需在此处输入密码，现在我们就有了电子邮件和

1351
01:47:43,912 --> 01:47:47,912
密码我们将在这里创建一个构造函数并使其保持不变

1352
01:47:47,912 --> 01:47:54,639
就这样好吧，所以现在我们有了登录事件

1353
01:47:54,639 --> 01:47:58,959
所以登录事件应该携带它自己的每一条信息

1354
01:47:58,959 --> 01:48:04,079
将来需要 auth 块才能将该用户登录到

1355
01:48:04,079 --> 01:48:08,159
进入我们的提供商，在这种情况下是 firebase 好的

1356
01:48:08,159 --> 01:48:12,639
所以在定义登录之后，如果你看一下，我们现在还需要定义注销

1357
01:48:12,639 --> 01:48:17,191
我们的嗯这里有这么多文件所以意见

1358
01:48:17,191 --> 01:48:22,551
我们有笔记，然后我们有对不起，如果你有，我们有笔记视图

1359
01:48:22,551 --> 01:48:27,120
如果您查看此内容并注销它正在执行的操作，请查看注释视图

1360
01:48:27,120 --> 01:48:32,799
你可以看到这是服务火力注销的重量所以

1361
01:48:32,799 --> 01:48:37,280
所以这是一个没有参数的明确事件，它只是告诉关闭

1362
01:48:37,280 --> 01:48:41,680
然后或在这种情况下阻止您需要注销的关闭服务

1363
01:48:41,680 --> 01:48:45,832
参数注销当前用户好吧，让我们去定义它

1364
01:48:45,832 --> 01:48:48,959
在这里，我们只说类

1365
01:48:48,959 --> 01:48:55,360
事件注销扩展了事件，它没有我提到的参数

1366
01:48:55,360 --> 01:48:59,040
所以让我们为它创建一个常量构造函数，然后它会调用

1367
01:48:59,040 --> 01:49:05,760
抽象类的常量构造函数称为 auth event

1368
01:49:05,760 --> 01:49:10,639
好吧，太棒了那些是我们必须定义的唯一事件初始化

1369
01:49:10,639 --> 01:49:14,639
登录和注销，所以这些是块的输入，然后我们有了我们的

1370
01:49:14,639 --> 01:49:20,959
auth 状态是输出我们的输出我们的关闭块

1371
01:49:20,959 --> 01:49:25,600
实际上现在就写

1372
01:49:25,600 --> 01:49:29,760
所以我们有事件和状态，唯一缺少的是

1373
01:49:29,760 --> 01:49:35,280
呃 auth 块本身所以让我们继续在这个块文件夹中创建一个关闭

1374
01:49:35,280 --> 01:49:40,639
阻止文件关闭阻止哎呀阻止嗯

1375
01:49:40,639 --> 01:49:44,719
飞镖

1376
01:49:44,719 --> 01:49:49,512
现在我们需要实际编写我们的身份验证块，这对我来说至少是这样

1377
01:49:49,512 --> 01:49:53,120
就像是最呃这是最有趣的

1378
01:49:53,120 --> 01:49:55,832
嗯

1379
01:49:55,832 --> 01:50:00,399
因为我们要把三片呃两片

1380
01:50:00,399 --> 01:50:04,319
信息状态和事件，现在我们正在创建实际登录

1381
01:50:04,319 --> 01:50:07,512
我们的身份验证块的逻辑，所以这是

1382
01:50:07,512 --> 01:50:13,191
非常令人兴奋，所以现在让我们说像这个扩展块这样的类关闭块

1383
01:50:13,191 --> 01:50:16,639
它会抱怨说它还不存在

1384
01:50:16,639 --> 01:50:21,680
因此，让我们继续导入您可以在此处看到的导入，现在请记住

1385
01:50:21,680 --> 01:50:26,319
块如果你进入源代码它有两个参数有两个通用数据

1386
01:50:26,319 --> 01:50:31,191
在这里输入事件并声明我们的事件被取消事件，它是

1387
01:50:31,191 --> 01:50:35,760
要自动导入，然后我们必须说 auth state

1388
01:50:35,760 --> 01:50:39,912
像这样也将自动导入

1389
01:50:39,912 --> 01:50:43,191
所以就像我们回去的时候一样

1390
01:50:43,191 --> 01:50:47,760
对于我们在这里的关闭服务，您会看到我们目前的身份验证服务是

1391
01:50:47,760 --> 01:50:52,479
将提供者作为参数，因此我们将做完全相同的事情

1392
01:50:52,479 --> 01:50:56,719
在我们的身份验证块中，它会说给我们提供一个与之合作的提供者是不是

1393
01:50:56,719 --> 01:51:00,231
firebase 提供者或它是什么

1394
01:51:00,231 --> 01:51:03,760
但我们不会直接去说给我们一个火力基地供应商，我们会

1395
01:51:03,760 --> 01:51:07,191
说给我们一个身份验证提供者记住我们有一个名为的抽象类

1396
01:51:07,191 --> 01:51:09,512
认证提供者在这里

1397
01:51:09,512 --> 01:51:12,959
这几乎定义了呃

1398
01:51:12,959 --> 01:51:18,079
逻辑或定义每个身份验证提供程序的接口，无论它是

1399
01:51:18,079 --> 01:51:21,760
firebase 身份验证提供者 gmail 汽车提供者 facebook 随便

1400
01:51:21,760 --> 01:51:25,680
这就是界面应该看起来不错的样子，所以我们需要做的是

1401
01:51:25,680 --> 01:51:29,512
创建一个 um 一个构造函数，在这里我们是什么

1402
01:51:29,512 --> 01:51:32,639
要说的是给我们一个身份验证提供者，所以

1403
01:51:32,639 --> 01:51:36,639
我们希望身份验证提供程序自动导入没问题，所以如果您在这里遇到错误

1404
01:51:36,639 --> 01:51:40,479
这是因为您有一个导入的关闭提供程序，就像 Visual Studio 代码一样

1405
01:51:40,479 --> 01:51:44,551
现在为我导入它，假设我们得到

1406
01:51:44,551 --> 01:51:48,319
我们在构造函数中调用提供者，如果你还记得

1407
01:51:48,319 --> 01:51:52,231
正确地从上一章开始，我们还需要确保 auth 块

1408
01:51:52,231 --> 01:51:56,639
总是有一个初始的初始状态，所以

1409
01:51:56,639 --> 01:52:01,360
这就是作为超类所需要的块，所以让我们看看你看到的是

1410
01:52:01,360 --> 01:52:06,799
块库块类的构造函数

1411
01:52:06,799 --> 01:52:12,719
说它应该有一个初始状态，所以我们的初始初始状态将是

1412
01:52:12,719 --> 01:52:17,760
在 k 处于加载状态所以让我们说关闭状态加载

1413
01:52:17,760 --> 01:52:22,479
像这样，我们创造了一个常数

1414
01:52:22,479 --> 01:52:27,120
好的，我现在可以看到我没有太多使用 scr cpy 所以我只是

1415
01:52:27,120 --> 01:52:32,399
会最小化，或者是的，我只是把它移到另一个

1416
01:52:32,399 --> 01:52:35,760
屏幕，所以我们不会被它打扰

1417
01:52:35,760 --> 01:52:40,551
然后使我能够在宽度上增加 Visual Studio 代码的大小，所以它是

1418
01:52:40,551 --> 01:52:45,440
更容易阅读所以我要在这里创建一个常量

1419
01:52:45,440 --> 01:52:49,600
然后我们将创建我们的大括号，以便进入实际的

1420
01:52:49,600 --> 01:52:54,639
初始化程序或此身份验证块的构造函数没问题

1421
01:52:54,639 --> 01:53:00,231
好吧，现在你在 auth 块内的工作是实际处理

1422
01:53:00,231 --> 01:53:06,159
各种事件，然后基于这些事件产生一个状态

1423
01:53:06,159 --> 01:53:11,600
什么是第一个事件记住这个事件初始化所以如果用户告诉我们

1424
01:53:11,600 --> 01:53:16,639
初始化我们的 uh auth 块我们应该做什么好我们

1425
01:53:16,639 --> 01:53:21,040
应该去那个提供者并实际告诉它初始化好

1426
01:53:21,040 --> 01:53:25,600
所以让我们继续做吧，所以我只想说关闭事件

1427
01:53:25,600 --> 01:53:31,440
初始化并记住你看到的每一个 on 函数

1428
01:53:31,440 --> 01:53:36,159
它需要事件让我们看看实际上是的

1429
01:53:36,159 --> 01:53:41,832
事件，然后是发射器，我的意思不是很清楚

1430
01:53:41,832 --> 01:53:46,959
从这个角度来看，它非常通用，我会说它是

1431
01:53:46,959 --> 01:53:51,512
太通用了，但是嗯，但就是这样，所以我们

1432
01:53:51,512 --> 01:53:56,719
采取进来的事件，以防万一你需要从你的

1433
01:53:56,719 --> 01:54:00,231
在这种情况下初始化初始化为空

1434
01:54:00,231 --> 01:54:05,912
类，所以它没有数据，但是当我们实际开始加载时，例如

1435
01:54:05,912 --> 01:54:11,832
我们开始处理登录事件，我们确实需要事件真正进入所以

1436
01:54:11,832 --> 01:54:16,159
我们可以提取此电子邮件和密码，但在事件的情况下

1437
01:54:16,159 --> 01:54:20,399
初始化事件几乎没用，所以我们可以忽略它

1438
01:54:20,399 --> 01:54:25,760
只是做这样的事情没关系，但无论如何我们都会接受它

1439
01:54:25,760 --> 01:54:31,120
所以现在我们有了那个事件，我们这里的第二个参数叫做emit

1440
01:54:31,120 --> 01:54:38,319
然后发出，然后允许您从您的实际发出和发送状态

1441
01:54:38,319 --> 01:54:44,231
向正在观看舞台变化的人发出关闭区域

1442
01:54:44,231 --> 01:54:49,280
这将是我们的用户界面，好吧，所以发射是你的出路是你的沟通

1443
01:54:49,280 --> 01:54:53,760
与外界的通道，所以让我们使这个函数异步

1444
01:54:53,760 --> 01:54:57,912
因为我们实际上会打电话给我们的提供者并打电话给一些

1445
01:54:57,912 --> 01:55:03,912
异步功能所以让我们继续看看我们是否可以做到这一点

1446
01:55:03,912 --> 01:55:07,760
所以我们需要在这里做的第一件事就是打电话给我们的提供者并说

1447
01:55:07,760 --> 01:55:11,512
初始化好并初始化你可以看到它是否返回

1448
01:55:11,512 --> 01:55:16,719
一个虚无的未来，所以我就等着吧，那么我们要做什么

1449
01:55:16,719 --> 01:55:20,639
做是说好的，然后我们会说

1450
01:55:20,639 --> 01:55:26,799
最终用户是提供者当前用户，如果您是可选的关闭用户

1451
01:55:26,799 --> 01:55:30,871
记住它的函数信号或你看到的 getter 签名

1452
01:55:30,871 --> 01:55:34,871
现在如果 auth 用户是

1453
01:55:34,871 --> 01:55:40,399
初始化后返回 null 然后我们知道状态应该被注销

1454
01:55:40,399 --> 01:55:44,719
这意味着我们初始化提供程序但没有用户您已注销好吧

1455
01:55:44,719 --> 01:55:51,440
所以让我们说如果用户为空，那么我们将发出一个新状态并且

1456
01:55:51,440 --> 01:55:55,832
我们会说 auth state 像这样注销

1457
01:55:55,832 --> 01:56:00,000
作为一个常数

1458
01:56:00,000 --> 01:56:05,680
但是，如果有一个用户，那么现在我们有一个用户，我们确信

1459
01:56:05,680 --> 01:56:10,639
我们不会在这里进入这个块，如果有的话，auth user is null

1460
01:56:10,639 --> 01:56:14,231
一个用户，但该用户未通过电子邮件验证，然后我们将生成

1461
01:56:14,231 --> 01:56:18,319
另一个州，所以让我们说如果

1462
01:56:18,319 --> 01:56:21,600
否则，如果你是用户

1463
01:56:21,600 --> 01:56:26,319
未通过电子邮件验证，因此未通过电子邮件验证，然后我们将发出

1464
01:56:26,319 --> 01:56:31,600
嗯，一个常量关闭状态，嗯，需要验证

1465
01:56:31,600 --> 01:56:35,912
好的，所以这也是有道理的，否则我们要说我们的

1466
01:56:35,912 --> 01:56:42,159
状态是购买状态登录并记住实际登录状态

1467
01:56:42,159 --> 01:56:46,871
需要你的用户好吧

1468
01:56:46,871 --> 01:56:51,040
嗯，这实际上现在工作得很好

1469
01:56:51,040 --> 01:56:55,440
现在它说用户

1470
01:56:55,440 --> 01:57:00,639
这不应该真的发生，因为用户实际上不是空的

1471
01:57:00,639 --> 01:57:04,959
所以我们已经检查了用户所以我们可以放让我们看看它是什么

1472
01:57:04,959 --> 01:57:09,832
实际上不能抱怨 null 类型的用户值

1473
01:57:09,832 --> 01:57:15,600
在 cons 构造函数中分配给 auth 用户的参数尝试使用子类型

1474
01:57:15,600 --> 01:57:20,159
或删除关键字 const 我的意思是我理解这部分是

1475
01:57:20,159 --> 01:57:22,639
对你诚实，这是正确的，这是我在这里犯的一个错误

1476
01:57:22,639 --> 01:57:26,159
那是因为我说用户正在调用一个常量构造函数

1477
01:57:26,159 --> 01:57:31,191
这是一个变量，所以你也应该知道我们不能这样做

1478
01:57:31,191 --> 01:57:36,231
因为 user 本身不是 const 因此我们不能调用 const 构造函数

1479
01:57:36,231 --> 01:57:40,399
在一个使用变量用户的状态上

1480
01:57:40,399 --> 01:57:44,871
太好了，现在我们已经处理了初始化事件

1481
01:57:44,871 --> 01:57:47,912
好吧，我们需要做的是处理

1482
01:57:47,912 --> 01:57:52,000
登录事件所以让我们在此之后继续我只是在这里发表评论

1483
01:57:52,000 --> 01:57:55,360
只是说初始化只是为了让事情变得有点

1484
01:57:55,360 --> 01:57:59,191
彼此分开，然后登录

1485
01:57:59,191 --> 01:58:02,319
我要把代码拿出来，所以你看到它有点抱歉

1486
01:58:02,319 --> 01:58:06,799
当我写这个评论时有点隐藏所以现在你可以看到它的样子

1487
01:58:06,799 --> 01:58:12,000
然后我们将处理登录事件，所以再次记住一个事件是什么

1488
01:58:12,000 --> 01:58:16,799
用户界面将向我们发送该事件，如果您记得它有一个用户名

1489
01:58:16,799 --> 01:58:20,719
抱歉，电子邮件和密码，然后我们将解压缩该电子邮件和密码

1490
01:58:20,719 --> 01:58:25,360
提供给我们的提供者 提供给我们的提供者 提供给

1491
01:58:25,360 --> 01:58:29,600
提供者，然后对从

1492
01:58:29,600 --> 01:58:33,040
提供者好吧

1493
01:58:33,040 --> 01:58:39,360
所以我们会说然后关闭事件登录哎呀登录，我们要

1494
01:58:39,360 --> 01:58:43,600
说事件然后发出，我们会说这是一个异步

1495
01:58:43,600 --> 01:58:48,000
功能，它在这里很好，所以没关系

1496
01:58:48,000 --> 01:58:53,600
现在这是一个使用 emit 的博客的美妙之处，您可以让您的消费者知道

1497
01:58:53,600 --> 01:58:57,120
你要做什么让我们说有人说登录什么是

1498
01:58:57,120 --> 01:59:01,280
我们要做的第一件事是，我们正在加载，我们处于加载状态

1499
01:59:01,280 --> 01:59:05,280
因为我们将开始加载并进行 api 调用，而这正是

1500
01:59:05,280 --> 01:59:10,799
为什么我们在这里有这些关闭状态记住我们有身份验证状态

1501
01:59:10,799 --> 01:59:14,319
加载，所以让我们在您告诉我们登录后立即更改我们的状态

1502
01:59:14,319 --> 01:59:19,191
会说哦，现在我们正在加载，因为我们没有一个状态说

1503
01:59:19,191 --> 01:59:23,120
登录，但我们有一个一般状态，说

1504
01:59:23,120 --> 01:59:26,319
如果你想加载，你可以删除它

1505
01:59:26,319 --> 01:59:29,360
加载状态，然后说

1506
01:59:29,360 --> 01:59:35,680
我有一个类，例如身份验证状态登录，这也是可以接受的，但

1507
01:59:35,680 --> 01:59:39,512
那么你必须有一个嗯

1508
01:59:39,512 --> 01:59:43,360
在呃状态中的东西，即使

1509
01:59:43,360 --> 01:59:48,551
你正在注销你应该说关闭状态呃注销

1510
01:59:48,551 --> 01:59:52,551
嗯，那么你必须有一个几乎所有状态的加载状态

1511
01:59:52,551 --> 01:59:55,760
做一些异步的事情，这就是为什么我们没有这样做

1512
01:59:55,760 --> 02:00:00,551
具有向外部指示的通用或通用加载状态

1513
02:00:00,551 --> 02:00:06,231
世界，嘿，你做得很好

1514
02:00:06,231 --> 02:00:09,120
不用担心所有这些已保存在此关闭的操作

1515
02:00:09,120 --> 02:00:14,000
状态文件，我的意思是我没有更改此文件中的任何内容，好吧

1516
02:00:14,000 --> 02:00:17,832
是我们离开舞台时的样子

1517
02:00:17,832 --> 02:00:23,360
好吧，让我们在这里然后发出一个身份验证状态加载

1518
02:00:23,360 --> 02:00:27,280
就像那样，在登录后我们需要做的事情

1519
02:00:27,280 --> 02:00:30,959
只是为了获取电子邮件，所以我们只是说电子邮件等于事件

1520
02:00:30,959 --> 02:00:35,912
邮箱和密码等于活动密码ok

1521
02:00:35,912 --> 02:00:39,512
然后我们会尝试并抓住

1522
02:00:39,512 --> 02:00:43,040
像这样告诉我们的供应商

1523
02:00:43,040 --> 02:00:48,479
所以我们会说等待提供者，嗯，我相信我们已经看到了

1524
02:00:48,479 --> 02:00:52,399
这里的问题避免好吧，没关系

1525
02:00:52,399 --> 02:00:57,912
然后让我们创建一个用户，假设最终用户等于提供者点

1526
02:00:57,912 --> 02:01:02,399
我们的提供商有登录功能，对不起

1527
02:01:02,399 --> 02:01:07,440
在这里，我们实际上是在将电子邮件和密码传递给该函数

1528
02:01:07,440 --> 02:01:12,479
记住提供者级别的登录功能

1529
02:01:12,479 --> 02:01:16,479
抛出一个异常，但这很好，因为我们在这里有一个问题，所以如果我们

1530
02:01:16,479 --> 02:01:20,551
转到我们的身份验证提供程序中的登录功能让我们看看是否可以找到

1531
02:01:20,551 --> 02:01:24,231
登录功能中的firebase auth提供程序让我们看看是否

1532
02:01:24,231 --> 02:01:28,000
我们可以在这里找到我们将抛出的各种异常

1533
02:01:28,000 --> 02:01:33,191
用户没有找到错误的密码通用身份验证异常，所以如果其中任何一个

1534
02:01:33,191 --> 02:01:38,000
发生异常我们将进入这个 catch 块好吧

1535
02:01:38,000 --> 02:01:41,832
所以现在我们有一个用户如果没有任何异常

1536
02:01:41,832 --> 02:01:46,639
发生然后我们会发出，我们会说 const 或者实际上我们

1537
02:01:46,639 --> 02:01:51,280
不能做 const 因为用户是一个变量所以我们要说 auth

1538
02:01:51,280 --> 02:01:53,832
登录状态

1539
02:01:53,832 --> 02:01:57,832
它只是说给我们一个用户，这就是用户

1540
02:01:57,832 --> 02:02:02,399
如果发生任何异常，我们将发出登录失败，我们将

1541
02:02:02,399 --> 02:02:06,231
说发出身份验证状态

1542
02:02:06,231 --> 02:02:10,159
哎呀日志

1543
02:02:10,159 --> 02:02:14,231
什么是失败登录失败我可以看到是的

1544
02:02:14,231 --> 02:02:19,040
在这里，我们从字面上传递了异常

1545
02:02:19,040 --> 02:02:22,959
不能被分配，所以我们可能只需要看看我可以我的意思是我

1546
02:02:22,959 --> 02:02:27,600
理解这个异常也是因为飞镖中的异常可能是

1547
02:02:27,600 --> 02:02:32,479
有点旁白，但飞镖中的例外可能是

1548
02:02:32,479 --> 02:02:36,159
什么我的意思是我不久前在推特上的linkedin上发布了一些东西说

1549
02:02:36,159 --> 02:02:42,079
那好吧，您甚至可以将枚举值作为异常抛出，那就是

1550
02:02:42,079 --> 02:02:46,799
为什么飞镖异常是对象类型和

1551
02:02:46,799 --> 02:02:50,399
在这种情况下，我相信它们甚至是对象可选对象不，实际上是

1552
02:02:50,399 --> 02:02:54,871
一个对象，所以这里的错误是你说的是关闭状态登录

1553
02:02:54,871 --> 02:02:59,912
需要异常的失败，但您将其传递给一个对象，所以让我们说

1554
02:02:59,912 --> 02:03:04,159
如果发生异常则异常

1555
02:03:04,159 --> 02:03:07,280
呃

1556
02:03:07,280 --> 02:03:11,040
那是因为我们知道我们的登录功能不是行动让我们有一个

1557
02:03:11,040 --> 02:03:15,191
查看登录功能，看看它是否可以抛出除

1558
02:03:15,191 --> 02:03:19,040
异常，我们现在看到它有一个普遍的问题

1559
02:03:19,040 --> 02:03:23,191
抛出通用身份验证异常的块，该异常又是异常

1560
02:03:23,191 --> 02:03:27,600
所以现在在我们的应用程序中，我们不会抛出任何不是

1561
02:03:27,600 --> 02:03:33,191
一个异常，所以每个异常都来自异常类

1562
02:03:33,191 --> 02:03:38,399
好极了，现在我们有我们的登录名

1563
02:03:38,399 --> 02:03:43,191
事件到位，我们发出登录或登录的正确状态

1564
02:03:43,191 --> 02:03:48,719
失败，现在我们必须处理注销，所以让我把代码调出来，我们要走了

1565
02:03:48,719 --> 02:03:52,799
说注销，这与登录非常相似，代码少一点，所以让我们

1566
02:03:52,799 --> 02:03:56,399
再说一遍，我们将处理输入好的

1567
02:03:56,399 --> 02:04:02,319
所以关闭事件注销所以如果有人告诉我们

1568
02:04:02,319 --> 02:04:06,319
像这样注销然后我们会说好吧我们

1569
02:04:06,319 --> 02:04:10,719
带上国家哦，到处都有这么多的文件

1570
02:04:10,719 --> 02:04:14,639
对不起事件，然后发射，然后我们做这个

1571
02:04:14,639 --> 02:04:18,959
像这样的异步函数，我们要做的第一件事

1572
02:04:18,959 --> 02:04:22,319
再次，因为在注销我们将调用

1573
02:04:22,319 --> 02:04:26,959
在我们的提供者上注销，这是我们需要告诉的异步函数

1574
02:04:26,959 --> 02:04:31,832
用户界面我们需要告诉用户界面，根据您的要求

1575
02:04:31,832 --> 02:04:36,319
从关闭块注销你必须做一些加载什么更好的方法

1576
02:04:36,319 --> 02:04:41,120
通过实际改变我们的

1577
02:04:41,120 --> 02:04:47,280
state 使用 emit 所以我们要说关闭状态加载没问题所以这就是我们

1578
02:04:47,280 --> 02:04:52,399
向外界表明我们正在做某事

1579
02:04:52,399 --> 02:04:57,680
好吧，那就让我们尝试一下，然后在这里赶上

1580
02:04:57,680 --> 02:05:02,231
cat on exception catch e

1581
02:05:02,231 --> 02:05:05,600
像这样，如果发生异常，那么我们就去

1582
02:05:05,600 --> 02:05:08,639
说发射

1583
02:05:08,639 --> 02:05:13,832
关闭状态失败我们有一个注销失败，并且预计会出现异常

1584
02:05:13,832 --> 02:05:19,040
所以我只是要把e放在那里，我们也可以把这张图片放进去试试

1585
02:05:19,040 --> 02:05:22,231
没关系，因为这并没有真正抛出异常，它永远不会

1586
02:05:22,231 --> 02:05:25,120
抛出异常，但我们将把它放入 try catch

1587
02:05:25,120 --> 02:05:30,159
因为我相信它只是有点清洁它就像一个交易

1588
02:05:30,159 --> 02:05:34,000
所以我们要做的是等待我们的提供者

1589
02:05:34,000 --> 02:05:38,719
并在此处注销，然后注销是否实际通过

1590
02:05:38,719 --> 02:05:42,159
我们要去下一行，对我来说是第 40 行，也许是另一行

1591
02:05:42,159 --> 02:05:45,912
给你的号码，然后在这种情况下，我们只是去

1592
02:05:45,912 --> 02:05:51,440
发出关闭状态的 const 注销

1593
02:05:51,440 --> 02:05:54,959
太棒了，好吧

1594
02:05:54,959 --> 02:06:01,120
那是真的我的意思是这只是很多谈话很多创造像呃

1595
02:06:01,120 --> 02:06:05,760
课程，但是我们现在已经到了那里，所以现在我们

1596
02:06:05,760 --> 02:06:09,760
有一个关闭块，然后我们有我们的身份验证事件和关闭状态，所以现在我们

1597
02:06:09,760 --> 02:06:13,280
有那些我要在你保存它们后关闭这些标签，所以请确保

1598
02:06:13,280 --> 02:06:17,912
这些文件也被保存了那么我们要做的就是

1599
02:06:17,912 --> 02:06:21,600
摆脱我们在上一章中创建的那个丑陋的计数器块

1600
02:06:21,600 --> 02:06:25,191
有点像弄脏我们的主用户界面，所以

1601
02:06:25,191 --> 02:06:29,280
让我们去主要飞镖，让我们抓住这个

1602
02:06:29,280 --> 02:06:36,079
主页我们在这里的方式让我们看看所以让我们进入这个新的主页

1603
02:06:36,079 --> 02:06:40,159
我们为我们的计数器块创建并完全删除所有内容

1604
02:06:40,159 --> 02:06:43,040
这与那个计数器块有关

1605
02:06:43,040 --> 02:06:48,832
然后让我们继续并带回我们的正常主页，例如

1606
02:06:48,832 --> 02:06:53,912
太棒了，呃，我们在那里有颤动的块和块

1607
02:06:53,912 --> 02:06:57,680
这引起了一些问题，但没关系

1608
02:06:57,680 --> 02:07:02,399
所以我们现在需要做的是实际上

1609
02:07:02,399 --> 02:07:04,551
去和

1610
02:07:04,551 --> 02:07:09,280
让我在这里提出下一个字幕，你现在可以看到我们

1611
02:07:09,280 --> 02:07:13,280
需要使用块提供者和块生成器，我们将在

1612
02:07:13,280 --> 02:07:17,680
我们的主要飞镖文件，所以我希望你没有

1613
02:07:17,680 --> 02:07:21,360
跳过了上一章，因为我在上一章讲了很多

1614
02:07:21,360 --> 02:07:24,871
关于块提供者的章节 块构建器 块侦听器 块消费者

1615
02:07:24,871 --> 02:07:27,832
以及它们之间的不同之处，并且有很多

1616
02:07:27,832 --> 02:07:31,040
在线提供的信息和材料，您也可以阅读

1617
02:07:31,040 --> 02:07:35,440
关于所有这些在线的东西，但如果你已经浏览了那一章并且

1618
02:07:35,440 --> 02:07:39,360
真的不明白事情是如何运作的，我们在这里需要的只是想

1619
02:07:39,360 --> 02:07:44,159
其中我们的主应用程序需要解除锁定授权块负责

1620
02:07:44,159 --> 02:07:49,280
现在从这一点开始处理与身份验证相关的所有事情

1621
02:07:49,280 --> 02:07:52,871
它不是 ui 部分，记住 ui 部分是

1622
02:07:52,871 --> 02:07:58,319
完全分离，就是以block为核心的目标，分离业务

1623
02:07:58,319 --> 02:08:02,231
表示逻辑中的逻辑，因此您的表示逻辑与

1624
02:08:02,231 --> 02:08:06,719
用户界面例如显示显示异常处理等的对话框

1625
02:08:06,719 --> 02:08:12,319
用户界面中的所有内容与所有内容无关，但关闭块是

1626
02:08:12,319 --> 02:08:15,600
将负责实际初始化身份验证过程

1627
02:08:15,600 --> 02:08:19,040
还可以使用firebase，还允许我们登录和注销等

1628
02:08:19,040 --> 02:08:22,639
cetera 我们需要 auth 块，所以我们如何获得

1629
02:08:22,639 --> 02:08:28,399
在我们的主应用程序中关闭块，因为整个应用程序都依赖于

1630
02:08:28,399 --> 02:08:32,079
即使您在应用程序的主 ui 中，也应该阻止 auth

1631
02:08:32,079 --> 02:08:37,040
仍然可以例如注销然后我们可以从字面上说哦

1632
02:08:37,040 --> 02:08:42,079
主函数中我们应用程序中的所有内容都将依赖于

1633
02:08:42,079 --> 02:08:47,680
那个离块所以我们要做的是在我们的主页

1634
02:08:47,680 --> 02:08:52,639
让我们在这里看看我们现在说我们有一个 home const 主页你

1635
02:08:52,639 --> 02:08:58,959
看看实际上让我命令这个并把呃 scrcpy 包带回这里

1636
02:08:58,959 --> 02:09:04,399
所以现在我们看到了我们的笔记，所以主页现在已经修复了

1637
02:09:04,399 --> 02:09:08,231
所以我们要在这里做的不是 const 主页

1638
02:09:08,231 --> 02:09:11,680
我们将用身份验证提供程序替换它，好吧

1639
02:09:11,680 --> 02:09:15,680
现在我们可以做到这一点，你可以看到我们有

1640
02:09:15,680 --> 02:09:19,280
嗯，我们对区块提供者感到抱歉

1641
02:09:19,280 --> 02:09:24,479
我在visual studio代码中有块扩展，然后给了我

1642
02:09:24,479 --> 02:09:28,959
用各种块包装东西的能力

1643
02:09:28,959 --> 02:09:34,319
组件和颤振块组件，你可以去扩展和安装

1644
02:09:34,319 --> 02:09:40,319
Visual Studio 代码的块库扩展

1645
02:09:40,319 --> 02:09:44,551
如果你是如果你正在使用另一个呃开发环境如果你是

1646
02:09:44,551 --> 02:09:51,120
使用 sublime 的实例你可能没有这种能力，所以

1647
02:09:51,120 --> 02:09:56,319
你需要做的是手写这个，所以我要利用

1648
02:09:56,319 --> 02:10:00,231
用块提供程序包装此主页，这意味着

1649
02:10:00,231 --> 02:10:06,551
我的主页现在让我们看看这里假设这也是一个常量

1650
02:10:06,551 --> 02:10:11,280
在创建之前是一个主页

1651
02:10:11,280 --> 02:10:14,231
取决于创建一个块好吗

1652
02:10:14,231 --> 02:10:20,000
所以让我们在这里说块提供者也在使用我们的关闭块

1653
02:10:20,000 --> 02:10:24,479
我相信现在视觉工作室代码将自动导入您可能需要

1654
02:10:24,479 --> 02:10:29,191
如果您不使用 Visual Studio 代码或文本编辑器，请手动导入

1655
02:10:29,191 --> 02:10:34,551
或现在在创建中具有此功能的 id

1656
02:10:34,551 --> 02:10:39,191
我们的块提供者的参数我们实际上必须创建 uh 块

1657
02:10:39,191 --> 02:10:44,079
我们承诺我们会创造，你可以在这里看到

1658
02:10:44,079 --> 02:10:48,159
所以我现在可以直接在这里看到

1659
02:10:48,159 --> 02:10:53,040
创建一个 const 提供程序，但我们不能仅仅因为

1660
02:10:53,040 --> 02:10:57,600
我们的身份验证块 如果我们回到这里的隔离区，我相信我们的

1661
02:10:57,600 --> 02:11:02,479
构造函数不是常量，所以如果你把 const 放在那里

1662
02:11:02,479 --> 02:11:06,551
你可以看到它不允许我们这样做仅仅是因为

1663
02:11:06,551 --> 02:11:12,159
将自身作为一个类作为库块在这里它没有常量构造函数，所以

1664
02:11:12,159 --> 02:11:16,719
我们不能有一个常量提供者，所以让我们从那里删除那个常量吧

1665
02:11:16,719 --> 02:11:20,479
现在在这里我们不得不说它应该创建offlock

1666
02:11:20,479 --> 02:11:25,280
如果你记得 offblock 需要一个身份验证提供程序，那么让我们进去吧

1667
02:11:25,280 --> 02:11:29,680
在这里说firebase off

1668
02:11:29,680 --> 02:11:33,600
火灾，这也将是自动进口的

1669
02:11:33,600 --> 02:11:36,479
完美，现在我们有了我们的

1670
02:11:36,479 --> 02:11:43,680
区块提供者太棒了，所以现在我们需要做的是看看

1671
02:11:43,680 --> 02:11:47,120
在这里看看我们还有什么需要改变的

1672
02:11:47,120 --> 02:11:52,000
我们的主要功能很好

1673
02:11:52,000 --> 02:11:55,040
我们目前拥有的我的意思是我们拥有

1674
02:11:55,040 --> 02:11:58,719
当然我们这里有这个功能来创建

1675
02:11:58,719 --> 02:12:03,680
在 main 函数中为我们提供了 auth 块，但我们实际上并没有真正使用它

1676
02:12:03,680 --> 02:12:08,159
在这里，我们正在使用未来的建设者，好吧

1677
02:12:08,159 --> 02:12:13,600
所以我们需要做的不是使用future builder让我们使用我们的um

1678
02:12:13,600 --> 02:12:18,319
我们要做的是我们将使用块提供程序

1679
02:12:18,319 --> 02:12:22,159
对不起，块生成器和块生成器有点像未来的生成器

1680
02:12:22,159 --> 02:12:25,040
但它会使用但它会使用我们的

1681
02:12:25,040 --> 02:12:29,760
现在在这里定义的块这似乎

1682
02:12:29,760 --> 02:12:33,600
一切都非常复杂，你需要了解的是

1683
02:12:33,600 --> 02:12:37,832
有很多魔术在幕后发生，当你

1684
02:12:37,832 --> 02:12:42,479
在这里创建一个块提供程序，然后它获取一个上下文，然后它到这里

1685
02:12:42,479 --> 02:12:47,912
创建块块内部发生的事情是那个上下文

1686
02:12:47,912 --> 02:12:53,191
它本身会被注入你的关闭块，所以当你创建身份验证时

1687
02:12:53,191 --> 02:12:58,639
login here 从此时开始，整个应用程序内部的上下文是

1688
02:12:58,639 --> 02:13:01,832
将是它将填充一个身份验证

1689
02:13:01,832 --> 02:13:07,191
块，你可以从好的阅读，我现在会告诉你如何

1690
02:13:07,191 --> 02:13:11,120
所以在你主页的构建功能中你需要在这里做什么

1691
02:13:11,120 --> 02:13:13,912
我们要说

1692
02:13:13,912 --> 02:13:17,040
看到我们有这个未来 我们有开关

1693
02:13:17,040 --> 02:13:20,719
的快照，这一切都很好

1694
02:13:20,719 --> 02:13:23,600
所以让我们继续吧

1695
02:13:23,600 --> 02:13:26,639
我们需要做的就是对你诚实

1696
02:13:26,639 --> 02:13:30,319
我们不会使用太多这段代码，所以它可能更有意义

1697
02:13:30,319 --> 02:13:34,319
只是把它调低一点，为我们腾出空间

1698
02:13:34,319 --> 02:13:40,479
块提供者好吧，抱歉，块生成器

1699
02:13:40,479 --> 02:13:44,959
所以我们的块构建器有一个构建器功能，但我们也将得到

1700
02:13:44,959 --> 02:13:49,120
暂缓我们的 um 实际块在这里

1701
02:13:49,120 --> 02:13:52,871
builder，当您访问您的主页时，您很快就会看到

1702
02:13:52,871 --> 02:13:56,719
我们需要做的第一件事是告诉我们的 os 块初始化自己

1703
02:13:56,719 --> 02:14:01,760
你还记得我们的身份验证块有这个用于初始化的 um 事件处理吗？

1704
02:14:01,760 --> 02:14:06,319
不知何故，在这个构建函数中，我们需要像嘿一样告诉我们的作者

1705
02:14:06,319 --> 02:14:09,912
初始化自己，那么我们如何掌握它

1706
02:14:09,912 --> 02:14:14,079
我谈到了这个我们如何推迟我们如何抓住off block in

1707
02:14:14,079 --> 02:14:18,399
在这里，因为我们在这里无法访问它，但我只是提到了

1708
02:14:18,399 --> 02:14:22,551
当您创建身份验证提供者时，对不起，博客提供者是博客提供者

1709
02:14:22,551 --> 02:14:28,399
将您的 off 块注入上下文中，以便隐藏 auth 块

1710
02:14:28,399 --> 02:14:34,000
在这种情况下的某个地方，阅读的方式就是你说上下文点

1711
02:14:34,000 --> 02:14:37,280
阅读然后有一个你看到有一个

1712
02:14:37,280 --> 02:14:40,959
函数在这里，如果你进入这个读取函数，你会看到它实际上来了

1713
02:14:40,959 --> 02:14:44,551
从这里的供应商那里

1714
02:14:44,551 --> 02:14:50,639
颤振提供者提供者飞镖好吧，所以在上下文中阅读让我们这么说

1715
02:14:50,639 --> 02:14:56,639
我们正在寻找 auth walk 而我们要告诉它的是

1716
02:14:56,639 --> 02:15:00,479
告诉它初始化，但如果你把点放在这里你会看到没有功能

1717
02:15:00,479 --> 02:15:04,479
称为初始化或任何东西，那是因为您与

1718
02:15:04,479 --> 02:15:09,040
我们在 um 中看到的 auth 块或您与块通信的方式

1719
02:15:09,040 --> 02:15:14,479
通常是您使用其添加功能向它发送消息，因此添加是您的

1720
02:15:14,479 --> 02:15:20,231
与您的区块或您的区块就各种事件进行沟通的方式

1721
02:15:20,231 --> 02:15:25,040
你发送好，所以在这里我们会说添加，然后我们

1722
02:15:25,040 --> 02:15:29,040
要说身份验证事件

1723
02:15:29,040 --> 02:15:31,760
好的，如果您对此有误

1724
02:15:31,760 --> 02:15:35,040
auth 事件初始化不在上下文中，这可能是因为您没有

1725
02:15:35,040 --> 02:15:42,231
在这里我有一个自动导入这个 uh 文件

1726
02:15:42,231 --> 02:15:48,719
我们现在正在向我们的身份验证块发送初始化事件

1727
02:15:48,719 --> 02:15:53,191
现在已经完成了，我们需要做我们的块构建器，所以在这个构建器中

1728
02:15:53,191 --> 02:15:57,360
函数让我去这里并从 Visual Studio 代码中获得帮助来完成它

1729
02:15:57,360 --> 02:16:02,639
你现在可以看到我得到了一个上下文和一个状态

1730
02:16:02,639 --> 02:16:06,799
所以让我们继续处理在此期间可能发生的各种状态

1731
02:16:06,799 --> 02:16:10,959
初始化期间的时期好吧，让我们说

1732
02:16:10,959 --> 02:16:17,120
如果状态是关闭状态登录所以如果我们实际登录然后我们

1733
02:16:17,120 --> 02:16:22,832
会像这样返回 const notes 视图，这就是这个视图

1734
02:16:22,832 --> 02:16:30,551
否则，如果状态是身份验证状态需要验证

1735
02:16:30,551 --> 02:16:35,832
然后让我们看看我们在做什么我们正在返回这个验证电子邮件视图所以

1736
02:16:35,832 --> 02:16:41,760
让我们继续这样做，如果

1737
02:16:41,760 --> 02:16:46,639
对不起，如果状态已注销，请再次原谅我

1738
02:16:46,639 --> 02:16:50,959
它已关闭已注销

1739
02:16:50,959 --> 02:16:57,360
那么让我们看看我们之前是如何处理的

1740
02:16:57,360 --> 02:17:03,680
嗯，如果我们被注销了，我们会像这里一样进入登录视图

1741
02:17:03,680 --> 02:17:09,680
因此，如果我们已注销，那么我们应该将用户发送到登录视图

1742
02:17:09,680 --> 02:17:13,512
否则，如果不是那些州

1743
02:17:13,512 --> 02:17:16,639
那么我们能做些什么让我们在

1744
02:17:16,639 --> 02:17:20,399
未来你将添加更多的状态，这

1745
02:17:20,399 --> 02:17:24,639
块块生成器现在无法处理

1746
02:17:24,639 --> 02:17:28,319
所以你想要的仍然是一个应用程序

1747
02:17:28,319 --> 02:17:32,079
那是在工作状态，你不应该崩溃或类似的东西

1748
02:17:32,079 --> 02:17:36,399
让我们在这种情况下返回一个脚手架

1749
02:17:36,399 --> 02:17:42,551
让它保持不变，让我们进入脚手架的主体

1750
02:17:42,551 --> 02:17:48,719
就这样创建一个圆形进度指示器，这样看起来

1751
02:17:48,719 --> 02:17:53,912
像这样你也可以标记你的块生成器，说它

1752
02:17:53,912 --> 02:17:59,040
有关闭块，也有你记得的关闭状态

1753
02:17:59,040 --> 02:18:03,280
块生成器在您看到这些参数

1754
02:18:03,280 --> 02:18:07,600
建设者和抱歉块本身和状态，这就是我标记的原因

1755
02:18:07,600 --> 02:18:12,000
他们喜欢这样，好吧，现在你可以看到 state 不是一个 uh 它不仅仅是一个

1756
02:18:12,000 --> 02:18:17,360
普通对象不再是关闭状态，然后再写入该状态只是一个

1757
02:18:17,360 --> 02:18:21,912
对象，但现在我已将其标记为关闭状态，您可以看到它已关闭

1758
02:18:21,912 --> 02:18:26,079
在这里也声明很棒的东西现在让我们摆脱

1759
02:18:26,079 --> 02:18:31,280
我们以前拥有的未来构建器，所以我要删除所有代码

1760
02:18:31,280 --> 02:18:36,079
对不起，现在你可以看到我们已经离开了

1761
02:18:36,079 --> 02:18:40,639
我们这里的块生成器和那里的块提供者

1762
02:18:40,639 --> 02:18:45,600
所以这就是我们所要做的，嗯，现在很好，实际上我们遇到了这个问题

1763
02:18:45,600 --> 02:18:50,959
嗯，你可以看到我喜欢这些错误，我的意思是很多开发人员都喜欢

1764
02:18:50,959 --> 02:18:55,120
害怕这样的东西，但真正阅读里面的东西非常重要

1765
02:18:55,120 --> 02:18:58,231
这就是它告诉我们的事情是因为你使用了构建

1766
02:18:58,231 --> 02:19:01,360
不包括您选择的提供者的上下文

1767
02:19:01,360 --> 02:19:07,832
正因为如此，你看到的是这个东西上下文读取身份验证块所以

1768
02:19:07,832 --> 02:19:11,832
所以颤动在说什么，嘿，你在期待我抽离

1769
02:19:11,832 --> 02:19:15,912
从上下文中屏蔽，但它不存在，好吧，为什么它不存在？

1770
02:19:15,912 --> 02:19:20,000
仅仅因为主要功能我在

1771
02:19:20,000 --> 02:19:24,231
当然，但我相信它是如此重要，以至于我想再次提及它

1772
02:19:24,231 --> 02:19:30,799
在热重载期间不会调用函数，我只是通过热重载

1773
02:19:30,799 --> 02:19:36,479
执行命令，因此上下文内没有块

1774
02:19:36,479 --> 02:19:40,871
因为块实际上是由块提供者创建的，它位于

1775
02:19:40,871 --> 02:19:44,639
main 函数，所以如果我想在构建中注入这个 auth 块

1776
02:19:44,639 --> 02:19:48,799
上下文然后我必须做一个热重启所以

1777
02:19:48,799 --> 02:19:52,719
现在应用程序正在正常工作

1778
02:19:52,719 --> 02:19:57,832
对不起，我们现在已经处理了我们的主要飞镖

1779
02:19:57,832 --> 02:20:02,319
文件删除了我们为我们创建的计数器应用程序所拥有的东西

1780
02:20:02,319 --> 02:20:06,799
使用我们使用块创建的身份验证，现在我们已经开始使用我们的

1781
02:20:06,799 --> 02:20:12,479
块的前两个组件是块提供者和块生成器，我们

1782
02:20:12,479 --> 02:20:16,639
有一些未使用的导入，所以让我们删除那些

1783
02:20:16,639 --> 02:20:21,120
好的只是为了确保这个文件很干净

1784
02:20:21,120 --> 02:20:26,319
部分是它现在已经完成了我们需要做的就是使用你可以看到的

1785
02:20:26,319 --> 02:20:31,040
我们需要在登录视图中使用我们的关闭块的标题和我们唯一的东西

1786
02:20:31,040 --> 02:20:35,040
真正需要做的是在按下登录按钮时我们需要发送关闭

1787
02:20:35,040 --> 02:20:41,440
事件登录到我们的 auth 块，这非常简单，所以让我们开始吧

1788
02:20:41,440 --> 02:20:46,159
提前并注意这很容易从

1789
02:20:46,159 --> 02:20:50,551
转到标题所示的登录视图以及我们在哪里调用它

1790
02:20:50,551 --> 02:20:55,912
如您所见，这里的登录功能是我们所说的

1791
02:20:55,912 --> 02:20:59,280
嗯，我们正在接收电子邮件和

1792
02:20:59,280 --> 02:21:04,639
密码，我们只是在调用登录，所以

1793
02:21:04,639 --> 02:21:09,832
让我们看看我们也有电子邮件验证，所以我们不会在

1794
02:21:09,832 --> 02:21:13,191
这一点，所以我们不会真的

1795
02:21:13,191 --> 02:21:18,799
嗯，请处理已验证的电子邮件，因此在此尝试声明中，请在此处验证

1796
02:21:18,799 --> 02:21:22,000
电子邮件路线，我们将尽快解决，所以让我们

1797
02:21:22,000 --> 02:21:26,551
删除此尝试块中的所有内容

1798
02:21:26,551 --> 02:21:31,600
在这里我们需要做的是我们需要阅读我们的块我们的身份验证块和

1799
02:21:31,600 --> 02:21:37,600
然后向它传达一个事件，好吧，我们如何读取 a 块，那就是

1800
02:21:37,600 --> 02:21:44,832
使用上下文点读取或它所谓的读取我相信实际上是的但是

1801
02:21:44,832 --> 02:21:50,000
记住自动阻塞和三个功能不可用

1802
02:21:50,000 --> 02:21:54,479
直到您导入您的提供商，我可以在这里看到说

1803
02:21:54,479 --> 02:22:00,399
包提供者 src 但在我们的主文件中我们实际上并没有

1804
02:22:00,399 --> 02:22:05,360
导入提供程序，所以我们已经导入了我们的颤振块，所以让我们继续做吧

1805
02:22:05,360 --> 02:22:10,639
也在这里，所以在登录视图飞镖中请导入你的颤振

1806
02:22:10,639 --> 02:22:16,639
阻塞，所以现在我们突然可以访问读取功能了

1807
02:22:16,639 --> 02:22:20,871
所以在那里我们要做的就是添加一个事件

1808
02:22:20,871 --> 02:22:23,912
我们让我们看看我们是否可以访问 oh for

1809
02:22:23,912 --> 02:22:27,280
我们可能还需要导入块

1810
02:22:27,280 --> 02:22:31,832
包对不起块

1811
02:22:31,832 --> 02:22:34,399
然后好的

1812
02:22:34,399 --> 02:22:38,231
让我们看看是否突然之间我们会在这里获得添加功能

1813
02:22:38,231 --> 02:22:42,399
上下文阅读哦，抱歉，这是因为这是我需要的功能

1814
02:22:42,399 --> 02:22:48,079
调用函数添加，然后我可以通过从这里删除块来逃脱我

1815
02:22:48,079 --> 02:22:51,440
抱歉，我们真的不需要导入 um

1816
02:22:51,440 --> 02:22:55,600
这样的块库

1817
02:22:55,600 --> 02:22:58,871
好吧，我明白这有点紧张，不过没关系，所以我们只是

1818
02:22:58,871 --> 02:23:03,040
做的是我们删除了 try uh 块中的所有内容，我们正在删除

1819
02:23:03,040 --> 02:23:07,512
我们正在使用上下文读取替换它，我们正在从

1820
02:23:07,512 --> 02:23:10,479
构建上下文，现在我们要告诉它

1821
02:23:10,479 --> 02:23:16,479
登录所以你记得我们有一个 l 关闭事件登录

1822
02:23:16,479 --> 02:23:20,159
所以让我们继续做吧，你可以看到它会自动导入它

1823
02:23:20,159 --> 02:23:22,871
我们所以我的意思是这里我们有电子邮件和

1824
02:23:22,871 --> 02:23:26,079
密码太棒了

1825
02:23:26,079 --> 02:23:30,799
所以没关系，所以这将发送

1826
02:23:30,799 --> 02:23:35,040
事件，然后我们有其余的豁免现在记住

1827
02:23:35,040 --> 02:23:39,040
我知道您可能会认为哦例外，但我们如何处理

1828
02:23:39,040 --> 02:23:41,760
他们很好

1829
02:23:41,760 --> 02:23:45,040
我们目前不是我们的异常处理是

1830
02:23:45,040 --> 02:23:50,079
通过使用 auth block 完全破坏了一切都被破坏了

1831
02:23:50,079 --> 02:23:56,231
就异常而言，因为嗯，您可以看到我们的身份验证阻止方式

1832
02:23:56,231 --> 02:24:00,799
实际上抛出异常是通过在状态中发出它们所以你看到

1833
02:24:00,799 --> 02:24:04,799
它说状态登录失败，然后有一个异常，所以我们不是

1834
02:24:04,799 --> 02:24:08,639
目前处理这些，所以你是对的，例外完全被打破

1835
02:24:08,639 --> 02:24:13,040
本章的全部内容，这没关系，因为我们要修复它们

1836
02:24:13,040 --> 02:24:16,959
就在这一章之后，所以现在你知道接下来会发生什么了

1837
02:24:16,959 --> 02:24:22,719
下一章，好吧，那是给我们的

1838
02:24:22,719 --> 02:24:25,912
登录所以我认为我们不需要做更多的事情

1839
02:24:25,912 --> 02:24:29,832
在我们的登录中诚实，所以让我们进入我们的导入并清理

1840
02:24:29,832 --> 02:24:32,639
进口也一样

1841
02:24:32,639 --> 02:24:37,280
很棒的东西，所以这是为了登录，嗯，我们现在还要做的是

1842
02:24:37,280 --> 02:24:40,639
标题表明我们必须进入我们的笔记视图

1843
02:24:40,639 --> 02:24:44,799
嗯，并确保我们可以使用我们的注销

1844
02:24:44,799 --> 02:24:48,799
auth 块也是如此，所以让我们在这里查看注释

1845
02:24:48,799 --> 02:24:52,719
现在我们正在做的是说我们正在等待身份验证服务

1846
02:24:52,719 --> 02:24:56,479
firebase 注销，所以我们不会再这样做了

1847
02:24:56,479 --> 02:25:01,680
所以我们只是要使用我们的关闭块来注销

1848
02:25:01,680 --> 02:25:05,512
所以在这里让我们删除它，然后说

1849
02:25:05,512 --> 02:25:10,079
我们说的是我们首先要获取身份验证块的位置，好吧，让我们

1850
02:25:10,079 --> 02:25:15,120
说上下文，然后我们将阅读我们的嗯

1851
02:25:15,120 --> 02:25:18,959
像这样自动阻止，如果他问视觉工作室

1852
02:25:18,959 --> 02:25:24,719
代码它将要导入嗯哦是的它要导入身份验证块所以

1853
02:25:24,719 --> 02:25:30,399
让我们抓住块把它带进来也不知道读从哪里来

1854
02:25:30,399 --> 02:25:34,079
从所以嗯

1855
02:25:34,079 --> 02:25:39,440
所以我们现在需要做的就是在这里导入呃块库

1856
02:25:39,440 --> 02:25:42,159
我只是要去

1857
02:25:42,159 --> 02:25:47,040
从我的笔记中复制该代码，然后导入颤振块

1858
02:25:47,040 --> 02:25:50,799
更平坦的挡板，在这里我实际上是在颤振内部钻探

1859
02:25:50,799 --> 02:25:55,280
阻止，只是看到我对阅读上下文感兴趣，然后阅读

1860
02:25:55,280 --> 02:26:00,000
上下文正如您在代码中看到的那样是函数

1861
02:26:00,000 --> 02:26:05,191
阅读这里哦，我的上帝，这里有很多文档，你看

1862
02:26:05,191 --> 02:26:09,760
好吧，这给了我们可以在这里使用的读取功能

1863
02:26:09,760 --> 02:26:13,600
抓住我们的障碍后，这就是功能，现在我们必须

1864
02:26:13,600 --> 02:26:17,360
在这里传达注销的信息，所以我们要添加一个事件

1865
02:26:17,360 --> 02:26:23,040
然后我们会说我们添加关闭事件注销的事件就像

1866
02:26:23,040 --> 02:26:27,512
that 和 this 也是一个常量构造函数，所以让我们发送它发送它

1867
02:26:27,512 --> 02:26:29,912
通过

1868
02:26:29,912 --> 02:26:34,319
在这样做之后，我们真的不需要做更多这样的事情

1869
02:26:34,319 --> 02:26:37,680
嗯，我们也不是在这种情况下，我们是

1870
02:26:37,680 --> 02:26:42,319
实际上不会去登录视图所以

1871
02:26:42,319 --> 02:26:45,191
这里会发生什么我实际上要删除它，我们会

1872
02:26:45,191 --> 02:26:49,440
将开始进行一些测试，以便您了解情况如何

1873
02:26:49,440 --> 02:26:53,191
所以我要在这里热重启

1874
02:26:53,191 --> 02:26:57,040
看看一切是否正常，是的，我接下来要做什么

1875
02:26:57,040 --> 02:27:01,280
让我们测试一下，退出好吧，所以在这里我只想说这个

1876
02:27:01,280 --> 02:27:05,280
注销，它说注销或取消我会说取消所以

1877
02:27:05,280 --> 02:27:09,360
这可以正常工作，我说注销然后注销

1878
02:27:09,360 --> 02:27:12,959
突然间，我们来到了登录视图，但是等一下，发生了什么事

1879
02:27:12,959 --> 02:27:16,479
我们删除了这个代码这个代码是在这里

1880
02:27:16,479 --> 02:27:21,832
为什么我们要在没有该代码的情况下进入登录视图所以这可能看起来

1881
02:27:21,832 --> 02:27:25,832
神奇，但正在发生的事情是，因为整个应用程序现在

1882
02:27:25,832 --> 02:27:30,231
使用我们的 auth block 一个 auth block

1883
02:27:30,231 --> 02:27:33,760
收到注销事件让我们去关闭块

1884
02:27:33,760 --> 02:27:37,912
所以你会想起注销事件，但它的意思是它首先

1885
02:27:37,912 --> 02:27:42,231
进入加载状态，然后如果它可以锁定用户并且它实际上

1886
02:27:42,231 --> 02:27:48,159
说我现在已经登出记得在 main 函数中我们实际上是

1887
02:27:48,159 --> 02:27:52,479
收听来自我们博客外的各种事件以及事件何时发生

1888
02:27:52,479 --> 02:27:57,600
进来的被注销我们正在显示登录视图所以它是主要的

1889
02:27:57,600 --> 02:28:00,639
uh 是做这项工作的主页

1890
02:28:00,639 --> 02:28:04,000
所以对我来说这绝对是美丽的

1891
02:28:04,000 --> 02:28:07,600
因为我们就像移除

1892
02:28:07,600 --> 02:28:12,479
呃我们代码中的逻辑，一次一步

1893
02:28:12,479 --> 02:28:16,871
所以在我们的登录中也是如此，所以我们需要

1894
02:28:16,871 --> 02:28:21,512
让我们在这里进入登录视图

1895
02:28:21,512 --> 02:28:28,479
呃，让我们看看这里的登录，你在登录后看到的，我们没有告诉

1896
02:28:28,479 --> 02:28:33,832
您必须转到屏幕 x 或屏幕 y 的应用程序

1897
02:28:33,832 --> 02:28:38,479
所以我们可以实际测试这个所以我要在这里说我的电子邮件地址

1898
02:28:38,479 --> 02:28:43,360
foo bar bath 然后登录看看它来到主屏幕怎么做

1899
02:28:43,360 --> 02:28:49,680
这样做，这又是因为你看到的主要飞镖首先说嗯

1900
02:28:49,680 --> 02:28:53,280
如果它处于加载状态，让我们看看我们是否在处理

1901
02:28:53,280 --> 02:28:58,079
加载某处不，我们没有使用那个，但是如果它真的变成了呃

1902
02:28:58,079 --> 02:29:03,120
登录然后它说显示注释视图，这就是这些屏幕现在的样子

1903
02:29:03,120 --> 02:29:06,479
在没有我们的情况下被随机播放并显示给用户

1904
02:29:06,479 --> 02:29:12,231
必须做推送路线或推送名称路线所以

1905
02:29:12,231 --> 02:29:15,600
太棒了 做得很好 我们已经处理了我们所说的一切

1906
02:29:15,600 --> 02:29:19,360
将在本章中处理 so 以及我们通常在最后做的事情

1907
02:29:19,360 --> 02:29:22,551
现在每一章都是你熟悉的一切你来的如此

1908
02:29:22,551 --> 02:29:27,600
本课程有近 40 40 章所以你应该知道我们需要标记

1909
02:29:27,600 --> 02:29:31,760
我们的工作，这样我们就不会失去它们

1910
02:29:31,760 --> 02:29:38,551
让我们继续看看我是否可以在这里启动终端

1911
02:29:38,551 --> 02:29:43,280
我们看到位日志，你可以看到最后一次提交是第 22 步，所以我们说 git

1912
02:29:43,280 --> 02:29:48,719
首先提交获取状态实际上添加了一个全新的文件夹，所以我们

1913
02:29:48,719 --> 02:29:52,399
会说 git 让我增加

1914
02:29:52,399 --> 02:29:57,600
屏幕也是如此，所以我们要说 git commit 和 um

1915
02:29:57,600 --> 02:30:04,319
步骤 23 好的并推送这些更改

1916
02:30:04,319 --> 02:30:09,680
我们看看我们的日志到第 22 步和第 23 步，什么都没有

1917
02:30:09,680 --> 02:30:14,479
在这一点上提交，所以让我们也标记我们的工作，我们说

1918
02:30:14,479 --> 02:30:19,832
第 23 步并获得推送标签

1919
02:30:19,832 --> 02:30:22,799
太棒了，所以如果你现在看看我们的标签，我们有

1920
02:30:22,799 --> 02:30:28,719
20 21 22-23 还好

1921
02:30:28,719 --> 02:30:31,912
就像这个传统一样棒极了，在每一章的结尾，我们都会谈论什么

1922
02:30:31,912 --> 02:30:35,832
我们将在即将到来的章节中讨论，嗯

1923
02:30:35,832 --> 02:30:40,719
正如我在谈话时简要提到的那样

1924
02:30:40,719 --> 02:30:44,799
关于异常处理，我们现在打破了异常处理

1925
02:30:44,799 --> 02:30:49,280
当我们发送广告时，您会看到

1926
02:30:49,280 --> 02:30:56,231
向我们的块发出信号，我们的 auth 块本身不会产生

1927
02:30:56,231 --> 02:31:00,231
例外，但现在我们正在处理该添加

1928
02:31:00,231 --> 02:31:05,040
函数，我们将它放在一个 try 块中，然后出现异常

1929
02:31:05,040 --> 02:31:08,719
之后等等等等，所以没有一个异常处理呃

1930
02:31:08,719 --> 02:31:14,000
捕获物会被捕获，所以我们会处理并修复

1931
02:31:14,000 --> 02:31:18,079
在下一章中，请吃点点心，我会在那里见到你的

1932
02:31:18,079 --> 02:31:21,760
大家好，欢迎来到本哲学课程的第 41 章

1933
02:31:21,760 --> 02:31:26,551
在前面的章节中，我们一直在谈论很多关于 uh block 和

1934
02:31:26,551 --> 02:31:30,479
嗯，我建议所有正在学习这门课程的人看看

1935
02:31:30,479 --> 02:31:34,551
也可以安排自己的时间并阅读文档，因为

1936
02:31:34,551 --> 02:31:38,079
嗯，我知道这个块可能是特别令人生畏的东西

1937
02:31:38,079 --> 02:31:41,600
对于那些以前没有为我们做过这种反应式编程的人

1938
02:31:41,600 --> 02:31:45,040
但是它允许我们创建一个很好的分离

1939
02:31:45,040 --> 02:31:50,079
在我们的用户界面和我们的业务逻辑之间，因为这就是使用块的重点

1940
02:31:50,079 --> 02:31:54,719
例如在 Flutter 应用程序中，所以在本章中，我们将构建

1941
02:31:54,719 --> 02:31:57,360
在我们已经完成的工作之上，但我们

1942
02:31:57,360 --> 02:32:01,440
从本章开始，我们将花一点时间来清理

1943
02:32:01,440 --> 02:32:05,832
逻辑上我的意思是即使事情可能正在以他们现在的方式工作

1944
02:32:05,832 --> 02:32:09,040
但是软件里有一句话

1945
02:32:09,040 --> 02:32:12,479
我通常强烈反对的发展

1946
02:32:12,479 --> 02:32:17,832
人们说如果它没有坏就不要修复它但是我们一遍又一遍地看到

1947
02:32:17,832 --> 02:32:22,799
再次表明有效的事情不一定继续有效或事情

1948
02:32:22,799 --> 02:32:26,319
现在工作的不一定能发挥出最好的效果

1949
02:32:26,319 --> 02:32:28,399
能力如此

1950
02:32:28,399 --> 02:32:31,912
为了在我们的源代码中让事情变得更好一点，我们将

1951
02:32:31,912 --> 02:32:37,680
花一点时间让逻辑更彻底，我们必须

1952
02:32:37,680 --> 02:32:42,479
多想一下，我们已经开始使用块了，但我们并不是真的

1953
02:32:42,479 --> 02:32:46,479
在本章中还有这样的，正如你在我们要处理的标题中看到的那样

1954
02:32:46,479 --> 02:32:50,479
登录期间关闭块异常，所以会有

1955
02:32:50,479 --> 02:32:55,191
嗯，在不同的文件之间移动了很多

1956
02:32:55,191 --> 02:32:59,680
我们会喜欢基本上把东西清理干净所以我们必须跳来跳去

1957
02:32:59,680 --> 02:33:02,639
文件之间，我会尽力解释

1958
02:33:02,639 --> 02:33:06,159
当我也在文件之间移动并且喜欢我们正在添加的内容时

1959
02:33:06,159 --> 02:33:09,440
删除和我们正在修改的内容，所以我希望你能

1960
02:33:09,440 --> 02:33:14,639
嗯你也可以跟着

1961
02:33:14,639 --> 02:33:17,512
好的，所以我们要做的第一件事就是你可以在

1962
02:33:17,512 --> 02:33:21,600
这里的标题是删除我们的关闭状态登录失败

1963
02:33:21,600 --> 02:33:27,280
所以我们要做的是首先我要把代码带到

1964
02:33:27,280 --> 02:33:31,440
到这里的主屏幕，这样你也可以看到它，我要

1965
02:33:31,440 --> 02:33:36,159
也许甚至没有提出 scrcpy 因为我真的不认为我们需要 scr cpy

1966
02:33:36,159 --> 02:33:42,159
现在所以如果我们看看我们的嗯

1967
02:33:42,159 --> 02:33:44,079
身份验证状态

1968
02:33:44,079 --> 02:33:47,680
现在的样子我什至不知道我打开了哪个文件

1969
02:33:47,680 --> 02:33:53,512
嗯，如果我说命令 p 关闭状态，那么让我们转到关闭状态 dart 文件好吧

1970
02:33:53,512 --> 02:33:58,639
正如你在这里看到的，如果我把尺寸放大一点

1971
02:33:58,639 --> 02:34:01,912
你可以看到我们现在有

1972
02:34:01,912 --> 02:34:05,760
嗯关闭状态登录失败然后那里

1973
02:34:05,760 --> 02:34:10,399
那里是一个例外，而且我们也登录了关闭状态，所以它

1974
02:34:10,399 --> 02:34:13,360
看起来这有点像我们正在遵循的模式，所以我们有

1975
02:34:13,360 --> 02:34:18,639
关闭状态登录，然后身份验证状态登录失败，出现异常，然后

1976
02:34:18,639 --> 02:34:23,040
我们有关闭状态注销然后注销失败

1977
02:34:23,040 --> 02:34:28,639
但是我们将在这里稍微清理一下，并确保

1978
02:34:28,639 --> 02:34:32,079
我们没有喜欢 除了喜欢

1979
02:34:32,079 --> 02:34:36,319
我们必须在我们的

1980
02:34:36,319 --> 02:34:41,832
应用程序没问题，所以我们需要做的是进入我们的

1981
02:34:41,832 --> 02:34:46,551
在此处注销并添加异常

1982
02:34:46,551 --> 02:34:50,639
重点是，如果你例如，嗯

1983
02:34:50,639 --> 02:34:54,079
目前已在应用程序中注销

1984
02:34:54,079 --> 02:34:58,551
那么也可能有一个例外，你你可能会问你如何

1985
02:34:58,551 --> 02:35:02,231
注销的状态能有异常吗

1986
02:35:02,231 --> 02:35:06,871
我们要做的是，当您尝试登录应用程序时，让我们

1987
02:35:06,871 --> 02:35:10,399
假设您是一个全新的用户并且您还没有登录到应用程序

1988
02:35:10,399 --> 02:35:14,551
在好之前你下载应用程序你是什么你的状态是什么你的状态

1989
02:35:14,551 --> 02:35:18,551
现在已注销 假设您编了一封电子邮件

1990
02:35:18,551 --> 02:35:22,399
和密码，然后在登录屏幕上写下密码，然后按

1991
02:35:22,399 --> 02:35:26,399
登录按钮没有用户让我们在系统中说

1992
02:35:26,399 --> 02:35:29,600
您提供的那些信息然后我们会给您一个

1993
02:35:29,600 --> 02:35:33,280
异常我们会给你一个错误，说你无法登录

1994
02:35:33,280 --> 02:35:36,551
你当时的状态是什么

1995
02:35:36,551 --> 02:35:41,040
您仍然可以注销，但现在您已注销，然后屏幕

1996
02:35:41,040 --> 02:35:45,760
还必须显示一些异常，这就是我们要构建构建的原因

1997
02:35:45,760 --> 02:35:50,799
进入身份验证状态的异常已注销

1998
02:35:50,799 --> 02:35:56,159
所以让我们进入这里，像这样在这里创建一个可选的异常，然后

1999
02:35:56,159 --> 02:35:59,680
就叫它例外好吧，我会从视觉工作室获得帮助

2000
02:35:59,680 --> 02:36:03,832
将该参数添加到初始化程序中的代码

2001
02:36:03,832 --> 02:36:08,159
让我在屏幕上做一些重新洗牌，以便你看得更清楚

2002
02:36:08,159 --> 02:36:13,440
也许也可以减小字体的大小

2003
02:36:13,440 --> 02:36:17,280
所以这是我们必须做的第一件事，你可以在这里看到

2004
02:36:17,280 --> 02:36:22,959
我写过我们真的不需要在身份验证事件登录中加载身份验证状态

2005
02:36:22,959 --> 02:36:26,799
所以我们要做的就是进去

2006
02:36:26,799 --> 02:36:32,719
我们的禁区，所以让我保存这个文件，让我们去禁区

2007
02:36:32,719 --> 02:36:36,479
在这里，我们有一个异常注销，我们将假设

2008
02:36:36,479 --> 02:36:41,600
修复它实际上让我们在这里看看是的让我们说

2009
02:36:41,600 --> 02:36:47,832
此刻登出，让我们在这里也传递一个空异常

2010
02:36:47,832 --> 02:36:52,079
所以我也会去我的笔记去验证块，以确保我拥有所有

2011
02:36:52,079 --> 02:36:55,760
传递给您的必要信息

2012
02:36:55,760 --> 02:36:59,760
所以让我们进入这里并修复它，所以现在我们在我们的 off block dart 文件中

2013
02:36:59,760 --> 02:37:04,231
我们修复了由我们添加可选参数引起的错误

2014
02:37:04,231 --> 02:37:11,360
嗯，我们的关闭状态嗯，嗯，注销好了，所以我们现在修好了

2015
02:37:11,360 --> 02:37:14,231
然后标题所示的下一步是我们要删除

2016
02:37:14,231 --> 02:37:20,319
从身份验证事件登录发出关闭状态加载所以

2017
02:37:20,319 --> 02:37:25,280
让我们继续这样做，所以我们将继续删除这张图片

2018
02:37:25,280 --> 02:37:29,280
从那里可以，所以我们不会显示任何类型的登录屏幕

2019
02:37:29,280 --> 02:37:32,231
或任何东西

2020
02:37:32,231 --> 02:37:34,719
好吧，嗯

2021
02:37:34,719 --> 02:37:39,280
正如你在这里看到的，我们现在将开始使用块监听器

2022
02:37:39,280 --> 02:37:44,231
嗯，我已经谈到了块侦听器块提供程序块生成器块

2023
02:37:44,231 --> 02:37:49,360
之前的消费者，但对于那些不知道什么是块监听器的人

2024
02:37:49,360 --> 02:37:53,600
顾名思义，它是一个块监听器，它只会监听

2025
02:37:53,600 --> 02:37:58,319
改变一个块的状态，例如我们的关闭块，它正在

2026
02:37:58,319 --> 02:38:02,231
让你发出一些副作用

2027
02:38:02,231 --> 02:38:07,360
副作用是例如显示新屏幕或显示对话

2028
02:38:07,360 --> 02:38:10,159
或删除对话或删除屏幕

2029
02:38:10,159 --> 02:38:13,600
从您的导航堆栈中，这些都是副作用

2030
02:38:13,600 --> 02:38:18,399
所以他们不一定要创建一个新的小部件

2031
02:38:18,399 --> 02:38:24,079
例如 uh 替换屏幕上的当前小部件

2032
02:38:24,079 --> 02:38:29,191
相反，他们可以创建一些侧面的东西，正如它的名字所表明的那样

2033
02:38:29,191 --> 02:38:32,959
listener 非常适合，所以 listener 属性

2034
02:38:32,959 --> 02:38:37,191
或块侦听器的侦听器参数不返回小部件，除了

2035
02:38:37,191 --> 02:38:41,280
它只是一个 void 块，所以它允许你对传入的状态做一些事情

2036
02:38:41,280 --> 02:38:44,799
好的，所以我们现在要做的是

2037
02:38:44,799 --> 02:38:48,639
将开始在我们的登录视图中使用块监听器

2038
02:38:48,639 --> 02:38:53,360
本章为了基本处理我们的

2039
02:38:53,360 --> 02:38:56,639
例外，因为如果你看看我们的

2040
02:38:56,639 --> 02:39:00,799
现在登录视图你可以看到我们有这个

2041
02:39:00,799 --> 02:39:07,280
读取登录信息的文本按钮，我们在其中发送一个

2042
02:39:07,280 --> 02:39:12,231
登录到我们的身份验证块的事件，但我们也在处理异常

2043
02:39:12,231 --> 02:39:16,079
这样，正如我们之前提到的，这些例外永远不会发生

2044
02:39:16,079 --> 02:39:21,680
在此流程中发生，因为向您的

2045
02:39:21,680 --> 02:39:27,040
块或任何块不一定要以它的方式抛出异常

2046
02:39:27,040 --> 02:39:31,440
如果我们回到我们的身份验证块并拥有一个

2047
02:39:31,440 --> 02:39:37,680
查看我们的登录信息，您可以看到如果出现异常，我们将执行什么操作

2048
02:39:37,680 --> 02:39:41,912
要做的事情和我们现在正在做的事情就像我们在说关闭状态登录

2049
02:39:41,912 --> 02:39:46,399
失败和我们也需要做的

2050
02:39:46,399 --> 02:39:51,280
实际上是为了清理它，因为登录失败不应该真的存在

2051
02:39:51,280 --> 02:39:55,680
所以我也会去我的笔记，并确保看起来是的

2052
02:39:55,680 --> 02:40:00,231
被完全移除，所以让我们进入我们的关闭状态，并且作为

2053
02:40:00,231 --> 02:40:04,551
我们在这里所做的注销了我们添加了异常

2054
02:40:04,551 --> 02:40:10,399
让我们去彻底消除这个登录失败，所以现在我处于关闭状态

2055
02:40:10,399 --> 02:40:15,512
黑暗文件，我删除了关闭状态

2056
02:40:15,512 --> 02:40:20,399
嗯关闭状态登录失败在哪里，因为我

2057
02:40:20,399 --> 02:40:25,760
提到登录失败现在由已注销的身份验证状态表示

2058
02:40:25,760 --> 02:40:29,600
好的，所以你要么登录要么退出

2059
02:40:29,600 --> 02:40:33,912
这就是我的想法，如果您已注销，可能会出现异常

2060
02:40:33,912 --> 02:40:37,040
因此，例如在

2061
02:40:37,040 --> 02:40:42,799
登录过程，所以现在我们已经删除了状态身份验证状态登录失败

2062
02:40:42,799 --> 02:40:47,760
在这里，我们将在我们要替换的 osblog dart 文件中替换它

2063
02:40:47,760 --> 02:40:52,399
通过身份验证状态和

2064
02:40:52,399 --> 02:40:57,040
注销然后在这里出现异常

2065
02:40:57,040 --> 02:41:00,639
就是这样

2066
02:41:00,639 --> 02:41:06,000
所以现在我们正在谈论 uh auth listeners 所以让我们继续尝试

2067
02:41:06,000 --> 02:41:11,040
在我们的登录视图中解决这个问题，所以我将进入我的笔记

2068
02:41:11,040 --> 02:41:16,000
好吧，如果你看看我们的登录视图

2069
02:41:16,000 --> 02:41:20,000
现在我们在屏幕底部有一个文本按钮

2070
02:41:20,000 --> 02:41:24,639
看起来像这样这是一个文本按钮，它有一个按下按钮

2071
02:41:24,639 --> 02:41:31,191
异步好的，所以这是实际的登录按钮，这个登录按钮

2072
02:41:31,191 --> 02:41:34,959
是现在要处理异常处理的那个

2073
02:41:34,959 --> 02:41:38,479
使用我们的

2074
02:41:38,479 --> 02:41:41,912
阻止侦听器，因此您可以在缓存中看到它说我们的登录视图不会

2075
02:41:41,912 --> 02:41:46,479
重建，因为状态相同但有一个例外

2076
02:41:46,479 --> 02:41:50,959
所以这对于实际理解非常重要，所以让我们再看看

2077
02:41:50,959 --> 02:41:55,191
我们在这里的身份验证状态和身份验证状态已注销

2078
02:41:55,191 --> 02:42:00,079
所以即使我们放置一个块监听器并且

2079
02:42:00,079 --> 02:42:04,959
用块监听器将这个按钮这个文本按钮包装在这里

2080
02:42:04,959 --> 02:42:08,000
一旦应用程序启动，您就会看到

2081
02:42:08,000 --> 02:42:13,512
我们的关闭块，您可以看到首先我们已注销，所以当

2082
02:42:13,512 --> 02:42:17,120
应用程序启动没有用户然后状态被注销然后

2083
02:42:17,120 --> 02:42:20,871
例如，当您使用无效凭据按下登录按钮时

2084
02:42:20,871 --> 02:42:24,639
那么状态仍然会被注销但有一个例外

2085
02:42:24,639 --> 02:42:30,079
但是此按钮将无法呈现或执行

2086
02:42:30,079 --> 02:42:35,512
有这些例外的任何东西，因为从我们的外块角度来看，它是

2087
02:42:35,512 --> 02:42:40,479
同一状态 一内无一一一一

2088
02:42:40,479 --> 02:42:45,360
有一个例外权，所以它是相同的状态，或者它是

2089
02:42:45,360 --> 02:42:48,799
至少相同的州级

2090
02:42:48,799 --> 02:42:54,000
我们实际上要解决这个问题，但现在我们要继续

2091
02:42:54,000 --> 02:43:00,079
在这里做一些清理工作，让我们继续，作为标题

2092
02:43:00,079 --> 02:43:05,760
表示我们将在此处的文本按钮中处理一些异常

2093
02:43:05,760 --> 02:43:12,479
所以让我们用一个块监听器来包装我们的文本按钮好吧，所以我要

2094
02:43:12,479 --> 02:43:16,639
对此做命令点，然后我会说用块换行

2095
02:43:16,639 --> 02:43:22,479
听众，正如我之前提到的那样，我有这些包装

2096
02:43:22,479 --> 02:43:27,512
块等，因为我在 Visual Studio 代码调用块中有一个扩展名

2097
02:43:27,512 --> 02:43:32,399
来自 felix angelov 我希望我发音正确

2098
02:43:32,399 --> 02:43:36,871
来自非常好的企业，他们基本上是赞助的人

2099
02:43:36,871 --> 02:43:41,440
块库所以

2100
02:43:41,440 --> 02:43:45,680
这就是我在 Visual Studio 代码中看到所有那些用块等包装的原因，如果

2101
02:43:45,680 --> 02:43:49,280
你没有，你可能不得不手工完成这部分，比如创建一个块

2102
02:43:49,280 --> 02:43:52,799
听众在这里，但我只是想利用这个扩展

2103
02:43:52,799 --> 02:43:57,440
视觉工作室代码，只是说用块监听器包装好

2104
02:43:57,440 --> 02:44:01,512
在这里你可以看到它说好的是什么类型的块，我会

2105
02:44:01,512 --> 02:44:06,799
说它是关闭块，它说它有什么状态

2106
02:44:06,799 --> 02:44:11,440
我会说好的状态，然后这里说好的做

2107
02:44:11,440 --> 02:44:14,799
无论你现在想做什么

2108
02:44:14,799 --> 02:44:16,799
所以嗯

2109
02:44:16,799 --> 02:44:21,832
那是我们的文本按钮与块侦听器的包装，就是这样

2110
02:44:21,832 --> 02:44:26,319
只是现在进展顺利，我们要做的就是如你所见

2111
02:44:26,319 --> 02:44:30,159
在标题中是处理可能发生的三个单独的异常

2112
02:44:30,159 --> 02:44:34,551
在登录时让我们回去让我们回到我们的

2113
02:44:34,551 --> 02:44:39,440
firebase auth provider um so firebase 作者提供者 dart 文件

2114
02:44:39,440 --> 02:44:43,760
并查看我们的登录代码，如您在此处看到的那样

2115
02:44:43,760 --> 02:44:47,832
你可以看到可能会发生三个例外情况

2116
02:44:47,832 --> 02:44:53,832
被称为 firebase 身份验证异常用户未找到错误密码等

2117
02:44:53,832 --> 02:44:58,079
所以我们需要处理这些关闭异常，这样用户就不会发现错误

2118
02:44:58,079 --> 02:45:03,912
密码和通用身份验证异常 好的，所以让我们进入这里，就这么说吧

2119
02:45:03,912 --> 02:45:12,159
好吧，如果状态是 um off 状态像那样注销

2120
02:45:12,159 --> 02:45:15,760
所以记住里面注销我们可以有

2121
02:45:15,760 --> 02:45:19,680
一个异常一个可选的异常，这正是我们要处理的

2122
02:45:19,680 --> 02:45:22,719
现在让我们说如果

2123
02:45:22,719 --> 02:45:27,912
那是你看到我们现在说如果状态被注销所以现在在这个代码块中

2124
02:45:27,912 --> 02:45:33,600
这里飞镖会明白，这里状态的任何地方都可以

2125
02:45:33,600 --> 02:45:38,719
身份验证状态已注销，因此您可以在此处访问异常

2126
02:45:38,719 --> 02:45:42,799
那么我们要说如果状态异常是

2127
02:45:42,799 --> 02:45:47,280
用户未发现异常

2128
02:45:47,280 --> 02:45:50,479
我们要展示一个体重表演

2129
02:45:50,479 --> 02:45:53,912
呃错误对话框所以让我们把它变成一个

2130
02:45:53,912 --> 02:45:59,280
监听器也是异步的，然后我们会说显示错误对话框

2131
02:45:59,280 --> 02:46:03,912
并且我们之前已经编码，请记住这使用通用对话框，所以我

2132
02:46:03,912 --> 02:46:08,799
回到这里登录查看 dart 和我们要说的文本

2133
02:46:08,799 --> 02:46:13,280
用户没有找到好的，那么我们也必须处理错误

2134
02:46:13,280 --> 02:46:19,040
密码关闭异常，否则如果状态异常错误密码关闭

2135
02:46:19,040 --> 02:46:22,959
例外然后在这里复制文本然后在这里我们只是要说

2136
02:46:22,959 --> 02:46:26,231
错误的凭据

2137
02:46:26,231 --> 02:46:30,319
并记住与用户名和密码有关的任何事情

2138
02:46:30,319 --> 02:46:36,479
重要的是你不要告诉用户他们的凭据的哪一部分实际上

2139
02:46:36,479 --> 02:46:40,799
不正确，因为如果我的意思是如果有黑客在尝试

2140
02:46:40,799 --> 02:46:45,280
进入系统并只使用用户界面然后如果你告诉他们错了

2141
02:46:45,280 --> 02:46:49,040
密码他们会像啊所以我得到了正确的电子邮件它只是一个密码

2142
02:46:49,040 --> 02:46:53,512
不正确，所以尽量不要告诉用户，即使它是为了

2143
02:46:53,512 --> 02:46:58,231
很好的理由，即使你认为很好，我也没有黑客

2144
02:46:58,231 --> 02:47:02,000
我的应用程序最好还是说错

2145
02:47:02,000 --> 02:47:06,399
凭据，因为用户自己可能已经知道他们的电子邮件

2146
02:47:06,399 --> 02:47:10,231
是正确的还是不正确的，所以他们首先要检查他们的电子邮件，所以如果

2147
02:47:10,231 --> 02:47:13,280
电子邮件是正确的，那么他们就会知道密码不正确，并且

2148
02:47:13,280 --> 02:47:15,912
如您所见，我们稍后将允许用户

2149
02:47:15,912 --> 02:47:20,799
重置他们的密码，所以只需在我的

2150
02:47:20,799 --> 02:47:25,280
意见至少如此，然后其他如果状态

2151
02:47:25,280 --> 02:47:30,871
异常是通用身份验证异常，然后我们将显示一个对话框

2152
02:47:30,871 --> 02:47:33,832
在这里我们只说身份验证

2153
02:47:33,832 --> 02:47:38,159
错误还好

2154
02:47:38,159 --> 02:47:44,000
所以这部分已经完成了，现在我们已经在我们的

2155
02:47:44,000 --> 02:47:48,399
显示登录的文本按钮的登录视图

2156
02:47:48,399 --> 02:47:51,280
好的

2157
02:47:51,280 --> 02:47:55,832
所以现在我们有了我们需要做的就是删除 uh 异常

2158
02:47:55,832 --> 02:48:02,959
从按钮本身处理，所以目前我们有一个巨大的 try 语句

2159
02:48:02,959 --> 02:48:07,512
实际上不是很大，我们在这里有很长的 try catch 语句

2160
02:48:07,512 --> 02:48:12,319
我们正在捕获三个异常，这些异常现在实际上在这里被捕获

2161
02:48:12,319 --> 02:48:16,231
我们的块监听器，让我们走吧，不要

2162
02:48:16,231 --> 02:48:19,832
实际上这样做，所以我希望你抓住这个复杂的阅读

2163
02:48:19,832 --> 02:48:24,639
以及我们实际将 log 事件传递到我们的块中并删除它的位置

2164
02:48:24,639 --> 02:48:30,719
整个 try and catch 块，只是在 auth 事件登录时读取上下文，所以

2165
02:48:30,719 --> 02:48:34,551
您的未按事件或对您的新闻表示抱歉

2166
02:48:34,551 --> 02:48:38,959
文本按钮的参数应该看起来很简单，就像这封电子邮件一样

2167
02:48:38,959 --> 02:48:45,512
密码，然后您将该事件传递给您的身份验证块

2168
02:48:45,512 --> 02:48:52,000
好吧，既然已经发生了，让我们实际检查一下，看看是否

2169
02:48:52,000 --> 02:48:56,799
一切正常，记住这就像我们迈向的开始

2170
02:48:56,799 --> 02:49:00,719
处理我们的身份验证的更好方法和

2171
02:49:00,719 --> 02:49:05,440
用块路由所以事情不会很顺利实际上我们有一个

2172
02:49:05,440 --> 02:49:09,512
我们必须解决很多问题，但这就像开始一样，所以我要走了

2173
02:49:09,512 --> 02:49:15,280
把 scr cpy 带进来，让我们测试一下

2174
02:49:15,280 --> 02:49:18,719
我要热重启

2175
02:49:18,719 --> 02:49:22,639
现在我在登录屏幕上，所以我很好

2176
02:49:22,639 --> 02:49:26,319
然后继续在这里输入我的电子邮件地址

2177
02:49:26,319 --> 02:49:29,760
然后我会在这里放一些查询凭据，好吧，我只是

2178
02:49:29,760 --> 02:49:34,551
按下登录按钮，现在你可以看到我们的块监听器是

2179
02:49:34,551 --> 02:49:39,360
照顾好它，所以它说哦，您已注销，然后就错了

2180
02:49:39,360 --> 02:49:44,799
凭据好的，所以我要按好，然后我要输入一个电子邮件地址

2181
02:49:44,799 --> 02:49:48,159
这里不存在，然后按登录按钮，现在你可以看到

2182
02:49:48,159 --> 02:49:52,079
用户没有找到好的，如果你想的话，对你说实话

2183
02:49:52,079 --> 02:49:55,191
我之前实际上说过，最好

2184
02:49:55,191 --> 02:50:00,639
不要告诉用户是他们的用户错误还是密码错误

2185
02:50:00,639 --> 02:50:05,912
想要实际包装用户未找到和错误的状态异常

2186
02:50:05,912 --> 02:50:10,079
密码，然后只显示相同的消息，这样你就可以说

2187
02:50:10,079 --> 02:50:14,639
战争在这里或那个

2188
02:50:14,639 --> 02:50:16,719
没错

2189
02:50:16,719 --> 02:50:20,000
然后你可以只显示相同的消息然后你可以删除

2190
02:50:20,000 --> 02:50:23,832
从那里的这个声明，这样也可以工作，我就这样离开它

2191
02:50:23,832 --> 02:50:28,079
这只是为了让您知道实际上最好采用我刚才的方法

2192
02:50:28,079 --> 02:50:32,319
暂时向你展示了一切，所以它看起来像我们的街区

2193
02:50:32,319 --> 02:50:36,159
监听器在登录视图中工作正常，所以这只是开始，

2194
02:50:36,159 --> 02:50:40,079
我们有很多要解决的问题，所以我们将在接下来的章节中解决这些问题

2195
02:50:40,079 --> 02:50:43,360
好吧，现在代码似乎正在运行

2196
02:50:43,360 --> 02:50:48,399
对于登录视图，让我们继续做我们通常做的事情并提交我们的

2197
02:50:48,399 --> 02:50:54,479
工作，以便我们在发生任何事情时不会丢失代码

2198
02:50:54,479 --> 02:50:59,191
我要最小化 scr cpy 制作 Visual Studio 代码一点点

2199
02:50:59,191 --> 02:51:03,832
在这里更大，并显着增加尺寸

2200
02:51:03,832 --> 02:51:08,871
让我们看看我们已经修改了三个文件的状态，所以让我们

2201
02:51:08,871 --> 02:51:14,231
说这是一个 git commit 并在这里

2202
02:51:14,231 --> 02:51:19,832
让我们实际上让我们这样做，然后我们在这里做一个正常的评论

2203
02:51:19,832 --> 02:51:23,912
这是第 24 步，好了，现在已经完成了，让我们推动

2204
02:51:23,912 --> 02:51:29,120
更改遥控器，然后让我们也获取状态

2205
02:51:29,120 --> 02:51:32,639
命令所以一切都成功提交，然后让我们标记为

2206
02:51:32,639 --> 02:51:38,319
第 24 步我相信是对的，所以这是我们的标签，然后我们推送我们的

2207
02:51:38,319 --> 02:51:42,871
标签，让我们看看我们的标签

2208
02:51:42,871 --> 02:51:48,959
这一点 23 我们有哪里是 24 并且有 24 所以我们把所有东西都标记了

2209
02:51:48,959 --> 02:51:54,719
成功了，就像你看到的那样

2210
02:51:54,719 --> 02:51:57,680
传统我们总是在每一章的末尾谈论我们谈论什么

2211
02:51:57,680 --> 02:52:00,871
我们需要在即将到来的章节中讨论

2212
02:52:00,871 --> 02:52:04,639
嗯，这样你就可以看到我们的路由和对话框

2213
02:52:04,639 --> 02:52:08,639
处理不是基于块的，目前我们仍然有很多

2214
02:52:08,639 --> 02:52:12,159
我们在应用程序中看到的位置，例如上下文导航器

2215
02:52:12,159 --> 02:52:16,319
推送名称并删除，直到或者我们正在推送名称，所以

2216
02:52:16,319 --> 02:52:19,912
所以我们已经处理了我们应用程序的一些点点滴滴，我们正在使用块

2217
02:52:19,912 --> 02:52:23,280
但例如我们没有在注册视图或验证中处理东西

2218
02:52:23,280 --> 02:52:27,440
电子邮件查看类似的东西，所以我们有很多工作要做，下一个

2219
02:52:27,440 --> 02:52:30,639
章节实际上会很重，但它会很关键

2220
02:52:30,639 --> 02:52:34,871
整个课程中的一章，如果你能坚持我的话

2221
02:52:34,871 --> 02:52:38,871
在下一章中，您将看到您的应用程序架构

2222
02:52:38,871 --> 02:52:43,280
实际上变得越来越强壮，所以如果你想吃点点心

2223
02:52:43,280 --> 02:52:47,512
下一章再见大家好，欢迎来到第42章

2224
02:52:47,512 --> 02:52:50,959
在前几章的这封信函课程中，我们已经谈得很清楚了

2225
02:52:50,959 --> 02:52:55,912
关于清理我们的应用程序逻辑和我们的身份验证逻辑

2226
02:52:55,912 --> 02:53:00,159
向前迈进一点，我们已经

2227
02:53:00,159 --> 02:53:05,512
嗯，我们在登录视图中清理了很多东西，现在我们正在使用块

2228
02:53:05,512 --> 02:53:09,120
如果您按时间顺序关注所有章节，则登录视图中的侦听器

2229
02:53:09,120 --> 02:53:11,440
直到包括上一章在内

2230
02:53:11,440 --> 02:53:14,959
所以你应该已经知道块块侦听器块消费者块

2231
02:53:14,959 --> 02:53:19,191
当然，提供者 um 和块生成器

2232
02:53:19,191 --> 02:53:24,399
但我们还有很多东西，我很自豪地说这一章

2233
02:53:24,399 --> 02:53:29,191
也许接下来的一两章会像

2234
02:53:29,191 --> 02:53:35,191
将应用程序带到更紧密的位置的胶水

2235
02:53:35,191 --> 02:53:39,360
准备发布到应用商店和游戏商店所以如果你坚持我

2236
02:53:39,360 --> 02:53:41,912
在剩下的这几章中

2237
02:53:41,912 --> 02:53:46,551
我们将基本上创造出更清洁的产品，不仅

2238
02:53:46,551 --> 02:53:53,040
最终用户可以使用，但它也是，但它在架构上也是合理的，所以

2239
02:53:53,040 --> 02:53:56,231
你会为实际发布这个应用程序而感到自豪，甚至可能

2240
02:53:56,231 --> 02:54:00,719
将此代码展示给您的朋友和同事，以便

2241
02:54:00,719 --> 02:54:03,760
作为本章案例的标题，我们将讨论移动到

2242
02:54:03,760 --> 02:54:08,959
阻止路由和对话，因为现在您知道路由我们所拥有的

2243
02:54:08,959 --> 02:54:14,399
在我们的应用程序中有点像主 dart 文件中的混合体，我的意思是

2244
02:54:14,399 --> 02:54:19,512
我们不必谈论 uh 所以像抽象概念概念我们可以

2245
02:54:19,512 --> 02:54:22,799
实际上看看我们的主要飞镖文件所以如果你看这里我们在

2246
02:54:22,799 --> 02:54:26,799
主 dart 文件，我们实际上是在创建一个块生成器，并且取决于

2247
02:54:26,799 --> 02:54:31,440
我们的块正在输出的状态我们正在显示正确的视图

2248
02:54:31,440 --> 02:54:35,600
所以这本身就很好，所以这没有什么问题，但是

2249
02:54:35,600 --> 02:54:40,479
我们还将它与我们应用程序中的自定义位置混合在一起

2250
02:54:40,479 --> 02:54:47,191
比如说 um 的上下文，让我们在关闭导航器的情况下实际看看

2251
02:54:47,191 --> 02:54:50,551
你可以看到我们正在做实际上这很好但是你可以在我们的登录中看到

2252
02:54:50,551 --> 02:54:54,551
查看当您按下未注册但在此处注册按钮以执行

2253
02:54:54,551 --> 02:54:58,479
用户的注册然后我们正在做一个push blah blah blah的导航器

2254
02:54:58,479 --> 02:55:03,600
所以在我们的应用程序中还有很多零碎的东西

2255
02:55:03,600 --> 02:55:06,959
要么直接与我们不应该做的身份验证服务交谈

2256
02:55:06,959 --> 02:55:12,479
应该和外面的人交谈，或者我们正在和 navigator 交谈

2257
02:55:12,479 --> 02:55:16,719
要做的事情 push name 所以在本章中我们要清理

2258
02:55:16,719 --> 02:55:20,959
这些东西基本上构成了我们的身份验证块和

2259
02:55:20,959 --> 02:55:25,680
使用 block 和

2260
02:55:25,680 --> 02:55:30,799
听众块建设者，嗯，我们都将使用块

2261
02:55:30,799 --> 02:55:36,799
我相信消费者，所以让我们继续这样做吧

2262
02:55:36,799 --> 02:55:38,719
所以这就是我的意思

2263
02:55:38,719 --> 02:55:41,280
正如标题所示，我的意思是我已经谈论过这个也许我应该

2264
02:55:41,280 --> 02:55:44,479
几秒钟前已显示此标题

2265
02:55:44,479 --> 02:55:47,440
但是我们已经讨论过这个我们应该基本上收紧我们的方式

2266
02:55:47,440 --> 02:55:52,399
使用我们的 um 路由和我们的

2267
02:55:52,399 --> 02:55:56,079
我们如何使用关闭服务

2268
02:55:56,079 --> 02:56:00,799
你可以在这里看到我们需要更多的身份验证事件才能能够

2269
02:56:00,799 --> 02:56:05,191
实现这一点，让我们继续打开我们的 um

2270
02:56:05,191 --> 02:56:09,512
我可能需要在屏幕上进行一些改组，以便您看到代码

2271
02:56:09,512 --> 02:56:15,280
更好，所以我会做我通常在这里做的事情，然后我们去参加我们的活动

2272
02:56:15,280 --> 02:56:17,912
在这里，这些是我们在

2273
02:56:17,912 --> 02:56:22,871
我们注销登录的那一刻，然后我们进行了初始化，但我们也

2274
02:56:22,871 --> 02:56:27,760
有相当多的应用程序正在执行的其他 ui 事件

2275
02:56:27,760 --> 02:56:31,120
实例与身份验证交互，例如

2276
02:56:31,120 --> 02:56:35,600
嗯，发送一封验证电子邮件，所以当你在验证电子邮件中时

2277
02:56:35,600 --> 02:56:39,512
查看并用户再次按下发送验证电子邮件，然后在

2278
02:56:39,512 --> 02:56:42,719
直接与我们的身份验证服务交谈的那一刻，我们不应该那样做

2279
02:56:42,719 --> 02:56:48,799
我们应该要求我们的关闭博客这样做，或者当你例如嗯

2280
02:56:48,799 --> 02:56:53,040
在我们的验证电子邮件视图中询问，所以如果你去这里你可以看到我们有

2281
02:56:53,040 --> 02:56:57,832
这个 um 注销按钮或重新启动按钮

2282
02:56:57,832 --> 02:57:03,440
所以让我们继续吧，我将把 scrcpy 带到这里，让我们

2283
02:57:03,440 --> 02:57:06,959
实际上，为了能够显示验证电子邮件，我们必须有一个用户没有

2284
02:57:06,959 --> 02:57:10,479
已经过验证，但如果你记得之前你刚刚创建了一个用户

2285
02:57:10,479 --> 02:57:14,231
例如最近或刚刚

2286
02:57:14,231 --> 02:57:18,719
用户尚未验证其凭据，那么他们将始终被移入

2287
02:57:18,719 --> 02:57:23,600
这个验证电子邮件视图，例如，他们必须说是的，嗯，我

2288
02:57:23,600 --> 02:57:28,399
我是不是他们有能力再次向他们的电子邮件发送验证电子邮件

2289
02:57:28,399 --> 02:57:32,639
或者重新启动整个过程意味着退出并进入注册

2290
02:57:32,639 --> 02:57:35,912
登录查看等现在直接发生

2291
02:57:35,912 --> 02:57:39,680
您可以看到它直接对 auth 服务关闭，我们应该这样做

2292
02:57:39,680 --> 02:57:42,799
然后有一个推送名称的导航器，然后删除，直到我们

2293
02:57:42,799 --> 02:57:46,159
为了收紧这些事情，也不应该这样做

2294
02:57:46,159 --> 02:57:50,871
我们需要在我们的 auth 事件 dart 文件中添加一些事件，这就是我们要做的

2295
02:57:50,871 --> 02:57:56,551
现在要做，所以让我们转到我们的 auth 事件文件，然后

2296
02:57:56,551 --> 02:58:01,680
我会在我的笔记中做同样的事情所以嗯第一个

2297
02:58:01,680 --> 02:58:05,280
如您所见，我们将在这里创建的新事件称为 auth

2298
02:58:05,280 --> 02:58:10,231
事件发送电子邮件验证好吧，让我们继续做我要去

2299
02:58:10,231 --> 02:58:15,280
摆脱这里的底视图以及项目结构

2300
02:58:15,280 --> 02:58:20,000
所以我已经在我的笔记中写了，所以我要把它带到这里来

2301
02:58:20,000 --> 02:58:23,512
到 Visual Studio 代码，所以我不必手动编写它，但事件

2302
02:58:23,512 --> 02:58:29,512
名称应该被取消事件发送电子邮件验证目标是我们的

2303
02:58:29,512 --> 02:58:34,079
验证电子邮件视图以将此事件发送到我们的关闭块以请求新的

2304
02:58:34,079 --> 02:58:41,120
验证邮件发送给当前登录的用户 ok

2305
02:58:41,120 --> 02:58:46,959
我们还需要一个注册事件，所以目标是在注册视图中

2306
02:58:46,959 --> 02:58:50,159
让我们现在看一下寄存器视图，您可以看到

2307
02:58:50,159 --> 02:58:54,799
用户按下注册按钮，此时我们正在说 uh firebase create

2308
02:58:54,799 --> 02:58:58,959
用户所以我们直接去firebase auth服务

2309
02:58:58,959 --> 02:59:02,000
我们说创建用户，然后我们立即说发送电子邮件

2310
02:59:02,000 --> 02:59:05,760
验证所以我们不应该做任何这些所以这三件事

2311
02:59:05,760 --> 02:59:10,231
从架构的角度来看，我们在这里所做的几乎是错误的，所以我们

2312
02:59:10,231 --> 02:59:14,000
不应该直接与这些服务交谈，我们应该把它清理干净

2313
02:59:14,000 --> 02:59:18,159
为了实现这一点，我们需要回到我们的 auth 事件并创建一个新的

2314
02:59:18,159 --> 02:59:23,832
oz 事件称为注册，所以我将把它放在底部

2315
02:59:23,832 --> 02:59:29,040
在这里登录所以让我继续创建一个新的

2316
02:59:29,040 --> 02:59:33,191
关闭事件我们称之为事件寄存器类

2317
02:59:33,191 --> 02:59:36,719
当然我们要扩展我们的 auth 事件

2318
02:59:36,719 --> 02:59:40,959
对于注册，如果我们回到注册视图，我们需要两个参数

2319
02:59:40,959 --> 02:59:44,079
在注册时看到我们总是发送电子邮件和密码所以

2320
02:59:44,079 --> 02:59:47,912
让我们继续在这里做同样的事情，所以我们说最后的字符串电子邮件和

2321
02:59:47,912 --> 02:59:51,120
我要复制这个，我要说密码并获得帮助

2322
02:59:51,120 --> 02:59:56,159
用于创建此常量构造函数的 Visual Studio 代码，您可能想要

2323
02:59:56,159 --> 03:00:01,360
使用这些来制作这些必需的名称字段，但我不会这样做

2324
03:00:01,360 --> 03:00:06,551
我就这样留下电子邮件和密码好了

2325
03:00:06,551 --> 03:00:12,871
所以这是我们的非活动注册对不起

2326
03:00:12,871 --> 03:00:19,360
所以我们需要一个称为事件的另一件事应该注册所以嗯

2327
03:00:19,360 --> 03:00:25,040
基本上这意味着例如，如果您还没有真正注册用户

2328
03:00:25,040 --> 03:00:28,871
那么我们需要发送这个事件我实际上会有

2329
03:00:28,871 --> 03:00:35,760
看看我的登录视图，例如，如果你去一个

2330
03:00:35,760 --> 03:00:39,191
登录视图在这里，然后你看看这个按钮

2331
03:00:39,191 --> 03:00:43,120
我们在这里尚未注册但在这里注册基本上是

2332
03:00:43,120 --> 03:00:46,231
我们现在要实施的事件，所以我们要告诉

2333
03:00:46,231 --> 03:00:51,680
阻止，嘿，你应该注册用户好，然后关闭阻止然后去

2334
03:00:51,680 --> 03:00:55,760
将其状态更改为应用程序将要理解的状态

2335
03:00:55,760 --> 03:00:59,360
自动将用户发送到注册视图好的所以

2336
03:00:59,360 --> 03:01:04,959
这就是用例，所以嗯，让我们继续吧，我只是

2337
03:01:04,959 --> 03:01:09,680
检查我的笔记，让我们继续开发这个应该注册和

2338
03:01:09,680 --> 03:01:13,360
我已经在我的笔记中做到了，所以我要把它放在最后

2339
03:01:13,360 --> 03:01:17,120
事件寄存器，但您需要自己编写，所以看起来像

2340
03:01:17,120 --> 03:01:20,871
auth 事件应该注册 extends off 事件，它只有一个常量

2341
03:01:20,871 --> 03:01:28,799
构造函数，所以它非常简单，所以这是我们的 auth um 事件应该

2342
03:01:28,799 --> 03:01:31,440
登记

2343
03:01:31,440 --> 03:01:34,319
所以现在如果我们现在就去

2344
03:01:34,319 --> 03:01:38,079
在我们也需要的标题中看到它，现在我们已经完成了这样的身份验证事件

2345
03:01:38,079 --> 03:01:42,079
我们必须创建的东西才能处理各种

2346
03:01:42,079 --> 03:01:46,319
来自 ui 的事件，但我们还需要修复我们的状态，所以让我们

2347
03:01:46,319 --> 03:01:50,871
转到我们的关闭状态并在这里复习你可以看到我们有状态

2348
03:01:50,871 --> 03:01:55,120
加载登录需要验证退出

2349
03:01:55,120 --> 03:01:58,719
并注销失败，但我们会稍微清理一下并确保

2350
03:01:58,719 --> 03:02:02,799
我们拥有应用程序所需的每个状态，以便能够

2351
03:02:02,799 --> 03:02:08,399
例如显示对话框或做路由好

2352
03:02:08,399 --> 03:02:13,040
所以在我们关闭状态的那一刻

2353
03:02:13,040 --> 03:02:17,832
我们需要做的是让你看到我们有这个加载状态以及我们是什么

2354
03:02:17,832 --> 03:02:22,159
要做的是实际删除加载状态，我们将创建

2355
03:02:22,159 --> 03:02:27,191
一个被调用的身份验证状态已经初始化好了，所以

2356
03:02:27,191 --> 03:02:30,399
嗯，让我们继续并实际删除它

2357
03:02:30,399 --> 03:02:35,360
关闭状态加载并在这里创建一个类说身份验证状态

2358
03:02:35,360 --> 03:02:40,399
初始化，因为当您登陆应用程序时

2359
03:02:40,399 --> 03:02:43,912
例如，您可能第一次真正想要

2360
03:02:43,912 --> 03:02:47,440
显示某种加载屏幕或其他什么，我们将指出

2361
03:02:47,440 --> 03:02:50,959
应用程序尚未真正初始化 firebase 或其

2362
03:02:50,959 --> 03:02:55,280
使用此关闭状态的身份验证系统未初始化，这只是

2363
03:02:55,280 --> 03:03:01,680
向两者指示呼叫方的更简洁的方式，即 ui 嘿，我们

2364
03:03:01,680 --> 03:03:05,440
还没有被初始化，所以你需要调用我们的初始化函数

2365
03:03:05,440 --> 03:03:10,079
off block 好的或抱歉，您必须发送 auth 事件

2366
03:03:10,079 --> 03:03:14,319
呃初始化身份验证事件好吧让我们进入关闭状态所以

2367
03:03:14,319 --> 03:03:18,799
只是为了回顾一下我删除了状态加载

2368
03:03:18,799 --> 03:03:23,600
现在我们将进入未初始化的关闭状态，因此我们将

2369
03:03:23,600 --> 03:03:29,680
说 uninitialize 扩展关闭状态，让我们创建一个常量

2370
03:03:29,680 --> 03:03:36,231
它的构造函数也可以

2371
03:03:36,231 --> 03:03:40,231
所以我们还必须实施的另一件事是

2372
03:03:40,231 --> 03:03:45,760
显然我们已经讨论过登录，就像这里登录注销然后注销

2373
03:03:45,760 --> 03:03:51,280
失败等，现在我们实际上必须开始

2374
03:03:51,280 --> 03:03:55,040
谈论当用户按下注册按钮时会发生什么

2375
03:03:55,040 --> 03:03:58,799
用户按下我们也必须处理的注册按钮

2376
03:03:58,799 --> 03:04:03,120
是的，我们目前正在注册，所以这是一个过程

2377
03:04:03,120 --> 03:04:07,512
正在进行，但我们还必须讨论如果注册会发生什么

2378
03:04:07,512 --> 03:04:12,231
失败了，所以我们正在注册过程中，要么一切顺利，然后

2379
03:04:12,231 --> 03:04:17,120
我们说您已注册，或者我们说注册表注册失败，所以我们走吧

2380
03:04:17,120 --> 03:04:21,280
前进，然后在此处创建一个状态

2381
03:04:21,280 --> 03:04:25,512
未初始化让我们说状态类

2382
03:04:25,512 --> 03:04:31,912
我们叫什么注册扩展状态好的，让我们进入

2383
03:04:31,912 --> 03:04:34,719
就像我们在这里做的一样，例如

2384
03:04:34,719 --> 03:04:37,440
注销的状态让我们复制一下

2385
03:04:37,440 --> 03:04:41,040
异常并使其进入关闭状态注册

2386
03:04:41,040 --> 03:04:44,639
然后让我们在这里为我们的关闭状态创建一个常量构造函数

2387
03:04:44,639 --> 03:04:48,319
注册，我只想在这里说不变，所以现在我们有了

2388
03:04:48,319 --> 03:04:54,159
像这样注册所以现在我们已经注册登录

2389
03:04:54,159 --> 03:04:59,191
而且我们实际上还需要删除关闭状态注销失败

2390
03:04:59,191 --> 03:05:02,719
因为我们很抱歉

2391
03:05:02,719 --> 03:05:08,319
我们已经退出了异常

2392
03:05:08,319 --> 03:05:13,040
嗯，所以让我们现在就开始吧，让我们删除状态日志

2393
03:05:13,040 --> 03:05:16,799
注销失败也可以，所以

2394
03:05:16,799 --> 03:05:23,600
再次对不起，这是为了关闭状态注册

2395
03:05:23,600 --> 03:05:26,479
正如你在标题中看到的那样

2396
03:05:26,479 --> 03:05:31,040
加载注销状态我们需要登录屏幕才能有一个加载对话框，所以

2397
03:05:31,040 --> 03:05:36,551
我们需要在注销的身份验证状态下加载，所以让我们看看

2398
03:05:36,551 --> 03:05:40,871
我们在这里登出

2399
03:05:40,871 --> 03:05:46,079
以前我们将此加载状态作为单独的状态，因此它处于关闭状态

2400
03:05:46,079 --> 03:05:49,360
加载，我们通常会在任何地方使用它，但现在我们是什么

2401
03:05:49,360 --> 03:05:52,719
要做的是将这个加载状态构建成

2402
03:05:52,719 --> 03:05:58,000
或将此加载标志构建到现有状态本身中

2403
03:05:58,000 --> 03:06:02,799
让我们继续说好，当您按下登录按钮时

2404
03:06:02,799 --> 03:06:07,360
我们要做的第一件事就是说嗯实际上等等让我们退后一步

2405
03:06:07,360 --> 03:06:10,959
假设您刚刚登陆应用程序，但您已经有一个用户

2406
03:06:10,959 --> 03:06:15,360
您之前没有记录它们，所以您的状态已注销并且

2407
03:06:15,360 --> 03:06:19,512
异常为空，我们将在这里添加一个标志

2408
03:06:19,512 --> 03:06:25,191
并说 final bool 正在加载，让我们添加正在加载的内容

2409
03:06:25,191 --> 03:06:30,399
在这里设置参数并使这两个必需的参数都可以这样

2410
03:06:30,399 --> 03:06:35,040
并在那里加上一个逗号，就像这个繁荣一样

2411
03:06:35,040 --> 03:06:39,120
当您进入应用程序异常时，您的状态会在那里注销

2412
03:06:39,120 --> 03:06:42,871
也不例外，所以异常 null 和正在加载是错误的，因为我们不是

2413
03:06:42,871 --> 03:06:46,639
加载任何东西然后你写你的凭据然后你按下登录

2414
03:06:46,639 --> 03:06:52,231
按钮然后发生什么状态仍然注销异常为空但正在加载

2415
03:06:52,231 --> 03:06:55,440
是真的那么我们就说你进入了

2416
03:06:55,440 --> 03:06:58,639
不正确的凭据那么我们将在我们的块身份验证块中做的是

2417
03:06:58,639 --> 03:07:02,959
会说哦，您已关闭状态已注销存在异常并正在加载

2418
03:07:02,959 --> 03:07:07,360
是假的，然后你现在就好了

2419
03:07:07,360 --> 03:07:10,639
输入查询凭据，然后您将更正这些凭据，然后

2420
03:07:10,639 --> 03:07:14,079
再次按下登录按钮现在我们要说什么我们要说好的

2421
03:07:14,079 --> 03:07:18,871
所有状态已注销的异常都没有，然后正在加载为真

2422
03:07:18,871 --> 03:07:21,912
如果那时我们可以让你登录，我们会

2423
03:07:21,912 --> 03:07:26,959
为您生成另一个状态，因此您会看到这就是我们使用状态来传达的方式

2424
03:07:26,959 --> 03:07:29,832
cur 喜欢正确的状态

2425
03:07:29,832 --> 03:07:33,440
应用到消费者，这是 ui 好的

2426
03:07:33,440 --> 03:07:37,912
所以这不像你可能想的哦，他怎么知道这是正确的

2427
03:07:37,912 --> 03:07:43,600
正确的做事方式在这里没有对错

2428
03:07:43,600 --> 03:07:47,680
这就是您对申请的推理方式

2429
03:07:47,680 --> 03:07:50,319
当我说没有对错

2430
03:07:50,319 --> 03:07:53,760
我的意思是有些事情比其他事情更正确，有些事情

2431
03:07:53,760 --> 03:07:58,399
比其他人更错误，但你需要找到的就像甜蜜一样

2432
03:07:58,399 --> 03:08:02,719
点在这里，这正是

2433
03:08:02,719 --> 03:08:07,600
对您的应用程序有好处，同时也不是不正确的，那

2434
03:08:07,600 --> 03:08:12,319
是为您的应用程序编写的定义，在这种情况下，这是

2435
03:08:12,319 --> 03:08:16,551
此应用程序的权利定义，因此您只需要找到一个最佳位置

2436
03:08:16,551 --> 03:08:20,231
为您的应用程序好

2437
03:08:20,231 --> 03:08:23,360
所以现在让我们看看这里

2438
03:08:23,360 --> 03:08:27,680
再谈一点关于平等的事情 嗯

2439
03:08:27,680 --> 03:08:30,959
我在这里所说的平等的意思是

2440
03:08:30,959 --> 03:08:35,512
你看我说的是三种不同的注销状态注销

2441
03:08:35,512 --> 03:08:40,551
异常 null 正在加载 false 注销异常正在加载

2442
03:08:40,551 --> 03:08:44,319
真，然后以异常注销并加载假

2443
03:08:44,319 --> 03:08:47,512
实例所以你正在生产三种不同的

2444
03:08:47,512 --> 03:08:52,719
状态类型都属于同一类，所以将如何

2445
03:08:52,719 --> 03:08:57,912
你的应用程序如何理解这些实际上是不同的状态

2446
03:08:57,912 --> 03:09:00,551
所以你需要区分

2447
03:09:00,551 --> 03:09:05,191
在您关闭状态的各种状态之间已注销，因此您需要告诉

2448
03:09:05,191 --> 03:09:09,191
你的应用程序虽然之前的状态也关闭了

2449
03:09:09,191 --> 03:09:13,360
状态已注销，并且我现在正在制作的正确状态是

2450
03:09:13,360 --> 03:09:18,231
也关闭状态已注销，但这两种状态实际上可能与

2451
03:09:18,231 --> 03:09:22,231
彼此以及它们所包含的内容，因此您需要像

2452
03:09:22,231 --> 03:09:24,639
平等和

2453
03:09:24,639 --> 03:09:28,719
逻辑到你的状态告诉应用程序嘿这个

2454
03:09:28,719 --> 03:09:33,680
虽然它是一样的，就像是同一个状态类的一个新实例，但是

2455
03:09:33,680 --> 03:09:38,319
内部不是一回事，为此我们必须实现所有人的平等

2456
03:09:38,319 --> 03:09:41,832
现在有一个很好的包允许

2457
03:09:41,832 --> 03:09:45,832
您这样做是为了在您的应用程序和

2458
03:09:45,832 --> 03:09:50,399
你的飞镖代码，它被称为公平的，所以让我们继续导入

2459
03:09:50,399 --> 03:09:54,159
不要被这里的所有这些日志吓倒，这只是因为我们

2460
03:09:54,159 --> 03:09:58,871
有很多我们正在解决的问题，所以让我们继续，嗯

2461
03:09:58,871 --> 03:10:02,551
我要稍微改变一下屏幕布局

2462
03:10:02,551 --> 03:10:07,040
增加尺寸，让我们继续说颤动

2463
03:10:07,040 --> 03:10:12,231
弹出添加公平

2464
03:10:12,231 --> 03:10:15,600
类似的东西，你可以阅读更多关于它的信息，所以我只是要提出

2465
03:10:15,600 --> 03:10:20,079
我的野生动物园在这里，让我们说

2466
03:10:20,079 --> 03:10:23,512
颤动或只是流行开发

2467
03:10:23,512 --> 03:10:28,399
让我们说公平的对不起

2468
03:10:28,399 --> 03:10:33,832
你可以看到它实际上是由颤振社区开发人员在这里开发的

2469
03:10:33,832 --> 03:10:38,159
它是经过验证的开发人员，您实际上也可以关注 Flutter

2470
03:10:38,159 --> 03:10:42,479
推特上的社区开发人员也可以获取有关他们的软件包的一些更新

2471
03:10:42,479 --> 03:10:47,120
所以我们现在将它导入到我们的应用程序中，我们现在应该能够

2472
03:10:47,120 --> 03:10:51,120
使用它，所以我要摆脱这个底栏

2473
03:10:51,120 --> 03:10:56,639
并再次更改屏幕布局减小字体大小

2474
03:10:56,639 --> 03:11:03,040
好的，所以现在让我们开始导入公平的，所以我要导入它

2475
03:11:03,040 --> 03:11:05,832
我已经在我的笔记中导入了，所以我将把它粘贴到你这里

2476
03:11:05,832 --> 03:11:10,959
import equitable like this package equitable slash equitable dart 好的

2477
03:11:10,959 --> 03:11:16,079
所以我们在这里需要的是我们已经在扩展一个现有的类所以你

2478
03:11:16,079 --> 03:11:21,120
可以做的是你可以使用混合在你的班级中带来平等，所以我们

2479
03:11:21,120 --> 03:11:26,832
会说混合 e quotable mix in 就像

2480
03:11:26,832 --> 03:11:32,799
抱歉，好吧，所以现在我们正在做那种混合

2481
03:11:32,799 --> 03:11:35,512
现在我们必须在这里实现一些功能，如您所见

2482
03:11:35,512 --> 03:11:40,159
视觉工作室代码帮助我说创建一个缺失的覆盖好吗

2483
03:11:40,159 --> 03:11:46,079
所以我在这里进行了覆盖，它说好的，现在我们必须覆盖

2484
03:11:46,079 --> 03:11:50,479
这个属性，你可以在这里看到你需要返回的是一个列表

2485
03:11:50,479 --> 03:11:55,360
当公平的包可以时必须考虑的属性

2486
03:11:55,360 --> 03:11:59,191
基本上计算你班上的平等，在这里什么

2487
03:11:59,191 --> 03:12:02,959
我们要说的是我们在这里有两个属性，称为异常

2488
03:12:02,959 --> 03:12:08,000
我们也有正在加载，所以在加载时要考虑这两个属性

2489
03:12:08,000 --> 03:12:15,191
在已注销的身份验证状态实例中计算相等性

2490
03:12:15,191 --> 03:12:18,871
好吧，做得很好，就是这样

2491
03:12:18,871 --> 03:12:23,760
我们已经在这里完成了，所以我们已经使我们的关闭状态注销类公平，并且

2492
03:12:23,760 --> 03:12:28,159
再次这样做的原因是我们需要生产各种

2493
03:12:28,159 --> 03:12:33,120
此关闭状态的各种 um 突变已注销

2494
03:12:33,120 --> 03:12:38,079
那些不同的突变有各种例外，并且是

2495
03:12:38,079 --> 03:12:41,600
加载需要相互区分，这就是为什么我们

2496
03:12:41,600 --> 03:12:45,600
在这里使用公平的包

2497
03:12:45,600 --> 03:12:48,959
所以嗯，这件事我们已经谈过了

2498
03:12:48,959 --> 03:12:53,912
而且我们不需要关闭状态注销失败，所以我们已经删除了它

2499
03:12:53,912 --> 03:12:57,440
作为我们之前进行的清理工作的一部分，但如果您忘记了

2500
03:12:57,440 --> 03:13:00,159
请看屏幕底部的标题只是为了

2501
03:13:00,159 --> 03:13:04,639
并确保您转到 offstate.file 并删除您的关闭状态

2502
03:13:04,639 --> 03:13:07,600
注销失败以及我之前解释过的原因是

2503
03:13:07,600 --> 03:13:12,159
现在注销失败实际上是内置并烘焙到关闭状态注销

2504
03:13:12,159 --> 03:13:17,120
类里面的异常没事

2505
03:13:17,120 --> 03:13:21,120
哇，好吧，让我们进入下一节

2506
03:13:21,120 --> 03:13:23,680
现在

2507
03:13:23,680 --> 03:13:26,871
好吧，您现在看到我们没有加载

2508
03:13:26,871 --> 03:13:31,912
我们的应用程序中的屏幕，所以当我们正在做的事情发生时

2509
03:13:31,912 --> 03:13:37,040
例如，一个 api 调用，或者我们要去我们的关闭提供商并说登录

2510
03:13:37,040 --> 03:13:42,231
或发送电子邮件验证我们在应用程序内没有加载屏幕

2511
03:13:42,231 --> 03:13:45,512
所以没有任何东西可以向用户表明某些东西实际上是

2512
03:13:45,512 --> 03:13:49,512
正在发生，我们会尽快解决这个问题，你会看到我们会

2513
03:13:49,512 --> 03:13:54,319
创建一个新对话框，为用户加载一些内容，然后使用它

2514
03:13:54,319 --> 03:13:57,191
对话用户会明白，好的事情正在发生，我只是有

2515
03:13:57,191 --> 03:14:00,479
等待它还可以，但我们拥有的用户体验

2516
03:14:00,479 --> 03:14:04,551
现在是一种次优的，因为用户按下登录屏幕和

2517
03:14:04,551 --> 03:14:07,832
取决于他们的抱歉用户按下登录按钮

2518
03:14:07,832 --> 03:14:11,040
并取决于他们的互联网连接和他们的速度

2519
03:14:11,040 --> 03:14:14,871
操作可能需要的互联网互联网连接

2520
03:14:14,871 --> 03:14:18,799
在几毫秒到几秒之间的任何地方，所以

2521
03:14:18,799 --> 03:14:22,231
如果您让用户根据他们的互联网等待几秒钟

2522
03:14:22,231 --> 03:14:25,832
连接速度然后你必须向他们展示你正在做的事情

2523
03:14:25,832 --> 03:14:29,760
很正常的事情，我的意思是你

2524
03:14:29,760 --> 03:14:33,600
可以这样做是显示某种小的加载指示器，例如

2525
03:14:33,600 --> 03:14:37,912
在 ios 上，你有一点加载

2526
03:14:37,912 --> 03:14:43,040
位于状态栏上的指示器，它只是移动了一点，它是

2527
03:14:43,040 --> 03:14:46,319
非常小，我敢说它小于

2528
03:14:46,319 --> 03:14:51,191
宽 20 像素，高 20 像素，甚至可能是 17 像素

2529
03:14:51,191 --> 03:14:55,191
高度上的宽度非常小，所以这是一个微妙的迹象，表明某些东西是

2530
03:14:55,191 --> 03:14:58,639
正在发生，但这通常是我的意思是我发现

2531
03:14:58,639 --> 03:15:02,639
很烦人，因为当加载某些内容时，您需要

2532
03:15:02,639 --> 03:15:07,512
阻止用户尝试按下同一个按钮数千次，所以

2533
03:15:07,512 --> 03:15:11,191
如果您在状态栏顶部显示那个小加载指示器

2534
03:15:11,191 --> 03:15:14,079
那么你还必须做的是你必须添加一些额外的逻辑到你的

2535
03:15:14,079 --> 03:15:18,799
应用程序来阻止例如当前的注册按钮或加载

2536
03:15:18,799 --> 03:15:22,871
按钮，您通常不想这样做，但因为这只是额外的逻辑

2537
03:15:22,871 --> 03:15:26,399
更有意义的是用户按下登录按钮或

2538
03:15:26,399 --> 03:15:29,760
注册按钮，您想像阻止屏幕一样显示

2539
03:15:29,760 --> 03:15:34,000
这告诉他们，嘿，我做的不错，所以不要做任何其他事情

2540
03:15:34,000 --> 03:15:39,512
虽然此屏幕在您的移动显示屏上可见，但让我们继续执行

2541
03:15:39,512 --> 03:15:41,912
那

2542
03:15:41,912 --> 03:15:45,360
所以我们要编写一个加载屏幕，正如你在标题中看到的那样，我们正在

2543
03:15:45,360 --> 03:15:49,280
将在 lib 实用程序对话框加载对话框中执行此操作，所以让我们开始吧

2544
03:15:49,280 --> 03:15:55,360
提前做，然后把我的笔记也拿出来

2545
03:15:55,360 --> 03:15:59,040
我将关闭所有这些文件，以确保我们也保存了它们

2546
03:15:59,040 --> 03:16:02,719
因为如果您在 Visual Studio 代码中关闭一个文件，至少我们没有

2547
03:16:02,719 --> 03:16:05,512
在视觉工作室显示你的对话之前保存，说你是

2548
03:16:05,512 --> 03:16:08,959
确定你想关闭这个文件而不保存它，所以这通常是个好习惯

2549
03:16:08,959 --> 03:16:13,680
在你开始做一些新的事情之前关闭你现有的文件

2550
03:16:13,680 --> 03:16:18,159
这样您至少可以确定您已经保存了这些更改

2551
03:16:18,159 --> 03:16:22,871
嗯，现在我的意思是我们有一些错误不要担心，所以

2552
03:16:22,871 --> 03:16:25,912
您现在应该对应用程序中的错误感到满意

2553
03:16:25,912 --> 03:16:28,551
因为你知道在每一章的结尾我们都会把事情收紧

2554
03:16:28,551 --> 03:16:33,912
并修复问题，所以让我们进入 lib 实用程序对话框

2555
03:16:33,912 --> 03:16:37,191
lib实用程序对话，我们将创建一个

2556
03:16:37,191 --> 03:16:42,000
此处的新文件作为标题指示称为加载对话框飞镖

2557
03:16:42,000 --> 03:16:46,399
你会看到这个加载对话框 我们在这个加载对话框中也必须拥有

2558
03:16:46,399 --> 03:16:48,719
是允许

2559
03:16:48,719 --> 03:16:53,360
允许调用者显示此对话框，但也允许调用者

2560
03:16:53,360 --> 03:16:57,191
关闭此对话框，因此能够关闭

2561
03:16:57,191 --> 03:17:01,760
当应用程序实际需要该对话框消失时的对话框

2562
03:17:01,760 --> 03:17:06,799
我们首先要做的是在这里创建一个类型 f 并且我们

2563
03:17:06,799 --> 03:17:11,600
将其称为关闭对话框让我也增加该字体的大小

2564
03:17:11,600 --> 03:17:16,479
我们要确保它在这里等于一个 void 函数

2565
03:17:16,479 --> 03:17:20,719
我们在这里要做的事情 我们将创建一个函数来显示

2566
03:17:20,719 --> 03:17:26,719
加载对话框，但它还返回调用者可以调用的函数

2567
03:17:26,719 --> 03:17:31,512
忽略它，所以这可能是你思考方式的一点转变

2568
03:17:31,512 --> 03:17:34,959
编程，如果这是你第一次做这样的事情，但我

2569
03:17:34,959 --> 03:17:39,120
向你保证，随着我们的开发，它会更有意义，所以让我们说

2570
03:17:39,120 --> 03:17:44,159
我们有一个返回关闭对话的函数，我们称之为显示加载

2571
03:17:44,159 --> 03:17:47,832
对话框好的，它有两个

2572
03:17:47,832 --> 03:17:51,832
必需的参数，所以让我们把花括号放在这里

2573
03:17:51,832 --> 03:17:57,512
然后假设我们需要构建上下文

2574
03:17:57,512 --> 03:18:03,440
我们称它为构建上下文，或者我们只称它为上下文，然后

2575
03:18:03,440 --> 03:18:07,680
我们有一个要显示的文本，所以需要的字符串文本可以

2576
03:18:07,680 --> 03:18:11,120
打扰一下

2577
03:18:11,120 --> 03:18:14,639
所以现在你可以看到你得到了这个必需的构建上下文

2578
03:18:14,639 --> 03:18:17,280
尝试更改其名称，我将从面部工作室代码获得帮助

2579
03:18:17,280 --> 03:18:21,912
进口让我们说材料好吧

2580
03:18:21,912 --> 03:18:25,440
现在我们只有一个错误说你在这里没有返回任何东西

2581
03:18:25,440 --> 03:18:28,231
所以我们要做的第一件事是我们实际上要定义我们的

2582
03:18:28,231 --> 03:18:32,000
对话框这个加载对话框的外观如何所以它是唯一的东西

2583
03:18:32,000 --> 03:18:36,871
要做的就是有一点加载指示器一点间距和

2584
03:18:36,871 --> 03:18:41,360
将使用文本小部件呈现的文本

2585
03:18:41,360 --> 03:18:44,639
字符串，所以让我们首先定义我们的对话，所以我只想说 final

2586
03:18:44,639 --> 03:18:48,959
对话等于像这样的警报对话

2587
03:18:48,959 --> 03:18:52,551
让我们转到下一行分号

2588
03:18:52,551 --> 03:18:55,912
好的，然后我们必须定义内容

2589
03:18:55,912 --> 03:18:59,280
如您所见，内容应该是一个小部件，因此我们正在开发的小部件

2590
03:18:59,280 --> 03:19:02,871
是一列，因为我们想要像加载的小部件的垂直列表

2591
03:19:02,871 --> 03:19:06,719
屏幕显示一点尺寸框间距和文本小部件，以便您可以

2592
03:19:06,719 --> 03:19:11,512
用列轻松呈现它并记住列是什么列

2593
03:19:11,512 --> 03:19:16,399
通常想要做的是尽可能多地抓住它需要的空间，这样它就可以像

2594
03:19:16,399 --> 03:19:20,479
整个屏幕很长，我们不希望列显示我们想要的内容

2595
03:19:20,479 --> 03:19:24,871
正确渲染其内容所需的尽可能少的空间，所以我们将

2596
03:19:24,871 --> 03:19:29,680
说主要访问大小哎呀练习它应该是主要类型

2597
03:19:29,680 --> 03:19:35,440
访问大小，我们将说最小的主要练习

2598
03:19:35,440 --> 03:19:41,440
它的孩子将是一个包含两个常量的数组

2599
03:19:41,440 --> 03:19:45,360
圆形进度指示器的小部件，例如

2600
03:19:45,360 --> 03:19:48,231
然后我们会说一个常数

2601
03:19:48,231 --> 03:19:52,719
尺寸盒我们没有使用尺寸盒

2602
03:19:52,719 --> 03:19:59,680
以前，但是尺寸框对嗯创造间距真的很好，所以

2603
03:19:59,680 --> 03:20:03,912
正如你在这里看到的，它只是一个高度为 10 的空白空间。

2604
03:20:03,912 --> 03:20:07,191
然后我们在这里要做的就是说 display also a

2605
03:20:07,191 --> 03:20:11,120
呈现此特定文本参数的文本

2606
03:20:11,120 --> 03:20:14,959
就在这里

2607
03:20:14,959 --> 03:20:19,280
现在我们在这里遇到了一个关于如何渲染这个东西的小问题，你

2608
03:20:19,280 --> 03:20:23,360
可以看到它们在同一行，这就是为什么它看起来很奇怪

2609
03:20:23,360 --> 03:20:27,832
让我们在这里输入一个逗号，然后保存文件以获取

2610
03:20:27,832 --> 03:20:31,680
格式正确，让我们在这里也放一个逗号

2611
03:20:31,680 --> 03:20:35,360
就这样好吧，所以现在它可以正常工作了，或者

2612
03:20:35,360 --> 03:20:40,399
至少它的格式应该如此，那么我们将在这里做什么

2613
03:20:40,399 --> 03:20:43,512
我们只想说我们想显示那个对话，所以

2614
03:20:43,512 --> 03:20:46,551
比方说显示哎呀

2615
03:20:46,551 --> 03:20:50,639
显示一个显示对话框

2616
03:20:50,639 --> 03:20:54,959
让我们进入这个对话的上下文，我将把它带来

2617
03:20:54,959 --> 03:20:59,120
在这里，您可以看到它的上下文是我们为此提供的上下文

2618
03:20:59,120 --> 03:21:03,120
功能和障碍或可解雇，我是

2619
03:21:03,120 --> 03:21:06,399
将向您展示非常可忽略的文档，让我们看看我们是否可以

2620
03:21:06,399 --> 03:21:09,440
居然发现哦

2621
03:21:09,440 --> 03:21:12,399
这对我没有帮助，但没关系，嗯

2622
03:21:12,399 --> 03:21:17,191
Barrier Dismissable 允许你做的是说如果用户点击

2623
03:21:17,191 --> 03:21:22,079
在此对话之外，要么允许解除此对话，要么不允许，并且

2624
03:21:22,079 --> 03:21:27,040
我们不希望用户能够在此对话框之外点击以关闭

2625
03:21:27,040 --> 03:21:29,512
这是因为当我们想要它时应该关闭加载屏幕

2626
03:21:29,512 --> 03:21:33,191
当用户希望它被解雇时不被解雇，并且

2627
03:21:33,191 --> 03:21:36,719
对于那些正在观看本课程的用户体验设计师来说，他实际上可能是

2628
03:21:36,719 --> 03:21:42,231
也想例如提供一个取消我实际上认为

2629
03:21:42,231 --> 03:21:46,231
在大多数加载屏幕上都有一个取消按钮是个好主意

2630
03:21:46,231 --> 03:21:50,079
因为有时无论出于何种原因，应用程序可能

2631
03:21:50,079 --> 03:21:52,799
无法处理例如不同的错误和异常

2632
03:21:52,799 --> 03:21:57,120
在进行 api 调用时可能会发生，我个人一直处于这种情况

2633
03:21:57,120 --> 03:22:00,959
向用户显示对话并且从未被解雇的地方

2634
03:22:00,959 --> 03:22:04,231
因为出了点问题，应用程序无法处理它所以

2635
03:22:04,231 --> 03:22:07,832
我个人作为用户不得不去强制终止应用程序并重新启动

2636
03:22:07,832 --> 03:22:11,760
整个过程是为了让事情顺利进行，所以如果你想拥有一个

2637
03:22:11,760 --> 03:22:15,280
取消按钮在这里很好但是我现在不这样做只是

2638
03:22:15,280 --> 03:22:19,440
为了简单起见，以便我们可以尽快继续使用此代码

2639
03:22:19,440 --> 03:22:22,719
尽可能快速准确

2640
03:22:22,719 --> 03:22:25,680
所以现在你知道障碍可忽略的错误是什么

2641
03:22:25,680 --> 03:22:30,000
对于生成器函数，这就是这个 um 错误，我们只需要

2642
03:22:30,000 --> 03:22:36,231
说好吧，我们得到一个上下文，但在这里我们所做的只是做我们

2643
03:22:36,231 --> 03:22:40,231
删除我们，我们在这里返回对话，好吧，所以现在我们说显示这个

2644
03:22:40,231 --> 03:22:45,120
对话然后我们就说

2645
03:22:45,120 --> 03:22:48,159
返回值看到我们仍然有这个问题，我们的返回值

2646
03:22:48,159 --> 03:22:51,280
不返回封闭式对话以及这种封闭式对话将是什么

2647
03:22:51,280 --> 03:22:55,600
我们是否要从我们的函数中返回一个函数，所以当用户然后

2648
03:22:55,600 --> 03:23:01,040
调用那个函数，我们要弹出这个对话框，很漂亮

2649
03:23:01,040 --> 03:23:04,231
所以假设我们返回一个函数一个错误函数

2650
03:23:04,231 --> 03:23:09,832
在调用时，我们将说这个上下文的导航器，我们只是

2651
03:23:09,832 --> 03:23:15,280
会说 pop 好的，这就是你返回一个可以被操作的函数的方式

2652
03:23:15,280 --> 03:23:19,832
并被其他人调用，所以现在我们保存这个，你可以看到我们

2653
03:23:19,832 --> 03:23:23,360
没有任何错误，我将只是

2654
03:23:23,360 --> 03:23:27,680
稍微调整一下大小，让字体变小一点，这样你就可以看到代码了

2655
03:23:27,680 --> 03:23:31,440
整体上

2656
03:23:31,440 --> 03:23:35,120
所以现在让我们谈谈加载和

2657
03:23:35,120 --> 03:23:38,551
登录过程中的异常处理所以

2658
03:23:38,551 --> 03:23:44,159
让我们转到我们的登录视图，您在这里看到我们已经有一些

2659
03:23:44,159 --> 03:23:47,832
异常处理，我们也有这个关闭块，但我们也有这个文本

2660
03:23:47,832 --> 03:23:52,399
像手动导航一样的按钮，它说按下名称并删除

2661
03:23:52,399 --> 03:23:58,399
直到我们需要把这些东西清理干净

2662
03:23:58,399 --> 03:24:04,399
所以让我们进入我们的登录视图等等

2663
03:24:04,399 --> 03:24:08,231
我也会在我的笔记中做

2664
03:24:08,231 --> 03:24:11,120
让我们看看我们是怎么做的

2665
03:24:11,120 --> 03:24:14,639
你可以在这里看到的东西 我们现在有一个块监听器

2666
03:24:14,639 --> 03:24:19,120
环绕这个文本按钮，所以我们

2667
03:24:19,120 --> 03:24:23,360
不会那样做，我们将拥有完全一样的文本按钮，所以

2668
03:24:23,360 --> 03:24:26,871
意思是我们要从这里移除这个块监听器

2669
03:24:26,871 --> 03:24:31,360
所以我们可以做的是，正如标题所示，我们只是要去这里

2670
03:24:31,360 --> 03:24:36,000
脚手架，然后说好吧，我们有一个新的块监听器并记住这一点

2671
03:24:36,000 --> 03:24:40,399
应该是禁区本身，所以我要说禁区，这应该是

2672
03:24:40,399 --> 03:24:45,912
像这样的关闭状态，那么在监听器内部我们需要做的是

2673
03:24:45,912 --> 03:24:49,680
带来我们已经拥有的东西

2674
03:24:49,680 --> 03:24:52,319
嗯里面

2675
03:24:52,319 --> 03:24:56,159
我们的文本按钮在这里，所以我们有

2676
03:24:56,159 --> 03:25:01,191
异常处理好的对不起，如标题所示

2677
03:25:01,191 --> 03:25:04,551
我们现在要在我们的新块中进行这个异常处理

2678
03:25:04,551 --> 03:25:08,871
顶部的侦听器，因此从块侦听器中删除所有代码以获取文本

2679
03:25:08,871 --> 03:25:12,000
按钮所有的异常处理只是剪掉它

2680
03:25:12,000 --> 03:25:16,799
并请把它带到这个位于顶层的块监听器中

2681
03:25:16,799 --> 03:25:21,280
正确并使其成为异步侦听器，以便您可以等待您的节目或

2682
03:25:21,280 --> 03:25:25,440
对话好的，这是第一步，但是我们仍然有这个空块

2683
03:25:25,440 --> 03:25:30,231
听众在这里，所以我现在要删除它所以突然间你现在看到了

2684
03:25:30,231 --> 03:25:36,079
我们这里有文本按钮，这太棒了

2685
03:25:36,079 --> 03:25:41,760
那么我们需要做的是开始处理我们的

2686
03:25:41,760 --> 03:25:46,231
加载屏幕基本上就是这样

2687
03:25:46,231 --> 03:25:52,079
一些代码，所以不要害怕我们很快就会处理

2688
03:25:52,079 --> 03:25:57,040
所以为了能够显示我们的加载屏幕，我们还有

2689
03:25:57,040 --> 03:26:01,280
有点像别这样，嗯

2690
03:26:01,280 --> 03:26:06,319
关闭句柄我的意思是什么让我们回到我们的加载对话框你

2691
03:26:06,319 --> 03:26:09,832
看到每次我们调用这个函数时，这会给我们一个函数

2692
03:26:09,832 --> 03:26:14,231
这样我们就可以关闭我们必须保留的对话框

2693
03:26:14,231 --> 03:26:18,551
这样当登录视图中的状态发生变化时，我们将查看

2694
03:26:18,551 --> 03:26:22,399
之前的句柄，就像哦，我们有一个加载屏幕

2695
03:26:22,399 --> 03:26:27,191
显示给用户，我们必须先将其关闭，所以让我们去我们所在的地方

2696
03:26:27,191 --> 03:26:31,832
在这里保留我们的电子邮件和密码，并保留一个

2697
03:26:31,832 --> 03:26:36,871
关闭对话，它会自动导入你看到的，所以如果你没有

2698
03:26:36,871 --> 03:26:41,832
自动导入您可能必须自己导入此文件

2699
03:26:41,832 --> 03:26:44,719
所以假设它是一个可选的，我们称之为关闭

2700
03:26:44,719 --> 03:26:47,680
对话句柄好

2701
03:26:47,680 --> 03:26:51,120
所以我们保留了我们还没有分配给它的东西，但我们会做

2702
03:26:51,120 --> 03:26:54,079
很快

2703
03:26:54,079 --> 03:26:59,912
所以让我们以注销的状态站在这里，在这里只需添加一些

2704
03:26:59,912 --> 03:27:03,040
空间和我们要做什么 我们要说

2705
03:27:03,040 --> 03:27:07,832
嗯，我们是否已经有一个关闭的对话框句柄，所以让我们说关闭

2706
03:27:07,832 --> 03:27:10,231
和对话框是

2707
03:27:10,231 --> 03:27:13,512
关闭对话框hana

2708
03:27:13,512 --> 03:27:17,360
我们现在要做的是看看我们的州和

2709
03:27:17,360 --> 03:27:22,871
如果我们有一个关闭的对话框句柄并且我们将显示正确

2710
03:27:22,871 --> 03:27:26,319
行为基本上所以我们要做的是我们要去

2711
03:27:26,319 --> 03:27:31,600
说如果我们没有加载状态是否正在加载

2712
03:27:31,600 --> 03:27:35,440
那一刻意味着也许我们之前正在加载

2713
03:27:35,440 --> 03:27:40,079
那么我们在这里的目标是说如果我们没有加载和

2714
03:27:40,079 --> 03:27:45,191
对不起，亲密的对话不是空的，对不起

2715
03:27:45,191 --> 03:27:47,760
所以

2716
03:27:47,760 --> 03:27:51,912
在这种情况下，这传达给我们的意思是说我们没有加载

2717
03:27:51,912 --> 03:27:56,719
现在，但我们之前正在加载，并且机器人部分来自

2718
03:27:56,719 --> 03:28:00,871
在这里，我们需要在这里做的就是关闭该对话框，所以让我们

2719
03:28:00,871 --> 03:28:05,760
说关闭对话框我们调用你看到的那个函数然后我们说

2720
03:28:05,760 --> 03:28:09,832
关闭对话句柄为空

2721
03:28:09,832 --> 03:28:15,760
所以我们现在只是清理它，好吧，然后我们现在看到

2722
03:28:15,760 --> 03:28:17,680
如果我们必须拥有我们所拥有的

2723
03:28:17,680 --> 03:28:20,719
现在处理的是关闭拨号但我们也有展示它的地狱

2724
03:28:20,719 --> 03:28:24,079
所以我们现在要说状态是否正在加载

2725
03:28:24,079 --> 03:28:29,440
而且我们没有关闭拨号抱歉，我们还没有加载对话框

2726
03:28:29,440 --> 03:28:34,079
屏幕然后我们必须显示它所以对不起所以让我们说如果状态是

2727
03:28:34,079 --> 03:28:36,159
加载和

2728
03:28:36,159 --> 03:28:40,159
关闭对话框为空

2729
03:28:40,159 --> 03:28:44,871
然后我们必须显示对话所以让我们说关闭对话句柄是

2730
03:28:44,871 --> 03:28:49,360
等于显示加载对话框我们传递上下文

2731
03:28:49,360 --> 03:28:53,040
让我们在这里做一些格式化，让我们说加载

2732
03:28:53,040 --> 03:28:57,680
就这样好吧，我们把剩下的东西留在

2733
03:28:57,680 --> 03:29:02,079
代码完全一样

2734
03:29:02,079 --> 03:29:04,871
我们现在需要做的下一件事是

2735
03:29:04,871 --> 03:29:08,479
正如您在屏幕上的标题中看到的那样，我们必须挂钩寄存器

2736
03:29:08,479 --> 03:29:12,799
当注册按钮被点击时，按钮到我们的身份验证块发送身份验证事件应该

2737
03:29:12,799 --> 03:29:18,639
注册到块，然后我们要做的是去

2738
03:29:18,639 --> 03:29:22,959
并通过抱歉登录在加载底部的此处找到此按钮

2739
03:29:22,959 --> 03:29:26,551
view.dart 文件，按下它让我们

2740
03:29:26,551 --> 03:29:30,231
这个，是的，我不认为它真的必须是

2741
03:29:30,231 --> 03:29:35,360
任何异步代码，所以让我们在这里假设我们

2742
03:29:35,360 --> 03:29:40,399
抓住我们的障碍，让我们说上下文读取

2743
03:29:40,399 --> 03:29:44,399
我们正在寻找在我们的上下文中的博客，然后我们将发送它

2744
03:29:44,399 --> 03:29:48,231
事件，我们将发送 const auth 事件

2745
03:29:48,231 --> 03:29:52,959
应该就这样注册好吗

2746
03:29:52,959 --> 03:29:57,912
所以我相信添加事件不是异步的，或者任何它只是一个空的，所以这个

2747
03:29:57,912 --> 03:30:01,760
函数不必是异步的，所以如果你把它作为异步的，你可以安全地

2748
03:30:01,760 --> 03:30:07,600
删除我也将保存此文件

2749
03:30:07,600 --> 03:30:11,760
好吧，我们已经做了很多工作，我们现在差不多了

2750
03:30:11,760 --> 03:30:17,280
几乎完成了我们的登录视图所以我要做的是我要关闭

2751
03:30:17,280 --> 03:30:21,040
所有这些文件现在都在屏幕上，我们要开始行动了

2752
03:30:21,040 --> 03:30:26,399
也阻止我们的注册视图，所以

2753
03:30:26,399 --> 03:30:31,600
让我们按照标题说的去注册视图

2754
03:30:31,600 --> 03:30:34,319
看看这里

2755
03:30:34,319 --> 03:30:38,479
目前我们没有，我可以在以前的这里看到

2756
03:30:38,479 --> 03:30:41,360
我们一直在清理登录视图的章节

2757
03:30:41,360 --> 03:30:44,639
阻止登录，但我们在注册视图中没有做同样的事情，并且

2758
03:30:44,639 --> 03:30:48,639
没关系，我们会处理的，我可以通过查看

2759
03:30:48,639 --> 03:30:52,799
在我们在这里的 try and catch 语句中，您会看到这些事情不应该是

2760
03:30:52,799 --> 03:30:56,479
在文本按钮中，一次只做一件事

2761
03:30:56,479 --> 03:30:59,512
当我捕获底部屏幕时，是的标题表明我们要

2762
03:30:59,512 --> 03:31:03,512
将脚手架包裹在一个块监听器中，这样它会非常

2763
03:31:03,512 --> 03:31:08,231
类似于我们为登录视图所做的事情

2764
03:31:08,231 --> 03:31:12,871
命令点并在此处使用块侦听器进行换行，我在

2765
03:31:12,871 --> 03:31:16,832
只是想说这将是关闭

2766
03:31:16,832 --> 03:31:20,479
块，它会自动为我导入它，如果你是

2767
03:31:20,479 --> 03:31:23,512
在此上下文中找不到身份验证块的错误

2768
03:31:23,512 --> 03:31:27,120
可能是因为你还没有导入块所以在这里我们要

2769
03:31:27,120 --> 03:31:30,551
说关闭状态，这也将其导入为

2770
03:31:30,551 --> 03:31:34,079
好吧，块监听器在这种情况下也不可用，因为我们没有

2771
03:31:34,079 --> 03:31:37,912
有一个颤振块，所以这也太重要了

2772
03:31:37,912 --> 03:31:42,479
三个所以这就是三个 um 汽车进口和

2773
03:31:42,479 --> 03:31:46,719
我相信它们都可用

2774
03:31:46,719 --> 03:31:51,760
auth block auth state 和flutter block so

2775
03:31:51,760 --> 03:31:55,360
如果你愿意的话，你实际上可以把它放在一起，这样你就知道哪个

2776
03:31:55,360 --> 03:31:59,680
要导入的是这三个

2777
03:31:59,680 --> 03:32:04,479
哇好吧嗯所以我们需要做的那是我们必须做的第一件事

2778
03:32:04,479 --> 03:32:07,600
这么处理

2779
03:32:07,600 --> 03:32:11,120
我们也正如我所说的，现在我们必须去开始处理

2780
03:32:11,120 --> 03:32:15,280
例外，所以这与我们的做法非常相似

2781
03:32:15,280 --> 03:32:19,912
在登录视图中做到了，所以我们需要摆脱这些

2782
03:32:19,912 --> 03:32:24,000
所以现在我们需要在我们的块监听器的这个监听器中做些什么

2783
03:32:24,000 --> 03:32:28,231
处理我们目前在底部处理的异常

2784
03:32:28,231 --> 03:32:32,079
所以这应该与我们在登录时的处理方式非常相似

2785
03:32:32,079 --> 03:32:36,639
如果您还记得的话，请查看

2786
03:32:36,639 --> 03:32:40,319
有这个 uh 块监听器，然后我们正在这样做

2787
03:32:40,319 --> 03:32:43,912
那里有一种模式，所以我们要做一些非常相似的事情

2788
03:32:43,912 --> 03:32:46,719
除了我们要在注册视图中这样做

2789
03:32:46,719 --> 03:32:51,440
在寄存器视图中，状态是我的意思是所有异常

2790
03:32:51,440 --> 03:32:57,360
可能出现的问题将在 um 注册状态内，所以

2791
03:32:57,360 --> 03:33:01,440
我们首先要确保我们处于那种状态，所以让我们说

2792
03:33:01,440 --> 03:33:06,231
状态是关闭状态注册

2793
03:33:06,231 --> 03:33:12,479
我们会说如果状态异常是弱密码身份验证异常

2794
03:33:12,479 --> 03:33:15,511
然后让我们让这个监听器异步，所以

2795
03:33:15,511 --> 03:33:20,639
我们可以在我们的节目对话框上做一个等待，所以我们说等待

2796
03:33:20,639 --> 03:33:25,279
并显示错误对话框，文本会很弱

2797
03:33:25,279 --> 03:33:30,159
密码好的，然后我们将做另一个

2798
03:33:30,159 --> 03:33:35,511
一个带有另一个 if 的 else 语句，我们说 if 状态异常

2799
03:33:35,511 --> 03:33:40,720
它的电子邮件已经在使用 auth 异常，然后我们将在这里显示

2800
03:33:40,720 --> 03:33:46,551
另一个对话框然后说例如电子邮件已在使用中

2801
03:33:46,551 --> 03:33:50,400
嗯，那么让我们去另一个

2802
03:33:50,400 --> 03:33:54,080
声明所以我要复制这个我有点懒，我只是去

2803
03:33:54,080 --> 03:33:58,159
说通用身份验证异常，然后我们要说

2804
03:33:58,159 --> 03:34:02,479
未能注册，因此这些是可能发生的各种异常

2805
03:34:02,479 --> 03:34:10,080
当您注册用户时，您可以在这里看到我们有三个

2806
03:34:10,080 --> 03:34:13,360
呃例外我们正在处理已经在使用的弱密码电子邮件然后

2807
03:34:13,360 --> 03:34:17,599
我们也有无效的电子邮件身份验证例外，所以也许我们实际上可以

2808
03:34:17,599 --> 03:34:21,040
处理它，所以让我们继续并添加另一个 else 语句

2809
03:34:21,040 --> 03:34:26,000
在这里，只是说无效呃无效的电子邮件身份验证异常，所以我们

2810
03:34:26,000 --> 03:34:30,000
只是说无效的电子邮件好吗

2811
03:34:30,000 --> 03:34:35,360
所以现在我们已经处理好了这四个异常

2812
03:34:35,360 --> 03:34:40,400
所以我们现在需要的是确保像你一样

2813
03:34:40,400 --> 03:34:43,439
可以在标题中看到注册视图中的注册按钮发送

2814
03:34:43,439 --> 03:34:47,759
auth 事件称为 auth event register 所以让我们找到那个注册按钮

2815
03:34:47,759 --> 03:34:51,360
我们在这里谈论的是你可以看到的这个文本按钮

2816
03:34:51,360 --> 03:34:54,871
它说注册好

2817
03:34:54,871 --> 03:34:58,799
所以我们现在需要做的也许是清理这段代码

2818
03:34:58,799 --> 03:35:03,191
这里有这么多信息，我们真的不必这样做

2819
03:35:03,191 --> 03:35:07,191
请在注册视图中注册按钮，几乎只需核对这个

2820
03:35:07,191 --> 03:35:12,159
整个尝试和所有这些 cad 声明的方式

2821
03:35:12,159 --> 03:35:17,040
所以现在我们有了一张白纸所以现在我们只有电子邮件和密码，让我们

2822
03:35:17,040 --> 03:35:21,360
在此处获取身份验证块并要求身份验证块进行注册好吗

2823
03:35:21,360 --> 03:35:25,360
所以我只想说上下文

2824
03:35:25,360 --> 03:35:30,551
让我们说我们在这里抓住了离块

2825
03:35:30,551 --> 03:35:34,639
好的作为一个功能

2826
03:35:34,639 --> 03:35:40,000
上下文如果我能拼写然后我只想说添加

2827
03:35:40,000 --> 03:35:44,231
注册的认证事件

2828
03:35:44,231 --> 03:35:48,871
这里有电子邮件和密码，就像这样

2829
03:35:48,871 --> 03:35:51,912
好的，所以你的代码应该看起来像

2830
03:35:51,912 --> 03:35:55,831
这个并在这里放一个逗号，让它更干净一点，就像那样

2831
03:35:55,831 --> 03:35:59,511
好的

2832
03:35:59,511 --> 03:36:05,119
好的，那是为了注册，现在我们还有一个

2833
03:36:05,119 --> 03:36:09,599
登录按钮在这里，现在在我们的注册视图中你还记得吗

2834
03:36:09,599 --> 03:36:13,279
如果您最终进入注册表视图并且不正确，那么您只需点击一些

2835
03:36:13,279 --> 03:36:16,080
按钮并在注册表中输入它们，就像哦，我在错误的地方我

2836
03:36:16,080 --> 03:36:20,231
想要实际登录，所以我们在这里有这个已经注册的登录

2837
03:36:20,231 --> 03:36:24,231
按钮，此时正在执行自定义导航器或推送名称并删除

2838
03:36:24,231 --> 03:36:28,799
直到它不应该那样做，所以让我们继续修复它，让我们

2839
03:36:28,799 --> 03:36:33,831
进入这里并删除该代码，然后说上下文读取身份验证块

2840
03:36:33,831 --> 03:36:39,191
我们将基本上在这里添加一个 const auth 类型的 con 事件

2841
03:36:39,191 --> 03:36:44,231
事件注销就像那样好吧，然后

2842
03:36:44,231 --> 03:36:50,959
将把用户发送到登录屏幕

2843
03:36:50,959 --> 03:36:54,720
好吧，让我们现在转到下一点，你可以看到它说发送

2844
03:36:54,720 --> 03:36:57,680
验证按钮和验证电子邮件视图飞镖

2845
03:36:57,680 --> 03:37:01,599
它应该发送一个 auth 事件，当你按下它时它应该发送 auth

2846
03:37:01,599 --> 03:37:06,871
事件将电子邮件验证发送到博客，所以我将进入我的笔记

2847
03:37:06,871 --> 03:37:11,680
以及，只需找到那个按钮，现在让我们

2848
03:37:11,680 --> 03:37:16,479
在这里输入我们的代码让我们去验证电子邮件视图

2849
03:37:16,479 --> 03:37:20,871
看看我们正在谈论的那个按钮就在这里

2850
03:37:20,871 --> 03:37:23,759
现在你可以看到它正在做所有的服务火力基地和电子邮件

2851
03:37:23,759 --> 03:37:26,159
验证，但我们不应该这样做

2852
03:37:26,159 --> 03:37:30,080
嗯，我们应该要求我们的街区这样做，所以让我们继续吧

2853
03:37:30,080 --> 03:37:33,119
首先删除里面的代码

2854
03:37:33,119 --> 03:37:37,279
未按下按钮，然后此按钮不必再异步

2855
03:37:37,279 --> 03:37:41,912
我们要说的只是说上下文并阅读

2856
03:37:41,912 --> 03:37:45,279
但我们没有读过，记得因为我们没有我们没有

2857
03:37:45,279 --> 03:37:49,599
导入的身份验证我们没有导入块或颤动

2858
03:37:49,599 --> 03:37:52,959
阻止进入这个文件，但我们很快就会解决这个问题，所以首先

2859
03:37:52,959 --> 03:37:57,680
说阅读关闭块，这也会为我们导入关闭块，所以

2860
03:37:57,680 --> 03:38:02,000
这是第一部分，现在你有这个错误让我们获取 Visual Studio 代码

2861
03:38:02,000 --> 03:38:05,831
导入相同的提供程序，但我实际上想要

2862
03:38:05,831 --> 03:38:10,231
颤振块，所以让我们继续自己导入

2863
03:38:10,231 --> 03:38:15,759
所以让我们说包装颤振块和颤振块飞镖

2864
03:38:15,759 --> 03:38:20,400
现在一切都好，所以让我们在这里，然后添加一个我们说 const off 的事件

2865
03:38:20,400 --> 03:38:25,680
事件发送电子邮件验证就像那样

2866
03:38:25,680 --> 03:38:31,279
好的，现在完成了

2867
03:38:31,279 --> 03:38:36,551
所以接下来我们要做的就是你可以在这个重启按钮里面看到

2868
03:38:36,551 --> 03:38:40,080
屏幕底部目前正在做很多工作

2869
03:38:40,080 --> 03:38:44,551
它基本上是首先从我们的身份验证服务中注销，然后它正在执行

2870
03:38:44,551 --> 03:38:48,319
导航，所以这个按钮就像它处理的所有地方一样

2871
03:38:48,319 --> 03:38:53,759
身份验证它正在处理我的意思是我实际上非常我在这里笑

2872
03:38:53,759 --> 03:38:56,959
因为我有点嘲笑我们迄今为止取得的进展

2873
03:38:56,959 --> 03:39:00,231
我们已经从非常原始的编程转变为

2874
03:39:00,231 --> 03:39:05,439
现在非常优雅地处理异常外星人处理

2875
03:39:05,439 --> 03:39:10,159
路由等，所以在这里对你说实话真的很有趣

2876
03:39:10,159 --> 03:39:14,400
所以在这里让我们删除该代码并抓住我们拥有的东西

2877
03:39:14,400 --> 03:39:17,759
在我们的发送电子邮件验证按钮中并将其带到此处而不是

2878
03:39:17,759 --> 03:39:21,912
发送关闭事件 发送电子邮件验证 我们将发送 alt 事件

2879
03:39:21,912 --> 03:39:25,360
像这样退出

2880
03:39:25,360 --> 03:39:30,400
对不起，那部分已经完成了

2881
03:39:30,400 --> 03:39:34,080
所以我们现在需要什么让我们现在进去

2882
03:39:34,080 --> 03:39:38,871
关闭这个文件并转到我们的关闭块，所以我们现在有很多工作要做

2883
03:39:38,871 --> 03:39:42,551
在我们的街区，你可以看到它到处都是，所以

2884
03:39:42,551 --> 03:39:45,759
我也想在我的笔记中做同样的事情，所以远离障碍

2885
03:39:45,759 --> 03:39:49,119
我们需要做的第一件事是确保我们没有使用它

2886
03:39:49,119 --> 03:39:53,360
状态加载，因为我们不再拥有它我们拥有的是关闭状态

2887
03:39:53,360 --> 03:39:59,912
每盏灯，所以请把它当作名字

2888
03:39:59,912 --> 03:40:04,720
所以我们现在也有一个身份验证事件发送

2889
03:40:04,720 --> 03:40:09,759
电子邮件验证，我们还没有处理，所以让我们继续

2890
03:40:09,759 --> 03:40:14,080
这个初始化我只是要发送说发送电子邮件验证好的，让我们

2891
03:40:14,080 --> 03:40:18,639
创建一个新的来处理身份验证事件和电子邮件验证，因为我们

2892
03:40:18,639 --> 03:40:23,040
还没有处理，所以我们在这里有事件动画

2893
03:40:23,040 --> 03:40:27,680
让我们说这是一个异步函数，然后打开它，然后

2894
03:40:27,680 --> 03:40:32,080
最后的分号以获得格式呃格式化工作

2895
03:40:32,080 --> 03:40:35,759
我们在 auth 事件中唯一要做的就是发送电子邮件验证到

2896
03:40:35,759 --> 03:40:40,479
实际上打电话告诉提供商嘿，我们基本上会发送一个

2897
03:40:40,479 --> 03:40:45,680
电子邮件验证没问题，所以我们就说一个等待提供商

2898
03:40:45,680 --> 03:40:48,639
和电子邮件验证，然后我们要做什么，我们要发出

2899
03:40:48,639 --> 03:40:55,040
完全相同的状态，因此通过发送此事件进入

2900
03:40:55,040 --> 03:40:58,720
我们只是要做一些工作并发出与你完全相同的状态

2901
03:40:58,720 --> 03:41:02,959
所以我们实际上并没有改变应用程序的状态，因为记住什么时候

2902
03:41:02,959 --> 03:41:07,680
您在验证电子邮件视图中，然后按下按钮实际发送

2903
03:41:07,680 --> 03:41:12,231
新的验证电子邮件 屏幕上发生的事情 我们不喜欢做的事

2904
03:41:12,231 --> 03:41:15,759
任何事情，只是我们正在发送电子邮件验证，所以我们

2905
03:41:15,759 --> 03:41:19,191
不会将您发送到新屏幕或类似的东西，这就是我们为什么

2906
03:41:19,191 --> 03:41:24,720
发出与我们之前完全相同的状态

2907
03:41:24,720 --> 03:41:29,759
好吧，现在我们必须实际处理一个

2908
03:41:29,759 --> 03:41:35,040
我们的身份验证事件寄存器，所以让我们继续这样做吧

2909
03:41:35,040 --> 03:41:40,871
全新的所以让我们说一下事件注册

2910
03:41:40,871 --> 03:41:45,439
我们说我们有事件、电子邮件和一个异步函数

2911
03:41:45,439 --> 03:41:50,159
就这样吧

2912
03:41:50,159 --> 03:41:52,871
所以当我们有 auth 事件注册时

2913
03:41:52,871 --> 03:41:57,831
你记得之前这个真实的包括电子邮件和密码本身

2914
03:41:57,831 --> 03:42:01,191
对不起，我们可以抓住那些和那个

2915
03:42:01,191 --> 03:42:06,080
现在的信息只是说电子邮件是高级的。电子邮件，让我们说最终

2916
03:42:06,080 --> 03:42:11,599
密码是 events.password 哎呀

2917
03:42:11,599 --> 03:42:16,319
好的，那么我们将把它放到一个 try and catch 块中，这样我们就可以

2918
03:42:16,319 --> 03:42:21,040
要说尝试异常捕获e

2919
03:42:21,040 --> 03:42:25,040
当异常发生时，我们将发出我们的

2920
03:42:25,040 --> 03:42:31,511
关闭状态注册该 e um

2921
03:42:31,511 --> 03:42:34,551
所以我们之前讨论过这个，但只是为了

2922
03:42:34,551 --> 03:42:39,191
当您在注册过程中刷新时，我们实际上可以发出一个新的

2923
03:42:39,191 --> 03:42:44,080
这里的状态只是称为注册，然后它可以包含一个

2924
03:42:44,080 --> 03:42:47,511
好的例外，所以这就是我们在这里发出的说你在

2925
03:42:47,511 --> 03:42:50,959
注册的过程，但发生了一些不好的事情，这是一个例外

2926
03:42:50,959 --> 03:42:53,360
正确的

2927
03:42:53,360 --> 03:42:58,080
所以在这里，我们只说等待提供者，我们将创建一个新的

2928
03:42:58,080 --> 03:43:03,279
用户的电子邮件和密码正好适合他们，这真的很棒

2929
03:43:03,279 --> 03:43:07,511
然后如果你还记得我们之前的注册过程

2930
03:43:07,511 --> 03:43:11,599
所以在我们注册时的注册视图中

2931
03:43:11,599 --> 03:43:14,871
在这里进行注册时，我们不仅

2932
03:43:14,871 --> 03:43:18,871
向提供商注册用户，但我们也会发送电子邮件验证

2933
03:43:18,871 --> 03:43:22,400
确保用户不必去发送电子邮件验证和

2934
03:43:22,400 --> 03:43:26,720
手动，所以我们将在我们的外块做同样的事情好吧

2935
03:43:26,720 --> 03:43:32,080
所以让我们也等待提供商，我们说只是发送电子邮件验证

2936
03:43:32,080 --> 03:43:37,119
就像那样好吧，然后在你这样做之后

2937
03:43:37,119 --> 03:43:41,279
很好地注册了一个新用户如果您还记得我们的状态是什么

2938
03:43:41,279 --> 03:43:43,912
关闭状态关闭状态

2939
03:43:43,912 --> 03:43:48,720
我们有这个需要验证我们知道当我们注册和使用新用户时

2940
03:43:48,720 --> 03:43:52,871
该用户总是需要验证权，所以让我们进入这里

2941
03:43:52,871 --> 03:43:58,319
并且只是发出那个状态，所以呃身份验证状态需要验证

2942
03:43:58,319 --> 03:44:01,279
像那样，那是一个空状态，所以它没有任何参数等

2943
03:44:01,279 --> 03:44:05,511
好的

2944
03:44:05,511 --> 03:44:10,080
好的，那么我们必须处理我们的身份验证事件

2945
03:44:10,080 --> 03:44:15,360
初始化所以让我们看看这里的代码是什么样子的

2946
03:44:15,360 --> 03:44:20,159
在这里，我们现在需要做的是我们已经注销，但你可以看到我们正在

2947
03:44:20,159 --> 03:44:24,000
不提供这是一个加载参数，我们不提供

2948
03:44:24,000 --> 03:44:28,080
例外所以我实际上只是要单击清理并手动编写

2949
03:44:28,080 --> 03:44:32,159
手动所以在发射中让我们只发射一个常量

2950
03:44:32,159 --> 03:44:35,119
关闭状态

2951
03:44:35,119 --> 03:44:38,231
呃登出

2952
03:44:38,231 --> 03:44:40,720
好吧

2953
03:44:40,720 --> 03:44:43,912
当你从应用程序初始化的时候开始

2954
03:44:43,912 --> 03:44:48,799
实际运行我们只会说默认情况下你已经注销了

2955
03:44:48,799 --> 03:44:52,639
所以如果用户当然是空的，让我们继续这样做

2956
03:44:52,639 --> 03:44:56,400
所以在异常中我们没有任何异常并且我们没有加载

2957
03:44:56,400 --> 03:45:00,000
任何这样的东西，就像默认状态一样，所以它是逗号

2958
03:45:00,000 --> 03:45:05,439
那里有一个逗号，只是为了让格式化工作

2959
03:45:05,439 --> 03:45:09,439
好吧，这似乎很好，但是

2960
03:45:09,439 --> 03:45:13,599
我们也有初始化在这里听起来不错注销

2961
03:45:13,599 --> 03:45:21,511
它已通过电子邮件验证，所以是的，这对我来说看起来不错

2962
03:45:21,511 --> 03:45:26,000
好的，现在让我们看看登录，你可以看到我们必须照顾

2963
03:45:26,000 --> 03:45:30,959
我们的登录名和逻辑一点点，并确保我们正在加载，所以当你

2964
03:45:30,959 --> 03:45:34,799
说我想登录我们会说好吧你想登录这意味着

2965
03:45:34,799 --> 03:45:39,360
您已注销，但您已注销，并且有一个加载屏幕，好吧

2966
03:45:39,360 --> 03:45:44,159
为什么我们创建了我们将要放入您的加载对话框

2967
03:45:44,159 --> 03:45:49,191
所以当用户要求登录时，让我们说好吧，我们将发出我们的

2968
03:45:49,191 --> 03:45:52,400
常量关闭状态

2969
03:45:52,400 --> 03:45:55,759
注销并且没有异常并且

2970
03:45:55,759 --> 03:46:01,599
加载标志实际上是真的，就像那样，就在那里

2971
03:46:01,599 --> 03:46:04,959
还好

2972
03:46:04,959 --> 03:46:09,759
这是加载部分，让我们看看我们是如何做的

2973
03:46:09,759 --> 03:46:15,439
东西在这里所以我们有我们的登录嗯

2974
03:46:15,439 --> 03:46:19,119
正如你在这里看到的那样，我们也是我们已经处理的那部分

2975
03:46:19,119 --> 03:46:23,191
现在我们要做的是禁用禁用加载屏幕，如果

2976
03:46:23,191 --> 03:46:28,400
电子邮件未验证，所以目前我们有此用户

2977
03:46:28,400 --> 03:46:32,799
在这里你可以看到最终用户没问题，然后我们只是说

2978
03:46:32,799 --> 03:46:36,959
现在的状态是突然登录但不完整

2979
03:46:36,959 --> 03:46:39,912
因为我们不检查用户是否

2980
03:46:39,912 --> 03:46:44,000
是否验证了他们的电子邮件地址，所以让我们继续吧

2981
03:46:44,000 --> 03:46:48,080
并说如标题所示，如果电子邮件未验证，则禁用

2982
03:46:48,080 --> 03:46:52,799
在发送需要之前通过发送一个新的注销好的加载屏幕

2983
03:46:52,799 --> 03:46:59,191
验证，所以让我们处理一下，所以我们说如果 um 用户通过电子邮件验证

2984
03:46:59,191 --> 03:47:02,479
不是，我们发出

2985
03:47:02,479 --> 03:47:08,959
像这样注销的身份验证状态常量

2986
03:47:08,959 --> 03:47:14,000
我们说好没有例外，我们没有加载好

2987
03:47:14,000 --> 03:47:20,720
这样就可以通过说它正在加载假来基本上禁用加载屏幕

2988
03:47:20,720 --> 03:47:26,319
请记住，我们发送的是加载 true 现在我们发送的是加载 false

2989
03:47:26,319 --> 03:47:30,000
然后在未验证电子邮件后，我们

2990
03:47:30,000 --> 03:47:34,639
实际上说然后发出一个 const of off

2991
03:47:34,639 --> 03:47:39,360
状态需要验证就好了

2992
03:47:39,360 --> 03:47:43,279
否则，如果用户的电子邮件经过验证，那么我们会说我们是

2993
03:47:43,279 --> 03:47:47,599
首先要禁用让我调出正确的标题所以

2994
03:47:47,599 --> 03:47:51,912
我们必须在这里做完全相同的事情，我们将基本上禁用

2995
03:47:51,912 --> 03:47:55,040
像这样的加载屏幕

2996
03:47:55,040 --> 03:47:59,279
然后我们将发送此登录信息

2997
03:47:59,279 --> 03:48:05,360
这里的状态还可以

2998
03:48:05,360 --> 03:48:10,799
好的，而且在我们的异常处理中，我们还没有使用这个

2999
03:48:10,799 --> 03:48:15,119
我们将使用注销状态，但我们将清理它，以便在内部发出

3000
03:48:15,119 --> 03:48:21,040
我们会说身份验证状态已注销，然后出现异常，我们