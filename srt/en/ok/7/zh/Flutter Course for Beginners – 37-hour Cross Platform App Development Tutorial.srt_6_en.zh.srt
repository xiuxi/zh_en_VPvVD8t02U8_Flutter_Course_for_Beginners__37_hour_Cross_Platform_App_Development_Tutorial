1
17:54:36,320 --> 17:54:39,116
我在这里即兴创作，因为这就像我

2
17:54:39,116 --> 17:54:42,956
打算给你看，但我实际上还没有准备任何笔记，所以让我们就

3
17:54:42,956 --> 17:54:47,200
继续在此处创建一个名为 user 的表，如您所见，我们将

4
17:54:47,200 --> 17:54:50,720
能够有一些嗯

5
17:54:50,720 --> 17:54:55,360
这里的字段 这里所谓的字段几乎就像一列

6
17:54:55,360 --> 17:54:58,160
因此，通过创建一个字段，您正在创建一个

7
17:54:58,160 --> 17:55:03,040
列好吧，关于sqlite的db浏览器的好处是你可以看到

8
17:55:03,040 --> 17:55:06,636
将为您生成的 sql 代码

9
17:55:06,636 --> 17:55:10,796
当我们将 sqlite 集成到我们的

10
17:55:10,796 --> 17:55:14,320
颤振应用程序，但现在我只想让您了解 sqlite 如何

11
17:55:14,320 --> 17:55:17,680
工作它如何创建表格等等

12
17:55:17,680 --> 17:55:22,796
所以现在我们有用户呃空表它没有任何字段

13
17:55:22,796 --> 17:55:27,116
或列我需要你在这里按下这个添加按钮，我们要做什么

14
17:55:27,116 --> 17:55:31,840
我们要做的是创建一个 id

15
17:55:31,840 --> 17:55:34,796
如果您不是开发人员或

16
17:55:34,796 --> 17:55:37,200
你之前的软件工程师朋友可能不会

17
17:55:37,200 --> 17:55:41,276
了解 id 字段及其重要性，或者您是否是来自

18
17:55:41,276 --> 17:55:44,400
之前你可能知道 id 是以前的主键

19
17:55:44,400 --> 17:55:48,480
所以嗯，一个 id 通常只是一个整数

20
17:55:48,480 --> 17:55:54,080
identifier an integer 是一个数字，因此您输入的每一行的数字标识符

21
17:55:54,080 --> 17:55:59,200
稍后插入您的表中，为什么它很重要，因为

22
17:55:59,200 --> 17:56:04,080
通常一个 id 是一个叫做主键的东西，默认情况下是一个主键

23
17:56:04,080 --> 17:56:06,320
伊斯兰国

24
17:56:06,320 --> 17:56:10,956
独特的，这意味着您能够在此创建用户

25
17:56:10,956 --> 17:56:15,116
表现在必须有它的唯一标识符

26
17:56:15,116 --> 17:56:21,116
如果你还记得我们的嗯我们基本上是如何对待用户的

27
17:56:21,116 --> 17:56:24,480
我们的用户界面是我们正在通过他们的电子邮件对待他们，因此您可以

28
17:56:24,480 --> 17:56:28,560
好好想想，电子邮件也是一个独特的东西，所以我们为什么不一起去呢？

29
17:56:28,560 --> 17:56:33,200
电子邮件的唯一性很好，我们可以对电子邮件应用唯一性约束

30
17:56:33,200 --> 17:56:39,200
电子邮件字段和/或电子邮件列，但它是非常成熟的模式

31
17:56:39,200 --> 17:56:42,880
您正在使用的数据库嗯世界

32
17:56:42,880 --> 17:56:48,160
我的意思是你可以创建一个字符串列的数据库

33
17:56:48,160 --> 17:56:54,000
唯一的，例如电子邮件，但主键通常是整数，例如

34
17:56:54,000 --> 17:57:00,720
作为 pk 或 id 所以这只是一个约定，不去也是一个好习惯

35
17:57:00,720 --> 17:57:04,400
具有字符串的唯一性，因为它

36
17:57:04,400 --> 17:57:07,596
需要更多资源来计算字符串的唯一性

37
17:57:07,596 --> 17:57:14,080
比整数需要的多，所以我们将调用这个字段 id

38
17:57:14,080 --> 17:57:17,840
将是整数，这里有一些字段没有被渲染

39
17:57:17,840 --> 17:57:20,480
好吧，我要增加这个的大小，我要做

40
17:57:20,480 --> 17:57:24,160
像这样可以

41
17:57:24,160 --> 17:57:28,240
所以我们要在这里做什么

42
17:57:28,240 --> 17:57:32,080
我们将带你在这里看到我们将要离开的类型

43
17:57:32,080 --> 17:57:38,160
很好的整数 n n 表示不为空，这意味着该字段应始终为

44
17:57:38,160 --> 17:57:42,796
呈现它绝不应该允许价值或价值的价值和空虚

45
17:57:42,796 --> 17:57:46,796
没有要存在的价值 好的 没有要存在的价值

46
17:57:46,796 --> 17:57:50,400
我希望这是有道理的，基本上只是意味着价值不能不是

47
17:57:50,400 --> 17:57:55,520
要么，所以我们将保留它，就像 pk 代表主键和

48
17:57:55,520 --> 17:57:59,040
这就是我哦，实际上我可以将鼠标移到它们上面，这是很棒的主键

49
17:57:59,040 --> 17:58:03,596
所以嗯，这意味着它是使用 which 的关键

50
17:58:03,596 --> 17:58:09,116
是此表中的唯一键，我们应该能够使用它

51
17:58:09,116 --> 17:58:14,720
然后轻松地从这个表中查询不同的用户，那么什么

52
17:58:14,720 --> 17:58:18,160
我们要做的是我们要把这个项目就在这里好吗

53
17:58:18,160 --> 17:58:22,080
我相信人工智能是自动增量，自动增量是一个很棒的功能

54
17:58:22,080 --> 17:58:27,116
sqlite 和许多其他 uh 数据库，让您如其名 uh

55
17:58:27,116 --> 17:58:31,436
建议，正如名称所示，由您

56
17:58:31,436 --> 17:58:36,880
例如，使用特定电子邮件创建用户，然后插入该用户

57
17:58:36,880 --> 17:58:41,276
进入此表中的数据库，您甚至不必分配 id

58
17:58:41,276 --> 17:58:46,560
对于你刚才说的那个用户，这里是用户电子邮件 boof 把它放在数据库中

59
17:58:46,560 --> 17:58:50,880
那么对不起，那么 sqlite 足够聪明

60
17:58:50,880 --> 17:58:55,040
说哦我，但我也需要一个 id 字段，你还没有提供它然后它

61
17:58:55,040 --> 17:58:59,360
看着这个字段，说哦 id 是自动递增的，所以它会创建

62
17:58:59,360 --> 17:59:04,080
该 id 为您增加先前生成的 id 并分配

63
17:59:04,080 --> 17:59:10,240
例如，如果您在此表中没有对象，则为您的对象添加新 ID

64
17:59:10,240 --> 17:59:15,276
然后您添加一个新用户，然后它会自动获取 id 零

65
17:59:15,276 --> 17:59:18,636
然后如果您生成下一个用户并将其放入其中，那么它将获得

66
17:59:18,636 --> 17:59:23,200
id 为 1，这样你就明白了，这正是我们要做的

67
17:59:23,200 --> 17:59:27,436
这个特殊的领域和独特的就像它的名字一样

68
17:59:27,436 --> 17:59:31,116
表示此字段必须是唯一的，但如果您将某些内容指定为主要字段

69
17:59:31,116 --> 17:59:36,480
key 隐含地它是一个独特的领域，好吧，老实说，我们可以

70
17:59:36,480 --> 17:59:39,840
实际上检查 not null 也意味着是的，它应该总是在那里

71
17:59:39,840 --> 17:59:44,480
以防万一，这是用户字段的好

72
17:59:44,480 --> 17:59:48,956
抱歉，这是 id 字段，现在让我们继续创建一个新的

73
17:59:48,956 --> 17:59:53,680
像这样的用户电子邮件和您应该使用的电子邮件的字段

74
17:59:53,680 --> 17:59:58,796
说这是一个文本好的，我们会做什么，我们会说它不应该

75
17:59:58,796 --> 18:00:06,080
为空，而且电子邮件是唯一的，所以现在看看它生成的

76
18:00:06,080 --> 18:00:11,200
它的代码说创建表用户 id 整数不为空电子邮件文本不是现在

77
18:00:11,200 --> 18:00:17,520
唯一的，它使用自动增量设置 id 的主键，所以

78
18:00:17,520 --> 18:00:22,880
这有点像我们在颤振中实际使用的代码

79
18:00:22,880 --> 18:00:27,116
应用程序，以便以编程方式创建此表

80
18:00:27,116 --> 18:00:31,040
稍后，但现在请记住，这有点像

81
18:00:31,040 --> 18:00:37,360
以编程方式创建一个 sqlite 表

82
18:00:37,360 --> 18:00:40,080
好的，那么你可以在这里按确定

83
18:00:40,080 --> 18:00:43,436
现在您可以看到已为您创建了用户表，这是代码

84
18:00:43,436 --> 18:00:48,480
为它或它在那里所说的模式

85
18:00:48,480 --> 18:00:52,560
现在好了，就像我们做用户表一样

86
18:00:52,560 --> 18:00:57,040
我们需要去创建我们的笔记表，因为记得我之前说过

87
18:00:57,040 --> 18:00:59,680
我们将允许用户在登录时创建笔记

88
18:00:59,680 --> 18:01:02,880
应用程序，当他们实际登录到应用程序时，我们

89
18:01:02,880 --> 18:01:07,436
应该已经为他们创建了一个用户 uh 行

90
18:01:07,436 --> 18:01:12,400
在用户表中，然后通过创建每个注释，我们

91
18:01:12,400 --> 18:01:16,480
还要在我们的笔记表中的数据库中创建一个新笔记

92
18:01:16,480 --> 18:01:18,796
就像标题所示的那样创建

93
18:01:18,796 --> 18:01:24,000
然后我们将该注释绑定到数据库中的那个用户，所以

94
18:01:24,000 --> 18:01:27,840
我需要你到这里然后我们需要通过按来创建一个新表

95
18:01:27,840 --> 18:01:31,840
创建表格按钮好吧，这里的案例中的标题让我们

96
18:01:31,840 --> 18:01:36,480
调用这个新的表格注释，然后我们将首先创建一个

97
18:01:36,480 --> 18:01:40,000
名为 id 的新字段，我们已经完成了这个你知道什么

98
18:01:40,000 --> 18:01:44,796
在这里做一个 id 字段作为整数，我们说它不应该在它不应该

99
18:01:44,796 --> 18:01:48,880
为 null 它应该是主键

100
18:01:48,880 --> 18:01:51,596
和

101
18:01:51,596 --> 18:01:55,276
我认为这就是对你说实话所以不是空的

102
18:01:55,276 --> 18:02:00,160
当然，自动增量也是如此，所以这是为了那是为了

103
18:02:00,160 --> 18:02:05,200
现在我们需要什么其他字段

104
18:02:05,200 --> 18:02:10,480
例如，我们可以说你有一个用户 ID，所以你想

105
18:02:10,480 --> 18:02:16,080
将用户绑定到节点，我们将在这里做什么

106
18:02:16,080 --> 18:02:20,880
要绑定这个我们要从字面上说这个哎呀它去哪儿了

107
18:02:20,880 --> 18:02:25,116
哦，这里的接口有点奇怪，所以也没关系

108
18:02:25,116 --> 18:02:31,520
嗯，所以用户 id 整数，我们要说它不为空

109
18:02:31,520 --> 18:02:36,160
而且我们要做的是我们想要做的是这个用户ID

110
18:02:36,160 --> 18:02:42,880
有点像绑定到用户表 id 字段，就是这样

111
18:02:42,880 --> 18:02:47,200
称为外键，所以你有一个主键

112
18:02:47,200 --> 18:02:51,756
这是您的表本身作为自己的字段管理的键，然后您将

113
18:02:51,756 --> 18:02:56,796
有一个外键，因为它的名字表明它是你里面的一个字段

114
18:02:56,796 --> 18:03:01,756
绑定到另一个表的表是其他列所以在这种情况下

115
18:03:01,756 --> 18:03:06,160
我们的用户 id 应该绑定到用户表 id 列，您可以创建它

116
18:03:06,160 --> 18:03:10,080
使用 db 浏览器用于 sqlite 内部约束

117
18:03:10,080 --> 18:03:14,080
在这里让我们看看我们添加了一个约束，我们说我们有一个

118
18:03:14,080 --> 18:03:16,880
外键和在这里

119
18:03:16,880 --> 18:03:20,956
所以让我们说sqlite外键

120
18:03:20,956 --> 18:03:26,240
我们说用户 id 我们说应用

121
18:03:26,240 --> 18:03:30,240
你现在可以看到它说外键或 id 引用它现在不是

122
18:03:30,240 --> 18:03:32,720
引用任何东西

123
18:03:32,720 --> 18:03:38,320
我想知道那个字段是否隐藏在右边的某个地方

124
18:03:38,320 --> 18:03:41,520
手边

125
18:03:41,520 --> 18:03:47,436
以及我们如何创建它让我们看看我之前记得的

126
18:03:47,436 --> 18:03:51,520
从一开始就开始工作有点奇怪，所以

127
18:03:51,520 --> 18:03:56,160
名字哦，也许是它的名字就在那里所以

128
18:03:56,160 --> 18:04:01,436
所以假设用户 id 引用 sqlite 外键让我们看看它是怎么回事

129
18:04:01,436 --> 18:04:04,720
创建外键用户 ID 引用

130
18:04:04,720 --> 18:04:10,000
如果我说 blob，我们应该在这里说 um 吗？

131
18:04:10,000 --> 18:04:13,200
会发生什么外键准备引用

132
18:04:13,200 --> 18:04:17,436
包含等等，所以那不是我真正想要的

133
18:04:17,436 --> 18:04:20,956
想要在那里，所以我要删除我刚刚创建的这个情节，让我们

134
18:04:20,956 --> 18:04:26,796
看看我们能不能改变我们不能改变的续集这里没有其他可用的字段

135
18:04:26,796 --> 18:04:30,720
我们可以玩的也许不是

136
18:04:30,720 --> 18:04:34,796
我想删除它只是为了看看我是否在那里犯了任何错误所以

137
18:04:34,796 --> 18:04:38,320
假设在这里我可以看到我们有一个用户 ID 和

138
18:04:38,320 --> 18:04:43,276
然后有一个外键，我可以在这里看到这也许是正确的

139
18:04:43,276 --> 18:04:46,636
实际的做事方式我记得有一些非常奇怪的东西

140
18:04:46,636 --> 18:04:53,116
现在我记得不幸的是它隐藏在这个外键 um 列下

141
18:04:53,116 --> 18:04:57,360
我相信这是一个有点奇怪的界面没关系我只是还在

142
18:04:57,360 --> 18:05:02,480
非常感谢我们有用于 sqlite 的 db browser 作为免费软件

143
18:05:02,480 --> 18:05:06,720
甚至可能是一个开源软件，我对此不确定，我非常

144
18:05:06,720 --> 18:05:09,520
感谢每一位为此工作的开发人员

145
18:05:09,520 --> 18:05:13,360
我只是希望它是理解的，但我们要做什么

146
18:05:13,360 --> 18:05:17,360
在这里我们想把这个用户 id 绑定到用户的 id 字段

147
18:05:17,360 --> 18:05:21,840
表所以只需在外键下单击此处并双击实际上我可以看到

148
18:05:21,840 --> 18:05:27,360
然后这个神奇的东西出现了所以让我们继续说我们想要

149
18:05:27,360 --> 18:05:32,796
将此绑定到用户表 id 字段和

150
18:05:32,796 --> 18:05:38,000
我相信应该是的，你现在可以看到这里生成的代码说

151
18:05:38,000 --> 18:05:44,320
我们有一个名为 user id 的外键，它引用了用户表 id 字段

152
18:05:44,320 --> 18:05:49,436
好吧完美嗯现在我们还需要做的是

153
18:05:49,436 --> 18:05:54,160
在此处创建另一个字段，这是每个注释的文本

154
18:05:54,160 --> 18:05:58,480
所以我们要为笔记做的将非常简单，我们的笔记是

155
18:05:58,480 --> 18:06:01,916
不包括任何形式的嗯

156
18:06:01,916 --> 18:06:06,000
他们不会包括任何类型的，例如嗯

157
18:06:06,000 --> 18:06:10,956
他们不会包含任何类型的图像

158
18:06:10,956 --> 18:06:15,116
有序列表或无序列表，它们将是简单的文本，好吧，它们

159
18:06:15,116 --> 18:06:19,040
甚至没有标题我们将从文本中得出的注释的标题

160
18:06:19,040 --> 18:06:21,840
笔记，所以很简单

161
18:06:21,840 --> 18:06:26,560
所以对于笔记的文本，我们就说它是文本类型

162
18:06:26,560 --> 18:06:31,116
呃，我相信我相信这就是我们所需要的

163
18:06:31,116 --> 18:06:36,160
现在所以用户 id 文本，是的，这很好，

164
18:06:36,160 --> 18:06:40,796
说实话，如果你愿意，你也可以创建一个其他领域

165
18:06:40,796 --> 18:06:45,360
在这里你可以看到这个呃在这个课程中我想做什么

166
18:06:45,360 --> 18:06:50,636
开始是允许我们创建一个本地数据库，你可以存储所有

167
18:06:50,636 --> 18:06:54,400
用户在其中的注释，但我希望您也能够

168
18:06:54,400 --> 18:06:57,596
以后以后摆脱这个本地数据库并将其替换为

169
18:06:57,596 --> 18:07:02,720
firebase 这就像目标，但是你们中的一些人实际上可能决定保留

170
18:07:02,720 --> 18:07:07,436
此本地数据库将用户的信息存储在此本地数据库中，并且

171
18:07:07,436 --> 18:07:11,116
不是用户的信息用户在这个数据库中的笔记然后你可以

172
18:07:11,116 --> 18:07:15,436
想要决定在

173
18:07:15,436 --> 18:07:20,080
背景并在适当的时候将这些笔记与firebase同步，以便

174
18:07:20,080 --> 18:07:22,956
如果您想这样做，这取决于您，那么您可能想要实际创建一个

175
18:07:22,956 --> 18:07:27,596
这里的小填充被称为与服务器同步或类似的东西

176
18:07:27,596 --> 18:07:32,240
没关系，或者它已与云同步，我已经

177
18:07:32,240 --> 18:07:35,520
在我的笔记中提到了它，所以让我们继续做吧，尽管我们实际上并没有

178
18:07:35,520 --> 18:07:38,796
打算使用这个字段，但我只是想向你证明这个字段是

179
18:07:38,796 --> 18:07:42,160
可以实现

180
18:07:42,160 --> 18:07:47,520
sqlite 然后在这里假设它是一个整数

181
18:07:47,520 --> 18:07:51,436
还有嗯，我们会说默认是

182
18:07:51,436 --> 18:07:57,116
0 表示它基本上没有同步 true 或 false

183
18:07:57,116 --> 18:08:01,680
true 可以翻译成任何非 0 的值，并且 0 可以翻译

184
18:08:01,680 --> 18:08:03,916
到 false 的值，所以把值

185
18:08:03,916 --> 18:08:08,480
这里的零意味着它不与任何云同步

186
18:08:08,480 --> 18:08:12,560
存储所以让我们继续说吧

187
18:08:12,560 --> 18:08:18,480
这是整数，嗯，我们应该说它不是空的，嗯，它不是

188
18:08:18,480 --> 18:08:22,880
必须是独一无二的，所以现在你可以看到这是创造的结果

189
18:08:22,880 --> 18:08:27,596
在我们的表中，这是 id integer not null 并且 id 也是主键

190
18:08:27,596 --> 18:08:31,596
自动递增然后有一个用户 ID，它是整数不为空，但它也是

191
18:08:31,596 --> 18:08:35,040
id 列下用户表的外键

192
18:08:35,040 --> 18:08:40,080
或 id 字段，然后我们这里有另一个字段表示 text 类型的 text 和

193
18:08:40,080 --> 18:08:44,480
然后另一个名为 isync 的字段，云整数不为空，默认为零

194
18:08:44,480 --> 18:08:48,320
好的，这就是我们需要做的一切

195
18:08:48,320 --> 18:08:52,000
我会按好，我需要在你这边做同样的事情

196
18:08:52,000 --> 18:08:56,400
现在我们有两个嗯

197
18:08:56,400 --> 18:09:00,956
我们的数据库中有两个表

198
18:09:00,956 --> 18:09:06,320
所以让我们继续前进，嗯，让我们继续前进，继续下一个

199
18:09:06,320 --> 18:09:09,520
指出我们将要谈论的问题是，我们需要将您视为字幕案例

200
18:09:09,520 --> 18:09:14,560
以编程方式创建这些，否则我们必须移动它

201
18:09:14,560 --> 18:09:17,436
我们刚刚创建的名为 testingdb 的数据库

202
18:09:17,436 --> 18:09:21,200
手动进入应用程序的文档文件夹我将解释什么

203
18:09:21,200 --> 18:09:27,040
这实际上意味着您现在看到我们有一个名为 testingdb 的文件

204
18:09:27,040 --> 18:09:32,080
有我们应用程序的数据库和一些表好吗

205
18:09:32,080 --> 18:09:35,040
但是我们需要能够创建这些

206
18:09:35,040 --> 18:09:40,080
如果您看到的应用程序中不存在表格，则以编程方式

207
18:09:40,080 --> 18:09:44,240
这个测试数据库对我来说是坐在我的桌面上它完全没有任何关系

208
18:09:44,240 --> 18:09:49,040
使用我们的颤振应用程序，您可以很聪明，喜欢拖动这个数据库

209
18:09:49,040 --> 18:09:53,596
进入你的firebase应用程序颤动应用程序，然后将其复制到

210
18:09:53,596 --> 18:09:58,400
应用程序在用户电话中执行时的正确位置或

211
18:09:58,400 --> 18:10:01,680
在平板电脑上，然后尝试从该数据库中读取

212
18:10:01,680 --> 18:10:05,840
这是可能的，但我要在这里做的是我要告诉你

213
18:10:05,840 --> 18:10:10,160
一种更好的方法是我们将实际创建这些表

214
18:10:10,160 --> 18:10:13,840
以编程方式在我们的颤振应用程序中，以便

215
18:10:13,840 --> 18:10:17,756
您还看到了该过程以及它是如何工作的，您如何与

216
18:10:17,756 --> 18:10:22,000
在你的颤振应用程序中使用 sqlite

217
18:10:22,000 --> 18:10:25,520
好吧，为了做到这一点，作为字幕案例，我们需要一些

218
18:10:25,520 --> 18:10:32,080
依赖关系呃我们需要 sql sqflight 路径提供程序和路径

219
18:10:32,080 --> 18:10:36,880
然后我会向你解释为什么我们需要这些依赖项，你看 sql

220
18:10:36,880 --> 18:10:40,720
sqflight 是一个包它是我们需要添加到我们的第三方包

221
18:10:40,720 --> 18:10:45,040
应用程序，以便我们的颤振应用程序能够与 sql 对话

222
18:10:45,040 --> 18:10:48,636
飞行，就是这样，那是为了

223
18:10:48,636 --> 18:10:54,956
storage 实际存储并与该软件包使用的数据库进行对话

224
18:10:54,956 --> 18:10:58,956
现在有一个依赖项我们必须拖到我们的应用程序中，称为路径

225
18:10:58,956 --> 18:11:05,596
路径用于我们能够抓取应用程序文档文件夹

226
18:11:05,596 --> 18:11:10,796
这样我们就可以在文档文件夹中创建一个文件并将我们的

227
18:11:10,796 --> 18:11:15,840
该文件中的数据就像我为节点和用户放置数据一样

228
18:11:15,840 --> 18:11:18,956
在我桌面上的这个测试数据库文件中，所以

229
18:11:18,956 --> 18:11:23,756
路径 uh 提供者和路径提供者 uh i

230
18:11:23,756 --> 18:11:27,680
可能实际上已经教过设置路径，但它实际上被称为路径提供者路径

231
18:11:27,680 --> 18:11:32,240
提供者依赖允许我们获取应用程序

232
18:11:32,240 --> 18:11:35,756
文档文件夹，如果您不熟悉移动应用程序

233
18:11:35,756 --> 18:11:40,080
开发你可能不知道，但是坐在呃上的应用程序

234
18:11:40,080 --> 18:11:45,916
android 手机或平板电脑以及 ios 手机或 ipad os 平板电脑

235
18:11:45,916 --> 18:11:50,480
它们有自己的文件结构，因此每个应用程序本身都有一个

236
18:11:50,480 --> 18:11:53,200
文档目录所以

237
18:11:53,200 --> 18:11:57,916
而在您的计算机上，就像您坐在笔记本电脑或台式机上一样

238
18:11:57,916 --> 18:12:03,360
您有一个文档文件夹，其他应用程序在您的操作系统上运行

239
18:12:03,360 --> 18:12:08,160
系统可以访问，因此它是每个应用程序都可以访问的一个文档文件夹

240
18:12:08,160 --> 18:12:12,400
请求访问并在其中存储信息并从中读取信息，但事实并非如此

241
18:12:12,400 --> 18:12:17,756
在移动设备和平板电脑上的每个应用程序都具有相同的概念

242
18:12:17,756 --> 18:12:23,280
在一个叫做沙箱的东西里面运行沙箱就像一个它就像一个

243
18:12:23,280 --> 18:12:27,756
应用程序所在的笼子和所有应用程序数据

244
18:12:27,756 --> 18:12:32,556
驻留在该沙箱中，因此每个应用程序都可以请求访问

245
18:12:32,556 --> 18:12:37,920
从操作系统读取它自己的文件夹没问题，那就是

246
18:12:37,920 --> 18:12:40,960
路径提供者是什么

247
18:12:40,960 --> 18:12:45,600
包将允许我们找到我们的应用程序文件

248
18:12:45,600 --> 18:12:50,640
我们将在其中存储数据库文件的文件夹

249
18:12:50,640 --> 18:12:53,756
现在我们还需要正如我提到的

250
18:12:53,756 --> 18:12:57,040
一个名为 path 的包和

251
18:12:57,040 --> 18:13:01,600
我们需要这条路径只是为了一个非常简单的操作和

252
18:13:01,600 --> 18:13:06,720
假设我们现在使用路径提供程序来获取我们的文档文件夹

253
18:13:06,720 --> 18:13:11,040
我们想在这个文档文件夹中创建一个文件

254
18:13:11,040 --> 18:13:15,116
有点像获取此文件文档文件夹斜杠的完整路径

255
18:13:15,116 --> 18:13:18,720
这个文件，这就是我们需要的路径包，因为它有一个很棒的

256
18:13:18,720 --> 18:13:23,516
名为 join 的函数允许我们获取目录的路径或

257
18:13:23,516 --> 18:13:28,000
文件夹并使用文件名加入该路径，然后

258
18:13:28,000 --> 18:13:32,556
给我们完整的路径，这样我们就可以访问那个文件了

259
18:13:32,556 --> 18:13:36,320
所以很多信息我要接受这个

260
18:13:36,320 --> 18:13:41,600
嗯到另一个屏幕，所以你看不到它，我可以看到

261
18:13:41,600 --> 18:13:44,876
这里它要求控制这台计算机的访问现在我要拒绝

262
18:13:44,876 --> 18:13:48,320
现在，嗯，好吧，所以我们要做什么

263
18:13:48,320 --> 18:13:51,600
如果我能找到它，我会提出我们的代码

264
18:13:51,600 --> 18:13:55,756
这是我们在前几章中留下的代码

265
18:13:55,756 --> 18:13:59,756
我可以看到它正在运行，对不起，我要带上 scrcpy

266
18:13:59,756 --> 18:14:03,600
它在这里我实际上不确定你是否需要在本章中使用 crcpy，所以它可能

267
18:14:03,600 --> 18:14:07,516
对我来说最好只是最小化 scr cpy

268
18:14:07,516 --> 18:14:11,516
我也会让这段代码在这里更大一点

269
18:14:11,516 --> 18:14:15,436
所以我们现在需要什么

270
18:14:15,436 --> 18:14:20,156
首先是在我们继续并实际创建我们的笔记服务之前

271
18:14:20,156 --> 18:14:24,080
引入这些依赖项好吧让我改变这个屏幕布局

272
18:14:24,080 --> 18:14:27,836
一点点让你看得更清楚我也会增加字体

273
18:14:27,836 --> 18:14:33,836
所以我需要你去你的编辑器文本编辑器或 id 如果你正在使用

274
18:14:33,836 --> 18:14:38,156
我们需要引入那些依赖关系好吗

275
18:14:38,156 --> 18:14:44,320
所以让我们打开你的网络浏览器，然后在公共场合说 pop.dev

276
18:14:44,320 --> 18:14:49,516
开发人员搜索 sql 航班没问题，您可以看到它就在那里以及前往的方式

277
18:14:49,516 --> 18:14:53,196
安装它很简单你应该可以说

278
18:14:53,196 --> 18:14:59,280
呃，在 sqflight 上扑腾扑腾，所以让我们继续手动做吧

279
18:14:59,280 --> 18:15:07,516
让我们试一试记住它不是 sqlite 它是 sqlite

280
18:15:07,516 --> 18:15:12,400
好的，已经添加了依赖项，然后我会说颤振流行添加提供

281
18:15:12,400 --> 18:15:18,400
一个路径提供者，我们实际上可以在 popdev 路径提供者中搜索它

282
18:15:18,400 --> 18:15:22,796
它就在那里，它是由那些拥有的人开发的

283
18:15:22,796 --> 18:15:27,436
给我们带来了颤抖，所以从谷歌开始，所以它不是真正的三分之一

284
18:15:27,436 --> 18:15:31,360
方应用程序或第三方呃包，我们实际上可以看看

285
18:15:31,360 --> 18:15:35,680
在 sql flight 上，看看是谁开发的

286
18:15:35,680 --> 18:15:40,156
哦，这是另一个，是的，这是另一个出版商自己不会颤抖，所以

287
18:15:40,156 --> 18:15:45,280
让我们回到路径提供者，我只想说

288
18:15:45,280 --> 18:15:50,960
如我们所见，安装是颤振弹出添加路径提供程序让我复制它

289
18:15:50,960 --> 18:15:55,516
并将其粘贴到那里添加路径提供程序

290
18:15:55,516 --> 18:16:00,400
然后我们还需要路径，所以让我们回到这里并输入路径 i

291
18:16:00,400 --> 18:16:05,196
相信这是我的颤振团队是的黑暗开发所以让我们说颤振流行

292
18:16:05,196 --> 18:16:10,796
添加路径

293
18:16:10,796 --> 18:16:16,476
好吧，这将完成它的工作，现在如果你去我们的 um

294
18:16:16,476 --> 18:16:21,360
pop special 那么你应该可以看到那些

295
18:16:21,360 --> 18:16:26,876
依赖项 sqflight 路径提供程序和路径就在那里

296
18:16:26,876 --> 18:16:31,756
现在我们已经完成了，我们可以去做我们应该在这里做的事情

297
18:16:31,756 --> 18:16:35,836
这是创建我们的笔记服务，您可以在

298
18:16:35,836 --> 18:16:38,720
呃，在我在标题中提供的描述中，我说我们在

299
18:16:38,720 --> 18:16:43,116
在名为 crud 的文件夹中创建，我们已经有你可以使用的 lib 服务

300
18:16:43,116 --> 18:16:48,960
在这里看到 lib services 和 lib services auth 但我们没有 crud 所以

301
18:16:48,960 --> 18:16:54,960
我要在 lib 中进入这里，只说新文件，我要说服务

302
18:16:54,960 --> 18:16:56,960
好斜线绝对是说它已经

303
18:16:56,960 --> 18:17:01,196
存在所以在服务内部我要说新文件然后我要带它

304
18:17:01,196 --> 18:17:04,796
所以你也可以看到它哦它去哪儿了

305
18:17:04,796 --> 18:17:08,320
服务新文件 crud

306
18:17:08,320 --> 18:17:13,360
我想我需要更改屏幕布局，所以很遗憾，你会看到的

307
18:17:13,360 --> 18:17:21,600
更好的服务再次新文件在这里一个新文件呃第三次或第四次

308
18:17:21,600 --> 18:17:28,476
幸运的 crud 然后是节点服务点

309
18:17:28,476 --> 18:17:31,280
好的，那么我们将如何处理这个节点

310
18:17:31,280 --> 18:17:36,244
服务是要呃是要基本抢

311
18:17:36,244 --> 18:17:41,516
持有我们的数据库，它是要使用的主要服务

312
18:17:41,516 --> 18:17:45,116
我们的 sqlite 数据库 它会抓住用户 它会

313
18:17:45,116 --> 18:17:51,116
创建新用户 删除用户 它会找到用户 它会创建笔记

314
18:17:51,116 --> 18:17:55,196
删除节点 更新节点 用户需要的一切

315
18:17:55,196 --> 18:17:59,600
此节点服务将要访问的接口

316
18:17:59,600 --> 18:18:04,320
为我们提供便利，好吧

317
18:18:04,320 --> 18:18:12,080
好的，所以我们需要在里面做的是

318
18:18:12,080 --> 18:18:16,156
所以我们现在需要做的是实际上我认为在我们这样做之前我们需要

319
18:18:16,156 --> 18:18:20,244
导入我们的依赖项，让我们导入我们需要的依赖项

320
18:18:20,244 --> 18:18:24,960
如果您还记得路径路径提供程序和 sqlite，则三个依赖项

321
18:18:24,960 --> 18:18:29,756
嗯，我会把那些带到这里，这样我们就不必

322
18:18:29,756 --> 18:18:35,040
再次输入，所以进口有点无聊，我

323
18:18:35,040 --> 18:18:38,796
我宁愿不输入它们所以让我们进入这里你可以看看什么

324
18:18:38,796 --> 18:18:42,476
我在这里导入了包 sql flight，然后我们导入它

325
18:18:42,476 --> 18:18:46,244
然后我们还可以使用路径提供程序，以便我们可以获取文档文件夹

326
18:18:46,244 --> 18:18:50,556
对于这个应用程序，然后我们也正在导入包路径路径，然后

327
18:18:50,556 --> 18:18:56,556
我这样做是为了引入这个名为的特定函数

328
18:18:56,556 --> 18:18:59,196
加入好吧

329
18:18:59,196 --> 18:19:03,600
你也可以跳过它，但问题是你把所有东西都放在里面

330
18:19:03,600 --> 18:19:07,756
飞镖的路径，这不是我想要的，所以我只想让我们得到这个特别的

331
18:19:07,756 --> 18:19:10,876
path.dart 中的函数，你也可以这样做

332
18:19:10,876 --> 18:19:15,280
在这里说实话，你可以说show um，我认为

333
18:19:15,280 --> 18:19:19,600
函数被称为获取应用程序文档目录所以让我们这样做为什么

334
18:19:19,600 --> 18:19:24,080
不要让我们从路径提供者那里得到那个特定的功能，好吧

335
18:19:24,080 --> 18:19:27,600
我们不需要整个路径提供者好吧

336
18:19:27,600 --> 18:19:32,476
好吧，那太好了

337
18:19:32,476 --> 18:19:36,320
我们需要的是让我们能够

338
18:19:36,320 --> 18:19:41,680
抓住我们当前的数据库路径，正如我提到的那样

339
18:19:41,680 --> 18:19:45,516
您使用 Flutter 为移动应用程序开发的每个应用程序

340
18:19:45,516 --> 18:19:50,244
android和ios以及ipad os等设备都有自己的文档

341
18:19:50,244 --> 18:19:54,476
目录，我们要创建，我们要得到的路径

342
18:19:54,476 --> 18:19:58,476
文件目录，然后我们就是我们要说的是我们要

343
18:19:58,476 --> 18:20:02,400
使用路径依赖加入它

344
18:20:02,400 --> 18:20:07,680
使用我们将为我们的数据库指定的名称

345
18:20:07,680 --> 18:20:10,156
所以嗯

346
18:20:10,156 --> 18:20:14,244
那么我们需要做的是让我们先实际并照顾好

347
18:20:14,244 --> 18:20:20,000
在我们真正开始之前需要处理的其他一些重要事项

348
18:20:20,000 --> 18:20:24,476
为我们的数据库创建函数功能，呃实现你

349
18:20:24,476 --> 18:20:28,080
请参阅注释服务将与数据库交谈，但在您执行此操作之前

350
18:20:28,080 --> 18:20:32,640
需要对这两个非常有某种飞镖表示

351
18:20:32,640 --> 18:20:38,960
我们创建了用户并注意的重要表，因此如果您从中读取该数据

352
18:20:38,960 --> 18:20:43,116
数据库我们将如何在我们的 dart 应用程序中表示它

353
18:20:43,116 --> 18:20:48,876
为此，我们需要飞镖课程

354
18:20:48,876 --> 18:20:53,756
我们现在需要的是作为标题，以防我们需要数据库用户创建一个

355
18:20:53,756 --> 18:20:59,516
在笔记服务飞镖内称为数据库用户的类

356
18:20:59,516 --> 18:21:03,920
好吧，这将是一些代码，所以我希望你已经准备好了

357
18:21:03,920 --> 18:21:07,680
让我们继续吧 我正在看我的笔记

358
18:21:07,680 --> 18:21:12,000
让我们继续创建，因为标题表明我们在这里创建了一个类

359
18:21:12,000 --> 18:21:15,920
我做了一个更大的班级，我只是

360
18:21:15,920 --> 18:21:22,720
如果您还记得从 db browser for

361
18:21:22,720 --> 18:21:26,320
sqlite 我要把它带到这里每个用户都有

362
18:21:26,320 --> 18:21:29,680
我们真的可以吗，哦，我们可以浏览它，但我想去

363
18:21:29,680 --> 18:21:33,920
回到用户并修改表保存它，你

364
18:21:33,920 --> 18:21:37,920
记住它有一个 id 和一个电子邮件 id 是整数和电子邮件是文本所以这是

365
18:21:37,920 --> 18:21:42,556
我们要在这里定义什么好的，所以我们要说 final 和 id 和

366
18:21:42,556 --> 18:21:46,320
最终字符串电子邮件

367
18:21:46,320 --> 18:21:49,436
从视觉工作室获得帮助以完全完成这个我不去

368
18:21:49,436 --> 18:21:53,116
一次又一次地解释这些，因为我们已经解释了很多

369
18:21:53,116 --> 18:21:58,476
之前的章节，所以到这里我只是假设你知道这些是什么

370
18:21:58,476 --> 18:22:02,244
让我们让它成为一个常量初始化器，然后让我们继续说这些

371
18:22:02,244 --> 18:22:05,040
两个参数是必需的参数所以

372
18:22:05,040 --> 18:22:09,756
默认情况下它们也成为命名参数

373
18:22:09,756 --> 18:22:15,360
这就是在这里放一个逗号所以我们得到暗格式化程序来发挥它的魔力

374
18:22:15,360 --> 18:22:19,436
我们要做的是记住我们什么时候

375
18:22:19,436 --> 18:22:23,196
实际上你不应该记得，因为你可能还不知道，但是当

376
18:22:23,196 --> 18:22:28,796
我们与我们将要阅读的数据库交谈

377
18:22:28,796 --> 18:22:33,756
就像我们从 for 中读取的每一行的哈希表

378
18:22:33,756 --> 18:22:38,400
从该表中，因此该数据库中的每个用户

379
18:22:38,400 --> 18:22:43,436
名为 user 的表将由该对象表示

380
18:22:43,436 --> 18:22:50,400
字符串和一个可选对象可以，所以这是用户表中的一行

381
18:22:50,400 --> 18:22:53,600
现在想象这个

382
18:22:53,600 --> 18:22:56,796
我们即将创建的节点服务

383
18:22:56,796 --> 18:22:59,920
从数据库中读取这些用户，它应该是

384
18:22:59,920 --> 18:23:04,476
能够将它传递给我们的数据库用户类，并且数据库用户类应该

385
18:23:04,476 --> 18:23:09,600
根据此地图中的值创建自身的实例

386
18:23:09,600 --> 18:23:15,116
好吧，让我们继续创建一个构造函数，我们称之为数据库用户

387
18:23:15,116 --> 18:23:20,080
然后我们说前排然后我们说我们得到一个字符串的映射

388
18:23:20,080 --> 18:23:25,436
和一个可选对象，然后我们就称它为 map 好吧

389
18:23:25,436 --> 18:23:29,116
所以我们要在这里做的是我们要为

390
18:23:29,116 --> 18:23:33,920
创建和构造我们的对象，我们会说 id 等于 this

391
18:23:33,920 --> 18:23:38,556
map 需要有某种称为 id 列的列，而不是

392
18:23:38,556 --> 18:23:42,796
像这样在这里进行硬编码让我们在这里定义一个常量

393
18:23:42,796 --> 18:23:47,680
称它为 id 列，让我们说这等于 id 并且在这里

394
18:23:47,680 --> 18:23:52,156
我们只是说id等于ib列就好了

395
18:23:52,156 --> 18:23:59,116
然后我们要说的是我们还需要电子邮件，电子邮件等于

396
18:23:59,116 --> 18:24:02,720
映射并记住我们有我要去的电子邮件

397
18:24:02,720 --> 18:24:06,320
在这里打开用户

398
18:24:06,320 --> 18:24:11,360
修改表

399
18:24:11,360 --> 18:24:17,040
让我们去看看这封电子邮件，里面有文字，好吗

400
18:24:17,040 --> 18:24:20,320
所以该列的表基本上是

401
18:24:20,320 --> 18:24:24,720
调用电子邮件，所以让我们继续创建 const 我将要做这个

402
18:24:24,720 --> 18:24:28,156
一个单一的代码，因为这就像做的首选方式

403
18:24:28,156 --> 18:24:32,720
它，我们称之为电子邮件列，我将把它分配给

404
18:24:32,720 --> 18:24:36,156
完整的电子邮件，在这里我只想说电子邮件专栏

405
18:24:36,156 --> 18:24:41,040
作为一个字符串，这应该是这样的

406
18:24:41,040 --> 18:24:43,680
这是我的意思是它看起来很复杂，但它

407
18:24:43,680 --> 18:24:48,556
真的不是这样，你可以看到它是一个常数，所以我们实际上也可以标记

408
18:24:48,556 --> 18:24:54,244
这是不可变的，我们需要导入基础才能能够

409
18:24:54,244 --> 18:24:57,116
这样做没关系

410
18:24:57,116 --> 18:25:01,516
现在我们有了数据库用户，我们还需要实现更多

411
18:25:01,516 --> 18:25:05,360
在我们真正完成之前这个类的功能

412
18:25:05,360 --> 18:25:09,040
有了它，我们需要做的三件事

413
18:25:09,040 --> 18:25:13,680
因为它首先为这个类创建一个字符串描述符，这样如果

414
18:25:13,680 --> 18:25:17,360
我们正在将此用户打印到调试控制台

415
18:25:17,360 --> 18:25:20,156
否则，我的意思是在我说否则之前，如果我们是

416
18:25:20,156 --> 18:25:25,280
将数据库用户的实例打印到调试控制台，所以我们

417
18:25:25,280 --> 18:25:29,836
查看我们数据库中的各种用户

418
18:25:29,836 --> 18:25:34,244
如果我们没有在我们的类上实现两个字符串，它实际上只会说

419
18:25:34,244 --> 18:25:39,040
控制台中数据库用户的实例，这不是那么有用，所以它是我的

420
18:25:39,040 --> 18:25:42,876
如果我打算打印出来，我的习惯

421
18:25:42,876 --> 18:25:46,960
这些东西到控制台我习惯去实现两个字符串所以

422
18:25:46,960 --> 18:25:51,836
让我们在这里对字符串说，它给了我们覆盖和什么

423
18:25:51,836 --> 18:25:55,920
我们要在这里做的只是我们要说一个人

424
18:25:55,920 --> 18:26:00,640
并且个人ID等于美元ID

425
18:26:00,640 --> 18:26:05,680
并且电子邮件等于美元电子邮件，好吧，这是您的字符串

426
18:26:05,680 --> 18:26:10,720
那么我们需要做的也是实现某种平等

427
18:26:10,720 --> 18:26:15,116
你看到的我们班级的行为我们希望能够看到两个不同的

428
18:26:15,116 --> 18:26:18,720
我们从数据库中检索到的人彼此是否相等

429
18:26:18,720 --> 18:26:24,876
所以如果我说如果人 x 等于人 y 那么就像明智地阅读这个人

430
18:26:24,876 --> 18:26:29,836
诸如此类的注释，所以让我们开始为我们的实现平等吧

431
18:26:29,836 --> 18:26:33,836
类和做到这一点的方法是你覆盖

432
18:26:33,836 --> 18:26:39,516
一个布尔运算符，它被称为布尔运算符 equal equal

433
18:26:39,516 --> 18:26:45,116
在这里你会有一个我们还没有讨论过的协变，我

434
18:26:45,116 --> 18:26:49,116
现在会和你谈谈

435
18:26:49,116 --> 18:26:53,436
协方差是飞镖中的一个关键字，很少有人知道，但它

436
18:26:53,436 --> 18:26:58,080
允许您更改输入参数的行为，以便它们执行

437
18:26:58,080 --> 18:27:03,436
不一定符合该参数的签名

438
18:27:03,436 --> 18:27:07,680
超级类所以记住我们在这里覆盖意味着那里

439
18:27:07,680 --> 18:27:12,556
此运算符的功能已经在对象级别定义，所以让我们开始吧

440
18:27:12,556 --> 18:27:16,960
对象只是在某处键入对象，例如

441
18:27:16,960 --> 18:27:20,720
void hello 然后说对象然后命令

442
18:27:20,720 --> 18:27:25,516
点击它，这样你就可以去那里搜索运营商

443
18:27:25,516 --> 18:27:29,516
equal equal 并且你会在这里看到它表示外部运算符 equal 和

444
18:27:29,516 --> 18:27:35,436
参数应该是 object 类型的，现在我们不想这样做，我们想要我们的

445
18:27:35,436 --> 18:27:40,556
要与相同类型的其他类进行比较的类，所以如果你不这样做

446
18:27:40,556 --> 18:27:43,836
把协变量放在这里你会得到一个错误

447
18:27:43,836 --> 18:27:47,116
分析器，你很快就会看到实际上我们很快就会删除它

448
18:27:47,116 --> 18:27:49,196
所以在这里我们说我们要

449
18:27:49,196 --> 18:27:53,360
比较我们的类与相等相等和我们类的实例相等相等

450
18:27:53,360 --> 18:27:57,836
我们将与同一类的另一个用户进行比较，然后

451
18:27:57,836 --> 18:28:01,680
在这里我们只是说我们的 id 应该等于另一个 id

452
18:28:01,680 --> 18:28:06,320
我们的平等现在让我们继续然后删除它

453
18:28:06,320 --> 18:28:10,156
正如我向你承诺的那样协变，现在你会看到你会得到一个错误

454
18:28:10,156 --> 18:28:15,116
说哦等一下根据对象等于等于应该比较

455
18:28:15,116 --> 18:28:19,756
当前对象与另一个对象但使用协变​​你告诉飞镖

456
18:28:19,756 --> 18:28:24,000
嘿，我不能与任何其他类的其他对象相提并论，我只会

457
18:28:24,000 --> 18:28:28,476
可与数据库用户实例相媲美，因此一切正常

458
18:28:28,476 --> 18:28:31,116
所以在你实施 equal 之后，你有

459
18:28:31,116 --> 18:28:34,320
还按照分析器的建议实施哈希码，所以我要去

460
18:28:34,320 --> 18:28:38,244
从视觉工作室代码的飞镖获得帮助，我要去

461
18:28:38,244 --> 18:28:42,960
说创建方法哈希码并在覆盖哈希码时我

462
18:28:42,960 --> 18:28:49,196
只是要返回我的 id 的哈希码，所以这基本上是 id

463
18:28:49,196 --> 18:28:53,920
成为这个类的主键，它会使用它来散列自己，所以它

464
18:28:53,920 --> 18:28:59,116
可以放置在地图或哈希节点中，如果你

465
18:28:59,116 --> 18:29:04,876
如果您是 ros 开发人员或字典 如果您是 swift 开发人员

466
18:29:04,876 --> 18:29:08,876
所以呃，这很好，所以感觉就像

467
18:29:08,876 --> 18:29:16,876
我们现在已经用我们的数据库用户完成了这个 um 所以

468
18:29:16,876 --> 18:29:20,640
那是相当多的代码，但我们做到了

469
18:29:20,640 --> 18:29:23,516
好了，现在我们已经完成了数据库用户，我们需要做一些事情

470
18:29:23,516 --> 18:29:28,960
类似，但这次我们需要为我们的节点做这件事，所以我们有一个数据库用户

471
18:29:28,960 --> 18:29:32,876
现在我们必须创建一个叫做数据库节点的东西

472
18:29:32,876 --> 18:29:36,556
不是节点，我将在

473
18:29:36,556 --> 18:29:41,280
数据库用户，以便我们可以更接近地访问这些常量

474
18:29:41,280 --> 18:29:43,836
对，所以我建议你做同样的事情

475
18:29:43,836 --> 18:29:47,920
假设我们创建了一个类，我们称之为数据库注释

476
18:29:47,920 --> 18:29:52,000
并从我们的数据库模式中记住一个注释，所以如果我进去说

477
18:29:52,000 --> 18:29:58,000
右键单击右键并修改表然后我们有 id 用户 id 文本和一个

478
18:29:58,000 --> 18:30:02,080
现场呼叫已与云同步，所以让我们继续做那个 id

479
18:30:02,080 --> 18:30:07,516
是整数用户 ID 整数文本是文本或字符串，因为 ins 与云同步

480
18:30:07,516 --> 18:30:09,836
这里只是一个整数，但我们要

481
18:30:09,836 --> 18:30:14,320
可以将其表示为布尔值，因此请记住这四个字段

482
18:30:14,320 --> 18:30:19,436
让我们继续说 final id 和 mint id

483
18:30:19,436 --> 18:30:23,920
我们在我们的数据库中有一个最终的 int 我们称之为用户下划线 id 因为

484
18:30:23,920 --> 18:30:28,796
这是 sqlite 或 sql 中的一个约定，通常你不会把你放在

485
18:30:28,796 --> 18:30:32,720
就像你不和用户一起写你的字段

486
18:30:32,720 --> 18:30:36,640
id 通常你不会像我们在 dart 中使用驼峰式大小写那样输入

487
18:30:36,640 --> 18:30:40,080
其他语言我们只是说用户一切都在一切之下

488
18:30:40,080 --> 18:30:43,516
小写字母和不同的单词用

489
18:30:43,516 --> 18:30:47,280
下划线，但在 dart 和其他语言中并非如此，而是我们说

490
18:30:47,280 --> 18:30:51,436
像这样的用户用户 ID 与面板案例全部

491
18:30:51,436 --> 18:30:54,876
对，我们也会创造让我

492
18:30:54,876 --> 18:30:59,360
把它移到那里一点，我们也将创建 um

493
18:30:59,360 --> 18:31:04,244
我们文本的字符串和

494
18:31:04,244 --> 18:31:09,436
最后我们要说的是与云同步这样的东西

495
18:31:09,436 --> 18:31:13,280
再次记住我们不会使用这个输入云，它只是为了你

496
18:31:13,280 --> 18:31:16,400
了解我们如何在数据库中创建不同的字段

497
18:31:16,400 --> 18:31:20,796
是的，这只是你未来保护自己的东西

498
18:31:20,796 --> 18:31:25,360
针对您的数据库架构中的未来更改，因此通过这样做您允许

499
18:31:25,360 --> 18:31:29,680
自己玩这个领域，这样你就知道本地的每一个音符

500
18:31:29,680 --> 18:31:33,600
在本地数据库中创建默认不与云端同步好吗

501
18:31:33,600 --> 18:31:36,720
我想从 Visual Studio 代码中获得帮助来完成构造函数

502
18:31:36,720 --> 18:31:41,920
这个，我要去按照要求做所有这些领域，所以我

503
18:31:41,920 --> 18:31:46,400
会说需要，我要复制那个粘贴它那里粘贴它

504
18:31:46,400 --> 18:31:51,040
就在那里，然后我要在最后加上一个逗号并命令 s

505
18:31:51,040 --> 18:31:56,720
在 mac 或 windows 和 linux 中的 control 上保存并获取 dart 格式化程序

506
18:31:56,720 --> 18:32:00,640
为我格式化这个文件，这就是初始化程序

507
18:32:00,640 --> 18:32:04,320
我们也需要做和我们在这里为我们的数据库做的一样的事情

508
18:32:04,320 --> 18:32:09,196
用户，我们需要从一行实例化它，所以让我复制这段代码

509
18:32:09,196 --> 18:32:12,000
它就在那里，我要把它带进我们的

510
18:32:12,000 --> 18:32:16,000
数据库注释我将把它粘贴在那里，而不是我要说

511
18:32:16,000 --> 18:32:21,920
来自行初始化程序的 this 创建了一个数据库注释

512
18:32:21,920 --> 18:32:26,640
在我们的数据库注释中，我们有一个 ID，但我们没有电子邮件，所以在这里我们

513
18:32:26,640 --> 18:32:31,436
只是说用户 id 是地图然后我们需要一个新列

514
18:32:31,436 --> 18:32:36,476
被称为用户 ID 列好吧，所以让我看看我的笔记我是如何创建它的

515
18:32:36,476 --> 18:32:40,400
是的，我可以看到它被称为只是用户 ID 调用，所以继续创建一个新的

516
18:32:40,400 --> 18:32:43,920
在这里保持不变并称之为

517
18:32:43,920 --> 18:32:48,796
用户 id 列，如果您记得我们的架构中它被称为用户

518
18:32:48,796 --> 18:32:52,796
下划线 id 所以用户 id

519
18:32:52,796 --> 18:32:56,080
好的，这里我们说用户 ID 等于地图

520
18:32:56,080 --> 18:33:00,244
用户 id 列作为字符串，它在抱怨

521
18:33:00,244 --> 18:33:03,436
现在因为我们还有两个要初始化的字段，但我们还没有真正阅读

522
18:33:03,436 --> 18:33:07,600
它们来自地图的值，因此文本并与云同步，因此对于文本，我们只是

523
18:33:07,600 --> 18:33:11,756
说文本等于地图，让我们去创建一个新的

524
18:33:11,756 --> 18:33:16,960
辅音在这里我们说文本列，它等于文本，所以它只是

525
18:33:16,960 --> 18:33:20,876
您在此处看到的字段或列的名称

526
18:33:20,876 --> 18:33:24,320
所以让我们继续说这是文本，在这里我们说文本

527
18:33:24,320 --> 18:33:27,196
柱子

528
18:33:27,196 --> 18:33:32,796
我们说添加字符串，我相信这就是我们所说的

529
18:33:32,796 --> 18:33:36,400
我们将调用一个可以初始化的字符串哦，对不起，用户

530
18:33:36,400 --> 18:33:40,320
id 不能是应该添加的字符串，所以我们只说它是一个 int 和

531
18:33:40,320 --> 18:33:43,836
最后但并非最不重要的是与云同步，所以我们要说

532
18:33:43,836 --> 18:33:50,720
async with cloud 实际上是从我们的数据库中读取的整数，记住

533
18:33:50,720 --> 18:33:54,080
以整数形式与云同步，所以我们要说

534
18:33:54,080 --> 18:33:57,680
我们将首先定义一个列，因为它是同步的

535
18:33:57,680 --> 18:34:00,876
带云柱

536
18:34:00,876 --> 18:34:04,796
我们将把它称为与云异步和

537
18:34:04,796 --> 18:34:08,640
我的意思是我说我们要调用它但实际上我们已经调用它了

538
18:34:08,640 --> 18:34:13,116
我们称它与云同步，因此只需将其复制并粘贴到此处

539
18:34:13,116 --> 18:34:17,836
你看没问题，然后我们要说的是

540
18:34:17,836 --> 18:34:24,156
与云同步等于现在你看到我们没有这个呃

541
18:34:24,156 --> 18:34:27,196
数据我们没有将此字段作为数据库中的布尔值我们将其作为

542
18:34:27,196 --> 18:34:31,280
整数，所以我们必须将其读取为整数，所以我们要在地图中说

543
18:34:31,280 --> 18:34:37,920
有一个名为 async with cloud 列的列，它是一个整数

544
18:34:37,920 --> 18:34:42,244
如果等于 1 则返回 true

545
18:34:42,244 --> 18:34:47,516
否则 uh 等于一个 true 否则为 false 所以

546
18:34:47,516 --> 18:34:51,040
你看这里发生了什么我们将列读取为整数

547
18:34:51,040 --> 18:34:55,920
哦，如果它等于一，那么这个人就等于真，否则这个人

548
18:34:55,920 --> 18:35:00,796
等于 false 好了，既然我们已经完成了初始化

549
18:35:00,796 --> 18:35:05,756
从我们的行中我们的数据库注释

550
18:35:05,756 --> 18:35:10,960
需要继续，我们还需要创建 tostring

551
18:35:10,960 --> 18:35:18,400
对于我们的数据库注释好的所以让我们去覆盖到字符串

552
18:35:18,400 --> 18:35:21,600
像这样，我们只会说这是一个

553
18:35:21,600 --> 18:35:24,556
我们要说的简单说明

554
18:35:24,556 --> 18:35:29,920
等于 note 并且其 id 等于美元 id 是文本

555
18:35:29,920 --> 18:35:33,756
等于或只是它的用户 ID 等于美元

556
18:35:33,756 --> 18:35:37,680
用户 ID，这是我们拥有的字段

557
18:35:37,680 --> 18:35:41,836
然后我们不会打印它的整个场景而是整个文本

558
18:35:41,836 --> 18:35:46,476
我们要说的是与云同步的是

559
18:35:46,476 --> 18:35:52,556
其他的就这样跟云同步了

560
18:35:52,556 --> 18:35:57,680
好吧，是的，我的意思是，如果您愿意，您也可以添加文本

561
18:35:57,680 --> 18:36:01,196
这取决于你，但问题是注释的文本

562
18:36:01,196 --> 18:36:05,040
可能会很长，以至于它实际上会妨碍您获取以下信息

563
18:36:05,040 --> 18:36:10,080
你的类实例，例如它的 id 用户 id 和一个单一的类，所以如果你

564
18:36:10,080 --> 18:36:14,796
希望文本在那里只需将其添加到末尾，这样它基本上不会中断

565
18:36:14,796 --> 18:36:19,756
您实际上可能有兴趣阅读的其他领域

566
18:36:19,756 --> 18:36:23,040
所以我们做了实现

567
18:36:23,040 --> 18:36:27,280
从 uh tostring 现在，但我们还没有完成相等，所以让我们走吧

568
18:36:27,280 --> 18:36:31,516
并覆盖相等以及哈希节点哈希码抱歉

569
18:36:31,516 --> 18:36:36,400
我将从我们的数据库用户那里复制该代码并将其带入

570
18:36:36,400 --> 18:36:40,876
数据库节点，然后我将其粘贴到此处，以便您将其视为

571
18:36:40,876 --> 18:36:43,920
好吧，我们处于平等地位，我们正在说

572
18:36:43,920 --> 18:36:49,116
只要我们的 id 等于另一个 id，我们就可以与数据库注释进行比较

573
18:36:49,116 --> 18:36:52,244
那么我们就可以使用哈希码然后我们将

574
18:36:52,244 --> 18:36:58,244
就像我们为其他类所做的那样，得到我们的 id 的哈希码

575
18:36:58,244 --> 18:37:03,600
哇，现在我们已经创建了数据库注释，这需要做很多工作

576
18:37:03,600 --> 18:37:08,640
以及标题表明嗯所以我们现在需要做的就是

577
18:37:08,640 --> 18:37:14,720
在我们继续之前确保我们所有的常量都到位现在记住

578
18:37:14,720 --> 18:37:18,476
在完成这些课程之后，我们将继续创建

579
18:37:18,476 --> 18:37:24,244
我们的 um 与我们的数据库对话的实际便笺服务，所以

580
18:37:24,244 --> 18:37:28,876
在我们这样做之前，让我们创建所有必要的常量，例如

581
18:37:28,876 --> 18:37:33,516
我们的数据库将被保存到的文件，所以我们就叫它吧

582
18:37:33,516 --> 18:37:38,720
bb 名称，我们只是将其命名为 notes.db 好吧，记住这就像

583
18:37:38,720 --> 18:37:43,280
文件名好，现在我们要创建，你可以在我们的 um 中看到

584
18:37:43,280 --> 18:37:48,244
文件在这里作为sqlite的db浏览器，我们称这个文件为testing.db，在我们的

585
18:37:48,244 --> 18:37:52,000
在这种情况下，我们只是将其称为nodesdb，并将其存储在文档中

586
18:37:52,000 --> 18:37:57,436
该应用程序内的文件夹可以，然后我们有两个表格和注释

587
18:37:57,436 --> 18:38:01,836
表和用户表，所以让我们继续创建它们的注释表是

588
18:38:01,836 --> 18:38:04,244
嗯投票

589
18:38:04,244 --> 18:38:08,876
和 const user 表表示用户，这些就像

590
18:38:08,876 --> 18:38:13,600
我们在这里定义的表名节点和用户没问题

591
18:38:13,600 --> 18:38:17,836
所以这些就是那些，我们还需要什么，嗯，我认为我认为这很漂亮

592
18:38:17,836 --> 18:38:21,436
老实说，我认为这些都是常数

593
18:38:21,436 --> 18:38:26,080
需要我们才能创建我们的笔记服务

594
18:38:26,080 --> 18:38:31,040
好吧，让我们现在开始，从我们的笔记服务器开始，所以我要清除

595
18:38:31,040 --> 18:38:35,360
这转到该文件的顶部，然后我将在此处留出一些空白空间

596
18:38:35,360 --> 18:38:40,240
并实际创建我们的笔记服务，让我们继续创建一个电路

597
18:38:40,240 --> 18:38:44,400
在这里上课并称之为节点服务非常令人兴奋这是开始

598
18:38:44,400 --> 18:38:48,552
我们创建了一个与我们的数据库一起使用的交叉服务，我们很快就会

599
18:38:48,552 --> 18:38:52,240
将创建实际上没问题，因为缓存表明我们需要一个

600
18:38:52,240 --> 18:38:57,600
function 一个打开数据库的异步函数，您看到打开数据库

601
18:38:57,600 --> 18:39:02,400
不是一个功能，你可以说现在它会发生

602
18:39:02,400 --> 18:39:07,192
异步，因为我们可能需要例如获取当前的 um

603
18:39:07,192 --> 18:39:12,080
当前 uh 文件夹做文档文件夹，然后追加或

604
18:39:12,080 --> 18:39:16,320
使用我们在此处定义的数据库名称加入该文档文件夹

605
18:39:16,320 --> 18:39:18,552
作为一个控制台，所以我们要处理很多异步的东西

606
18:39:18,552 --> 18:39:22,080
在那里发生的不是很多，但至少有一些

607
18:39:22,080 --> 18:39:25,512
这就是这个开放函数将是异步的原因

608
18:39:25,512 --> 18:39:28,240
好的，所以我在任何情况下加上标题，让我们继续吧

609
18:39:28,240 --> 18:39:32,400
创造一个未来的虚空并称之为

610
18:39:32,400 --> 18:39:37,120
刚刚打开，我们称之为异步

611
18:39:37,120 --> 18:39:41,440
现在这个开放的功能将保持延迟

612
18:39:41,440 --> 18:39:45,192
我的意思是在它打开数据库之后实际上会

613
18:39:45,192 --> 18:39:49,280
将它存储在我们的节点服务中的某个地方，所以它会说嘿我已经打开了

614
18:39:49,280 --> 18:39:52,552
这里的数据库是对象，以便其他

615
18:39:52,552 --> 18:39:55,360
未来的功能，例如功能将让我们

616
18:39:55,360 --> 18:39:58,960
从数据库中读取用户或您读取

617
18:39:58,960 --> 18:40:02,800
数据库中的注释那些函数然后他们会说 ah oh here's

618
18:40:02,800 --> 18:40:07,040
数据库实例我知道如何从中获取值好吧

619
18:40:07,040 --> 18:40:11,760
我们要做的是说我们有一个数据库

620
18:40:11,760 --> 18:40:16,640
如您所见，它是由我们的 sqflite 带来的

621
18:40:16,640 --> 18:40:19,600
库，我们只是将其称为 db all

622
18:40:19,600 --> 18:40:23,360
对，所以一开始是空的，我们要

623
18:40:23,360 --> 18:40:26,640
分配给它

624
18:40:26,640 --> 18:40:30,480
好的 嗯

625
18:40:30,480 --> 18:40:36,800
那么我们现在应该怎么做呢，嗯，让我们继续，然后开始做一个

626
18:40:36,800 --> 18:40:41,192
测试看看这个数据库是否已经打开你看看我们是否有一个实例

627
18:40:41,192 --> 18:40:44,640
这个数据库然后我们可以假设这个数据库文件有

628
18:40:44,640 --> 18:40:48,240
已经打开了，我们不必再打开了，所以我们就说如果

629
18:40:48,240 --> 18:40:51,920
数据库不为空

630
18:40:51,920 --> 18:40:54,240
然后扔

631
18:40:54,240 --> 18:40:59,832
呃，一个新的例外，我们就称它为一个已经打开的数据库

632
18:40:59,832 --> 18:41:04,240
异常所以让我们去定义一个异常

633
18:41:04,240 --> 18:41:07,040
呃这里

634
18:41:07,040 --> 18:41:12,640
让我看看我是否可以从我的笔记中复制并粘贴它

635
18:41:12,640 --> 18:41:15,512
但是你看到这只是一个例外，它是一个数据库已经打开的例外

636
18:41:15,512 --> 18:41:20,080
好的，所以在这里我们只是说数据库已经打开异常

637
18:41:20,080 --> 18:41:23,440
如果你调用 open 函数就很简单

638
18:41:23,440 --> 18:41:27,120
在数据库已经打开的情况下多次您将获得一个

639
18:41:27,120 --> 18:41:30,160
例外好吧，所以这种情况是有道理的

640
18:41:30,160 --> 18:41:34,160
所以让我们继续，现在获取文档

641
18:41:34,160 --> 18:41:37,360
目录路径，我们必须在这里尝试

642
18:41:37,360 --> 18:41:42,400
因为这实际上可以抛出异常所以让我们说find final

643
18:41:42,400 --> 18:41:46,000
文档路径等于

644
18:41:46,000 --> 18:41:50,960
如果你需要，你需要说获取文件获取应用程序文件目录

645
18:41:50,960 --> 18:41:54,960
看看这个方法的签名它说我返回一个未来

646
18:41:54,960 --> 18:41:59,192
目录，所以让我们继续这样做，所以我们需要等待它，这就是

647
18:41:59,192 --> 18:42:02,320
我们的函数是异步的，这就是我们等待的原因，因为这个

648
18:42:02,320 --> 18:42:06,080
如果您查看，现在异步返回路径

649
18:42:06,080 --> 18:42:10,640
这个文档你可以看到它实际上可以抛出一个异常

650
18:42:10,640 --> 18:42:14,240
如果系统无法访问，则称为缺少平台目录异常

651
18:42:14,240 --> 18:42:18,160
如果出于某种原因，请提供目录

652
18:42:18,160 --> 18:42:21,440
系统无法提供文档目录

653
18:42:21,440 --> 18:42:25,192
嗯，我们会抛出这个异常，这正是我们为什么

654
18:42:25,192 --> 18:42:29,600
将我们的代码放在这里的 try 语句中，所以让我们说如果该异常是

655
18:42:29,600 --> 18:42:34,640
像这样抛出然后我们将抛出我们自己的异常，所以让我们定义

656
18:42:34,640 --> 18:42:40,720
我们称之为无法获取文档目录的异常

657
18:42:40,720 --> 18:42:44,800
这只是一个无法获取文档目录的类

658
18:42:44,800 --> 18:42:49,040
例外没什么特别的

659
18:42:49,040 --> 18:42:53,832
然后我们在这里说投掷

660
18:42:53,832 --> 18:42:56,872
呃名字缺少平台哦我看到你了

661
18:42:56,872 --> 18:43:00,872
看到它现在在抱怨，我可以看到你看不到我的代码

662
18:43:00,872 --> 18:43:04,480
为它在抱怨并说我找不到这个丢失而道歉

663
18:43:04,480 --> 18:43:10,000
平台目录异常，那是因为在这个um中指定了这个

664
18:43:10,000 --> 18:43:14,160
路径提供者，但对于我们的路径提供者，我们只说 show get

665
18:43:14,160 --> 18:43:18,000
获取应用程序文档目录，以便对我们隐藏所有其他符号

666
18:43:18,000 --> 18:43:21,680
我们可以删除它并导入整个路径提供程序，然后

667
18:43:21,680 --> 18:43:26,400
错误消失了

668
18:43:26,400 --> 18:43:31,440
好的，现在让我们这样做现在让我们说

669
18:43:31,440 --> 18:43:35,600
抱歉，让我们了解一下我们的实际路径

670
18:43:35,600 --> 18:43:41,120
数据库，这样做你会说，我们叫它什么 db path is equal

671
18:43:41,120 --> 18:43:45,832
加入请记住，我们在这里加入了我们从路径导入的这个函数

672
18:43:45,832 --> 18:43:51,760
我们说加入文档路径路径和我们的数据库名称

673
18:43:51,760 --> 18:43:55,512
记住数据库名称是一个常量作为字符串，我们在这里定义它，我们只是

674
18:43:55,512 --> 18:43:59,440
调用将要加入的 notes db

675
18:43:59,440 --> 18:44:04,240
我们文档文件夹的实际路径

676
18:44:04,240 --> 18:44:07,512
我们要做的是我们要说我们现在想要

677
18:44:07,512 --> 18:44:11,920
使用名为 open database 的函数打开数据库，该函数来自

678
18:44:11,920 --> 18:44:16,240
skflight 并且路径是 dbpath 并记住这一点

679
18:44:16,240 --> 18:44:22,480
我相信开放数据库是您看到的我们数据库的未来，所以我们等待它

680
18:44:22,480 --> 18:44:25,040
好的和

681
18:44:25,040 --> 18:44:29,832
然后我们将它分配给我们的本地数据库实例

682
18:44:29,832 --> 18:44:34,320
所以这基本上是在打开数据库所以我们现在已经打开了

683
18:44:34,320 --> 18:44:37,280
但记住

684
18:44:37,280 --> 18:44:44,320
我们现在所做的只是在这个用于 sqlite 的数据库浏览器中

685
18:44:44,320 --> 18:44:47,680
这个程序在这里管理它的东西

686
18:44:47,680 --> 18:44:52,160
自己的数据库文件这个数据库文件不会存在于你的颤振中

687
18:44:52,160 --> 18:44:56,160
我们刚刚玩过的应用程序 我刚刚向您展示了如何创建一个 sqlite

688
18:44:56,160 --> 18:45:01,040
数据库如何创建不同的表什么字段是什么主键是什么

689
18:45:01,040 --> 18:45:05,192
你需要有点像忘记这个应用程序以及它在哪里

690
18:45:05,192 --> 18:45:09,040
存储您现在需要的数据

691
18:45:09,040 --> 18:45:12,400
颤振应用程序将能够创建这些表你的颤振怎么样

692
18:45:12,400 --> 18:45:16,552
应用程序将从表中重新读取数据或从表中删除数据

693
18:45:16,552 --> 18:45:19,680
这张桌子，所以如果你考虑一下，如果你有

694
18:45:19,680 --> 18:45:24,800
完全忘记了sqlite的db浏览器，那么你可以

695
18:45:24,800 --> 18:45:28,480
只是说此时你看到打开的数据库也可以创建

696
18:45:28,480 --> 18:45:33,280
如果数据库不存在，我们可以查看它的文档

697
18:45:33,280 --> 18:45:37,280
在这里，哦，天哪，在给定的路径上打开数据库

698
18:45:37,280 --> 18:45:41,360
系统 uh on 是第一个让我们看看 encrypt 是

699
18:45:41,360 --> 18:45:45,192
如果在调用 opendatabase 之前数据库不存在，则调用它

700
18:45:45,192 --> 18:45:48,872
可以为您创建数据库，这就是它要做的，但那些表是

701
18:45:48,872 --> 18:45:52,640
不会存在，我们必须有一种方法来创建这些表，如果他们

702
18:45:52,640 --> 18:45:57,280
在我们打开数据库时就不存在了，这就是我们要在这里做的

703
18:45:57,280 --> 18:46:04,960
所以让我们继续并实际获取用于创建用户表的代码，所以我

704
18:46:04,960 --> 18:46:11,192
只是说 const create user table 等于，现在是

705
18:46:11,192 --> 18:46:14,240
我将实际使用我们以前没有使用过的语法，那就是

706
18:46:14,240 --> 18:46:18,320
三引号没问题，然后三引号上

707
18:46:18,320 --> 18:46:23,120
下一行，然后是分号，现在它的作用是它允许您放置

708
18:46:23,120 --> 18:46:27,120
该字符串中的几乎所有内容，而无需转义该字符串

709
18:46:27,120 --> 18:46:31,832
因为三引号非常独特，所以如果您粘贴任何其他程序

710
18:46:31,832 --> 18:46:34,960
这里的编程语言代码很可能是编程语言

711
18:46:34,960 --> 18:46:40,480
代码不会包含三个三个引号，所以目的

712
18:46:40,480 --> 18:46:45,280
这就是现在您可以在您的 sqlite uh db 浏览器中继续使用 sqlite 和

713
18:46:45,280 --> 18:46:51,280
抓住那些用户，嗯，如果我去这里数据库结构用户修改表和

714
18:46:51,280 --> 18:46:55,280
您现在可以从字面上获取由 db 浏览器创建的代码

715
18:46:55,280 --> 18:47:02,872
sqlite 并将其粘贴在这里你看到所以我们现在你有一个漂亮的

716
18:47:02,872 --> 18:47:06,720
此处的数据库创建代码对不起表创建代码说创建

717
18:47:06,720 --> 18:47:11,920
table user blah blah id integer not null 但是我们需要注意

718
18:47:11,920 --> 18:47:17,832
这里有一些东西，我们只是说如果不存在，我相信

719
18:47:17,832 --> 18:47:22,080
我们也必须把它放在用户面前，所以这是我们唯一的事情

720
18:47:22,080 --> 18:47:26,240
在这里添加我们基本上是说如果没有创建一个表调用用户

721
18:47:26,240 --> 18:47:29,440
存在是因为您看到我们不想出错

722
18:47:29,440 --> 18:47:32,800
因为如果您创建一个已经存在于数据库中的表，那么

723
18:47:32,800 --> 18:47:35,512
skflight 会抛出一个错误，说这个表已经存在

724
18:47:35,512 --> 18:47:42,160
好的，这就是为什么如果不存在我们需要，然后我们需要做的是告诉

725
18:47:42,160 --> 18:47:46,240
我们的数据库 我们在此处创建的用于执行该命令的数据库

726
18:47:46,240 --> 18:47:49,440
所以我们只会说执行，你看它说给我一个续集

727
18:47:49,440 --> 18:47:52,720
执行，我会给你一个未来的空虚，我们说好吧执行

728
18:47:52,720 --> 18:47:59,680
创建用户表，我们等待它

729
18:47:59,680 --> 18:48:04,960
一些评论在这里我们只是说创建用户表

730
18:48:04,960 --> 18:48:10,872
然后在我们执行完创建用户后在这里为嗯

731
18:48:10,872 --> 18:48:17,192
表我们还必须照顾呃创建我们的笔记表

732
18:48:17,192 --> 18:48:20,640
所以我会做和我们在这里做的一样的事情，然后说创建

733
18:48:20,640 --> 18:48:23,440
笔记表

734
18:48:23,440 --> 18:48:28,480
等于单引号 三单引号分号 让我们去 db

735
18:48:28,480 --> 18:48:34,240
sqlite 的浏览器并在此处获取此节点并说修改表并获取

736
18:48:34,240 --> 18:48:38,080
为您生成的代码并将其粘贴到此处进行一些格式化，因此

737
18:48:38,080 --> 18:48:42,400
它变得更容易阅读和查看，我们会做

738
18:48:42,400 --> 18:48:47,600
和我们在上面做的一样，我们说如果不存在就好了

739
18:48:47,600 --> 18:48:50,480
所以我想我想对你说实话

740
18:48:50,480 --> 18:48:53,600
我们很高兴去那里我认为我们不需要在那里做任何特别的事情

741
18:48:53,600 --> 18:48:57,680
还必须执行该命令，所以我要从那里获取代码

742
18:48:57,680 --> 18:49:02,400
把它贴在这里，就像那样，我要说

743
18:49:02,400 --> 18:49:07,680
创建便笺表，以便将便笺表创建为

744
18:49:07,680 --> 18:49:11,600
干得好，这是一个很大的

745
18:49:11,600 --> 18:49:14,480
功能我的意思是我们所拥有的标准

746
18:49:14,480 --> 18:49:17,512
到目前为止，这是一个相当大的功能，可以，但通常不是

747
18:49:17,512 --> 18:49:21,192
考虑到这么大的功能，我现在记得你实际上有常量

748
18:49:21,192 --> 18:49:27,832
在这里你能不能我的意思是如果是我决定我会带这个

749
18:49:27,832 --> 18:49:32,640
不在这个函数内的其他地方的常量，我们可以从字面上继续我

750
18:49:32,640 --> 18:49:36,080
意思是我没有为此计划，但让我们继续从

751
18:49:36,080 --> 18:49:39,192
在这里，把它带到这个文件的末尾好吧，我们有所有其他的

752
18:49:39,192 --> 18:49:42,720
像这样的常量，让我们去抓取另一个常量

753
18:49:42,720 --> 18:49:44,640
从这里嘘

754
18:49:44,640 --> 18:49:49,832
把它也记下来，所以我们把它放在我们文件的末尾

755
18:49:49,832 --> 18:49:52,080
好吧，就像我说的那样我没有计划，但是

756
18:49:52,080 --> 18:49:55,832
我只是认为这是有道理的，因为现在我们的功能更干净了

757
18:49:55,832 --> 18:49:58,552
看这里我们有一个创建用户表的评论让我们创建一个

758
18:49:58,552 --> 18:50:03,440
在这里我们也说创建注释表

759
18:50:03,440 --> 18:50:08,800
并删除那些空白空间并完美保存您的文件

760
18:50:08,800 --> 18:50:14,552
现在我们有了 open 函数，让我们继续看看我们如何

761
18:50:14,552 --> 18:50:19,600
可以关闭我们的数据库吗让我们看看

762
18:50:19,600 --> 18:50:24,000
我的笔记在这里好吧让我们看看我们的

763
18:50:24,000 --> 18:50:28,160
关闭代码所以我要在这里折叠 open 函数所以我们看不到它

764
18:50:28,160 --> 18:50:32,320
让我们继续进行创作，正如您在我们必须要做的标题中看到的那样

765
18:50:32,320 --> 18:50:39,360
说future void close um好的，它是异步的，所以

766
18:50:39,360 --> 18:50:43,760
那么我们需要做的是我们不应该允许任何人关闭数据库

767
18:50:43,760 --> 18:50:47,920
如果数据库没有打开，那么让我们继续为它定义一个异常

768
18:50:47,920 --> 18:50:52,720
我们将调用数据库未打开好吧，所以我要复制它

769
18:50:52,720 --> 18:50:56,480
例外，所以我不必手动手动输入，因为此时

770
18:50:56,480 --> 18:51:00,400
你知道如何创建异常，所以对你来说没什么特别的

771
18:51:00,400 --> 18:51:02,960
学习数据库未打开，这是一个新的

772
18:51:02,960 --> 18:51:06,160
例外好吧，所以我们要做的是我们要去

773
18:51:06,160 --> 18:51:10,000
说我们有我们的数据库最终数据库是相等的

774
18:51:10,000 --> 18:51:15,832
到我们当地的数据库，我们说如果数据库为空

775
18:51:15,832 --> 18:51:22,960
然后我们抛出数据库未打开 oops 数据库

776
18:51:22,960 --> 18:51:28,720
没有打开，否则我们会要求 skflight 关闭

777
18:51:28,720 --> 18:51:33,120
该数据库对我们来说以及做到这一点的方法就是说 db.close 并且您可以

778
18:51:33,120 --> 18:51:37,120
看到这是一个虚无的未来，所以这就是我们等待它的原因

779
18:51:37,120 --> 18:51:40,640
然后到那时我们还必须重置这个本地数据库

780
18:51:40,640 --> 18:51:45,512
称为下划线数据 underscore db 所以我们说 db 等于 no

781
18:51:45,512 --> 18:51:52,480
就这么简单 peasy close 实际上很快

782
18:51:52,480 --> 18:51:55,040
好的

783
18:51:55,040 --> 18:51:58,960
现在我们需要你看到我们现在因为我们必须打开和关闭现在我们是

784
18:51:58,960 --> 18:52:02,160
将开始处理数据库中的数据，但是

785
18:52:02,160 --> 18:52:06,240
为了让你变得像你的嗯

786
18:52:06,240 --> 18:52:11,920
数据库，以便它可以例如实际抓取

787
18:52:11,920 --> 18:52:15,280
就像每个试图从数据库中读取内容的函数一样

788
18:52:15,280 --> 18:52:18,400
有一些代码以确保数据库是打开的，否则它

789
18:52:18,400 --> 18:52:21,920
必须抛出一个错误，所以我们将拥有 5 6 个这样的函数

790
18:52:21,920 --> 18:52:25,360
每个人都会检查数据库然后做同样的事情是

791
18:52:25,360 --> 18:52:28,960
数据库打开是的，如果它没有打开抛出这个错误，我们可以把那个

792
18:52:28,960 --> 18:52:33,360
我们将调用 getdatabase 或函数的特定代码

793
18:52:33,360 --> 18:52:38,240
throw 好吧，让我们继续在这里，只是说这个函数返回一个

794
18:52:38,240 --> 18:52:43,120
数据库它数据库或抛出

795
18:52:43,120 --> 18:52:45,600
并在它前面加上下划线表示

796
18:52:45,600 --> 18:52:50,480
这是一个私有函数，然后我们会说 final db is db

797
18:52:50,480 --> 18:52:54,400
如果 db 为空

798
18:52:54,400 --> 18:52:59,600
我们说throw um database is not open

799
18:52:59,600 --> 18:53:04,080
否则我们会返回数据库，所以这是一个

800
18:53:04,080 --> 18:53:08,720
我们在这个类中读写内部函数的私有函数

801
18:53:08,720 --> 18:53:12,160
将使用以获取当前数据库，以便他们避免

802
18:53:12,160 --> 18:53:16,400
到处都做同样的 if 语句没问题

803
18:53:16,400 --> 18:53:21,360
好的，现在我们将从实际代码开始，所以

804
18:53:21,360 --> 18:53:24,240
在这种情况下，从数据库读取和写入，我们将从一个

805
18:53:24,240 --> 18:53:29,440
称为删除用户的功能，允许我们提供您可以看到的电子邮件

806
18:53:29,440 --> 18:53:32,320
地址并使用该电子邮件地址，然后我们

807
18:53:32,320 --> 18:53:36,160
将从我们的数据库中删除该用户，以便您学习如何操作

808
18:53:36,160 --> 18:53:40,960
来自我们或我们数据库中的数据

809
18:53:40,960 --> 18:53:44,400
所以让我们继续做那个函数签名，因为它在这里表明我是

810
18:53:44,400 --> 18:53:47,512
只是说未来无效删除用户

811
18:53:47,512 --> 18:53:54,480
并且需要 uh string email 并使这个函数异步好

812
18:53:54,480 --> 18:53:57,440
那么我们要做的就是得到我们的

813
18:53:57,440 --> 18:54:01,440
数据库具有这个绝对漂亮的获取数据库或抛出函数，我们

814
18:54:01,440 --> 18:54:06,160
在这里创建，所以我只想说最终的 vb 是获取数据库或抛出

815
18:54:06,160 --> 18:54:10,160
这反过来又会抛出一个名为 database it's not open 的异常

816
18:54:10,160 --> 18:54:12,720
如果数据库没有打开所以我们不必

817
18:54:12,720 --> 18:54:17,680
手动这样做没关系，所以为了删除一些东西

818
18:54:17,680 --> 18:54:22,640
从 sql flight uh 或者在这种情况下由 sqflight 管理的 sqlite 我们

819
18:54:22,640 --> 18:54:28,872
可以说 db dot db dot delete ，如您所见

820
18:54:28,872 --> 18:54:33,040
返回被删除的行数的未来，然后它说好的

821
18:54:33,040 --> 18:54:37,760
哪个表，然后是 where 子句和要传递给您的单词的对象列表

822
18:54:37,760 --> 18:54:42,832
子句，所以我们要说从用户表中删除

823
18:54:42,832 --> 18:54:46,800
呃这个词从句将是

824
18:54:46,800 --> 18:54:52,160
电子邮件等于某物，在这种情况下，艺术在哪里

825
18:54:52,160 --> 18:54:56,960
将电子邮件转为小写好的，所以我要放这个

826
18:54:56,960 --> 18:55:00,720
那里的分号和这里的电话，然后我们将等待它，我们

827
18:55:00,720 --> 18:55:05,600
要说最终和删除帐户是一个重量

828
18:55:05,600 --> 18:55:09,040
所以在这种情况下，我的意思是如你所见，我们基本上在做的是

829
18:55:09,040 --> 18:55:12,720
只是我们正在格式化我们要说我们要说删除

830
18:55:12,720 --> 18:55:17,120
用户表中的某些内容，只要该内容的电子邮件等于

831
18:55:17,120 --> 18:55:21,680
某事，那某事又是那封电子邮件，所以您基本上是在说

832
18:55:21,680 --> 18:55:25,192
在用户中删除尽可能多的对象

833
18:55:25,192 --> 18:55:29,512
表，只要他们的电子邮件与此相同，并记住我们使电子邮件独一无二

834
18:55:29,512 --> 18:55:34,400
因此，如果我们正确地完成了作业，那么删除计数应该是

835
18:55:34,400 --> 18:55:40,000
为零表示没有个人帐户或没有使用此电子邮件的用户

836
18:55:40,000 --> 18:55:45,600
存在于表中，或者它应该是一个意思，是的，我可以删除呃

837
18:55:45,600 --> 18:55:49,040
没有问题所以

838
18:55:49,040 --> 18:55:53,360
我们实际上会断言我们会说如果删除计数

839
18:55:53,360 --> 18:55:55,600
不是一个

840
18:55:55,600 --> 18:55:59,280
好吧，那么我们将抛出一个错误，无法删除用户，所以我

841
18:55:59,280 --> 18:56:04,000
我会抓住那个例外我会把它放在这里

842
18:56:04,000 --> 18:56:07,832
所以我们说如果我们不能删除那个用户，我们只会说 throw 可以

843
18:56:07,832 --> 18:56:12,960
不删除用户好吗

844
18:56:12,960 --> 18:56:18,872
所以我们不能删除那个用户

845
18:56:18,872 --> 18:56:22,400
嗯，好吧，让我们继续吧

846
18:56:22,400 --> 18:56:26,872
现在我们已经完成了删除用户并且记住你可能会问好的

847
18:56:26,872 --> 18:56:30,080
为什么我们要抛出一个用户，也许那个用户不存在，它应该只是

848
18:56:30,080 --> 18:56:33,832
工作正常，当然我的意思是如果你有它会正常工作

849
18:56:33,832 --> 18:56:37,192
调用此函数时的 try 和 catch 语句

850
18:56:37,192 --> 18:56:40,640
我们所说的是节点服务的接口将抛出一个

851
18:56:40,640 --> 18:56:45,120
如果您使用不存在的电子邮件呼叫主要用户，则会因异常而出错

852
18:56:45,120 --> 18:56:49,512
这对于服务来说完全没问题，但是你在哪里消费

853
18:56:49,512 --> 18:56:53,920
服务然后你可以管理并说哦这个删除功能会抛出

854
18:56:53,920 --> 18:56:57,040
一个例外，例如查看文档查看

855
18:56:57,040 --> 18:57:01,600
代码然后我将在调用站点处理它

856
18:57:01,600 --> 18:57:06,080
这被称为好的，所以这完全没问题

857
18:57:06,080 --> 18:57:10,080
做一个服务然后我们接下来要做的

858
18:57:10,080 --> 18:57:13,512
重点是创建一个用户，你可以看到

859
18:57:13,512 --> 18:57:16,960
这将是数据库用户的未来，所以这很漂亮

860
18:57:16,960 --> 18:57:20,160
实际上创建一个给定电子邮件地址的用户，然后它会返回

861
18:57:20,160 --> 18:57:23,920
那个数据库用户给我们，所以让我们继续做吧，让我们说

862
18:57:23,920 --> 18:57:27,192
未来的数据库用户

863
18:57:27,192 --> 18:57:33,920
我们会说创建用户和电子邮件的必需字符串字段

864
18:57:33,920 --> 18:57:37,120
我们要让它异步

865
18:57:37,120 --> 18:57:40,000
所以在这里我们要做的就是获取我们正在使用的数据库

866
18:57:40,000 --> 18:57:44,960
要说最终的vb等于获取db数据库或抛出

867
18:57:44,960 --> 18:57:49,192
然后我们会说 um db.query

868
18:57:49,192 --> 18:57:53,600
嗯，因为我们实际上要向数据库发出查询

869
18:57:53,600 --> 18:57:56,160
好的，你可以看到这是一个帮助

870
18:57:56,160 --> 18:57:59,760
查询表和返回项发现所有可选子句都未过滤或

871
18:57:59,760 --> 18:58:03,512
格式化为 sql 查询没问题

872
18:58:03,512 --> 18:58:08,800
所以嗯，让我们继续，在这里我们首先要做的是

873
18:58:08,800 --> 18:58:13,120
我们要加密用户的第一件事现在我们要实际检查一个

874
18:58:13,120 --> 18:58:17,600
具有给定电子邮件的用户已经存在，这就是我们这样做的原因

875
18:58:17,600 --> 18:58:20,720
查询，我们不喜欢在数据库中插入一些东西来开始

876
18:58:20,720 --> 18:58:26,552
我们要求数据在用户表中说嘿

877
18:58:26,552 --> 18:58:31,680
我们正在寻找并且我们正在为一个人或一个用户获取数据库

878
18:58:31,680 --> 18:58:36,640
谁的电子邮件是这个，这个东西实际上会返回，让我们

879
18:58:36,640 --> 18:58:41,760
看看它，它将返回一个可用的行列表

880
18:58:41,760 --> 18:58:47,192
数据库没问题，如果没有，该列表将为空

881
18:58:47,192 --> 18:58:51,920
没有实体与我们的查询相匹配，所以我们称之为最终结果是

882
18:58:51,920 --> 18:58:57,440
我们正在查询用户表，我们会说嗯

883
18:58:57,440 --> 18:59:00,720
我们只寻找一件商品

884
18:59:00,720 --> 18:59:05,832
我们有一个词等于我们正在寻找电子邮件以及在哪里

885
18:59:05,832 --> 18:59:09,120
艺术将是

886
18:59:09,120 --> 18:59:15,600
电子邮件末尾的小写分号并像这样带来

887
18:59:15,600 --> 18:59:21,040
等于 bb，我们等着没关系

888
18:59:21,040 --> 18:59:25,512
所以我们首先对数据库进行查询，然后

889
18:59:25,512 --> 18:59:30,400
检查是否存在使用相同电子邮件的用户，我们基本上是在避免

890
18:59:30,400 --> 18:59:34,552
稍后收到该电子邮件唯一性的错误

891
18:59:34,552 --> 18:59:38,080
在 sql 层

892
18:59:38,080 --> 18:59:43,512
所以在这种情况下，如果我将鼠标移到它上面，你可以看到结果，它说

893
18:59:43,512 --> 18:59:48,480
它是行列表，如果此列表不为空

894
18:59:48,480 --> 18:59:52,960
它的字面意思是已经存在具有该公司但没有电子邮件地址的用户

895
18:59:52,960 --> 18:59:56,240
在数据库中所以让我们说如果

896
18:59:56,240 --> 19:00:00,720
results 不为空，然后我们会说 throw

897
19:00:00,720 --> 19:00:04,872
用户已经存在呃异常，我们没有那个

898
19:00:04,872 --> 19:00:10,160
例外，所以让我们继续，至少为我找到那个例外，

899
19:00:10,160 --> 19:00:14,480
我可以在这里粘贴它，所以已经定义了这个异常使用

900
19:00:14,480 --> 19:00:18,000
存在，让我们继续扔那个

901
19:00:18,000 --> 19:00:22,320
异常用户已经存在好吧

902
19:00:22,320 --> 19:00:25,512
这就是我们的 if 语句，所以那时我们已经

903
19:00:25,512 --> 19:00:30,640
基本上确定数据库中不存在那个用户就好了

904
19:00:30,640 --> 19:00:35,600
所以我们需要做的是现在去插入那个用户

905
19:00:35,600 --> 19:00:38,400
我们已经检查了他或她在数据库中不存在所以我们必须去

906
19:00:38,400 --> 19:00:42,640
并插入该用户，所以我们这样做的方式是去告诉我们的

907
19:00:42,640 --> 19:00:47,832
数据库我们说 db insert ，你可以看到它说在哪个表中，然后给出

908
19:00:47,832 --> 19:00:52,640
我是键和值的映射，它是列名

909
19:00:52,640 --> 19:00:56,800
并且该列的值没问题，所以假设我们插入

910
19:00:56,800 --> 19:01:00,160
用户表，这是我们定义的常量

911
19:01:00,160 --> 19:01:03,440
在记住之前，然后地图将是

912
19:01:03,440 --> 19:01:09,680
对于呃，让我们回到我们的 sql 数据库浏览器，请注意对不起用户

913
19:01:09,680 --> 19:01:13,360
哎呀用户

914
19:01:13,360 --> 19:01:18,160
我们有 id 这是主键不为空和自动递增，所以我们不必

915
19:01:18,160 --> 19:01:22,720
插入 id 但我们需要插入电子邮件所以让我们继续说我们有

916
19:01:22,720 --> 19:01:26,960
电子邮件呼叫等于 b 它将等于

917
19:01:26,960 --> 19:01:32,800
电子邮件转为小写就可以了，如果可以的话，请插入

918
19:01:32,800 --> 19:01:37,120
看看这里它会返回一个 pin 的功能，如果你阅读了文档

919
19:01:37,120 --> 19:01:42,480
呃，让我们看看它是否在这里给我们提供了一些文档

920
19:01:42,480 --> 19:01:46,320
某些特定的冲突算法算法算法可以返回零

921
19:01:46,320 --> 19:01:50,400
如果没有插入，那么这基本上会给我们

922
19:01:50,400 --> 19:01:53,440
呃，在这种情况下它要做的是

923
19:01:53,440 --> 19:01:57,040
实际上会给我们一个用户ID我希望有一些好的文档

924
19:01:57,040 --> 19:02:01,360
关于它哦，在这里你可以看到它说插入

925
19:02:01,360 --> 19:02:06,080
返回 id 所以这非常非常好这是

926
19:02:06,080 --> 19:02:10,552
实际上真的很酷，因为记得我们说过我们返回一个数据库用户和一个

927
19:02:10,552 --> 19:02:13,360
数据库用户实际上有一个 id 所以

928
19:02:13,360 --> 19:02:18,240
如果这里的这个函数没有返回 id 那么我们将如何获得 id

929
19:02:18,240 --> 19:02:21,832
我们必须插入然后读取同一个用户才能获得 id 但我们

930
19:02:21,832 --> 19:02:25,440
不必这样做所以在这里然后我们说最终

931
19:02:25,440 --> 19:02:30,552
我们说用户 id 等于等待这个函数功能

932
19:02:30,552 --> 19:02:37,192
然后我们只返回一个数据库用户，这样你就可以看到代码然后我们

933
19:02:37,192 --> 19:02:41,680
说用户 ID，电子邮件是以前的电子邮件

934
19:02:41,680 --> 19:02:46,800
他们在那里添加了一个很棒的专栏，现在我们已经处理好了

935
19:02:46,800 --> 19:02:49,192
创建用户呃

936
19:02:49,192 --> 19:02:52,552
在我们的数据库中运行，这样就创建了我要关注的用户，所以现在我们

937
19:02:52,552 --> 19:02:56,320
有创建用户删除用户和打开和关闭和私有功能

938
19:02:56,320 --> 19:03:00,640
为了获取当前数据库没问题

939
19:03:00,640 --> 19:03:05,120
正如标题所示，现在我们必须处理一个名为 get user 的函数

940
19:03:05,120 --> 19:03:10,240
它可以检索给定其电子邮件地址的用户，所以

941
19:03:10,240 --> 19:03:14,552
我要继续，基本上写那个函数签名

942
19:03:14,552 --> 19:03:18,552
在这里通过从我的笔记中粘贴它，所以我不必手动输入它，但你

943
19:03:18,552 --> 19:03:22,720
把它放在标题中，以防你需要去看它，我们就像我们在

944
19:03:22,720 --> 19:03:25,360
我们将获取当前数据库或抛出错误的其他函数

945
19:03:25,360 --> 19:03:31,360
如果数据库没有打开，那么我们会说 db 是获取数据库或抛出

946
19:03:31,360 --> 19:03:35,192
那么我们要做的是查询数据库

947
19:03:35,192 --> 19:03:38,552
电子邮件地址，如果您记得在创建用户中我们已经这样做了，那么让我们

948
19:03:38,552 --> 19:03:41,040
去复制那个书包

949
19:03:41,040 --> 19:03:44,480
像这样，我将折叠创建用户和

950
19:03:44,480 --> 19:03:49,680
让我们在这里粘贴代码我们有结果

951
19:03:49,680 --> 19:03:53,512
所以在这种情况下，我们必须做与你在创建用户中看到的相反的事情

952
19:03:53,512 --> 19:03:56,800
检查以确保

953
19:03:56,800 --> 19:03:58,800
嗯

954
19:03:58,800 --> 19:04:02,080
结果实际上是空的，因为我们想在创建一个新的

955
19:04:02,080 --> 19:04:06,720
使用该电子邮件的用户该电子邮件尚不存在，但在这种情况下，我们

956
19:04:06,720 --> 19:04:09,760
当您想要获得我们想要创建的用户时，实际上必须做相反的事情

957
19:04:09,760 --> 19:04:15,360
确定它确实存在，所以我们必须说结果是否为空，这意味着我们

958
19:04:15,360 --> 19:04:20,240
找不到具有给定电子邮件地址的用户，然后我们说抛出

959
19:04:20,240 --> 19:04:24,800
找不到用户实际上我们还没有，所以我们

960
19:04:24,800 --> 19:04:28,640
需要定义一个名为找不到用户的新异常，我要带来

961
19:04:28,640 --> 19:04:33,192
它在这里就像我们必须删除用户一样

962
19:04:33,192 --> 19:04:36,800
找不到用户好吗，然后在这里我们必须抛出无法

963
19:04:36,800 --> 19:04:42,080
如果结果为空，则可以找到用户，然后我们抛出

964
19:04:42,080 --> 19:04:46,480
否则我们必须为用户构建一个数据库，所以我们说

965
19:04:46,480 --> 19:04:53,040
从行返回数据库用户，我们说结果

966
19:04:53,040 --> 19:04:57,280
dot first 这是读取的第一行

967
19:04:57,280 --> 19:04:59,192
来自

968
19:04:59,192 --> 19:05:03,832
用户表还记得我们设置了一个限制，所以它应该是

969
19:05:03,832 --> 19:05:08,000
它应该是零行或一行是用户

970
19:05:08,000 --> 19:05:11,512
给定的电子邮件地址没问题

971
19:05:11,512 --> 19:05:15,120
好吧，完美，嗯，让我们继续下一个我们必须做的功能

972
19:05:15,120 --> 19:05:19,280
实施，那是为了让我们能够创造新的

973
19:05:19,280 --> 19:05:23,440
节点，所以如果你想像我一样在这里清理一下代码

974
19:05:23,440 --> 19:05:28,000
把所有东西都折叠起来，这样你就只能看到函数签名了，现在我们可以专注于

975
19:05:28,000 --> 19:05:31,920
下一个创建节点的函数我只是要找到它

976
19:05:31,920 --> 19:05:37,440
在我的笔记中只是为了确保我给你准确的

977
19:05:37,440 --> 19:05:42,320
创建注释功能所需的代码

978
19:05:42,320 --> 19:05:47,832
呃，如果我能找到它，嗯，就在那里创建笔记，好吧

979
19:05:47,832 --> 19:05:50,640
正如标题所示，我们必须拥有

980
19:05:50,640 --> 19:05:55,760
一个称为创建节点的异步函数它返回一个数据库节点，它

981
19:05:55,760 --> 19:06:00,872
还说谁是这个节点的所有者，它只是要创建一个新节点

982
19:06:00,872 --> 19:06:06,552
带有一个空文本，它将把它和节点与给定的

983
19:06:06,552 --> 19:06:11,760
数据库用户，您可以看到参数的类型为数据库用户和

984
19:06:11,760 --> 19:06:16,000
获取用户的方法是创建一个，如果它不存在并且你得到

985
19:06:16,000 --> 19:06:20,000
数据库用户，或者你得到一个现有用户，所以

986
19:06:20,000 --> 19:06:24,552
对不起，让我们继续说未来的数据库用户

987
19:06:24,552 --> 19:06:28,160
我们称这个函数为节点表示创建节点，我们说它是一个

988
19:06:28,160 --> 19:06:33,512
数据库用户的必填字段糟糕，它不应该返回

989
19:06:33,512 --> 19:06:37,760
数据库用户应该是数据库节点，参数是

990
19:06:37,760 --> 19:06:43,440
owner 是数据库用户，它是一个异步函数

991
19:06:43,440 --> 19:06:48,080
所以就像我们在其他地方所做的那样，我们会说 final db 是 get

992
19:06:48,080 --> 19:06:53,512
或 throw 获取当前数据库或 throw

993
19:06:53,512 --> 19:06:57,600
所以我们首先需要做的就是确保我们的当前用户

994
19:06:57,600 --> 19:07:01,680
正在传递这里已经存在于数据库中，因为记住数据库用户

995
19:07:01,680 --> 19:07:06,240
只是一个类，它可以通过调用它的构造函数来创建，这是正确的

996
19:07:06,240 --> 19:07:09,920
在这里，嗯，这里的某个地方

997
19:07:09,920 --> 19:07:12,720
所以我可以创建一个新的数据库用户

998
19:07:12,720 --> 19:07:17,120
实例作为数据库用户和随机电子邮件和随机 id

999
19:07:17,120 --> 19:07:21,600
但是在这里，当我们尝试为该特定数据库用户创建节点时

1000
19:07:21,600 --> 19:07:24,800
我们需要首先确保该数据库用户实际上在

1001
19:07:24,800 --> 19:07:27,680
数据库没问题，我们说最后

1002
19:07:27,680 --> 19:07:31,120
bb用户等于await

1003
19:07:31,120 --> 19:07:36,480
我们实际上在这里调用了我们自己的 get user 函数，我们说 get user with

1004
19:07:36,480 --> 19:07:41,192
um 所有者的电子邮件在我们的电子邮件中

1005
19:07:41,192 --> 19:07:46,872
所以在这里我们实际上是在重用我们创建的代码

1006
19:07:46,872 --> 19:07:49,600
那么我们要做的是

1007
19:07:49,600 --> 19:07:54,552
检查这个数据库用户是否真的是所有者

1008
19:07:54,552 --> 19:07:58,320
看看我的意思是什么 我的意思是让我们

1009
19:07:58,320 --> 19:08:02,160
说我去把事情搞砸了，我说哦，我创建了一个新的实例

1010
19:08:02,160 --> 19:08:05,920
手动数据库用户而不插入数据库，这是一些 id

1011
19:08:05,920 --> 19:08:10,240
一种随机的 id，然后这是我知道存在于

1012
19:08:10,240 --> 19:08:12,960
数据库现在我们需要在我们的代码中做的是

1013
19:08:12,960 --> 19:08:18,160
只是为了确保您在数据库中提供的 id

1014
19:08:18,160 --> 19:08:22,160
这里的用户实际上是我们数据库中现有用户的 id 并做

1015
19:08:22,160 --> 19:08:26,552
我们可以从字面上使用我们之前编写的这个漂亮的小函数

1016
19:08:26,552 --> 19:08:30,240
这是我们的数据库用户的相等函数，它实际上检查了我们的

1017
19:08:30,240 --> 19:08:34,640
id 相对于其他数据库用户的 id 所以如果我们从字面上看

1018
19:08:34,640 --> 19:08:40,400
在这里说在这里我们说如果数据库用户不是进入我们的所有者

1019
19:08:40,400 --> 19:08:45,680
equal 等于运算符并取反它说 oh 如果它不等于 then

1020
19:08:45,680 --> 19:08:51,280
我们说 throw 找不到用户好吗

1021
19:08:51,280 --> 19:08:53,680
所以在这个地方之后

1022
19:08:53,680 --> 19:08:58,480
如果我们真的找到了该电子邮件的 db 用户并且 id 是确切的 id

1023
19:08:58,480 --> 19:09:01,760
作为所有者，我们实际上可以确定该用户确实存在于

1024
19:09:01,760 --> 19:09:05,360
具有正确电子邮件和正确 ID 的数据库可以，所以让我们输入

1025
19:09:05,360 --> 19:09:11,832
在这里发表评论并说确保所有者存在于数据库中

1026
19:09:11,832 --> 19:09:16,400
正确的 id 没关系

1027
19:09:16,400 --> 19:09:20,480
好吧，在我们完成之后，我们还必须注意实际创建

1028
19:09:20,480 --> 19:09:24,832
嗯，所以让我们继续创建一个

1029
19:09:24,832 --> 19:09:30,480
嗯文字在这里我们说文字是呃对不起我注意到你不能

1030
19:09:30,480 --> 19:09:35,440
看到那个代码我希望你至少看到这个代码

1031
19:09:35,440 --> 19:09:39,280
我在这里写的，但如果你不这样做，我会为此道歉，因为只是因为

1032
19:09:39,280 --> 19:09:43,760
我正在使用一个软件，我在我的主机上一直看不到该软件

1033
19:09:43,760 --> 19:09:47,760
监视器是我正在编码的监视器我必须查看辅助监视器

1034
19:09:47,760 --> 19:09:51,832
这是在这里，所以我正在尽我所能看看那个辅助显示器

1035
19:09:51,832 --> 19:09:54,640
确保您看到所有内容，但有时我可能会错过

1036
19:09:54,640 --> 19:09:57,832
我为此道歉，让我们看看

1037
19:09:57,832 --> 19:10:01,192
现在你可以看到这段代码了

1038
19:10:01,192 --> 19:10:05,040
所以让我们继续创建笔记，所以我要发表评论

1039
19:10:05,040 --> 19:10:10,160
在这里说我们现在的工作是创建笔记创建笔记

1040
19:10:10,160 --> 19:10:12,960
以及我们要说的我们要说的

1041
19:10:12,960 --> 19:10:16,800
db insert 就像我们之前为创建用户所做的插入一样

1042
19:10:16,800 --> 19:10:19,512
为笔记做一个数据库插入，它在

1043
19:10:19,512 --> 19:10:23,440
注释表，你会看到这里的值

1044
19:10:23,440 --> 19:10:27,680
成为一张地图，如果你看地图

1045
19:10:27,680 --> 19:10:31,440
插入函数实际上是字符串和对象的映射，所以

1046
19:10:31,440 --> 19:10:35,360
让我们看看这里的笔记表，您可以右键单击查看笔记

1047
19:10:35,360 --> 19:10:41,512
修改需要用户 ID 文本并与云列同步的表，让我们开始吧

1048
19:10:41,512 --> 19:10:46,160
提前说用户 ID 列用户 ID 调用

1049
19:10:46,160 --> 19:10:50,640
这是业主的身份证，我们还有什么我们有

1050
19:10:50,640 --> 19:10:54,800
文本列，这等于我们的文本

1051
19:10:54,800 --> 19:10:57,760
刚刚创建出来，基本上是一个空文本

1052
19:10:57,760 --> 19:11:00,960
你不必这样做 你不必做那部分 你可以从字面上看

1053
19:11:00,960 --> 19:11:03,440
就这么说

1054
19:11:03,440 --> 19:11:09,192
对我来说，如果我像这样事先定义这些东西会更易读

1055
19:11:09,192 --> 19:11:13,512
然后在这里我们只是说是同步的

1056
19:11:13,512 --> 19:11:19,040
cloud 列，在这种情况下它的值是 1 所以我们基本上是说

1057
19:11:19,040 --> 19:11:23,920
我们从那开始，好吧，我只是注意到我错过了一个

1058
19:11:23,920 --> 19:11:28,240
那里的列记住插入它返回插入对象的ID

1059
19:11:28,240 --> 19:11:34,160
数据库，它是一个未来，所以让我们说最后的注释 id 等于

1060
19:11:34,160 --> 19:11:41,512
等待该函数将注释插入注释表

1061
19:11:41,512 --> 19:11:44,960
好了，现在完成了，我们要

1062
19:11:44,960 --> 19:11:49,600
实际上返回一个新的笔记实例并返回一个数据库笔记所以我们是什么

1063
19:11:49,600 --> 19:11:51,832
在这里我们要说最后

1064
19:11:51,832 --> 19:11:56,480
note 等于数据库注释注释

1065
19:11:56,480 --> 19:12:00,160
对于 id，我们要说 note id，我会提出来，所以你看

1066
19:12:00,160 --> 19:12:02,872
更好

1067
19:12:02,872 --> 19:12:07,760
对于用户 ID，我们将说所有者 ID 文本是文本，所以这是另一个

1068
19:12:07,760 --> 19:12:11,440
有理由像我一样将它定义为常量，以便我们可以重用

1069
19:12:11,440 --> 19:12:14,640
它在这里和那里并与云同步我们应该做什么

1070
19:12:14,640 --> 19:12:19,280
我们应该说真的好吗

1071
19:12:19,280 --> 19:12:23,440
创建一个便笺，您必须将其返回，然后在您的 um 异步中

1072
19:12:23,440 --> 19:12:26,640
功能没问题，我也要在这里加一个逗号，以确保

1073
19:12:26,640 --> 19:12:31,360
格式已经到位，现在我们将注释插入到

1074
19:12:31,360 --> 19:12:37,120
数据库，我们还创建了一个数据库节点来从我们的函数中返回它

1075
19:12:37,120 --> 19:12:40,720
哇很多代码很多代码，但我希望

1076
19:12:40,720 --> 19:12:44,640
你在本章中一直坚持我，所以现在我们已经创建了笔记

1077
19:12:44,640 --> 19:12:47,760
正如标题所示，现在我们必须开发一个功能，使我们能够

1078
19:12:47,760 --> 19:12:52,000
删除一个节点，因为记住我们将允许用户选择一个节点

1079
19:12:52,000 --> 19:12:56,080
在数据库中稍后抱歉选择用户界面上的节点

1080
19:12:56,080 --> 19:12:59,832
用户自己已经创建并能够删除该注释，所以我们

1081
19:12:59,832 --> 19:13:04,720
需要一个允许我们使用它的 id 删除节点的函数

1082
19:13:04,720 --> 19:13:08,480
所以我们走吧，我只是要带上

1083
19:13:08,480 --> 19:13:12,160
此功能的基础知识或几乎整个功能实际上在这里

1084
19:13:12,160 --> 19:13:16,480
所以我们不必手动编写代码，我将把它粘贴到这里

1085
19:13:16,480 --> 19:13:19,512
正如你在这里看到的这个函数的签名我将解释它

1086
19:13:19,512 --> 19:13:23,280
直到这个函数的所有签名都被称为删除节点作为异步

1087
19:13:23,280 --> 19:13:27,600
作为屏幕底部的标题，以防我们执行 get db

1088
19:13:27,600 --> 19:13:31,512
然后我们实际上只是调用了删除函数，这正是

1089
19:13:31,512 --> 19:13:35,440
我相信我们在删除用户时所做的同样的事情让我们来看看

1090
19:13:35,440 --> 19:13:39,512
你在表中看到 delete count db delete

1091
19:13:39,512 --> 19:13:44,720
然后是你的工作条款，在这种情况下，在我们所说的删除注释中

1092
19:13:44,720 --> 19:13:50,000
从注释表中删除其列 id 等于的对象

1093
19:13:50,000 --> 19:13:54,720
一些东西，然后我们在 where arcs 中传递一些东西

1094
19:13:54,720 --> 19:14:00,160
现在，如果给定 id 的笔记不存在，我们无法删除任何内容

1095
19:14:00,160 --> 19:14:03,600
我们抛出了一个异常，称为无法删除节点，这是一个

1096
19:14:03,600 --> 19:14:07,120
我们尚未定义的异常，我们将不得不在

1097
19:14:07,120 --> 19:14:10,640
到目前为止我们已经定义的所有其他例外的底部，所以这是不可能的

1098
19:14:10,640 --> 19:14:14,320
删除节点可以执行异常

1099
19:14:14,320 --> 19:14:18,872
所以我想我的意思是我通常不会复制粘贴代码，即使它是我自己的代码

1100
19:14:18,872 --> 19:14:23,192
但我认为这是一个如此简单的代码，我们实际上已经完成了每个部分

1101
19:14:23,192 --> 19:14:28,000
在我们完成 get db 之前类似的事情我们之前已经完成了删除

1102
19:14:28,000 --> 19:14:32,480
我们以前做过这个 if 语句，所以这不是什么新鲜事，我不认为你

1103
19:14:32,480 --> 19:14:36,240
必须让我在这里花时间解释

1104
19:14:36,240 --> 19:14:38,872
同样的事情一遍又一遍，这就是为什么我复制粘贴这个删除

1105
19:14:38,872 --> 19:14:41,832
注意这里好

1106
19:14:41,832 --> 19:14:47,192
好吧，那么我们还需要能够删除所有节点

1107
19:14:47,192 --> 19:14:51,360
我们的数据库我们如何做到这一点，正如您所见，我们需要一个名为 future 的函数

1108
19:14:51,360 --> 19:14:55,760
表示从

1109
19:14:55,760 --> 19:14:59,920
我们称之为删除所有节点的数据库，它是一个异步函数

1110
19:14:59,920 --> 19:15:04,800
好的，我们需要在这里做的是

1111
19:15:04,800 --> 19:15:10,160
只是非常简单，我们要说 final db 等于 get 或 throw

1112
19:15:10,160 --> 19:15:14,800
然后我们说 db delete 然后我们就直接说 uh

1113
19:15:14,800 --> 19:15:22,000
注意 哎呀 注意 表 呃 繁荣 繁荣 等待 它 好吧

1114
19:15:22,000 --> 19:15:25,680
如果您发出删除命令，您会看到这一点

1115
19:15:25,680 --> 19:15:30,480
在具有给定表的数据库上，它所做的就是删除每个

1116
19:15:30,480 --> 19:15:35,832
在那个 uh 表中为您提供的行，它将返回之前的行数

1117
19:15:35,832 --> 19:15:38,872
受影响，因此您可以看到它返回受影响的行数，因此

1118
19:15:38,872 --> 19:15:44,960
正是我们想要返回的，所以只需在这个函数中返回那个值就行了

1119
19:15:44,960 --> 19:15:48,800
完美的好东西我们已经完成了一些大功能和一些

1120
19:15:48,800 --> 19:15:52,400
小功能，所以有一些小功能也很令人耳目一新

1121
19:15:52,400 --> 19:15:57,360
即使对我来说，所以我们现在需要做的是创造

1122
19:15:57,360 --> 19:16:02,240
获取您实际看到的特定节点的功能

1123
19:16:02,240 --> 19:16:05,920
进入我们将数据库内的所有节点渲染到的 ui

1124
19:16:05,920 --> 19:16:09,680
我们的用户在我们应用程序的主用户界面中，我们将列出所有

1125
19:16:09,680 --> 19:16:13,040
节点，然后如果用户按下任何特定节点，那么我们将

1126
19:16:13,040 --> 19:16:17,360
获取该节点的 id，然后从

1127
19:16:17,360 --> 19:16:21,192
数据库，这就是为什么我们需要一个函数来获取节点的 id 和

1128
19:16:21,192 --> 19:16:25,512
实际上从数据库中为我们抓取了那个节点，好吧

1129
19:16:25,512 --> 19:16:30,080
所以让我们继续编程，所以我要带上呃

1130
19:16:30,080 --> 19:16:33,760
我要带上函数签名，我们不会

1131
19:16:33,760 --> 19:16:37,832
这次复制粘贴它让我复制粘贴功能实际上我的意思是这样

1132
19:16:37,832 --> 19:16:43,040
让我们继续获取数据库，这样对您来说很容易，现在您知道该怎么做

1133
19:16:43,040 --> 19:16:46,400
我们要查询数据库所以我们只说最后的笔记

1134
19:16:46,400 --> 19:16:48,872
这将像

1135
19:16:48,872 --> 19:16:54,160
sqlite 数据库可以读取的地图的可迭代列表

1136
19:16:54,160 --> 19:16:58,640
所以我们要说等待数据库查询

1137
19:16:58,640 --> 19:17:01,920
我们要在注释表中说我要删除所有这些

1138
19:17:01,920 --> 19:17:06,872
覆盖，以便您看到代码更好的注释表，我们只会说

1139
19:17:06,872 --> 19:17:12,080
嗯，汇款一张，因为我们想得到一张纸条

1140
19:17:12,080 --> 19:17:17,040
并且单词从句将使用它的 id 你看我们要说

1141
19:17:17,040 --> 19:17:21,600
id 等于某物，而艺术将只是 id 本身

1142
19:17:21,600 --> 19:17:26,960
那种隆隆声和这样的分号

1143
19:17:26,960 --> 19:17:31,920
现在，如果这说明 uh 这是

1144
19:17:31,920 --> 19:17:36,080
如果 notes 为空，你可以看到它是一个列表，我们将抛出一个

1145
19:17:36,080 --> 19:17:40,552
例外所以我们会说嗯找不到笔记我们有吗

1146
19:17:40,552 --> 19:17:45,360
呃找不到用户我们找不到我们没有的笔记所以让我们去吧

1147
19:17:45,360 --> 19:17:48,800
定义它，我将把它从

1148
19:17:48,800 --> 19:17:52,400
我自己的笔记，所以我们不必手动编写

1149
19:17:52,400 --> 19:17:56,480
所以定义一个异常叫做找不到节点实现异常没关系

1150
19:17:56,480 --> 19:18:01,440
然后在这里我们只是抛出它找不到节点所以如果你给我们一个 id 我们

1151
19:18:01,440 --> 19:18:04,640
在数据库中找不到它，否则我们只是抛出一个异常

1152
19:18:04,640 --> 19:18:09,440
我们需要实际创建数据库节点的一个实例，所以我们说返回

1153
19:18:09,440 --> 19:18:17,600
来自行和节点的数据库注释首先可以，这与我们的操作方式相似

1154
19:18:17,600 --> 19:18:22,320
在获得用户之前

1155
19:18:22,320 --> 19:18:25,760
好吧，现在我们还需要

1156
19:18:25,760 --> 19:18:31,192
一种功能，使我们能够获取您看到的系统中的所有节点

1157
19:18:31,192 --> 19:18:35,440
获取节点以删除所有节点删除节点创建节点但我们没有任何节点

1158
19:18:35,440 --> 19:18:39,120
可以获取所有节点的功能，这就是我们的确切功能

1159
19:18:39,120 --> 19:18:42,872
将使用我们应用程序的主界面来渲染所有节点

1160
19:18:42,872 --> 19:18:46,872
给定的用户好吧

1161
19:18:46,872 --> 19:18:50,720
让我确保我在这里有这个功能

1162
19:18:50,720 --> 19:18:59,440
它被称为获取所有节点

1163
19:18:59,440 --> 19:19:03,440
让我们看看我们可以找到一个功能得到所有

1164
19:19:03,440 --> 19:19:06,480
某处的节点

1165
19:19:06,480 --> 19:19:11,920
创建我们有的注释得到我们有的用户

1166
19:19:11,920 --> 19:19:15,920
也许我现在实际上没有功能，我可以在我的

1167
19:19:15,920 --> 19:19:20,872
注意到我实际上并没有得到所有的笔记，但这实际上不是问题

1168
19:19:20,872 --> 19:19:25,832
在这里的获取说明中，您看到我们必须定义此获取

1169
19:19:25,832 --> 19:19:30,240
所有的笔记，所以让我们继续做吧，我要复制这个的签名

1170
19:19:30,240 --> 19:19:33,360
功能，我要把它带到这里，我们

1171
19:19:33,360 --> 19:19:35,760
会说我们要回归未来

1172
19:19:35,760 --> 19:19:39,832
数据库注释列表，我们说的是

1173
19:19:39,832 --> 19:19:46,552
像这样的所有笔记都可以，对不起，它不应该需要任何参数

1174
19:19:46,552 --> 19:19:50,320
我们只是要让数据库返回所有的笔记就好了

1175
19:19:50,320 --> 19:19:54,160
再次抱歉，我将复制该功能

1176
19:19:54,160 --> 19:19:58,400
从这里获取笔记

1177
19:19:58,400 --> 19:20:02,872
再次对不起，在这里我们现在不会限制

1178
19:20:02,872 --> 19:20:07,280
任何东西，我们没有任何地方的条款，好吧，就像我们一样

1179
19:20:07,280 --> 19:20:12,160
会从笔记表中说数据库查询，然后我们得到所有笔记，然后如果

1180
19:20:12,160 --> 19:20:15,440
笔记是空的，然后我们说找不到笔记

1181
19:20:15,440 --> 19:20:20,480
或者我们可以只说注释我们可以看到这是我们可以看到的列表

1182
19:20:20,480 --> 19:20:23,280
从字面上看，这里没有任何特殊的逻辑

1183
19:20:23,280 --> 19:20:27,192
说找不到笔记或任何东西，我要看看我的笔记

1184
19:20:27,192 --> 19:20:30,480
这里

1185
19:20:30,480 --> 19:20:33,600
很好，我们现在需要做的是

1186
19:20:33,600 --> 19:20:38,320
我们的笔记，我们可以映射它们，所以我们说笔记映射，你可以命名这个

1187
19:20:38,320 --> 19:20:42,960
参数 and 在你的映射中你需要说好的我得到一个数据库注释

1188
19:20:42,960 --> 19:20:46,480
你可以看到哪个类型让我看看我能不能把鼠标移到这里

1189
19:20:46,480 --> 19:20:51,600
这是一个字符串对象的映射，与我们的数据库注释完美匹配

1190
19:20:51,600 --> 19:20:56,320
但是从行然后你说从这个 n

1191
19:20:56,320 --> 19:21:00,720
让我们实际上称它为笔记行或类似的东西，我们把它放在那里

1192
19:21:00,720 --> 19:21:03,680
如果你说最终结果

1193
19:21:03,680 --> 19:21:06,640
现在我认为老实说这是一个高音，所以你可以看到它

1194
19:21:06,640 --> 19:21:10,640
一个可迭代的数据库注释好的，所以我们可以做的实际上是改变我们的

1195
19:21:10,640 --> 19:21:14,800
未来在这里而不是说列表我们返回 iturble 好吧

1196
19:21:14,800 --> 19:21:20,080
为了呃清洁，我也要改变我们的字幕

1197
19:21:20,080 --> 19:21:24,872
在这里说 iterable 以便您在屏幕上看到正确的信息

1198
19:21:24,872 --> 19:21:27,600
好吧好吧

1199
19:21:27,600 --> 19:21:32,160
所以这就是我们的结果所以我们需要在这里做的只是返回它就是这样

1200
19:21:32,160 --> 19:21:34,640
就这样

1201
19:21:34,640 --> 19:21:38,480
完美，嗯，这就是 get 的功能

1202
19:21:38,480 --> 19:21:43,760
所有节点，所以它很简单没什么特别的

1203
19:21:43,760 --> 19:21:47,680
现在我们需要做的就是

1204
19:21:47,680 --> 19:21:51,120
最后一个我们必须实现并记住的功能

1205
19:21:51,120 --> 19:21:54,080
当我们进入应用程序的主界面时，我们将允许

1206
19:21:54,080 --> 19:21:57,760
用户创建节点列出所有他们创建的节点，也可以点击

1207
19:21:57,760 --> 19:22:01,760
在任何特定节点上以更新该节点的内容，因此我们需要一个

1208
19:22:01,760 --> 19:22:08,800
函数名为 update note 所以让我们把我的笔记带到这里 update notes

1209
19:22:08,800 --> 19:22:13,600
所以让我们继续为该功能和未来创建签名

1210
19:22:13,600 --> 19:22:18,400
数据库注释，我们说更新注释

1211
19:22:18,400 --> 19:22:22,480
像这样，我们将有一些我们实际上需要的参数

1212
19:22:22,480 --> 19:22:27,512
抓取一个现有的数据库注释对象，然后我们

1213
19:22:27,512 --> 19:22:31,360
期望用户也提供一个新文本，所以我们只说需要

1214
19:22:31,360 --> 19:22:36,720
数据库注释注释然后我们说它是必需的

1215
19:22:36,720 --> 19:22:43,680
像这样的文本字符串

1216
19:22:43,680 --> 19:22:46,872
你已经熟悉了我们会得到我们说的数据库

1217
19:22:46,872 --> 19:22:50,160
扔好

1218
19:22:50,160 --> 19:22:54,240
我们只是要发布我们的更新

1219
19:22:54,240 --> 19:22:59,440
数据库我们之前没有为我们的 sql 类数据库进行过更新，所以这就是

1220
19:22:59,440 --> 19:23:02,320
我们现在要做，所以我们只说 db.update

1221
19:23:02,320 --> 19:23:06,160
你可以看到上面写着给我们一张桌子或者给我一张桌子

1222
19:23:06,160 --> 19:23:10,832
你的更新列表，所以让我们进去说

1223
19:23:10,832 --> 19:23:15,512
更新 uh note 表

1224
19:23:15,512 --> 19:23:18,240
嗯，实际上在这样做之前我们怎么做

1225
19:23:18,240 --> 19:23:22,720
确保该注释的表已存在于数据库中，因为

1226
19:23:22,720 --> 19:23:27,832
就像我们之前看到的那样，任何人都可以去添加

1227
19:23:27,832 --> 19:23:30,800
或创建一个数据库节点的实例，它不一定必须在

1228
19:23:30,800 --> 19:23:33,920
数据库，但我们需要确保它已经存储在

1229
19:23:33,920 --> 19:23:38,800
数据库，因为在我们可以更新以更新其文本之前，我们已经有了一个

1230
19:23:38,800 --> 19:23:42,552
记住的功能会获取带有 id 的注释，因此我们可以

1231
19:23:42,552 --> 19:23:46,872
字面上只是说等待

1232
19:23:46,872 --> 19:23:50,872
它是便笺，然后我们说便笺 ID

1233
19:23:50,872 --> 19:23:54,400
你看到这实际上引发了一个错误

1234
19:23:54,400 --> 19:23:58,080
如果你去这个函数它会抛出一个错误，叫做找不到注释

1235
19:23:58,080 --> 19:24:02,720
正是我们所追求的，但我们实际上并不追求它的结果

1236
19:24:02,720 --> 19:24:06,400
我们不想要实际的注释，因为我们假设那是相同的

1237
19:24:06,400 --> 19:24:12,080
这样的对象，所以我们只是忽略它的返回值

1238
19:24:12,080 --> 19:24:14,480
在更新中我们会说笔记表

1239
19:24:14,480 --> 19:24:17,512
我们要提供的值是两个我们要说的

1240
19:24:17,512 --> 19:24:21,280
文本列我需要一个新文本

1241
19:24:21,280 --> 19:24:25,680
我们将在您更新节点的文本时，我们还将假设

1242
19:24:25,680 --> 19:24:30,480
突然之间，这个节点没有与后端或与

1243
19:24:30,480 --> 19:24:34,320
数据用 uh 用云数据库好了

1244
19:24:34,320 --> 19:24:39,512
这又回到了我们的 um async with cloud 专栏

1245
19:24:39,512 --> 19:24:43,440
所以让我们进入这里并说与云列同步然后它将是

1246
19:24:43,440 --> 19:24:47,760
设置为零记住那是一个整数字段好吧更新是一个

1247
19:24:47,760 --> 19:24:50,400
异步函数，所以你有它的重量

1248
19:24:50,400 --> 19:24:54,320
它还返回感觉更新的行数

1249
19:24:54,320 --> 19:24:59,120
我们要说更新的更新计数

1250
19:24:59,120 --> 19:25:01,120
抱歉最后

1251
19:25:01,120 --> 19:25:06,872
更新计数等于您现在对 db update 的权重

1252
19:25:06,872 --> 19:25:11,040
在调用更新注释函数的调用端，我们假设

1253
19:25:11,040 --> 19:25:15,192
注意应该已经存在于数据库中，所以在这种情况下

1254
19:25:15,192 --> 19:25:22,080
更新计数应该是一个非零的值好吧，所以我们说如果

1255
19:25:22,080 --> 19:25:27,120
更新计数等于 0 调出代码，以便您可以看到它

1256
19:25:27,120 --> 19:25:30,832
然后我们必须抛出一个名为无法更新的新异常

1257
19:25:30,832 --> 19:25:35,280
从我的笔记中记下并粘贴该异常

1258
19:25:35,280 --> 19:25:38,720
所以它应该看起来像这个类无法更新节点实现所有异常

1259
19:25:38,720 --> 19:25:41,920
对，所以我也需要你写这段代码

1260
19:25:41,920 --> 19:25:46,320
如果更新记录如果更新计数为零，那么我们是

1261
19:25:46,320 --> 19:25:51,120
会说 throw 无法更新笔记

1262
19:25:51,120 --> 19:25:53,832
否则现在你可以看到我们承诺的是

1263
19:25:53,832 --> 19:25:58,960
返回一个新的数据库注释，所以让我们说吧

1264
19:25:58,960 --> 19:26:04,080
那我们是不是我的意思是这就是我们更新的东西，呃，怎么做

1265
19:26:04,080 --> 19:26:09,760
我们向您返回更新数据库注释我们可以这样做

1266
19:26:09,760 --> 19:26:14,400
用那个笔记 id 转动它的 uh 笔记，因为

1267
19:26:14,400 --> 19:26:19,440
我们已经很好地实现了获取笔记功能

1268
19:26:19,440 --> 19:26:23,040
哇，如果你能坚持的话，做得很好

1269
19:26:23,040 --> 19:26:28,400
我贯穿这一章，因为我们做了很多工作，所以我要弃牌

1270
19:26:28,400 --> 19:26:32,000
this fold this 你可以看到我们这里有很多功能

1271
19:26:32,000 --> 19:26:36,080
相当多的工作，我认为到目前为止这是最大的一章

1272
19:26:36,080 --> 19:26:40,800
这门课程，但我们也有很多事情要做很多信息我

1273
19:26:40,800 --> 19:26:44,320
希望你能坚持我让我们现在继续清理我们的

1274
19:26:44,320 --> 19:26:48,080
标题所示的异常让我们将所有人群异常放入

1275
19:26:48,080 --> 19:26:54,400
lib services 中的一个文件 crowd crud 下划线 quad 例外 好的

1276
19:26:54,400 --> 19:26:58,480
所以让我们进去看看

1277
19:26:58,480 --> 19:27:04,400
呃实际上它应该说人群削减人群例外所以嗯，如果我看看我的

1278
19:27:04,400 --> 19:27:10,480
服务杂物内的注释我要修复这个标题，我为此道歉

1279
19:27:10,480 --> 19:27:18,000
我会像这样在旅途中修复它，我会提出来

1280
19:27:18,000 --> 19:27:22,160
实际上它应该说 crowd slash crud 强调异常所以我认为

1281
19:27:22,160 --> 19:27:25,360
那里有不止一个错误和 cros

1282
19:27:25,360 --> 19:27:30,320
必需的例外，所以它应该是口头服务斜线四边形

1283
19:27:30,320 --> 19:27:34,080
例外好吧，让我们去解决它

1284
19:27:34,080 --> 19:27:37,832
在服务内部，我们已经有人群了，我们有节点服务飞镖让我们

1285
19:27:37,832 --> 19:27:42,720
在那里创建一个新文件，我们现在称之为 crud exceptions dot art

1286
19:27:42,720 --> 19:27:46,800
需要您进入节点服务 dart 文件并获取所有这些异常

1287
19:27:46,800 --> 19:27:52,000
您在此处定义并在 macintosh 或 control x 上使用命令 x 剪切它们

1288
19:27:52,000 --> 19:27:57,120
在 linux 和 windows 中，然后把它带入你的 quad 异常中

1289
19:27:57,120 --> 19:28:00,160
保存这个文件

1290
19:28:00,160 --> 19:28:06,552
让我也看看这里

1291
19:28:06,552 --> 19:28:09,920
只是为了确保我的笔记对你来说也是干净的

1292
19:28:09,920 --> 19:28:14,400
嗯，因为我注意到下一个标题也有点不正确

1293
19:28:14,400 --> 19:28:18,000
现在我们需要在我们的笔记系列中使用人群异常，因为

1294
19:28:18,000 --> 19:28:21,600
你可以看到它现在被标记为红色，因为有很多

1295
19:28:21,600 --> 19:28:26,080
抛出异常，这个文件无法再访问了，所以我

1296
19:28:26,080 --> 19:28:29,120
将在此处使用命令点从 Visual Studio 代码中获得帮助并说导入

1297
19:28:29,120 --> 19:28:34,320
人群异常和所有这些错误都会消失

1298
19:28:34,320 --> 19:28:39,040
好吧，干得好，巨大的章节完成了很多工作，祝贺你

1299
19:28:39,040 --> 19:28:44,080
现在和我一起度过这一章，就像我们现在要遵循的传统一样

1300
19:28:44,080 --> 19:28:50,872
继续提交我们的工作，嗯，也给它贴上标签，所以我要让屏幕成为

1301
19:28:50,872 --> 19:28:54,872
大一点，让我们去我们的终端

1302
19:28:54,872 --> 19:29:00,552
然后我要在这里说我们将标记并提交我们的工作作为步骤

1303
19:29:00,552 --> 19:29:05,040
11 所以让我们先获取状态然后我们说 git add all

1304
19:29:05,040 --> 19:29:09,680
再次点击状态这里是我们所做的事情 pop spec 被改变了，因为

1305
19:29:09,680 --> 19:29:14,480
我们添加了三个依赖 uh 提供了一个路径 provider path

1306
19:29:14,480 --> 19:29:18,800
而且我相信实际上它被称为路径和路径提供者

1307
19:29:18,800 --> 19:29:22,552
是的路径路径提供程序和 sqlite 就是这样

1308
19:29:22,552 --> 19:29:25,920
为什么这两个文件被更改了节点服务是全新的和人群

1309
19:29:25,920 --> 19:29:30,720
异常也是新的，所以 git commit

1310
19:29:30,720 --> 19:29:36,000
呃，第 11 步，因为标题表明 git push

1311
19:29:36,000 --> 19:29:40,400
他们首先要记住，然后我们将其标记为第 11 步

1312
19:29:40,400 --> 19:29:45,832
我们也推我们的标签太棒了

1313
19:29:45,832 --> 19:29:49,512
现在再次祝贺你和我一起读完这一章

1314
19:29:49,512 --> 19:29:52,872
巨大的一章，我认为是迄今为止最大的一章，我们需要为下一章做好准备

1315
19:29:52,872 --> 19:29:56,800
章节作为其他章节的传统最后我们谈了一点

1316
19:29:56,800 --> 19:30:00,240
关于我们在下一章中要做的事情只是为了做好准备

1317
19:30:00,240 --> 19:30:03,680
所以我们现在在数据上做了很多工作

1318
19:30:03,680 --> 19:30:08,640
我们需要将它与我们的 uh 与我们的 ui 融合在一起，为了做到这一点，我们

1319
19:30:08,640 --> 19:30:12,400
需要谈谈你看到的流和流控制器

1320
19:30:12,400 --> 19:30:16,160
登录后，当您在应用程序的主用户界面中时

1321
19:30:16,160 --> 19:30:20,960
需要查看您的笔记列表，但是如果您看到了笔记列表会发生什么

1322
19:30:20,960 --> 19:30:24,000
你的笔记，然后你按下加号按钮来创建一个新的笔记，这

1323
19:30:24,000 --> 19:30:27,192
加号按钮是我们将在接下来的章节中创建的按钮

1324
19:30:27,192 --> 19:30:31,512
如果您按下加号按钮然后手动发送信号，则会发生

1325
19:30:31,512 --> 19:30:37,192
对你的用户界面说，嘿，一个新的笔记被创建了更新列表，这是很多

1326
19:30:37,192 --> 19:30:42,552
工作，如果你使用流和

1327
19:30:42,552 --> 19:30:46,552
流控制器，这就是我们将在下一章中讨论的内容

1328
19:30:46,552 --> 19:30:49,600
所以你可能想在之后稍作停顿

1329
19:30:49,600 --> 19:30:53,760
这一章，因为它太大了，所以请喝点咖啡

1330
19:30:53,760 --> 19:30:57,280
随便喝茶，下一章见

1331
19:30:57,280 --> 19:31:01,920
大家好，欢迎来到前几章的 swata 课程第 28 章

1332
19:31:01,920 --> 19:31:05,832
我们一直在谈论很多关于 crud create read update delete 的事情，我们

1333
19:31:05,832 --> 19:31:10,160
谈到了我们如何在我们的节点中拥有原始功能

1334
19:31:10,160 --> 19:31:13,760
服务，以便我们可以从数据库中读取删除数据库中的内容

1335
19:31:13,760 --> 19:31:19,280
创建用户等现在我们在过去的两章中还没有真正工作过

1336
19:31:19,280 --> 19:31:23,040
我们的用户界面有这么多，这完全没问题，因为有时

1337
19:31:23,040 --> 19:31:25,760
在开发应用程序或开发软件时，您可能拥有

1338
19:31:25,760 --> 19:31:29,512
走弯路以创建稍后将要实现的功能

1339
19:31:29,512 --> 19:31:32,080
你的用户界面需要，你会做

1340
19:31:32,080 --> 19:31:35,832
如果你在做像 uh web 这样的后端开发，同样的事情

1341
19:31:35,832 --> 19:31:39,192
开发所以我自己用 django 做 web 开发，有时我

1342
19:31:39,192 --> 19:31:43,280
必须先在后端创建很多功能

1343
19:31:43,280 --> 19:31:47,680
在我真正去镜像 UI 上的功能之前

1344
19:31:47,680 --> 19:31:51,120
以用户消费内容的网络浏览器为例

1345
19:31:51,120 --> 19:31:53,360
即使你是设计师

1346
19:31:53,360 --> 19:31:58,080
例如，你正在使用 figma，你不能总是制作面向用户的内容

1347
19:31:58,080 --> 19:32:01,192
就像原型一样，你有时可能不得不去设计

1348
19:32:01,192 --> 19:32:04,552
组件，然后在你完成组件之后，你就可以准备好了

1349
19:32:04,552 --> 19:32:08,480
将这些组件放入屏幕并将其显示给您的产品所有者或

1350
19:32:08,480 --> 19:32:11,440
你的开发人员

1351
19:32:11,440 --> 19:32:15,360
嗯，到目前为止，我们一直在合作

1352
19:32:15,360 --> 19:32:19,600
用户看不到的东西，我们必须喜欢缝合

1353
19:32:19,600 --> 19:32:23,440
在我们真正进入 ui 并进行操作之前，先整理一下最后的点点滴滴

1354
19:32:23,440 --> 19:32:29,360
我们的笔记服务现在可以处理的数据我们缺少一些

1355
19:32:29,360 --> 19:32:32,320
我们将在本章中在节点中开发的功能

1356
19:32:32,320 --> 19:32:34,400
服务和

1357
19:32:34,400 --> 19:32:38,160
我们将在本章中使用的尤其是流和

1358
19:32:38,160 --> 19:32:42,320
流控制器，所以让我调出标题

1359
19:32:42,320 --> 19:32:45,680
我现在要谈的是什么是流，什么是流

1360
19:32:45,680 --> 19:32:49,440
如果您已经是开发人员，那么控制器很好

1361
19:32:49,440 --> 19:32:52,720
做过软件开发你可能知道一些

1362
19:32:52,720 --> 19:32:58,000
关于反应式编程和反应式编程是你所拥有的

1363
19:32:58,000 --> 19:33:02,000
例如，一堆数据放在某个地方，然后你执行一些

1364
19:33:02,000 --> 19:33:06,080
对该数据的操作，该数据会更新，您将收到通知

1365
19:33:06,080 --> 19:33:10,480
这些更新是通过某种信息管道进行的，所以

1366
19:33:10,480 --> 19:33:13,760
如果你之前没有做过软件开发，那么被动

1367
19:33:13,760 --> 19:33:16,000
编程和流和流控制可能有点

1368
19:33:16,000 --> 19:33:20,160
压倒性的，但我们将开始非常缓慢，所以没有什么可做的

1369
19:33:20,160 --> 19:33:24,160
担心我会尽我所能解释一切

1370
19:33:24,160 --> 19:33:27,440
事情对你来说更容易，但如果你没有发展

1371
19:33:27,440 --> 19:33:30,800
软件工程背景之前的背景不是这样

1372
19:33:30,800 --> 19:33:34,320
我可以为您解释有关流和流控制器的很多内容

1373
19:33:34,320 --> 19:33:39,360
完全理解它们是如何工作的我只能说想象一个流是

1374
19:33:39,360 --> 19:33:44,480
只是一个时间点或一个流基本上是一个控制数据的实体

1375
19:33:44,480 --> 19:33:48,800
好吧，只要说一些保留数据的东西，然后你执行一些事情

1376
19:33:48,800 --> 19:33:53,512
在它上面所以你说添加这个数据或删除这个数据用这个数据添加这个数据

1377
19:33:53,512 --> 19:33:58,080
并给我结果，这样它就可以保存它的数据并且它有一个

1378
19:33:58,080 --> 19:34:03,120
时间线，因此它从某个时间点开始操作其数据，然后它要么

1379
19:34:03,120 --> 19:34:07,512
最后错误说哎呀我不能这样做然后它就死了或

1380
19:34:07,512 --> 19:34:11,192
它会在某个时候完成，还有第三类

1381
19:34:11,192 --> 19:34:14,480
数据一直存在的流

1382
19:34:14,480 --> 19:34:16,960
它从来没有基本上嗯

1383
19:34:16,960 --> 19:34:20,240
完成或出错

1384
19:34:20,240 --> 19:34:25,040
因此，只需将流视为数据类型的信息管道，您可以

1385
19:34:25,040 --> 19:34:28,960
操作，您还可以对

1386
19:34:28,960 --> 19:34:33,680
所以如果这就是流，那么什么是 dart 中的流流控制器

1387
19:34:33,680 --> 19:34:40,640
流控制器是您的流的接口，所以

1388
19:34:40,640 --> 19:34:45,600
你有坐在这里的溪流，你不能

1389
19:34:45,600 --> 19:34:49,832
你基本上不会去直接向流中添加内容或阅读

1390
19:34:49,832 --> 19:34:54,000
来自流的东西你可以做的是在你所在的地方有一个流控制器

1391
19:34:54,000 --> 19:34:58,320
操作流，例如我们的节点服务和这个流控制器

1392
19:34:58,320 --> 19:35:02,552
例如，能够向流中添加内容或从流中读取内容，因此

1393
19:35:02,552 --> 19:35:05,760
想象一下流控制器有点像那个流的管理者

1394
19:35:05,760 --> 19:35:10,160
所以如果这一切听起来有点高层次和抽象我完全

1395
19:35:10,160 --> 19:35:13,680
了解这通常是在您使用响应式编程时

1396
19:35:13,680 --> 19:35:17,192
有些人实际上讨厌反应式编程，但是

1397
19:35:17,192 --> 19:35:20,640
正如我的一位同事曾经说过的那样，总是更容易

1398
19:35:20,640 --> 19:35:25,512
讨厌比学习，我的方法通常是如果我讨厌某事是因为

1399
19:35:25,512 --> 19:35:29,040
也许我还没有真正完全理解它，所以我的东西很少

1400
19:35:29,040 --> 19:35:34,552
我真正学到的生活，我在学习后讨厌的生活

1401
19:35:34,552 --> 19:35:38,400
如果您对流和流控制器或反应式有点不知所措

1402
19:35:38,400 --> 19:35:41,600
如果你知道如何使用它们，它们实际上并不好

1403
19:35:41,600 --> 19:35:46,160
所以只要你掌握 uh 的句柄，它们就很容易使用

1404
19:35:46,160 --> 19:35:50,720
基本上它是如何掌握正确使用它们的方法的

1405
19:35:50,720 --> 19:35:52,960
我将在本章中向您展示什么，然后

1406
19:35:52,960 --> 19:35:57,832
即将到来的章节，所以让我们走吧，对不起，让我们去我们的

1407
19:35:57,832 --> 19:36:00,960
应用程序我要把代码放在这里让我们看看什么

1408
19:36:00,960 --> 19:36:04,640
到目前为止，我们已经写过，我将增加屏幕的大小，然后

1409
19:36:04,640 --> 19:36:09,512
稍微减小字体大小，这样就不会那么大了

1410
19:36:09,512 --> 19:36:11,832
所以嗯

1411
19:36:11,832 --> 19:36:15,440
让我们看看到目前为止我们做了什么，你可以看到我们有很多

1412
19:36:15,440 --> 19:36:19,760
例如，这里的功能是删除所有节点

1413
19:36:19,760 --> 19:36:23,440
然后我们得到了所有节点

1414
19:36:23,440 --> 19:36:27,760
我们有更新节点，所以有很多功能

1415
19:36:27,760 --> 19:36:31,680
但是如果您看到所有这些都直接与我们的数据库对话

1416
19:36:31,680 --> 19:36:34,640
sqlite 数据库 这些功能都不是

1417
19:36:34,640 --> 19:36:38,240
实际上告诉或者我们甚至不必谈论

1418
19:36:38,240 --> 19:36:41,600
功能，但如果您查看它本身的节点服务，它不包含

1419
19:36:41,600 --> 19:36:47,512
节点列表，因此它无法缓存这些节点，因此它就像

1420
19:36:47,512 --> 19:36:50,240
只要你给它一个命令节点服务我不知道该怎么做

1421
19:36:50,240 --> 19:36:53,680
只是去数据库，做你说我必须做的事

1422
19:36:53,680 --> 19:36:58,400
但是，这可能不是在我们的应用程序中，而是在一个应用程序中

1423
19:36:58,400 --> 19:37:02,552
有数百万行数据，例如这不可能

1424
19:37:02,552 --> 19:37:06,080
一个好主意，你总是去数据库和

1425
19:37:06,080 --> 19:37:11,512
阅读整个内容，例如删除一行或基本上删除

1426
19:37:11,512 --> 19:37:15,120
这些操作应该有点像之前缓存在您的应用程序中

1427
19:37:15,120 --> 19:37:19,760
你有希望地去访问数据库，我们将尽你所能

1428
19:37:19,760 --> 19:37:22,960
看这里的标题，我们将真正开始缓存笔记列表

1429
19:37:22,960 --> 19:37:26,872
节点服务具有因此目标是笔记服务器能够

1430
19:37:26,872 --> 19:37:32,552
公开一个笔记列表，然后用户界面可以在用户屏幕上呈现这些笔记列表

1431
19:37:32,552 --> 19:37:36,640
所以如果用户去按下加号按钮，那么那个加号按钮就是

1432
19:37:36,640 --> 19:37:40,720
将在此处向我们的便笺服务器发送消息，然后转到此

1433
19:37:40,720 --> 19:37:44,320
函数创建节点，然后在内部创建节点函数

1434
19:37:44,320 --> 19:37:49,280
操纵节点服务内的节点列表说嘿这是一个新节点

1435
19:37:49,280 --> 19:37:53,192
添加它，然后我们的 ui 将听

1436
19:37:53,192 --> 19:37:56,872
笔记服务中可用的这些笔记的列表，如果事情发生变化

1437
19:37:56,872 --> 19:37:59,280
列出然后ui就可以了

1438
19:37:59,280 --> 19:38:02,960
自动更新自身以及 ui 和节点之间的这个接口

1439
19:38:02,960 --> 19:38:06,160
服务器将通过流完成

1440
19:38:06,160 --> 19:38:09,280
我知道这是很多很多信息，但你会得到它你会得到

1441
19:38:09,280 --> 19:38:12,320
只要我们一起读完这一章

1442
19:38:12,320 --> 19:38:15,920
所以我们首先需要做的是让我们走，然后作为底部的标题

1443
19:38:15,920 --> 19:38:20,320
屏幕的 表示我们要在我们的

1444
19:38:20,320 --> 19:38:24,720
注意服务 好的，让我们继续说我们有一个清单

1445
19:38:24,720 --> 19:38:29,680
呃数据库笔记，我们只是称之为笔记和

1446
19:38:29,680 --> 19:38:34,080
我们将从一个空列表开始

1447
19:38:34,080 --> 19:38:36,960
所以这真的很好，现在我们可以说这是我们的缓存，这就是

1448
19:38:36,960 --> 19:38:42,800
我们保留了该节点服务可以正常操作的所有注释

1449
19:38:42,800 --> 19:38:46,800
所以现在让我们去谈谈我们的嗯

1450
19:38:46,800 --> 19:38:51,680
流控制器，因此您可以看到我们需要做的事情

1451
19:38:51,680 --> 19:38:57,040
这里的信息说我们需要的是节点服务

1452
19:38:57,040 --> 19:39:04,000
能够控制节点流，所以当这个节点的列表发生变化时，我们

1453
19:39:04,000 --> 19:39:07,440
需要在笔记服务器中告诉我们的流

1454
19:39:07,440 --> 19:39:11,920
嘿，添加了一些元素 嘿，删除了一些元素，或者删除了一些元素

1455
19:39:11,920 --> 19:39:15,512
更新后，用户界面可以反应性地收听

1456
19:39:15,512 --> 19:39:21,360
对于节点服务中的这些更改，我们通过 um 做到这一点

1457
19:39:21,360 --> 19:39:25,760
我们的流控制器，所以让我们开始吧，因为标题表明我是

1458
19:39:25,760 --> 19:39:29,440
会写它和笔记实际上也许我应该是的，我要写

1459
19:39:29,440 --> 19:39:34,240
它注意到流控制器和创建流控制器的方法是

1460
19:39:34,240 --> 19:39:38,080
你只是说流控制器，然后你指定你的数据类型

1461
19:39:38,080 --> 19:39:42,640
流包含哪个是数据库节点列表

1462
19:39:42,640 --> 19:39:48,080
然后我们就说点广播

1463
19:39:48,080 --> 19:39:52,000
像那样，我相信流控制器还没有

1464
19:39:52,000 --> 19:39:56,960
对不起，我们的笔记服务中没有导入，所以我会得到帮助

1465
19:39:56,960 --> 19:40:01,120
视觉工作室代码，你可以看到它说流控制器很好

1466
19:40:01,120 --> 19:40:08,400
在 dart 异步包中可用，所以嗯，是的，异步意味着异步

1467
19:40:08,400 --> 19:40:11,440
所以为了能够使用流控制器，你必须导入它

1468
19:40:11,440 --> 19:40:14,552
我将从 Visual Studio 代码中获得帮助来做到这一点

1469
19:40:14,552 --> 19:40:17,920
好吧，让我们看看我们在这里做了什么

1470
19:40:17,920 --> 19:40:21,920
这是什么语法看起来真的很可怕但它真的不是全部

1471
19:40:21,920 --> 19:40:25,760
你是说我希望能够控制流

1472
19:40:25,760 --> 19:40:30,000
嗯，基本上是一个数据库笔记列表

1473
19:40:30,000 --> 19:40:33,512
你是说我有一根管子这个管子

1474
19:40:33,512 --> 19:40:37,832
这个管道内的每个事件都是一个数据库节点列表，所以让我们说

1475
19:40:37,832 --> 19:40:41,512
你从一个空列表开始，所以这个列表在这个管道内是空的，然后你

1476
19:40:41,512 --> 19:40:44,640
将项目添加到此管道

1477
19:40:44,640 --> 19:40:49,360
然后它做什么它说哦，在我在空列表上之前我是什么添加新的

1478
19:40:49,360 --> 19:40:54,480
项目所以现在我是一个项目现在我是一个包含一个项目的数组或列表然后它放

1479
19:40:54,480 --> 19:40:58,872
流中的那个数组，所以流的值现在在开头

1480
19:40:58,872 --> 19:41:03,360
是空列表，那么它是一个项目的列表，所以这个流控制器是

1481
19:41:03,360 --> 19:41:09,120
基本上在控制，因为它的名字表明它在控制变化

1482
19:41:09,120 --> 19:41:14,240
到这个笔记嗯列表它还没有被吸引到，但是

1483
19:41:14,240 --> 19:41:18,552
这就是它的目的，这就是它的数据类型完全相同的原因

1484
19:41:18,552 --> 19:41:24,800
流控制器现在在这里和作为广播部分

1485
19:41:24,800 --> 19:41:28,000
你可以看到文档实际上在上面说控制器在哪里

1486
19:41:28,000 --> 19:41:32,000
可以多次收听流并且

1487
19:41:32,000 --> 19:41:35,280
如果你之前做过暗开发或颤动开发

1488
19:41:35,280 --> 19:41:40,400
知道如果你然后嗯，我现在假设我说你的飞镖或

1489
19:41:40,400 --> 19:41:43,512
如果您已经创建了流控制器并且

1490
19:41:43,512 --> 19:41:47,120
然后你去听流控制器对该流的更改

1491
19:41:47,120 --> 19:41:51,440
正在控制，然后您进行热重载，然后您会从您的

1492
19:41:51,440 --> 19:41:54,640
花应用说哦，这个流已经被听过了所以你

1493
19:41:54,640 --> 19:41:58,552
不能再听了，这就是普通流控制器的问题

1494
19:41:58,552 --> 19:42:02,872
可能会导致你一旦听了他们就应该关闭你的

1495
19:42:02,872 --> 19:42:06,872
收听该流的频道，然后您才能再次收听它们

1496
19:42:06,872 --> 19:42:10,552
如果您不是之前的开发人员，那么广播可以解决什么问题

1497
19:42:10,552 --> 19:42:15,440
广播基本上是说你可以创建新的

1498
19:42:15,440 --> 19:42:19,760
侦听此流控制器更改的侦听器，因此这是一个管道

1499
19:42:19,760 --> 19:42:23,600
在这一点上你开始听信息然后就完全没问题了

1500
19:42:23,600 --> 19:42:26,480
如果您想在稍后收听流控制器的更改

1501
19:42:26,480 --> 19:42:30,080
未来也是如此，所以你不会通过这个广播得到任何错误

1502
19:42:30,080 --> 19:42:33,040
好的

1503
19:42:33,040 --> 19:42:36,160
好的 嗯

1504
19:42:36,160 --> 19:42:40,960
现在我们还需要一个方便的功能

1505
19:42:40,960 --> 19:42:44,640
在我们的嗯

1506
19:42:44,640 --> 19:42:50,240
在我们的 application.can

1507
19:42:50,240 --> 19:42:54,552
它可以从我们的数据库中读取所有可用的笔记，然后缓存它们

1508
19:42:54,552 --> 19:42:59,920
在此处的便笺缓存和我们的控制器中都可以

1509
19:42:59,920 --> 19:43:05,120
所以你明白我们在本章中的目标是

1510
19:43:05,120 --> 19:43:09,600
确保这是我们笔记的真实来源

1511
19:43:09,600 --> 19:43:15,760
列表包含所有节点，例如当前用户

1512
19:43:15,760 --> 19:43:20,160
那么流控制器就是我们与外界的接口

1513
19:43:20,160 --> 19:43:24,872
ui 将监听此流中发生的更改

1514
19:43:24,872 --> 19:43:28,480
控制器所以每当你看到这个不是

1515
19:43:28,480 --> 19:43:30,960
将从外部读取的东西

1516
19:43:30,960 --> 19:43:34,800
一切都会通过这个从外部读取，所以请保持

1517
19:43:34,800 --> 19:43:37,360
记住这一点，所以让我们继续作为案例的标题，我们将

1518
19:43:37,360 --> 19:43:41,120
在这里创建一个名为缓存注释的函数，其目的只是为了阅读

1519
19:43:41,120 --> 19:43:45,760
数据库中的所有笔记并将其放置在内部和内部

1520
19:43:45,760 --> 19:43:51,360
我们的节点流控制器，可以从外部读取

1521
19:43:51,360 --> 19:43:54,960
所以让我们去做吧，所以我会说future void，我们会打电话给

1522
19:43:54,960 --> 19:44:00,080
它缓存和笔记是异步的

1523
19:44:00,080 --> 19:44:04,000
那么如果你还记得我们已经有一个名为 get all notes 的异步函数，那么

1524
19:44:04,000 --> 19:44:10,400
我只想说，嗯，最后，嗯，所有的笔记都在等待

1525
19:44:10,400 --> 19:44:14,872
所有的笔记都可以，所以我们所有的笔记

1526
19:44:14,872 --> 19:44:20,720
我们会把它分配到我们的笔记列表中

1527
19:44:20,720 --> 19:44:25,040
所以让我们进去，说你记得得到所有的笔记返回

1528
19:44:25,040 --> 19:44:29,192
可迭代我们所有的笔记，现在我们这里有一点问题

1529
19:44:29,192 --> 19:44:32,552
因为我们说的是所有笔记的清单，在这里我们也说清单

1530
19:44:32,552 --> 19:44:38,800
笔记，所以我们必须将那个可怕的东西转换为所有笔记的列表，好吧

1531
19:44:38,800 --> 19:44:43,440
要么我们可以这样做，要么我们可以让这个只是作为一个眼睛高音坐在那里

1532
19:44:43,440 --> 19:44:47,680
这完全取决于你我没有任何问题，我们可以一起去

1533
19:44:47,680 --> 19:44:50,080
清单，所以让我们进去，然后我们要

1534
19:44:50,080 --> 19:44:55,832
说呃我们的笔记是私人笔记是所有笔记

1535
19:44:55,832 --> 19:44:58,960
列表，我们也将更新我们的

1536
19:44:58,960 --> 19:45:04,080
带有下划线节点值的流控制器可以，所以我们

1537
19:45:04,080 --> 19:45:09,832
如果我能拼写，我会说注释流控制器

1538
19:45:09,832 --> 19:45:14,080
然后我们将向流中添加注释并记住一个

1539
19:45:14,080 --> 19:45:19,120
流只是价值随时间的演变

1540
19:45:19,120 --> 19:45:22,400
这种演变的第一点是

1541
19:45:22,400 --> 19:45:25,920
空列表，然后下一个将是

1542
19:45:25,920 --> 19:45:29,040
所有的笔记都在

1543
19:45:29,040 --> 19:45:33,360
数据库好的，这只是我们告诉任何人在听

1544
19:45:33,360 --> 19:45:38,400
流控制器，嘿，这是一个新值，好吧

1545
19:45:38,400 --> 19:45:42,720
好的，现在我们正在这样做，你可以看到

1546
19:45:42,720 --> 19:45:47,600
我们遇到了一个错误，dart 实际上这个分析非常聪明，因为

1547
19:45:47,600 --> 19:45:52,400
你看它告诉我们缓存笔记功能现在没有被使用

1548
19:45:52,400 --> 19:45:56,000
你可能会问自己这些功能都没有被使用更新

1549
19:45:56,000 --> 19:45:59,040
注意例如没有被使用所以如果我

1550
19:45:59,040 --> 19:46:02,832
搜索更新说明让我们看看更新

1551
19:46:02,832 --> 19:46:07,832
节点无法更新节点所以是的你可以看到更新节点功能

1552
19:46:07,832 --> 19:46:12,320
本身根本没有被使用，所以为什么

1553
19:46:12,320 --> 19:46:15,832
分析器特别抱怨这个功能，原因是

1554
19:46:15,832 --> 19:46:20,480
因为我们在这个函数名后面有一个小前缀

1555
19:46:20,480 --> 19:46:24,080
这个前缀告诉分析器这个函数是

1556
19:46:24,080 --> 19:46:29,040
现在 dart 分析器正在查看这个类的私有和私有

1557
19:46:29,040 --> 19:46:32,480
好吧，这是一门私人课程，但您没有使用它，所以

1558
19:46:32,480 --> 19:46:35,832
其他功能不正常的原因

1559
19:46:35,832 --> 19:46:40,080
标有此警告的是 dart 知道它们没有前缀

1560
19:46:40,080 --> 19:46:44,400
with a with a 带下划线的意思是

1561
19:46:44,400 --> 19:46:48,960
它们将在其他地方公开使用，所以还不会

1562
19:46:48,960 --> 19:46:51,760
给我们任何警告说你没有尽快使用这些功能

1563
19:46:51,760 --> 19:46:55,192
您删除了您看到警告也消失了但我们将保留

1564
19:46:55,192 --> 19:46:58,320
降低分数好吧我只是想向你解释为什么你会看到这个

1565
19:46:58,320 --> 19:47:03,280
小警告 好吧 既然我们已经做了现金票据 什么

1566
19:47:03,280 --> 19:47:06,800
我们要做的只是去我们的标题案例，我们要去

1567
19:47:06,800 --> 19:47:10,080
打开函数让我们看看能不能找到它

1568
19:47:10,080 --> 19:47:12,720
这里开

1569
19:47:12,720 --> 19:47:18,800
打开我们的数据库后，让我看看我的笔记

1570
19:47:18,800 --> 19:47:24,000
打开我们的数据库后，我们将

1571
19:47:24,000 --> 19:47:30,000
缓存所有这些，嗯，让我看看我的

1572
19:47:30,000 --> 19:47:33,280
笔记是的，我们基本上会去呃

1573
19:47:33,280 --> 19:47:36,872
我们在这里的 open 函数 future void open

1574
19:47:36,872 --> 19:47:39,440
我有点惊讶我实际上没有

1575
19:47:39,440 --> 19:47:44,400
写了关于那个的任何笔记是的，我可以看到实际上我有，所以这很好

1576
19:47:44,400 --> 19:47:47,512
所以在执行这个命令之后

1577
19:47:47,512 --> 19:47:51,040
在我们创建了用户表和笔记表之后创建笔记表

1578
19:47:51,040 --> 19:47:54,960
现在我们知道我们可以打开数据库，我们还必须缓存所有

1579
19:47:54,960 --> 19:47:59,832
我们局部变量中的注释，所以让我们去调用

1580
19:47:59,832 --> 19:48:02,872
那个函数，所以我们只说等待缓存

1581
19:48:02,872 --> 19:48:07,680
注释好，所以这意味着当你调用它时

1582
19:48:07,680 --> 19:48:10,552
如果在我们确定所有表格之后打开函数

1583
19:48:10,552 --> 19:48:13,512
一切都在那里，如果他们不存在，那么我们会

1584
19:48:13,512 --> 19:48:17,360
阅读所有笔记并将它们放在这个 notes 变量中，也放在这个

1585
19:48:17,360 --> 19:48:21,440
流控制器好吧，这就是我们做缓存笔记的方式，我希望你

1586
19:48:21,440 --> 19:48:24,872
可以看到代码并且它没有被标题隐藏

1587
19:48:24,872 --> 19:48:30,000
屏幕底部没事，所以这部分现在完成了

1588
19:48:30,000 --> 19:48:34,240
现在我们需要在这里做的是转到代码的下一部分，就像你

1589
19:48:34,240 --> 19:48:38,720
可以看到它在创建节点功能中的创建节点中显示缓存注释添加新的

1590
19:48:38,720 --> 19:48:42,800
节点下划线节点和节点流控制器

1591
19:48:42,800 --> 19:48:46,080
所以我要去我的节点这里创建

1592
19:48:46,080 --> 19:48:50,552
节点并确保当我们创建节点时

1593
19:48:50,552 --> 19:48:55,600
在我们的创建节点中

1594
19:48:55,600 --> 19:48:58,640
就在这里，在创建节点的这个函数中，你现在看到了什么

1595
19:48:58,640 --> 19:49:01,760
我们正在做的是我们只是创建一个节点并返回它

1596
19:49:01,760 --> 19:49:07,192
这很好，但我的意思是这还不够好，因为正如我所说，我们需要 ui

1597
19:49:07,192 --> 19:49:12,160
能够反应性地聆听所有现在在

1598
19:49:12,160 --> 19:49:16,480
该当前用户的数据库好的，所以在我们创建注释后在这里

1599
19:49:16,480 --> 19:49:21,600
我们实际上要将它添加到我们的节点数组中，然后我们也要去

1600
19:49:21,600 --> 19:49:25,600
将它添加到我们的流控制器中，所以我要走了

1601
19:49:25,600 --> 19:49:31,832
进入这里并说节点并在其中添加这个新节点

1602
19:49:31,832 --> 19:49:35,512
记住流控制器的职责只是反映值

1603
19:49:35,512 --> 19:49:38,480
在下划线节点内部到外部世界所以我们所要做的就是

1604
19:49:38,480 --> 19:49:43,832
只是说注释流控制器添加注释就像那样，因为注释是

1605
19:49:43,832 --> 19:49:49,120
我之前提到的真相的来源好吧

1606
19:49:49,120 --> 19:49:52,872
好东西，嗯，现在我们需要照顾其他人

1607
19:49:52,872 --> 19:49:58,240
名为删除笔记的函数让我们搜索它

1608
19:49:58,240 --> 19:50:03,120
嗯删除笔记好吧

1609
19:50:03,120 --> 19:50:06,552
我们需要做的是在这里看看这个呃功能，你可以

1610
19:50:06,552 --> 19:50:11,280
看到它说如果我们不能删除任何东西然后呃扔这个

1611
19:50:11,280 --> 19:50:15,760
例外，但现在我们要在这里添加一个 else 语句

1612
19:50:15,760 --> 19:50:20,000
我们能够删除该便笺，这意味着您可以看到我们的便笺 ID

1613
19:50:20,000 --> 19:50:23,600
have which is this id 所以我们需要做什么作为标题在我们需要的情况下

1614
19:50:23,600 --> 19:50:27,832
实际上也从我们的本地缓存中删除该注释，所以我们要说注释

1615
19:50:27,832 --> 19:50:31,360
删除where，这是便条，然后我要走了

1616
19:50:31,360 --> 19:50:36,160
说注意id应该等于那个id

1617
19:50:36,160 --> 19:50:40,720
之后我们可以说注意流控制器添加

1618
19:50:40,720 --> 19:50:44,552
笔记，你可以尝试你可以在这里变得聪明，你

1619
19:50:44,552 --> 19:50:47,680
实例可以说哦，你看到了

1620
19:50:47,680 --> 19:50:51,600
谁说那张纸条实际上存在于我们的缓存中，我们不能 100 确定

1621
19:50:51,600 --> 19:50:54,800
但是如果你看一下 remove where 函数的签名

1622
19:50:54,800 --> 19:51:00,400
嗯删除所有对象哦，也许我们没有能力真正知道

1623
19:51:00,400 --> 19:51:04,800
如果该节点被删除，但你能做什么，你可以说 count before

1624
19:51:04,800 --> 19:51:09,192
是笔记计数然后你可以在这里或长度

1625
19:51:09,192 --> 19:51:12,960
在这里你可以说如果笔记链接

1626
19:51:12,960 --> 19:51:18,240
在那之前不算数你可以更新你的流我不打算这样做但是

1627
19:51:18,240 --> 19:51:22,480
如果你愿意，你可以尝试这样做，这只是你的保障

1628
19:51:22,480 --> 19:51:28,320
说只有当我真的可以时，我才会更新我的面向外部的流

1629
19:51:28,320 --> 19:51:31,760
如果您认为值得，请从我的缓存中删除此注释我不认为

1630
19:51:31,760 --> 19:51:35,440
这是值得的，但这只是一个意见

1631
19:51:35,440 --> 19:51:39,680
所以我们将像标题一样留下它

1632
19:51:39,680 --> 19:51:43,440
现在你看到我们还有删除所有节点的功能，所以

1633
19:51:43,440 --> 19:51:47,192
让我找到所有节点的功能

1634
19:51:47,192 --> 19:51:54,800
好吧，让我们在这里删除所有节点，找到该函数并

1635
19:51:54,800 --> 19:51:58,400
你现在可以看到它在做什么只是返回数量

1636
19:51:58,400 --> 19:52:01,440
删除节点现在我们要做什么我们要去

1637
19:52:01,440 --> 19:52:05,512
说最后呃我们应该称之为多少

1638
19:52:05,512 --> 19:52:08,720
删除等于这个，我们要返回

1639
19:52:08,720 --> 19:52:12,400
删除的数量可以，因为我的意思是我这样做只是因为我们

1640
19:52:12,400 --> 19:52:17,832
需要在中间做一些工作好吗

1641
19:52:17,832 --> 19:52:21,680
那么我们要做的就是说笔记

1642
19:52:21,680 --> 19:52:27,120
是一个空列表，所以我们正在重置笔记，然后在做之后

1643
19:52:27,120 --> 19:52:30,480
我们还要更新我们的流控制器所以我们要说

1644
19:52:30,480 --> 19:52:34,400
将下划线节点添加到流控制，然后返回数量

1645
19:52:34,400 --> 19:52:38,960
删除，所以让我们确保我们的本地缓存已更新，并且

1646
19:52:38,960 --> 19:52:42,400
我们类的面向用户的界面是

1647
19:52:42,400 --> 19:52:48,720
流控制器也更新了最新信息

1648
19:52:48,720 --> 19:52:51,600
好的，我们需要做的下一件事，正如您在缓存中看到的那样

1649
19:52:51,600 --> 19:52:56,872
更新缓存获取节点删除具有相同ID的旧节点并添加新节点

1650
19:52:56,872 --> 19:53:04,080
更新这个流，让我们去我们的 git 节点

1651
19:53:04,080 --> 19:53:10,000
好吧，嗯

1652
19:53:10,000 --> 19:53:13,680
让我们看看我们的get note in here

1653
19:53:13,680 --> 19:53:17,280
现在你可以在这里看到它在做什么

1654
19:53:17,280 --> 19:53:22,160
哎呀，没有得到注意，嗯，这是得到注意

1655
19:53:22,160 --> 19:53:24,160
就在那儿好吧

1656
19:53:24,160 --> 19:53:28,080
正如你在这里看到的，嗯，我们基本上是我们正在做的就是我们是

1657
19:53:28,080 --> 19:53:32,160
当你试图从

1658
19:53:32,160 --> 19:53:36,552
数据库我们实际上只是对数据库进行查询，然后如果我们

1659
19:53:36,552 --> 19:53:42,080
可以通过创建一个数据库节点来找到我们正在返回的那个项目

1660
19:53:42,080 --> 19:53:48,320
从你可以在这里看到的一排，呃，但我们要做的是，如果

1661
19:53:48,320 --> 19:53:53,440
你试图得到一个便条，我们可能已经知道了

1662
19:53:53,440 --> 19:53:58,320
笔记本地缓存在我们的笔记数组中，但该笔记是

1663
19:53:58,320 --> 19:54:03,680
呃过时的意思是我们在缓存中的副本并不是真的

1664
19:54:03,680 --> 19:54:07,360
使用已应用于数据库的最新更改进行更新，因此它

1665
19:54:07,360 --> 19:54:13,360
在创建数据库节点的新实例时，从这里到现在都很有意义

1666
19:54:13,360 --> 19:54:17,280
实际上也可以更新我们的本地缓存，所以我只想说final

1667
19:54:17,280 --> 19:54:21,120
注意等于那个，我们将返回那个节点

1668
19:54:21,120 --> 19:54:25,440
在这里结算，所以这段代码和以前完全一样，除了我们是

1669
19:54:25,440 --> 19:54:30,872
现在在这里将 from row 的返回值分配给一个新的局部变量

1670
19:54:30,872 --> 19:54:34,320
所以让我们去我们的笔记，说删除哪里

1671
19:54:34,320 --> 19:54:38,160
我要在这里说注意我要说我要说注意

1672
19:54:38,160 --> 19:54:42,960
id 应该等于 id 是

1673
19:54:42,960 --> 19:54:48,080
这个东西在这里没问题所以我们首先从注释中删除那个节点现有节点

1674
19:54:48,080 --> 19:54:52,320
数组然后我们说节点添加

1675
19:54:52,320 --> 19:54:56,160
然后我们在其中添加新节点然后我们要做的就是正确的

1676
19:54:56,160 --> 19:55:01,760
之后更新流控制器，这是我们面向外部的 um 接口

1677
19:55:01,760 --> 19:55:07,280
所以注意流控制器添加笔记好吧，所以你可以看到这个模式所以我们首先

1678
19:55:07,280 --> 19:55:11,760
总是更新我们的本地缓存，然后我们将这些更改反映到外部

1679
19:55:11,760 --> 19:55:17,512
世界很好很好很好的东西所以嗯

1680
19:55:17,512 --> 19:55:20,100
这是笔记流控制器和笔记嗯

1681
19:55:20,100 --> 19:55:23,512
[音乐] 现在还有另一个功能是

1682
19:55:23,512 --> 19:55:28,872
调用更新说明，让我们实际去更新节点之前

1683
19:55:28,872 --> 19:55:33,192
我们看看其他任何东西，当我们更新时你可以在这里看到

1684
19:55:33,192 --> 19:55:36,872
首先，我们确保该节点存在，所以让我们在此处实际添加评论

1685
19:55:36,872 --> 19:55:40,552
确保笔记存在

1686
19:55:40,552 --> 19:55:44,080
然后我们说更新数据库我要扩展这段代码

1687
19:55:44,080 --> 19:55:47,680
所以你看得更清楚，那是更新数据库部分

1688
19:55:47,680 --> 19:55:52,320
如果我们不能更新任何东西，那么我们抛出它不能更新注释和

1689
19:55:52,320 --> 19:55:57,280
你可以在这里看到我们想要的更新节点

1690
19:55:57,280 --> 19:56:00,480
我的意思是到目前为止我们所做的非常聪明，因为这意味着

1691
19:56:00,480 --> 19:56:04,160
我们已经更新了数据库，但是我们为了返回新的

1692
19:56:04,160 --> 19:56:07,832
刷新节点实际上是我们调用getsnow所以

1693
19:56:07,832 --> 19:56:11,440
那很好，但是我们还需要做的就是

1694
19:56:11,440 --> 19:56:15,120
确保我们的本地和缓存也更新

1695
19:56:15,120 --> 19:56:18,160
所以让我们进去说final

1696
19:56:18,160 --> 19:56:21,920
更新的节点以及我们将要做的事情

1697
19:56:21,920 --> 19:56:25,920
屏幕底部的标题表示我们将删除它

1698
19:56:25,920 --> 19:56:31,120
来自我们本地缓存的笔记并在其中添加更新的笔记，然后

1699
19:56:31,120 --> 19:56:35,512
将添加消息也发送到我们的流控制器，所以让我们说

1700
19:56:35,512 --> 19:56:38,640
注释并删除

1701
19:56:38,640 --> 19:56:42,000
所以我们要从缓存中删除旧对象，我只想说

1702
19:56:42,000 --> 19:56:46,160
注释只要注释 id 等于

1703
19:56:46,160 --> 19:56:52,400
更新了注释 ID，以便删除现有的现有节点

1704
19:56:52,400 --> 19:56:56,400
我要说注释添加，我们有

1705
19:56:56,400 --> 19:57:01,120
更改后立即在此处更新节点

1706
19:57:01,120 --> 19:57:06,320
笔记和本地缓存，那么您还需要更新您的流，以便流

1707
19:57:06,320 --> 19:57:08,800
控制器添加注释

1708
19:57:08,800 --> 19:57:13,360
好的，然后我们返回更新的笔记

1709
19:57:13,360 --> 19:57:17,440
所以这里发生的只是我们更新了数据库中的一些内容

1710
19:57:17,440 --> 19:57:23,120
从 uh 数据库中获取了新对象，我们从本地删除了那个 uh 节点

1711
19:57:23,120 --> 19:57:28,640
缓存，然后我们将其添加到那里，好的，将其添加回来，这是更新的节点

1712
19:57:28,640 --> 19:57:32,800
好的好的好的东西要更新

1713
19:57:32,800 --> 19:57:38,000
注释，然后我们需要的是字幕案例是获取或创建用户

1714
19:57:38,000 --> 19:57:41,920
节点服务所以嗯

1715
19:57:41,920 --> 19:57:45,760
这是我们将在下一章实际使用的函数

1716
19:57:45,760 --> 19:57:48,800
嗯

1717
19:57:48,800 --> 19:57:52,400
这个功能有什么用这是我们第一次真正看到

1718
19:57:52,400 --> 19:57:54,960
这个函数的 um 签名作为名称

1719
19:57:54,960 --> 19:57:59,192
如果它说获取或创建您看到的用户

1720
19:57:59,192 --> 19:58:04,320
当您现在进入我们的用户界面时，让我们进入登录视图

1721
19:58:04,320 --> 19:58:06,960
实例登录视图在这里

1722
19:58:06,960 --> 19:58:12,160
我要删除资源管理器，这样你就可以在这里看到完整的代码

1723
19:58:12,160 --> 19:58:16,480
当我们进行 auth service firebase login 时，如果

1724
19:58:16,480 --> 19:58:21,360
电子邮件已验证是我们现在要去节点路由现在让我们去我们的

1725
19:58:21,360 --> 19:58:25,280
您现在可以看到的笔记视图 笔记视图 它唯一能做的就是

1726
19:58:25,280 --> 19:58:29,280
它正在创建一个带有嗯抱歉的应用栏它正在创建一个带有应用栏的脚手架

1727
19:58:29,280 --> 19:58:34,000
我们有我们的注销按钮，让我们开始吧，让我提出来

1728
19:58:34,000 --> 19:58:40,720
scr cpy 所以我要在登录屏幕中使用我的电子邮件地址所以嗯

1729
19:58:40,720 --> 19:58:46,640
我实际上可能需要去把这个设备连接到 wi-fi 所以繁荣

1730
19:58:46,640 --> 19:58:50,640
我要打开 嗯

1731
19:58:50,640 --> 19:58:56,160
用我的用户登录，所以我要摆脱所有这些

1732
19:58:56,160 --> 19:59:00,720
我要在这里登录使用哎呀，我们已经给你发了一封电子邮件验证

1733
19:59:00,720 --> 19:59:03,280
好吧，也许我应该用

1734
19:59:03,280 --> 19:59:08,000
已经通过验证的用户

1735
19:59:08,000 --> 19:59:12,640
因此，让我们使用您在应用程序 um 的主 ui 中看到的这个用户登录

1736
19:59:12,640 --> 19:59:17,040
我们的应用程序我们有这个hello world，因为

1737
19:59:17,040 --> 19:59:22,720
嗯，你现在可以看到我们笔记的正文部分了

1738
19:59:22,720 --> 19:59:27,120
只是说你好世界，所以你几乎可以说笔记视图有

1739
19:59:27,120 --> 19:59:31,040
目前几乎没有与notes服务联系

1740
19:59:31,040 --> 19:59:36,080
但我们很快就会解决这个问题，首先确保笔记服务允许

1741
19:59:36,080 --> 19:59:40,552
用户界面在转到

1742
19:59:40,552 --> 19:59:44,960
屏幕，所以当我们来到屏幕时，我们需要确保有一个用户

1743
19:59:44,960 --> 19:59:48,480
与当前的 firebase 用户相关联

1744
19:59:48,480 --> 19:59:53,512
在我们的数据库里面没问题所以这就是我们需要的这个小呃

1745
19:59:53,512 --> 19:59:59,120
调用 get 或 create user 的好函数，它在我们的数据库中返回一个数据库用户

1746
19:59:59,120 --> 20:00:04,240
笔记服务，所以我们将在下一章中使用它，所以请记住，好的

1747
20:00:04,240 --> 20:00:08,000
但是我们现在需要创建这个函数

1748
20:00:08,000 --> 20:00:13,600
好吧，让我们去创建这个函数，正如名字所暗示的那样，未来

1749
20:00:13,600 --> 20:00:19,600
和数据库用户，我们会说获取或创建用户，它有一个必需的

1750
20:00:19,600 --> 20:00:23,280
参数我可以看到所需的流电子邮件

1751
20:00:23,280 --> 20:00:27,192
它是一个异步函数，所以嗯

1752
20:00:27,192 --> 20:00:33,440
我们基本上需要看看如何创建这个用户

1753
20:00:33,440 --> 20:00:37,192
所以这里的目标是首先我们尝试

1754
20:00:37,192 --> 20:00:41,040
如果该用户不存在，则从数据库中获取该用户，然后我们将

1755
20:00:41,040 --> 20:00:45,920
创建该用户，然后在这两种情况下，我们都将返回

1756
20:00:45,920 --> 20:00:49,600
获取或创建的用户返回到

1757
20:00:49,600 --> 20:00:54,480
来电者所以让我们进去然后说

1758
20:00:54,480 --> 20:00:58,240
最终用户正在等待

1759
20:00:58,240 --> 20:01:02,800
让用户没事，您会看到电子邮件非常适合那里，但是如果您

1760
20:01:02,800 --> 20:01:06,240
记住 get user 的实现让我们进去并扩展它

1761
20:01:06,240 --> 20:01:08,552
如果找不到用户，那么它

1762
20:01:08,552 --> 20:01:13,832
抛出一个错误说找不到用户是 rq 所以如果那个函数

1763
20:01:13,832 --> 20:01:16,872
抛出那个错误然后我们将创建那个用户所以如果那个用户没有

1764
20:01:16,872 --> 20:01:20,320
它存在于需要创建的数据库中，所以让我们在其中添加一个 try 语句

1765
20:01:20,320 --> 20:01:23,832
在这里，然后我们要说找不到用户

1766
20:01:23,832 --> 20:01:28,000
所以这里是用户所以在这种情况下在尝试

1767
20:01:28,000 --> 20:01:32,160
声明这意味着我们可以让用户没事，所以如果我们得到这个回报

1768
20:01:32,160 --> 20:01:35,680
声明它意味着获取用户函数没有抛出任何异常

1769
20:01:35,680 --> 20:01:39,040
例如在我们找不到我们要去的用户的情况下找不到用户

1770
20:01:39,040 --> 20:01:42,960
实际创建一个用户，所以我们只说创建的用户

1771
20:01:42,960 --> 20:01:48,552
是一种使用该电子邮件创建用户的方法，然后我们会说

1772
20:01:48,552 --> 20:01:54,000
返回创建的用户，如果您也查看创建用户功能

1773
20:01:54,000 --> 20:02:00,800
在这里，我也相信它会抛出是的，所以如果它无法创建该用户，如果

1774
20:02:00,800 --> 20:02:04,800
结果是空的，它只是说用户哦不，这就是我们得到的地方

1775
20:02:04,800 --> 20:02:08,872
用户很抱歉，我们需要看看这个插入，所以

1776
20:02:08,872 --> 20:02:11,920
是的，这是它唯一在做的事情，所以它基本上不会扔任何其他东西

1777
20:02:11,920 --> 20:02:14,960
错误好吧，它唯一能做的就是如果你是

1778
20:02:14,960 --> 20:02:18,000
创建一个已经存在的用户我要画一个错误

1779
20:02:18,000 --> 20:02:21,120
所以在这里我们有哪里，我们最终得到了一个

1780
20:02:21,120 --> 20:02:25,120
try 和 catch 块也可能引发异常

1781
20:02:25,120 --> 20:02:30,320
我们还没有处理好所以你能做的就是做一个完整的捕获

1782
20:02:30,320 --> 20:02:34,960
在这里，然后什么都不做，我非常喜欢这种模式

1783
20:02:34,960 --> 20:02:38,552
代码至少是因为如果我不这样做，那么我实际上就没有

1784
20:02:38,552 --> 20:02:42,400
以后可以调试我的应用程序，所以我不能像断点一样放置

1785
20:02:42,400 --> 20:02:47,040
在这里，如果您不这样做，是否会出现任何其他异常，因为那时

1786
20:02:47,040 --> 20:02:50,872
异常将被抛出给调用者，调用者必须

1787
20:02:50,872 --> 20:02:54,080
处理它，但在这种情况下，我们并没有真正处理我们只是

1788
20:02:54,080 --> 20:02:58,480
抓住它，然后我们把它扔回调用方，这只允许

1789
20:02:58,480 --> 20:03:01,680
如果你想调试你的，你基本上在这里放一个断点

1790
20:03:01,680 --> 20:03:06,640
以后申请还好，所以它只是一个它只是一种相当便宜的制作方式

1791
20:03:06,640 --> 20:03:12,240
对于那些对此感兴趣的人来说，您的代码更容易调试

1792
20:03:12,240 --> 20:03:16,000
好吧，太棒了，我们已经介绍了很多

1793
20:03:16,000 --> 20:03:21,920
还有很多事情要做，但我们已经走了很远，所以恭喜你

1794
20:03:21,920 --> 20:03:24,480
让我们看看这里它说让我们为下一章做好准备

1795
20:03:24,480 --> 20:03:28,720
登录我们需要调用我们的 get 或 create user 函数并让用户

1796
20:03:28,720 --> 20:03:31,040
准备好了，这就是我向你提到的

1797
20:03:31,040 --> 20:03:33,512
之前在我们的笔记视图中

1798
20:03:33,512 --> 20:03:36,960
我们没有任何功能可以创建

1799
20:03:36,960 --> 20:03:40,872
新用户或根据他们的电子邮件获取当前用户（如果他们已经）

1800
20:03:40,872 --> 20:03:45,440
存在于数据库中，这将像实际的呃

1801
20:03:45,440 --> 20:03:50,320
我们将在下一章中做的第一个逻辑，它整合了我们的

1802
20:03:50,320 --> 20:03:53,832
使用笔记服务器查看笔记，因此速度

1803
20:03:53,832 --> 20:03:58,552
我们现在的课程将越来越多地转向笔记视图

1804
20:03:58,552 --> 20:04:04,080
直到我们有一个笔记列表并允许用户创建笔记更新笔记

1805
20:04:04,080 --> 20:04:07,920
这是激动人心的时刻，我们已经走了很远，为此我们做了很多工作

1806
20:04:07,920 --> 20:04:11,280
点嗯，还有很多，但是嗯

1807
20:04:11,280 --> 20:04:14,960
希望你能像这样受到攻击

1808
20:04:14,960 --> 20:04:19,192
课程的节奏越来越好和你

1809
20:04:19,192 --> 20:04:22,400
可以看到为什么我们以我们现在的方式做事

1810
20:04:22,400 --> 20:04:25,680
这样做了，再次恭喜

1811
20:04:25,680 --> 20:04:29,040
如果你想的话，你可以喝点茶点

1812
20:04:29,040 --> 20:04:32,872
再来一杯咖啡茶，下一章见

1813
20:04:32,872 --> 20:04:36,720
大家好，欢迎来到上一期 Flutter 课程的第 29 章

1814
20:04:36,720 --> 20:04:40,872
如您所见，我们使用便笺服务器工作并讨论了流

1815
20:04:40,872 --> 20:04:45,680
和流控制器我们已经付出了你知道很多努力

1816
20:04:45,680 --> 20:04:49,360
在我们的便笺服务中，以便与数据库进行对话并从中读取

1817
20:04:49,360 --> 20:04:52,480
数据库并缓存红色信息

1818
20:04:52,480 --> 20:04:56,240
在我们的笔记中 uh 成员变量所以如果你还没有看过上一章

1819
20:04:56,240 --> 20:04:58,800
我强烈建议你这样做，因为

1820
20:04:58,800 --> 20:05:01,360
在没有看过他的章节的情况下继续这门课程

1821
20:05:01,360 --> 20:05:05,512
按时间顺序让你很难继续，所以

1822
20:05:05,512 --> 20:05:08,640
我将建立在上一章的基础上，就像我们对另一章所做的那样

1823
20:05:08,640 --> 20:05:12,872
章节也是如此，在这一章中，我们将基本上开始投入

1824
20:05:12,872 --> 20:05:17,040
放置呃所有必要的结构，以便

1825
20:05:17,040 --> 20:05:20,400
我们能够显示所有用户生成的注释

1826
20:05:20,400 --> 20:05:24,800
在笔记视图中可以，所以你可以看到我们几乎

1827
20:05:24,800 --> 20:05:29,440
一切就绪，还有一些功能要做，我们也在这个

1828
20:05:29,440 --> 20:05:33,120
在本章的视频中，我们将讨论未来的建设者以及

1829
20:05:33,120 --> 20:05:36,400
流生成器，我认为我们没有谈论过

1830
20:05:36,400 --> 20:05:40,240
在我们讨论未来的构建器之前，流构建器，所以这将是一个

1831
20:05:40,240 --> 20:05:45,040
令人兴奋的是本章要讨论的新事物

1832
20:05:45,040 --> 20:05:48,800
好的，所以我刚刚在

1833
20:05:48,800 --> 20:05:52,160
嗯在上一章的结尾

1834
20:05:52,160 --> 20:05:57,120
我们现在在第 29 章需要做的是

1835
20:05:57,120 --> 20:06:01,192
允许用户进入便笺视图，并在进入便笺 c 时

1836
20:06:01,192 --> 20:06:05,440
现在您会看到，所有人总是要确保该用户存在于我们的数据库中

1837
20:06:05,440 --> 20:06:10,240
我们在这里有firebase，然后我们的用户在进入笔记视图时

1838
20:06:10,240 --> 20:06:14,960
该用户必须使用经过验证的电子邮件地址登录，以便该用户

1839
20:06:14,960 --> 20:06:19,360
存在我们知道该用户存在于firebase中并且有一个经过验证的电子邮件

1840
20:06:19,360 --> 20:06:24,480
地址，但该用户可能不存在于我们的数据库中记住我们要存储

1841
20:06:24,480 --> 20:06:29,600
用户在我们的数据库中生成注释并将它们连接到创建的用户

1842
20:06:29,600 --> 20:06:33,512
这些笔记还可以，所以嗯，所以在进入笔记视图时，我们

1843
20:06:33,512 --> 20:06:38,240
始终需要确保该用户存在于数据库中

1844
20:06:38,240 --> 20:06:40,960
以及如何做到这一点，如果你记得让我带上你不知道的代码

1845
20:06:40,960 --> 20:06:47,360
必须试着记住这一点，所以让我们进入我们的笔记服务，你可以看到

1846
20:06:47,360 --> 20:06:51,600
我们有一个名为获取所有笔记的函数，但我们没有任何功能

1847
20:06:51,600 --> 20:06:56,960
目前例如给我们一个特定用户的笔记，所以

1848
20:06:56,960 --> 20:07:01,040
如果我们想这样做，例如，如果您想获取所有笔记

1849
20:07:01,040 --> 20:07:05,120
特定用户然后我们将使用用户的电子邮件地址，因为如果

1850
20:07:05,120 --> 20:07:09,360
你看看我们的应用程序与 um 合作的方式

1851
20:07:09,360 --> 20:07:13,512
您可以看到的当前用户我们一直在与官员合作，所以我们不是

1852
20:07:13,512 --> 20:07:18,800
直接通过 um firebase，我们的身份验证服务也有一个关闭用户，所以

1853
20:07:18,800 --> 20:07:23,600
让我们看看我们的 auth 并看看 auth 用户，你会看到

1854
20:07:23,600 --> 20:07:28,080
我们的 auth 用户只有一个标志，只是说已通过电子邮件验证

1855
20:07:28,080 --> 20:07:33,192
那么我们如何去调用这个被称为get或create user on的函数

1856
20:07:33,192 --> 20:07:37,360
我们的便笺服务实际上没有我们当前的电子邮件地址

1857
20:07:37,360 --> 20:07:40,240
用户，这就是我们需要做的，我们需要做的

1858
20:07:40,240 --> 20:07:44,872
继续为我们的关闭用户添加一个电子邮件字段

1859
20:07:44,872 --> 20:07:49,120
所以正如标题所示，我们需要将此字段添加到我们的关闭用户

1860
20:07:49,120 --> 20:07:53,192
好的，所以我要稍微改变一下屏幕布局，让你看得更清楚

1861
20:07:53,192 --> 20:07:56,800
让我们继续在其中添加一个新字段，我要看看我的

1862
20:07:56,800 --> 20:08:02,640
还请注意 um 或 user so 并在此处添加一个新字段，我们

1863
20:08:02,640 --> 20:08:06,480
就叫它最后的字符串嗯电子邮件

1864
20:08:06,480 --> 20:08:12,240
就这样并从您的编辑那里获得帮助以添加电子邮件字段

1865
20:08:12,240 --> 20:08:17,360
在此处添加最终字段，因此这也将是必需的参数，例如

1866
20:08:17,360 --> 20:08:20,240
这个，我只是让它像这样需要它，它出现在

1867
20:08:20,240 --> 20:08:25,680
结束完成格式化，在这里我们实际创建我们的

1868
20:08:25,680 --> 20:08:30,240
auth 用户的实例我们要做的是说我们返回一个 auth 用户

1869
20:08:30,240 --> 20:08:34,160
并且电子邮件实际上已经在 firebase 用户中，让我们去 firebase

1870
20:08:34,160 --> 20:08:40,240
用户并查找电子邮件，您会看到有一个名为 email 的 getter 好

1871
20:08:40,240 --> 20:08:45,280
问题是这个电子邮件获取器是可选字符串所以我们需要做

1872
20:08:45,280 --> 20:08:50,000
只是让它成为可选的，也许在我们的关闭用户中也可以，所以在这里

1873
20:08:50,000 --> 20:08:53,280
我们在哪里创建关闭用户，我们只是说电子邮件字段等于

1874
20:08:53,280 --> 20:08:57,512
用户电子邮件并在此处末尾添加逗号，并在此处添加逗号以获取

1875
20:08:57,512 --> 20:09:01,512
格式，所以我们在这里所做的一切都会说我们的

1876
20:09:01,512 --> 20:09:06,552
r auth 用户有一个可选字符串作为其电子邮件，并且该电子邮件字符串被读取

1877
20:09:06,552 --> 20:09:10,552
来自firebase用户，这并不复杂

1878
20:09:10,552 --> 20:09:14,080
好的

1879
20:09:14,080 --> 20:09:18,000
好吧，我们需要做的就是如标题所示转到我们的笔记

1880
20:09:18,000 --> 20:09:23,512
在这里查看并抓取我们的笔记视图，然后我们需要阅读

1881
20:09:23,512 --> 20:09:28,080
当前用户的电子邮件地址没问题，所以我们要做的是说我们的

1882
20:09:28,080 --> 20:09:32,320
auth 用户有一个可选的电子邮件，但我们作为应用程序开发人员确信

1883
20:09:32,320 --> 20:09:36,872
因为我们使用的是电子邮件和密码注册，所以我们确信

1884
20:09:36,872 --> 20:09:41,360
任何最终进入笔记视图的用户都有一个电子邮件地址，所以

1885
20:09:41,360 --> 20:09:45,360
这是我们要做的假设，尽管我们离开了

1886
20:09:45,360 --> 20:09:48,480
让我们看看能不能找到它的用户

1887
20:09:48,480 --> 20:09:52,800
关闭用户这里虽然关闭用户说我可以选择有一个电子邮件但是

1888
20:09:52,800 --> 20:09:56,240
我们总是会说不，电子邮件应该存在，因为我们只是在

1889
20:09:56,240 --> 20:10:01,040
使用电子邮件密码登录方法的那一刻好吧

1890
20:10:01,040 --> 20:10:05,680
为了让这个笔记视图能够调用笔记服务和

1891
20:10:05,680 --> 20:10:09,192
抢或抱歉创建或获取当前

1892
20:10:09,192 --> 20:10:13,760
用户它需要一封电子邮件，所以让我们继续在我们的笔记中公开一个功能

1893
20:10:13,760 --> 20:10:17,040
视图作为标题表示抓取

1894
20:10:17,040 --> 20:10:22,000
用户的电子邮件，所以让我们进入这里，我也将进入我的笔记视图

1895
20:10:22,000 --> 20:10:25,280
我的笔记没问题

1896
20:10:25,280 --> 20:10:29,512
我们要做的只是暴露用户的电子邮件，所以让我们

1897
20:10:29,512 --> 20:10:34,720
只是说字符串获取用户电子邮件

1898
20:10:34,720 --> 20:10:38,640
让我们也摆脱这个side explorer

1899
20:10:38,640 --> 20:10:43,192
我要说的是服务火力基地

1900
20:10:43,192 --> 20:10:47,120
好的服务，我不认为它是进口的，所以让我们看看是不是

1901
20:10:47,120 --> 20:10:50,800
进口的

1902
20:10:50,800 --> 20:10:54,080
关闭服务是的，它是进口的，好吧，这很好

1903
20:10:54,080 --> 20:10:57,832
关于火力基地

1904
20:10:57,832 --> 20:11:01,440
这不可能是平等的，所以这就是为什么它会有点疯狂的火力基地

1905
20:11:01,440 --> 20:11:05,680
然后我们会说当前用户，你会看到这个当前用户现在

1906
20:11:05,680 --> 20:11:09,120
可选，但因为我们是应用程序开发人员，我们确信

1907
20:11:09,120 --> 20:11:12,872
如果您最终进入注释视图，那么您应该有一个当前用户

1908
20:11:12,872 --> 20:11:16,000
这就是我们在前面的步骤中已经确定的，所以如果你看

1909
20:11:16,000 --> 20:11:19,192
在登录屏幕上，例如在我们的登录中

1910
20:11:19,192 --> 20:11:24,480
查看所以我在这里打开登录视图我们说当前用户是否存在并且是

1911
20:11:24,480 --> 20:11:27,760
电子邮件验证为真，然后转到注释视图，以便

1912
20:11:27,760 --> 20:11:31,192
那么我们可以确定在notes视图中我们已经有一个用户了

1913
20:11:31,192 --> 20:11:34,480
所以这个当前在firebase的用户目前

1914
20:11:34,480 --> 20:11:39,280
说是可选的，但我们要快速打开它，好吧，然后我们要

1915
20:11:39,280 --> 20:11:44,640
说电子邮件并强制打开它

1916
20:11:44,640 --> 20:11:48,552
好吧，这就是我们所做的，所以现在我们得到了

1917
20:11:48,552 --> 20:11:54,640
如果你记得在我们的 um 里面，现在用户的电子邮件

1918
20:11:54,640 --> 20:11:58,320
在我们的便笺服务中，我们有两个非常重要的功能

1919
20:11:58,320 --> 20:12:04,872
时刻位于此类的底部，称为打开和关闭

1920
20:12:04,872 --> 20:12:08,872
分别，我们需要确保的是

1921
20:12:08,872 --> 20:12:15,512
在去注释视图时，我们的数据库实际上是打开的，所以我们

1922
20:12:15,512 --> 20:12:20,800
如果

1923
20:12:20,800 --> 20:12:24,552
数据库句柄实际上并没有被创建，所以

1924
20:12:24,552 --> 20:12:28,480
然后让我们转到我们的 uh notes 视图和

1925
20:12:28,480 --> 20:12:31,920
如您所见，这就是我们制作此内容的原因，并注意查看a

1926
20:12:31,920 --> 20:12:37,192
有状态的小部件，因为我们现在需要挂钩的两个生命周期事件

1927
20:12:37,192 --> 20:12:42,000
我们注意到您并在创建此节点时打开我们的数据库 2 和

1928
20:12:42,000 --> 20:12:45,512
然后在处理数据库时关闭数据库

1929
20:12:45,512 --> 20:12:49,040
如标题所示，让我们去覆盖 init 状态函数

1930
20:12:49,040 --> 20:12:52,720
好的，我们要在这里做什么，我们要说

1931
20:12:52,720 --> 20:12:57,512
嗯，现在我们基本上想在我们的

1932
20:12:57,512 --> 20:13:03,360
初始化状态，我们还需要确保它是打开的，所以

1933
20:13:03,360 --> 20:13:07,600
所以让我们看看 呃让我也看看我的笔记

1934
20:13:07,600 --> 20:13:10,160
好吧，嗯

1935
20:13:10,160 --> 20:13:14,000
我们需要在那里打开数据库，所以让我们开始吧

1936
20:13:14,000 --> 20:13:17,600
抓住我们的便笺服务，所以我们现在没有便笺服务，但是

1937
20:13:17,600 --> 20:13:23,832
我们将创建它，所以让我们说一下最后的最后笔记

1938
20:13:23,832 --> 20:13:30,000
所以这是我们的 uh notes view uh undefined class notes 服务

1939
20:13:30,000 --> 20:13:34,080
我们没有导入笔记服务，我们还没有，所以让我们在导入时做吧

1940
20:13:34,080 --> 20:13:38,720
现在这是我们的笔记视图，它抓住了一个节点的实例

1941
20:13:38,720 --> 20:13:44,400
服务器，以便它可以使用它，好吧，嗯

1942
20:13:44,400 --> 20:13:48,000
让我们继续这样做，然后我们要说

1943
20:13:48,000 --> 20:13:52,720
笔记服务等于节点的一个实例

1944
20:13:52,720 --> 20:13:57,760
像这样的服务，然后我们要说 nodeservice.open

1945
20:13:57,760 --> 20:14:01,040
现在这个功能是未来的空白

1946
20:14:01,040 --> 20:14:04,720
你可能真的无法做到

1947
20:14:04,720 --> 20:14:08,800
async 在您的 init 中说明，但我们现在只是说

1948
20:14:08,800 --> 20:14:14,800
open all right 所以打开数据库，这就是我们所要做的，然后我们

1949
20:14:14,800 --> 20:14:18,872
必须照顾关闭数据库所以让我们继续说

1950
20:14:18,872 --> 20:14:23,040
在处理这个 uh notes 意见处理后，我们

1951
20:14:23,040 --> 20:14:27,040
还要关闭数据库，因为我们是飞镖实验室的好公民，所以

1952
20:14:27,040 --> 20:14:30,640
我们不只是要让数据库保持打开状态，所以节点服务和我们

1953
20:14:30,640 --> 20:14:35,440
会说关闭好吧，仅此而已

1954
20:14:35,440 --> 20:14:38,640
我们现在必须做

1955
20:14:38,640 --> 20:14:45,440
好吧，好东西，让我们保存这个，嗯，我也可能会带一个 crcpy

1956
20:14:45,440 --> 20:14:49,192
在这里，我要做的就是做一个

1957
20:14:49,192 --> 20:14:52,960
热重启和

1958
20:14:52,960 --> 20:14:57,680
让我们退出，然后我将使用该用户登录

1959
20:14:57,680 --> 20:15:03,120
再说一次，如果我能拼出pick solitude

1960
20:15:03,120 --> 20:15:07,120
嗯 foo barb 我的密码太可怕了

1961
20:15:07,120 --> 20:15:11,680
在身份验证错误之前提到了这一点

1962
20:15:11,680 --> 20:15:16,640
foo barbaz 可能是因为这个呃电话

1963
20:15:16,640 --> 20:15:21,832
现在没有无线网络所以让我们进去打开无线网络然后我会

1964
20:15:21,832 --> 20:15:24,800
回到这里 Android 手机通常是初始的

1965
20:15:24,800 --> 20:15:28,240
非常快地初始化他们的 wi-fi 站点，所以现在我们应该可以说登录

1966
20:15:28,240 --> 20:15:31,120
我们最终进入了应用程序的主界面，所以这个打开的函数有

1967
20:15:31,120 --> 20:15:34,240
进展顺利，我可以看到我们没有任何

1968
20:15:34,240 --> 20:15:38,080
调试控制台中抛出的异常，所以

1969
20:15:38,080 --> 20:15:42,640
那是打开和关闭的

1970
20:15:42,640 --> 20:15:48,000
所以让我们看看这里，嗯，正如你在标题中看到的那样

1971
20:15:48,000 --> 20:15:52,240
现在我们正在做的是我们就像发布不同的功能

1972
20:15:52,240 --> 20:15:55,920
例如我们的函数让我们看看删除用户它的作用是

1973
20:15:55,920 --> 20:16:00,480
它说 get database or throw um 并且目前这个 get database or

1974
20:16:00,480 --> 20:16:05,680
throw 它所做的唯一事情就是确保该数据库在那里可用

1975
20:16:05,680 --> 20:16:08,640
但它并不能确保该数据库是打开的，因此它只是使

1976
20:16:08,640 --> 20:16:13,360
确保节点中有互联网中的数据库实例

1977
20:16:13,360 --> 20:16:17,192
服务所以我们现在需要确保的是

1978
20:16:17,192 --> 20:16:20,872
与我们的数据库一起工作的每个功能首先确保数据库

1979
20:16:20,872 --> 20:16:25,360
不仅有实例，而且数据库也有

1980
20:16:25,360 --> 20:16:28,960
可以正常打开，因为如果您查看

1981
20:16:28,960 --> 20:16:32,960
对不起，我们有开放的数据库，基本上

1982
20:16:32,960 --> 20:16:36,240
可以将实例设置为该数据库

1983
20:16:36,240 --> 20:16:40,640
所以我们需要做的是创建一个小函数，上面写着确保

1984
20:16:40,640 --> 20:16:45,040
数据库，它叫什么，确保数据库是打开的

1985
20:16:45,040 --> 20:16:47,920
呃，我只是要继续前进，并有一个

1986
20:16:47,920 --> 20:16:55,680
看看我的笔记，确保数据库打开，嗯，让我们看看

1987
20:16:55,680 --> 20:17:00,080
把它放在上面打开，好吧，所以

1988
20:17:00,080 --> 20:17:04,080
如果您和我一起关注，您只需转到打开功能的顶部，然后

1989
20:17:04,080 --> 20:17:09,280
我们只是说future void确保数据库是开放的

1990
20:17:09,280 --> 20:17:13,760
这是一个异步函数

1991
20:17:13,760 --> 20:17:17,120
那么我们要做的就是

1992
20:17:17,120 --> 20:17:21,680
说嗯让我们看看

1993
20:17:21,680 --> 20:17:26,640
我们将在这里放一个 try 块，让我们看看我们的 open

1994
20:17:26,640 --> 20:17:30,480
此刻的函数抛出一个异常，说数据库

1995
20:17:30,480 --> 20:17:33,192
已经打开异常所以我们需要确保我们缓存它

1996
20:17:33,192 --> 20:17:39,680
例外，所以当我们的 uh 我们的 uh notes 视图被热重新加载时

1997
20:17:39,680 --> 20:17:43,680
它不应该一遍又一遍地尝试打开数据库，如果确实如此

1998
20:17:43,680 --> 20:17:46,720
这个打开的函数会抛出异常

1999
20:17:46,720 --> 20:17:51,120
嗯，我们确保 dbs 开放功能是

2000
20:17:51,120 --> 20:17:55,040
会抓住它，它会让它一切都好，所以它所做的就是

2001
20:17:55,040 --> 20:17:58,160
我们只是确保我们不会开放

2002
20:17:58,160 --> 20:18:01,512
一遍又一遍的数据库，因为这只是开销

2003
20:18:01,512 --> 20:18:06,000
所以我们接下来要做的是我们会说等待在这里打开

2004
20:18:06,000 --> 20:18:09,600
在这里我们说我们正在捕获数据库

2005
20:18:09,600 --> 20:18:14,000
已经打开了异常，在这种情况下我们就让它过去吧

2006
20:18:14,000 --> 20:18:20,320
我们只是说对不起，所以现在我们有了这个

2007
20:18:20,320 --> 20:18:25,680
介绍数据库功能是开放的呃这是你的数据库是开放的功能

2008
20:18:25,680 --> 20:18:30,720
我们需要开始使用那个嗯所以让我提出正确的标题所以

2009
20:18:30,720 --> 20:18:34,552
我们需要开始在各种功能中使用确保数据库打开功能

2010
20:18:34,552 --> 20:18:38,720
我们的应用程序让我们先去删除用户

2011
20:18:38,720 --> 20:18:42,400
在这里，我们只是说等待

2012
20:18:42,400 --> 20:18:49,360
确保数据库是打开的，这是第一位的，让我们去创建用户

2013
20:18:49,360 --> 20:18:53,040
嗯，我们有一个叫做创建用户的函数

2014
20:18:53,040 --> 20:18:56,240
在这里，我们将等待确保 db 是

2015
20:18:56,240 --> 20:18:59,920
打开好

2016
20:18:59,920 --> 20:19:03,440
那是创建用户现在让我们去getuser

2017
20:19:03,440 --> 20:19:07,120
如果我出于某种原因可以访问此功能，则可以在此处获取用户

2018
20:19:07,120 --> 20:19:13,360
不能去这里，让我们说等待数据库结束了

2019
20:19:13,360 --> 20:19:18,320
呃 那就是那部分让我们去拿所有的笔记

2020
20:19:18,320 --> 20:19:22,160
函数获取所有笔记并做同样的事情等待

2021
20:19:22,160 --> 20:19:27,440
确保数据库是打开的哦，我也可以看到我实际上并没有打电话

2022
20:19:27,440 --> 20:19:31,120
这个功能，所以让我们确保我已经在其他地方完成了它

2023
20:19:31,120 --> 20:19:35,280
只是要复制该代码并确保 bb 是打开的让我们确保我是

2024
20:19:35,280 --> 20:19:40,160
实际上调用函数，就像我不喜欢把它放在那里

2025
20:19:40,160 --> 20:19:44,320
所以它看起来很好，所以你必须这样做

2026
20:19:44,320 --> 20:19:48,400
节点功能也一样，我们将去创建节点和

2027
20:19:48,400 --> 20:19:52,480
做同样的事情，所以让我们继续等待

2028
20:19:52,480 --> 20:19:56,960
实际上将该代码粘贴在那里等待确保数据库是打开的

2029
20:19:56,960 --> 20:20:01,040
我们需要在 um 中完成，所以我们没有在创建节点中完成

2030
20:20:01,040 --> 20:20:05,120
让我们继续删除节点删除节点

2031
20:20:05,120 --> 20:20:08,552
并将函数粘贴在那里以及抱歉粘贴

2032
20:20:08,552 --> 20:20:13,040
调用函数删除所有节点

2033
20:20:13,040 --> 20:20:18,480
以及删除那里的所有节点做同样的事情，我们也这样做

2034
20:20:18,480 --> 20:20:21,280
在这里得到注释

2035
20:20:21,280 --> 20:20:26,872
同样的事情，我们还有什么，我们还有什么

2036
20:20:26,872 --> 20:20:30,400
在那里更新笔记

2037
20:20:30,400 --> 20:20:35,040
我们第一次打电话

2038
20:20:35,040 --> 20:20:38,480
但是然后呃我们还需要在哪里做呢

2039
20:20:38,480 --> 20:20:43,120
让我们看看我们现在已经完成了删除用户是的我想现在我们放置了确保数据库

2040
20:20:43,120 --> 20:20:46,640
打开所有这些电话

2041
20:20:46,640 --> 20:20:53,512
好的，这是很多信息，所以我们现在需要做的是

2042
20:20:53,512 --> 20:20:58,720
基本上确保我们按照我们在

2043
20:20:58,720 --> 20:21:02,080
本章开头现在你看到了

2044
20:21:02,080 --> 20:21:06,960
我们创建确保数据库打开的原因是在任何这些之前

2045
20:21:06,960 --> 20:21:11,832
函数被调用，我们的代码实际上是要打开数据库

2046
20:21:11,832 --> 20:21:16,400
我们这意味着在我们的笔记视图中我们实际上不必再这样做了，因为

2047
20:21:16,400 --> 20:21:21,192
我们知道，通过向我们的节点服务发出任何与数据库相关的命令

2048
20:21:21,192 --> 20:21:25,192
该函数本身将为我们打开数据库它只是一个

2049
20:21:25,192 --> 20:21:29,120
我们节点服务器中的一个不错的小功能，以确保我们不必制作

2050
20:21:29,120 --> 20:21:35,120
在我们之前打开数据库的额外调用

2051
20:21:35,120 --> 20:21:39,192
开始使用我们的节点服务好吧，这样就方便了一点

2052
20:21:39,192 --> 20:21:42,480
现在我可以作为字幕案例发挥作用

2053
20:21:42,480 --> 20:21:47,760
将谈论未来的构建器和异步快照，嗯，我们已经谈过了

2054
20:21:47,760 --> 20:21:52,400
实际上之前有点关于未来的建设者

2055
20:21:52,400 --> 20:21:57,360
但是呃，未来的建设者是什么，也许实际上你应该把它写在这里

2056
20:21:57,360 --> 20:22:00,960
builder，然后转到代码，这样您就可以更好地看到它

2057
20:22:00,960 --> 20:22:07,760
它是一个有状态的小部件，它的作用是订阅未来

2058
20:22:07,760 --> 20:22:11,040
如果你熟悉 javascript 那么它将在未来返回它的值

2059
20:22:11,040 --> 20:22:13,680
你会知道它是承诺

2060
20:22:13,680 --> 20:22:18,960
呃，如果你熟悉 rx swift 或任何与 rx 相关的东西，那么你就会知道

2061
20:22:18,960 --> 20:22:22,552
可能就像一个单一的或可观察的，实际上不是一个

2062
20:22:22,552 --> 20:22:25,440
可观察的，因为这是一个流构建器，未来的构建器有点像

2063
20:22:25,440 --> 20:22:30,000
单个构建器意味着一个值从某个地方开始，然后

2064
20:22:30,000 --> 20:22:34,320
计算一些东西返回它的值，然后它完成了

2065
20:22:34,320 --> 20:22:37,512
所以未来的建设者允许你提交未来

2066
20:22:37,512 --> 20:22:41,760
它将允许您提交一个构建器，这意味着

2067
20:22:41,760 --> 20:22:45,760
它将产生价值的那段代码作为它所说的未来

2068
20:22:45,760 --> 20:22:50,552
好吧，现在它是我的了，我会订阅它作为它的价值

2069
20:22:50,552 --> 20:22:54,320
未来的变化我会给你返回各种小部件的能力

2070
20:22:54,320 --> 20:22:58,320
需要显示在屏幕上，所以它基本上是联系在一起的

2071
20:22:58,320 --> 20:23:01,512
你未来的逻辑和你的 ui 逻辑所以它是

2072
20:23:01,512 --> 20:23:05,920
绝对漂亮，所以我们现在需要做的是

2073
20:23:05,920 --> 20:23:11,192
确保在您看到的正文中转到我们的构建功能时

2074
20:23:11,192 --> 20:23:16,872
在我们的注释视图的正文中，我们需要确保

2075
20:23:16,872 --> 20:23:22,000
我们正在创建用户或获取当前用户

2076
20:23:22,000 --> 20:23:26,800
数据库中的用户，如果它已经存在并且我们正在创建该用户，如果

2077
20:23:26,800 --> 20:23:30,640
该用户不存在，如果您还记得我们有此功能

2078
20:23:30,640 --> 20:23:35,920
它已经被称为获取或创建某物某事获取或创建

2079
20:23:35,920 --> 20:23:41,280
用户，这是一个未来，所以我们将在我们的 uh 笔记中创建一个未来的构建器

2080
20:23:41,280 --> 20:23:45,832
订阅自己返回的值的视图 this 然后它

2081
20:23:45,832 --> 20:23:49,920
将告诉我们各种更新，这些不同的更新将是

2082
20:23:49,920 --> 20:23:54,720
作为所谓的异步快照提供给我们的异步快照是

2083
20:23:54,720 --> 20:23:58,640
基本上，正如它的名字所表明的那样，它是一个包装器，作为围绕

2084
20:23:58,640 --> 20:24:02,640
异步功能，在这种情况下是我们的未来

2085
20:24:02,640 --> 20:24:07,440
获取或创建用户，这就是我们将在我们的

2086
20:24:07,440 --> 20:24:11,680
注释视图，如您在

2087
20:24:11,680 --> 20:24:16,000
标题我们现在要在节点视图中返回一个未来的构建器。

2088
20:24:16,000 --> 20:24:21,280
实际上应该说注释查看注释下划线

2089
20:24:21,280 --> 20:24:24,000
查看所以我也要修复标题

2090
20:24:24,000 --> 20:24:29,512
我不会混淆任何人，包括我自己和笔记视图

2091
20:24:29,512 --> 20:24:32,240
所以现在最好我为此道歉

2092
20:24:32,240 --> 20:24:35,280
所以现在我们有这个你好世界但是

2093
20:24:35,280 --> 20:24:39,360
我们要改变它，让它返回一个笔记视图，所以我要说对不起

2094
20:24:39,360 --> 20:24:43,600
未来的建设者，假设我们现在返回一个未来的建设者

2095
20:24:43,600 --> 20:24:46,552
现在它说好的，我们必须提供两个参数

2096
20:24:46,552 --> 20:24:50,552
是未来另一个实际上是构建器功能所以构建器

2097
20:24:50,552 --> 20:24:52,872
对不起，未来本身就是

2098
20:24:52,872 --> 20:24:56,800
你看到未来是我们的笔记服务

2099
20:24:56,800 --> 20:25:02,000
如果您记得是当前用户的电子邮件，请获取或创建用户和电子邮件

2100
20:25:02,000 --> 20:25:06,640
我们为被调用的用户电子邮件创建了一个 getter 的地址，所以让我们把它

2101
20:25:06,640 --> 20:25:10,640
在那里用户电子邮件，然后你可以看到它仍然在抱怨说

2102
20:25:10,640 --> 20:25:14,320
尚未提供构建器功能

2103
20:25:14,320 --> 20:25:17,280
所以让我们说我们有一个构建器函数

2104
20:25:17,280 --> 20:25:21,512
就在那里，我谈到了异步快照，因为那是参数

2105
20:25:21,512 --> 20:25:27,832
你进入这里的是现在对象的异步快照快照

2106
20:25:27,832 --> 20:25:34,080
但我们会解决这个问题，所以我们就在这里

2107
20:25:34,080 --> 20:25:39,832
然后让我们在这里讨论一下这个功能

2108
20:25:39,832 --> 20:25:43,120
所以在我们获取当前用户或创建后

2109
20:25:43,120 --> 20:25:48,000
一个新用户，如果该用户在我们的数据库中不存在，我们还需要获取所有

2110
20:25:48,000 --> 20:25:51,680
该用户的节点和

2111
20:25:51,680 --> 20:25:56,000
我们现在没有功能

2112
20:25:56,000 --> 20:26:00,000
拥有当前用户的所有节点流，我们将添加它

2113
20:26:00,000 --> 20:26:03,832
很快，但正如您在缓存中看到的那样，我们可以通过我们的流实现这一点

2114
20:26:03,832 --> 20:26:08,080
我们已经在我们的节点中放置的控制器作为基础

2115
20:26:08,080 --> 20:26:11,440
服务所以让我们去创造一点

2116
20:26:11,440 --> 20:26:15,832
我们的笔记服务中的功能 dot dart

2117
20:26:15,832 --> 20:26:20,480
正如你所看到的，它允许你检索所有的笔记，所以

2118
20:26:20,480 --> 20:26:24,080
我们只会说流

2119
20:26:24,080 --> 20:26:29,280
像这样的数据库注释列表

2120
20:26:29,280 --> 20:26:34,720
我们它是一个吸气剂，我们称它为所有的笔记都可以，它的作用是

2121
20:26:34,720 --> 20:26:39,600
本身将订阅这个笔记流控制器并检索所有

2122
20:26:39,600 --> 20:26:42,872
来自该控制器的注释，因为请记住此注释流控制器

2123
20:26:42,872 --> 20:26:46,800
它本身就包含了这个家伙

2124
20:26:46,800 --> 20:26:50,320
所以这就是我们要做的我们要说它返回节点

2125
20:26:50,320 --> 20:26:54,240
流控制器流

2126
20:26:54,240 --> 20:26:58,640
实际上，另一个流得到所有的东西都不是很抱歉这是错误的

2127
20:26:58,640 --> 20:27:01,600
和流

2128
20:27:01,600 --> 20:27:04,720
好的

2129
20:27:04,720 --> 20:27:09,680
所以这是我们获取所有笔记的吸气剂，嗯，现在我们需要做的是

2130
20:27:09,680 --> 20:27:15,600
现在我们已经在 note2.dart 中创建了我们的 uh so back to back

2131
20:27:15,600 --> 20:27:19,280
创建了我们的用户

2132
20:27:19,280 --> 20:27:26,160
我们需要确保的是，如果可以创建用户，那么我们就是

2133
20:27:26,160 --> 20:27:30,320
将使用称为流构建器的东西来检索所有

2134
20:27:30,320 --> 20:27:34,160
节点服务中的节点，然后将它们呈现在屏幕上

2135
20:27:34,160 --> 20:27:37,600
但是我们还不能渲染它们我们没有任何用户生成的内容而且我们

2136
20:27:37,600 --> 20:27:41,120
还不知道如何渲染它们，所以首先让我们处理一下

2137
20:27:41,120 --> 20:27:45,680
这里这个快照在这里我们需要做的是说如果 snapchat

2138
20:27:45,680 --> 20:27:51,600
连接状态是连接状态点完成

2139
20:27:51,600 --> 20:27:53,920
像这样嗯

2140
20:27:53,920 --> 20:27:57,440
如果是这样的话，那么我们将在这里做一些逻辑，所以让我们说

2141
20:27:57,440 --> 20:28:03,360
现在返回一个你好的文本好吧实际上我们可能需要切换它所以

2142
20:28:03,360 --> 20:28:07,680
让我们说开关

2143
20:28:07,680 --> 20:28:12,872
快照点连接状态，我真的很想得到呃视觉工作室代码

2144
20:28:12,872 --> 20:28:16,080
为我完成剩下的，所以我不喜欢写所有的案例，所以我只是

2145
20:28:16,080 --> 20:28:19,832
我会说命令点或在 Mac 上或在 Linux 和 Windows 上控制点我说

2146
20:28:19,832 --> 20:28:24,240
添加缺少的案例条款，在完成的情况下，我只想说返回

2147
20:28:24,240 --> 20:28:28,720
如果创建或检索

2148
20:28:28,720 --> 20:28:32,960
当前用户已完成，然后返回此文本 hello

2149
20:28:32,960 --> 20:28:38,160
在任何其他情况下，例如在默认情况下

2150
20:28:38,160 --> 20:28:43,680
我们只是要返回一个循环进度指示器，就像

2151
20:28:43,680 --> 20:28:48,400
那好吧，那我就完成了

2152
20:28:48,400 --> 20:28:52,400
上面那个就好了

2153
20:28:52,400 --> 20:28:59,040
然后让我们进行热重启，我可以看到我的 um scrcpy 有点崩溃了

2154
20:28:59,040 --> 20:29:03,280
是的，有时会发生这样的事情，没关系，让我继续吧

2155
20:29:03,280 --> 20:29:08,080
回到这个 shell 并说 hcr cpy

2156
20:29:08,080 --> 20:29:11,600
该应用程序运行良好，只是 scr cpy 波峰，所以我只是

2157
20:29:11,600 --> 20:29:15,440
我会说你的笔记现在会出现在这里

2158
20:29:15,440 --> 20:29:19,832
command 实际上我的调试过程已经崩溃了

2159
20:29:19,832 --> 20:29:22,552
好吧，所以我现在要运行该应用程序

2160
20:29:22,552 --> 20:29:25,760
再次

2161
20:29:25,760 --> 20:29:29,360
希望这个 gradle 任务进展得很快，因为我们已经

2162
20:29:29,360 --> 20:29:32,320
已经编译了之前的应用程序

2163
20:29:32,320 --> 20:29:37,192
所以我们需要做什么你看我们现在正在确保用户

2164
20:29:37,192 --> 20:29:40,960
如果它不存在，则在数据库中创建，或者如果存在我们正在获取用户

2165
20:29:40,960 --> 20:29:46,000
用户存在于数据库中，但我们还需要做的是开始收听

2166
20:29:46,000 --> 20:29:50,720
在我们的笔记服务中更改此流，称为所有节点和

2167
20:29:50,720 --> 20:29:55,760
根据该流的状态，然后我们将构建我们的用户

2168
20:29:55,760 --> 20:30:00,960
界面没问题，所以在这里我们实际上不会像这样返回

2169
20:30:00,960 --> 20:30:05,360
嘿，你的笔记会出现在这里，但我们实际上会使用

2170
20:30:05,360 --> 20:30:10,320
流构建器，它与未来的构建器非常相似，但它实际上会监听

2171
20:30:10,320 --> 20:30:14,400
更改为流好

2172
20:30:14,400 --> 20:30:18,400
所以哎呀，我只是杀死了应用程序

2173
20:30:18,400 --> 20:30:21,192
就在这里，所以我们去你的笔记会出现

2174
20:30:21,192 --> 20:30:24,552
在这里，这似乎工作正常，所以让我们

2175
20:30:24,552 --> 20:30:29,832
进去然后说我们想嗯

2176
20:30:29,832 --> 20:30:32,872
返回我们的流生成器​​，我要放这个

2177
20:30:32,872 --> 20:30:37,192
回过头来，在我们这样做之前，我想解释一下我已经

2178
20:30:37,192 --> 20:30:42,080
显示在标题中的等待和黎明标志是什么

2179
20:30:42,080 --> 20:30:45,680
您看到的流构建器和未来的连接状态

2180
20:30:45,680 --> 20:30:49,440
builder 使用称为异步快照的东西，这就是你看到的这个人

2181
20:30:49,440 --> 20:30:53,920
异步快照和这个异步快照可以有各种连接状态，所以如果

2182
20:30:53,920 --> 20:30:58,000
你在那里进入连接状态，你可以看到我们没有等待活动

2183
20:30:58,000 --> 20:31:03,600
做得很好

2184
20:31:03,600 --> 20:31:07,120
当你当你看到在一个活跃的情况下说例如一个

2185
20:31:07,120 --> 20:31:10,872
已返回至少一个值但尚未完成的流

2186
20:31:10,872 --> 20:31:17,440
所以那是为了一个流，呃，但是如果你在等待一个未来或者

2187
20:31:17,440 --> 20:31:21,360
一个流然后你会得到这个等待标志，它会发生

2188
20:31:21,360 --> 20:31:26,640
给你一个未来，一个已经完成任务的未来，就像我说的那样

2189
20:31:26,640 --> 20:31:30,552
一些东西，它完成了，但一个流通常它只是继续生活，所以你

2190
20:31:30,552 --> 20:31:34,400
不喜欢挂钩，或者您不应该挂钩到流的完成事件

2191
20:31:34,400 --> 20:31:39,440
但你实际上应该挂在你的等待中

2192
20:31:39,440 --> 20:31:42,480
连接状态，这就是我们要做的，所以连接保持完成

2193
20:31:42,480 --> 20:31:46,872
嗯的一个未来和一个连接状态是

2194
20:31:46,872 --> 20:31:51,280
等待流所以在这里让我们创建一个

2195
20:31:51,280 --> 20:31:55,920
流生成器和我们的流

2196
20:31:55,920 --> 20:32:03,440
将成为我们的笔记服务所有笔记嗯

2197
20:32:03,440 --> 20:32:08,080
这就是流本身，然后我们需要一个构建器，让我们来看看

2198
20:32:08,080 --> 20:32:13,280
工作室为我们完成，嗯，好吧，在建设者中我们要做什么

2199
20:32:13,280 --> 20:32:19,120
做的是我们要说切换快照连接状态

2200
20:32:19,120 --> 20:32:22,320
像这样获取visual studio代码来为你完成剩下的

2201
20:32:22,320 --> 20:32:26,480
在等待的情况下

2202
20:32:26,480 --> 20:32:30,640
我们只会说返回

2203
20:32:30,640 --> 20:32:36,160
暂停文本等待所有笔记

2204
20:32:36,160 --> 20:32:40,552
好的，我要从这里删除休息

2205
20:32:40,552 --> 20:32:45,192
在任何其他情况下，在默认情况下，我们只会说

2206
20:32:45,192 --> 20:32:50,320
返回循环进度指示器就像

2207
20:32:50,320 --> 20:32:54,320
所以现在你看看我是否命令 s 变热

2208
20:32:54,320 --> 20:32:58,800
重新加载然后它只是说等待所有节点出现在屏幕上所以

2209
20:32:58,800 --> 20:33:04,800
这现在就像我们应用程序的注释视图的骨架，因此它

2210
20:33:04,800 --> 20:33:08,552
处理两件事情，它让当前用户使用他或她的电子邮件

2211
20:33:08,552 --> 20:33:11,680
如果该用户已存在于数据库中或创建它，则地址为

2212
20:33:11,680 --> 20:33:16,320
未来构建器和未来返回的小部件

2213
20:33:16,320 --> 20:33:20,960
builder 本身就是一个流构建器，因此流构建器然后计算

2214
20:33:20,960 --> 20:33:25,512
所有节点并从节点服务返回它们，然后它有一个

2215
20:33:25,512 --> 20:33:28,960
连接状态和等待现在又说等待所有

2216
20:33:28,960 --> 20:33:31,360
节点，我们稍后会改变它

2217
20:33:31,360 --> 20:33:34,872
所以，所以，呃

2218
20:33:34,872 --> 20:33:38,240
它不只是返回一个文本它实际上返回一个笔记列表

2219
20:33:38,240 --> 20:33:42,320
那么现在让我们谈谈别的

2220
20:33:42,320 --> 20:33:46,872
在我们结束这一章之前，你现在看到我们正在做的是

2221
20:33:46,872 --> 20:33:53,040
我们说我们的便笺服务是这里的一项新服务，所以每次

2222
20:33:53,040 --> 20:33:57,680
如果我在这里命令 s 或者您进行了热重载或热，则进入初始化状态

2223
20:33:57,680 --> 20:34:01,120
在这里重启实际上是热重启这个

2224
20:34:01,120 --> 20:34:04,400
我可以看到也许这就是我们使整个应用程序崩溃的原因，因为

2225
20:34:04,400 --> 20:34:07,360
我们正在创建一个新的节点服务，这可能是我可以看到热的原因

2226
20:34:07,360 --> 20:34:11,920
重启现在有点不稳定所以嗯，这就是原因

2227
20:34:11,920 --> 20:34:15,192
如果你不熟悉什么

2228
20:34:15,192 --> 20:34:19,760
单例是单例本质上是软件开发中使用的一种模式

2229
20:34:19,760 --> 20:34:24,872
您在其中创建服务实例或类实例

2230
20:34:24,872 --> 20:34:30,240
该类实例现在只是整个应用程序中的一个

2231
20:34:30,240 --> 20:34:33,760
在我们的应用程序中的任何地方，我们都可以去创建一个新的节点服务实例

2232
20:34:33,760 --> 20:34:38,000
但是如果您考虑一下，节点服务应该只作为一个副本存在

2233
20:34:38,000 --> 20:34:41,360
整个应用程序不应该像制作此笔记的新副本

2234
20:34:41,360 --> 20:34:44,720
一遍又一遍地服务，这就是单例，这就是

2235
20:34:44,720 --> 20:34:50,320
我们将使用我们的便笺服务，所以我知道我有一点问题

2236
20:34:50,320 --> 20:34:53,440
和我的嗯

2237
20:34:53,440 --> 20:34:56,400
字幕，我将带来下一个字幕并修复它

2238
20:34:56,400 --> 20:35:00,720
所以让我们先继续，呃，在我运行应用程序之前，也许我们

2239
20:35:00,720 --> 20:35:04,080
应该用我们的单例解决这个问题，所以让我们转到我们的注释

2240
20:35:04,080 --> 20:35:08,320
服务，我们现在要创建一个

2241
20:35:08,320 --> 20:35:12,800
各种语言的单例模式我的意思是它与语言不同

2242
20:35:12,800 --> 20:35:16,872
在我看来，对你说实话，飞镖并不像应该的那样干净

2243
20:35:16,872 --> 20:35:22,240
例如它在诸如 swift um 之类的语言中，但它就是这样，我们需要

2244
20:35:22,240 --> 20:35:26,552
有点像现在这样工作

2245
20:35:26,552 --> 20:35:30,000
所以我们这样做的方式是我们做我们的

2246
20:35:30,000 --> 20:35:35,512
课堂笔记服务单身人士继续前进

2247
20:35:35,512 --> 20:35:40,080
首先为我们的类创建一个私有构造函数，所以我们要去

2248
20:35:40,080 --> 20:35:45,040
说注意服务下划线只是一个

2249
20:35:45,040 --> 20:35:48,640
共享实例，这只是一个函数名

2250
20:35:48,640 --> 20:35:52,552
只是这个类的私有初始化器

2251
20:35:52,552 --> 20:35:55,440
然后我们要做的是我们要说静态

2252
20:35:55,440 --> 20:35:58,832
最后的笔记

2253
20:35:58,832 --> 20:36:03,600
服务，所以我们正在创建一个共享实例，我们要说注释

2254
20:36:03,600 --> 20:36:06,800
服务获得了共享实例，因此这会创建

2255
20:36:06,800 --> 20:36:10,800
为我们共享实例，但外界没有人能够

2256
20:36:10,800 --> 20:36:15,040
然后给这两个打电话，因为他们很私密，所以现在我们要走了

2257
20:36:15,040 --> 20:36:18,960
要创建一个工厂构造函数，我们将把它称为笔记服务

2258
20:36:18,960 --> 20:36:22,400
就像那样，这将为我们返回一个共享实例，所以它只是一个

2259
20:36:22,400 --> 20:36:26,240
在我看来，老实说，至少这是一种 hacky 方式

2260
20:36:26,240 --> 20:36:31,760
创建一个单例，但至少现在它在飞镖中是这样工作的

2261
20:36:31,760 --> 20:36:35,680
好吧，现在我们已经创建了我们的单例，所以我们可以做的是我

2262
20:36:35,680 --> 20:36:38,720
意味着我们不必对这个人的初始化状态做任何改变，因为

2263
20:36:38,720 --> 20:36:43,040
现在它正在构建节点服务，我们

2264
20:36:43,040 --> 20:36:47,600
已经改变了，所以任何像这样调用节点服务的人实际上都是

2265
20:36:47,600 --> 20:36:51,832
来到工厂构造函数，然后依次返回这个共享

2266
20:36:51,832 --> 20:36:55,832
实例反过来调用这个私有工厂，它会导致私有

2267
20:36:55,832 --> 20:36:59,760
初始化器或构造器，所以它就像一个三层

2268
20:36:59,760 --> 20:37:05,360
为了创建一个单例，我们做得很好

2269
20:37:05,360 --> 20:37:10,480
我的意思是我们也可以在这一切进行时尝试运行应用程序

2270
20:37:10,480 --> 20:37:16,160
我可以再次调出 scr cpy，如果它做得更好，请在这里调出

2271
20:37:16,160 --> 20:37:18,000
可以，然后呢

2272
20:37:18,000 --> 20:37:22,400
我们已经做了很多工作 我们为下一章奠定了基础

2273
20:37:22,400 --> 20:37:27,512
所以现在我们有能力连接到我们数据库中的所有可用笔记

2274
20:37:27,512 --> 20:37:31,280
它由流和流控制器控制，然后我们

2275
20:37:31,280 --> 20:37:37,440
能够然后我们能够使用这个在屏幕上显示这些注释

2276
20:37:37,440 --> 20:37:41,832
我现在正在尝试找到的流生成器​​就在这里，好吧

2277
20:37:41,832 --> 20:37:45,120
我们已经做了很多工作，对你坚持我做得很好

2278
20:37:45,120 --> 20:37:50,552
贯穿本章，就像我们在做的传统一样

2279
20:37:50,552 --> 20:37:54,400
在每一章结束时，我们都会提交我们的工作并标记

2280
20:37:54,400 --> 20:37:57,192
他们所以让我们继续做那我要改变

2281
20:37:57,192 --> 20:38:00,720
屏幕布局一点点摆脱cr cpy 已经一点点了

2282
20:38:00,720 --> 20:38:05,832
今天对我们生气这个 scr cpy 和这里的屏幕布局，我

2283
20:38:05,832 --> 20:38:11,192
会增加它的字体大小和一个新的外壳，所以在

2284
20:38:11,192 --> 20:38:15,760
上一章我们呃承诺并将我们的工作标记为

2285
20:38:15,760 --> 20:38:20,552
第 11 步我相信所以如果你说 git tag 你可以看到我们已经到第 11 步了。让我们

2286
20:38:20,552 --> 20:38:25,360
继续说 git status 首先是的一些文件已被修改

2287
20:38:25,360 --> 20:38:29,512
然后我们添加所有文件然后我们说

2288
20:38:29,512 --> 20:38:34,552
这次是第 12 步，我们推动我们的改变

2289
20:38:34,552 --> 20:38:38,800
然后我们将标记我们的工作以及步骤

2290
20:38:38,800 --> 20:38:44,000
12 然后我们推动我们的攻击

2291
20:38:44,000 --> 20:38:48,720
太棒了，现在又做得很好，嗯，我们在每一个结束时都做了什么

2292
20:38:48,720 --> 20:38:52,160
章节是我们谈了一点我们接下来要谈的内容

2293
20:38:52,160 --> 20:38:55,680
章节和标题表明我们要

2294
20:38:55,680 --> 20:38:58,400
呃，我们已经完成了笔记的基础知识

2295
20:38:58,400 --> 20:39:02,080
但我们没有数据，这就是我们接下来要解决的补救措施

2296
20:39:02,080 --> 20:39:06,640
本章我们将讨论如何允许用户按下按钮

2297
20:39:06,640 --> 20:39:11,120
例如，为了创建一个新的便笺，然后该便笺出现在我们的

2298
20:39:11,120 --> 20:39:15,832
流生成器并显示给用户

2299
20:39:15,832 --> 20:39:19,920
也许你想休息一下，喝点点心，请这样做，然后

2300
20:39:19,920 --> 20:39:24,080
下一章见大家好，欢迎来到第30章

2301
20:39:24,080 --> 20:39:27,920
在前几章的 Flutter 课程中，我们已经做了很多工作

2302
20:39:27,920 --> 20:39:31,680
使用我们的数据库层，我们也一直在使用 ui 以便

2303
20:39:31,680 --> 20:39:36,400
有点确保我们可以有一个笔记清单，嗯，但正如你所知道的

2304
20:39:36,400 --> 20:39:39,920
在前面的章节中看到我们没有注释或

2305
20:39:39,920 --> 20:39:43,600
我们实际上没有能力让用户创建这些

2306
20:39:43,600 --> 20:39:47,832
笔记 所以从本章开始我们将开始创作

2307
20:39:47,832 --> 20:39:51,192
用户可以输入的某种用户界面

2308
20:39:51,192 --> 20:39:55,040
他们的笔记和这些笔记将保存在我们的四服务器上

2309
20:39:55,040 --> 20:39:59,040
我们在前一章中创建了

2310
20:39:59,040 --> 20:40:03,280
在我们继续之前，让我们现在处理一件事，我们的笔记视图

2311
20:40:03,280 --> 20:40:07,360
真的没有合适的标题我要把代码带到这里

2312
20:40:07,360 --> 20:40:12,720
在屏幕上，所以你也可以看到它，我会带上 scrcpy，你可以

2313
20:40:12,720 --> 20:40:18,160
让您的模拟器或模拟器 um 或实际设备出现在屏幕上，这样就可以了

2314
20:40:18,160 --> 20:40:22,320
也很好，让我们在这里重新安排一下，我

2315
20:40:22,320 --> 20:40:27,360
还将在此处重新排列屏幕，以便您现在可以更好地查看代码

2316
20:40:27,360 --> 20:40:32,240
ui 和我们的 main ui 的标题只是说 main ui 所以让我们保重

2317
20:40:32,240 --> 20:40:36,320
那就是里面的笔记查看飞镖

2318
20:40:36,320 --> 20:40:41,440
让我们找到我们正在创建应用栏的位置，这里我们说的是 main ui 所以

2319
20:40:41,440 --> 20:40:44,800
标题表明我们会将其更改为您的笔记

2320
20:40:44,800 --> 20:40:50,480
像这样和命令的热重载然后我们可以看到你的笔记出现在那里

2321
20:40:50,480 --> 20:40:55,760
所以这部分现在已经完成了

2322
20:40:55,760 --> 20:41:00,240
现在让我们看看我们将如何让用户在我们的

2323
20:41:00,240 --> 20:41:03,440
你看到的应用程序

2324
20:41:03,440 --> 20:41:06,320
有不同的方式去做，就像一些

2325
20:41:06,320 --> 20:41:10,320
将显示称为浮动操作的应用程序

2326
20:41:10,320 --> 20:41:14,872
按钮 浮动操作按钮是通常出现在

2327
20:41:14,872 --> 20:41:19,680
如果您的语言是从左到右的，或者如果您的语言是从左到右的

2328
20:41:19,680 --> 20:41:23,600
你有像你写的那样的阿拉伯语波斯语的阿拉伯语语言

2329
20:41:23,600 --> 20:41:27,920
从右到左然后浮动操作按钮应该出现在左下角所以

2330
20:41:27,920 --> 20:41:32,000
它有点像一个浮在屏幕上的按钮

2331
20:41:32,000 --> 20:41:37,280
嗯，通常这就像你的 um 不适合你的主

2332
20:41:37,280 --> 20:41:40,400
ui uh 但是它有时会进入

2333
20:41:40,400 --> 20:41:43,512
中途所以嗯

2334
20:41:43,512 --> 20:41:47,440
例如，如果您有一个笔记列表，并且这些笔记可以喜欢它们的标题

2335
20:41:47,440 --> 20:41:52,160
可以转到几行文本然后你有一个浮动按钮

2336
20:41:52,160 --> 20:41:55,360
就像在屏幕底部一样，它可能会再次阻止

2337
20:41:55,360 --> 20:41:58,720
你的内容，所以有些人不喜欢浮动动作

2338
20:41:58,720 --> 20:42:02,240
按钮和浮动条操作按钮是

2339
20:42:02,240 --> 20:42:04,800
通常它们通常出现在android中

2340
20:42:04,800 --> 20:42:08,720
应用程序是我认为它来自谷歌的材料设计我可以

2341
20:42:08,720 --> 20:42:12,160
这是错误的，但通常你不会在 ios 应用程序中看到它们，并且

2342
20:42:12,160 --> 20:42:16,000
因为我们正在开发我们的应用程序，以便对 ios 和

2343
20:42:16,000 --> 20:42:19,120
android 用户，我们暂时不打算使用浮动操作按钮，但是

2344
20:42:19,120 --> 20:42:22,552
需要明确的是，浮动动作确实没有错

2345
20:42:22,552 --> 20:42:27,360
按钮所以我们可以做的是我们可以

2346
20:42:27,360 --> 20:42:32,400
进入我们已经注销的菜单并在这里创建一个新项目

2347
20:42:32,400 --> 20:42:37,040
说例如加号或添加添加新注释或类似的东西

2348
20:42:37,040 --> 20:42:41,760
对不起，我也将这个添加到呃请勿打扰，所以我们也可以

2349
20:42:41,760 --> 20:42:46,640
在此处添加一个项目，上面写着添加类似的注释，或者我们可以去

2350
20:42:46,640 --> 20:42:49,832
这个栏，我们在这里有我们的应用栏

2351
20:42:49,832 --> 20:42:54,240
并添加一个新项目，就像我们有这三个垂直

2352
20:42:54,240 --> 20:42:58,800
点我们可以在那里添加一个新项目

2353
20:42:58,800 --> 20:43:02,160
所以现在它涉及到一种喜欢的偏好

2354
20:43:02,160 --> 20:43:06,000
以及为什么我们应该添加的某种推理

2355
20:43:06,000 --> 20:43:10,552
加号按钮，我们将添加它的方式以及我背后的推理

2356
20:43:10,552 --> 20:43:15,360
想放加号按钮，但喜欢在这个旁边

2357
20:43:15,360 --> 20:43:20,080
这些垂直的三个点是添加一个新的音符很像

2358
20:43:20,080 --> 20:43:24,552
用户希望在您的应用程序的主要用户中执行的主要任务之一

2359
20:43:24,552 --> 20:43:29,680
界面，所以他们要么进入这里删除他们的笔记更新他们的

2360
20:43:29,680 --> 20:43:33,120
笔记或添加新笔记，所以他们要做三件事

2361
20:43:33,120 --> 20:43:38,552
删除笔记通常并不常见，因此更新笔记并添加新笔记

2362
20:43:38,552 --> 20:43:43,192
注释应该就像您的用户在您的主要操作中执行的主要操作

2363
20:43:43,192 --> 20:43:47,280
应用程序 ui 所以它应该是非常即时的 它应该是非常

2364
20:43:47,280 --> 20:43:51,600
用户很容易做到这一点，所以如果你在这里放一个加号按钮

2365
20:43:51,600 --> 20:43:56,872
除了这三个垂直点，用户只需单击一下即可

2366
20:43:56,872 --> 20:44:01,360
转到新屏幕以创建一个新节点但是如果你像添加

2367
20:44:01,360 --> 20:44:04,720
到这里的注释菜单然后他们必须先做

2368
20:44:04,720 --> 20:44:09,832
一个选项卡转到此处，然后另一个选项卡以创建转到下一个

2369
20:44:09,832 --> 20:44:13,040
屏幕，这就像一个额外的标签

2370
20:44:13,040 --> 20:44:19,512
这就是我们要在这三个垂直点旁边添加一个加号按钮的地方

2371
20:44:19,512 --> 20:44:23,760
所以在我们开始之前让我们继续

2372
20:44:23,760 --> 20:44:27,760
为此做一些准备，所以我们需要一个小部件，这将是我们的

2373
20:44:27,760 --> 20:44:32,080
新的笔记视图，正如你所看到的，我们将在里面为它创建一个新文件

2374
20:44:32,080 --> 20:44:38,872
lib views notes 这是一个我相信我们以前没有的新文件夹

2375
20:44:38,872 --> 20:44:42,800
让我们进去吧，我们有您可以看到的视图，但我们没有文件夹

2376
20:44:42,800 --> 20:44:47,040
称为注释，以便查看我们现在要创建的内容

2377
20:44:47,040 --> 20:44:51,512
这个 dart 文件是新节点视图吗，所以我要右键单击它并说

2378
20:44:51,512 --> 20:44:55,120
在这里，我要说一个我们还没有的名为 notes 的文件夹

2379
20:44:55,120 --> 20:45:00,480
我要说新的笔记视图点dart好的所以那是那个文件了

2380
20:45:00,480 --> 20:45:04,080
我们还不会在那个文件中做任何事情

2381
20:45:04,080 --> 20:45:09,680
现在我们在视图下有了我们的笔记文件夹

2382
20:45:09,680 --> 20:45:13,760
感觉将我们的笔记视图也移动到这里

2383
20:45:13,760 --> 20:45:19,440
在视图下你可以看到这里的面包屑说 lib views notes view it makes

2384
20:45:19,440 --> 20:45:24,640
现在感觉将这个笔记视图移动到这个笔记中，这是我们的笔记列表

2385
20:45:24,640 --> 20:45:29,512
文件夹也是如此，所以我需要您只需拖动该文件并将其放置

2386
20:45:29,512 --> 20:45:34,640
在notes文件夹里面没问题

2387
20:45:34,640 --> 20:45:39,512
好的，对不起，我们现在已经这样做了

2388
20:45:39,512 --> 20:45:43,192
嗯，现在如果我带来你可能会注意到什么

2389
20:45:43,192 --> 20:45:45,680
现在我们已经把列表高了一点

2390
20:45:45,680 --> 20:45:48,320
这样做也让我们确保我们没有

2391
20:45:48,320 --> 20:45:51,192
打破任何呃进口

2392
20:45:51,192 --> 20:45:55,512
笔记视图哦，我知道这真的很棒，因为通过拖动笔记视图

2393
20:45:55,512 --> 20:45:58,720
进入笔记文件夹视觉工作室是

2394
20:45:58,720 --> 20:46:03,680
足够聪明，可以重构我们所指的所有导入

2395
20:46:03,680 --> 20:46:07,832
注释视图，以便您选择编辑器，例如您使用的是 sublime 还是

2396
20:46:07,832 --> 20:46:12,080
例如，使用一些 vim 可能无法自动处理

2397
20:46:12,080 --> 20:46:16,640
因此，您可以根据方式将笔记视图移动到笔记文件夹中

2398
20:46:16,640 --> 20:46:21,280
你这样做你可能还需要修复你的进口，所以

2399
20:46:21,280 --> 20:46:25,760
如果您搜索节点视图。让我们看看

2400
20:46:25,760 --> 20:46:30,720
我可以看到它被导入的唯一地方是 main.dart 文件，所以你会

2401
20:46:30,720 --> 20:46:34,552
你可能需要去那里修复那个导入，所以如果你得到一个

2402
20:46:34,552 --> 20:46:39,440
您的导入错误，那么您就知道为什么了

2403
20:46:39,440 --> 20:46:43,512
如果你注意到如果你回到

2404
20:46:43,512 --> 20:46:47,920
这里的编辑器你可能已经注意到我们有一些红色的文件

2405
20:46:47,920 --> 20:46:51,760
这里是因为我们加了嗯

2406
20:46:51,760 --> 20:46:56,552
我们的电子邮件呃一个电子邮件字段给我们的身份验证用户所以如果

2407
20:46:56,552 --> 20:47:00,720
你进入这里你可以看到我们在我们的身份验证用户中添加了这个电子邮件字段

2408
20:47:00,720 --> 20:47:04,080
前几章的内容，因为我们需要

2409
20:47:04,080 --> 20:47:08,640
能够从我们的

2410
20:47:08,640 --> 20:47:12,872
节点服务还可以，所以在添加之后现在我们已经坏了

2411
20:47:12,872 --> 20:47:17,832
我们的测试，我们还没有真正的时间来修复测试所以

2412
20:47:17,832 --> 20:47:20,800
嗯，让我们看看我们如何修复我们的

2413
20:47:20,800 --> 20:47:26,872
测试我们，如果你博士，呃，在我们的测试文件中向下滚动一点，你会

2414
20:47:26,872 --> 20:47:31,832
注意我们在哪里打破了测试，这就是我们在两个地方

2415
20:47:31,832 --> 20:47:37,120
我们正在这里创建一个关闭用户，以及我们处理这个关闭的方式

2416
20:47:37,120 --> 20:47:41,832
我们测试中的用户并不是我们为以后编写测试的东西

2417
20:47:41,832 --> 20:47:45,360
我们实际上并没有创建一个关闭用户，然后

2418
20:47:45,360 --> 20:47:50,640
对关闭用户的电子邮件进行测试，所以目前它几乎

2419
20:47:50,640 --> 20:47:55,280
只是装饰，我们只需要确保我们的测试编译和

2420
20:47:55,280 --> 20:47:59,760
我们这里没有编译错误所以让我们去看看是否可视化

2421
20:47:59,760 --> 20:48:03,120
工作室代码可以帮助我们，所以我只想在 mac 上执行命令 dot 或

2422
20:48:03,120 --> 20:48:07,680
在 windows 和 linux 上控制点并说添加所需的参数 eval 和电子邮件

2423
20:48:07,680 --> 20:48:12,080
你可以只说 fooatbar.com 这样没关系，在

2424
20:48:12,080 --> 20:48:16,552
最终得到暗格式化程序为我们正确格式化文件

2425
20:48:16,552 --> 20:48:20,160
然后对不起，我会再次从 Visual Studio 代码中获得帮助，然后说添加

2426
20:48:20,160 --> 20:48:24,552
记录争论的电子邮件，然后我们再说一次

2427
20:48:24,552 --> 20:48:29,360
fooatbar.com 和一个指挥好的

2428
20:48:29,360 --> 20:48:32,240
所以正如你在标题中看到的那样，我们只需要确保我们是

2429
20:48:32,240 --> 20:48:35,680
运行我们的测试并确保我们没有破坏任何东西，所以让我们开始吧

2430
20:48:35,680 --> 20:48:40,480
在这里进行我们的测试，看看我是否可以提出这个问题

2431
20:48:40,480 --> 20:48:44,400
改变屏幕布局，这样你也能看到我在做什么

2432
20:48:44,400 --> 20:48:48,800
增加屏幕的大小，我要搜索颤振测试和

2433
20:48:48,800 --> 20:48:52,400
这就是您还必须键入的命令作为标题的行

2434
20:48:52,400 --> 20:48:57,192
屏幕底部也有指示，让我们运行测试看看

2435
20:48:57,192 --> 20:49:00,640
如果我们正确地完成了我们不应该做的所有事情，我们会得到什么结果

2436
20:49:00,640 --> 20:49:04,320
目前我们的测试有任何问题

2437
20:49:04,320 --> 20:49:08,640
但是您可能出于充分的理由而偏离了课程，并写了

2438
20:49:08,640 --> 20:49:13,760
更多测试，然后您可能还必须修复这些测试，我高度

2439
20:49:13,760 --> 20:49:16,960
鼓励所有观看此课程的观众

2440
20:49:16,960 --> 20:49:21,832
用小部件测试集成进行尽可能多的测试

2441
20:49:21,832 --> 20:49:26,400
尽可能多地进行测试和单元测试，以了解其工作原理

2442
20:49:26,400 --> 20:49:30,000
嗯，好吧，就是这样，现在我们走吧

2443
20:49:30,000 --> 20:49:33,760
提前并更改我们现在已经完成测试的屏幕布局，您可以

2444
20:49:33,760 --> 20:49:38,872
看到测试已经通过了，我们也没有

2445
20:49:38,872 --> 20:49:45,680
我们的 auth test.dart 文件中有更多危险信号

2446
20:49:45,680 --> 20:49:48,800
好的，所以我们现在需要做的是你看

2447
20:49:48,800 --> 20:49:54,480
然后我们在主 ui 中添加一个加号按钮以转到

2448
20:49:54,480 --> 20:49:59,360
我们的新观点，嗯，我相信我们在这里创造了新的笔记

2449
20:49:59,360 --> 20:50:02,552
视图我们需要为它定义一个回合

2450
20:50:02,552 --> 20:50:07,440
已经为嗯

2451
20:50:07,440 --> 20:50:12,240
我们所有的其他路线，所以如果我们看看我们的嗯，让我们看看我们是否能找到

2452
20:50:12,240 --> 20:50:15,120
它固定路线

2453
20:50:15,120 --> 20:50:18,800
我们已经验证了电子邮件路由我们有节点路由注册路由和所有

2454
20:50:18,800 --> 20:50:21,512
那些，所以我要看看我的

2455
20:50:21,512 --> 20:50:25,040
注意并确保我们在这里定义我们的新路线

2456
20:50:25,040 --> 20:50:28,000
对不起，让我们去叫这条新路线

2457
20:50:28,000 --> 20:50:32,320
我们将把它称为新的音符路线，我们只想说

2458
20:50:32,320 --> 20:50:35,832
斜线和注释斜线

2459
20:50:35,832 --> 20:50:38,552
新笔记好吧

2460
20:50:38,552 --> 20:50:43,600
请记住，这实际上并没有任何意义，除了

2461
20:50:43,600 --> 20:50:48,320
再次原谅我，除非你像你的路线一样处理

2462
20:50:48,320 --> 20:50:53,040
命名，所以如果你喜欢带有 z 的音符，它会

2463
20:50:53,040 --> 20:50:56,480
只要您在任何地方都使用相同的路线名称，也可以使用

2464
20:50:56,480 --> 20:51:00,960
所以不要认为这就像绑定到任何类型的魔法

2465
20:51:00,960 --> 20:51:04,640
文件在颤动中找到一个机制它与它无关，它只是

2466
20:51:04,640 --> 20:51:09,040
让你定义你的路线名称，这样你就可以在这里说 fu 和

2467
20:51:09,040 --> 20:51:12,400
只要您在任何地方都使用此路线名称，一切都会正常进行

2468
20:51:12,400 --> 20:51:15,512
正如所料

2469
20:51:15,512 --> 20:51:20,000
这是我们在 cons 中创建的新笔记路由

2470
20:51:20,000 --> 20:51:24,160
路线飞镖作为注释表明的标题

2471
20:51:24,160 --> 20:51:28,320
屏幕显示我们必须在此处转到主 dart 文件

2472
20:51:28,320 --> 20:51:32,960
然后我们需要去定义那条路线呃在这里

2473
20:51:32,960 --> 20:51:37,360
好的，所以我们有登录路由注册路由注释路由验证电子邮件路由和

2474
20:51:37,360 --> 20:51:41,760
然后我们必须定义这条新路由，称为新节点路由

2475
20:51:41,760 --> 20:51:46,960
所以我们就说新节点路由在这里需要一个构建上下文

2476
20:51:46,960 --> 20:51:49,760
如果你想我不做，我们可以用下划线忽略它

2477
20:51:49,760 --> 20:51:54,000
然后我们将创建一个 new uh 的新实例

2478
20:51:54,000 --> 20:51:59,440
节点路由对不起一个新的节点视图嗯，但我们没有

2479
20:51:59,440 --> 20:52:05,120
还没有，所以让我们去定义新的节点视图

2480
20:52:05,120 --> 20:52:09,680
但是现在我只想说这样的 const new node view 而这不是

2481
20:52:09,680 --> 20:52:12,960
去工作，因为我们没有设置那个视图

2482
20:52:12,960 --> 20:52:16,400
但是我们刚刚为它创建了文件

2483
20:52:16,400 --> 20:52:21,192
所以我要关闭一些我们不需要的文件，让我们进入我们的新文件

2484
20:52:21,192 --> 20:52:24,320
笔记视图

2485
20:52:24,320 --> 20:52:28,960
正如标题所示，我们将创建一个名为 new 的有状态小部件

2486
20:52:28,960 --> 20:52:35,120
注意视图，所以我将使用颤振抱歉的视觉工作室代码和有状态

2487
20:52:35,120 --> 20:52:40,480
小部件模板在这里 stf 我将把它称为新的笔记视图

2488
20:52:40,480 --> 20:52:43,600
对，我们会遇到一些错误

2489
20:52:43,600 --> 20:52:47,760
你已经知道那是因为我们有一个进口材料圆点飞镖所以我

2490
20:52:47,760 --> 20:52:50,160
将从 Visual Studio 代码命令点获得帮助

2491
20:52:50,160 --> 20:52:53,440
在 mac 上或在 linux 和 windows 上控制点并说导入材料

2492
20:52:53,440 --> 20:52:57,280
所有这些错误都会消失

2493
20:52:57,280 --> 20:53:04,160
所以现在我们有了新的节点视图，对不起

2494
20:53:04,160 --> 20:53:09,360
所以让我们在这个新的笔记视图中创建一个简单的脚手架

2495
20:53:09,360 --> 20:53:14,320
我要说我们有一个脚手架，在我们的脚手架内我们有一个应用程序

2496
20:53:14,320 --> 20:53:19,360
栏，我们要说 avbar 和一个应用栏有一个标题，在这里

2497
20:53:19,360 --> 20:53:23,600
我们只会说 cons text new note

2498
20:53:23,600 --> 20:53:29,120
像这样的东西，对于这个脚手架的主体，我们是

2499
20:53:29,120 --> 20:53:36,320
只是要添加一个 const 的文本，上面写着写你的新的

2500
20:53:36,320 --> 20:53:42,240
请注意这里类似这样的东西，所以这是一个非常简单的有状态小部件

2501
20:53:42,240 --> 20:53:45,680
目前我的意思是它甚至不是有状态的，它在做什么正确

2502
20:53:45,680 --> 20:53:49,192
现在它几乎可以通过无状态小部件来实现，但是在

2503
20:53:49,192 --> 20:53:52,960
在接下来的章节中，我们将为这个视图添加越来越多的逻辑，所以它

2504
20:53:52,960 --> 20:53:57,440
需要成为有状态的小部件才能在将来也能工作

2505
20:53:57,440 --> 20:54:04,080
对于我们已经计划好的，对不起，现在我们有了这个妈妈

2506
20:54:04,080 --> 20:54:09,120
新的笔记视图让我们继续回到我们的主要飞镖并获得帮助

2507
20:54:09,120 --> 20:54:13,600
Visual Studio 代码为我们导入该文件，所以我只想说导入和

2508
20:54:13,600 --> 20:54:18,720
你会在第五行看到对我来说可能是一个新的导入

2509
20:54:18,720 --> 20:54:22,720
另一行给你，所以让我们导入一个新的节点视图和它

2510
20:54:22,720 --> 20:54:27,760
允许我们基本上定义一条路线，我只是说 command s，只是为了

2511
20:54:27,760 --> 20:54:30,960
当然，因为实际上不确定我们是我们

2512
20:54:30,960 --> 20:54:36,080
100 确定我们的主要 um 函数中的变化不会

2513
20:54:36,080 --> 20:54:38,960
不会被带走的

2514
20:54:38,960 --> 20:54:42,800
考虑到当我们进行热重载时，我们必须进行热重启

2515
20:54:42,800 --> 20:54:48,960
这些更改要生效，所以让我们在此处进行热重启

2516
20:54:48,960 --> 20:54:53,680
好的，由于某种原因，我实际上可以看到我的 scr cpy 现在又崩溃了

2517
20:54:53,680 --> 20:54:57,600
这有点片状没关系我不会抱怨的

2518
20:54:57,600 --> 20:54:59,920
呃，这只是

2519
20:54:59,920 --> 20:55:03,512
老实说，一个开源项目，我可以看到我实际上已经输了

2520
20:55:03,512 --> 20:55:07,600
我从颤振到程序的连接也是如此

2521
20:55:07,600 --> 20:55:13,600
让我现在在我的实际 Android 手机上的 scrcpy 中运行该代码

2522
20:55:13,600 --> 20:55:16,640
我还要确保我的 android

2523
20:55:16,640 --> 20:55:22,240
手机实际上也有 wi-fi，所以在我的手机上打开 wi-fi，然后

2524
20:55:22,240 --> 20:55:28,160
我要回到这里回到主界面所以虽然这一切都在编译

2525
20:55:28,160 --> 20:55:31,512
让我们进入下一步我们必须照顾的实际上是

2526
20:55:31,512 --> 20:55:35,600
显示哎呀

2527
20:55:35,600 --> 20:55:43,360
所以这实际上是在显示这个新的笔记视图

2528
20:55:43,360 --> 20:55:47,280
作为标题表明我们需要进入注释视图并按下图标

2529
20:55:47,280 --> 20:55:52,240
按钮显示新的笔记视图，所以我也要去我的笔记去

2530
20:55:52,240 --> 20:55:55,920
在这里做笔记

2531
20:55:55,920 --> 20:56:02,400
我们必须添加一个小按钮

2532
20:56:02,400 --> 20:56:07,600
在我们的 uh notes 视图中，让我们继续

2533
20:56:07,600 --> 20:56:11,832
去那里我们会看看我们的note2是如何构建的

2534
20:56:11,832 --> 20:56:16,480
现在可以看到我们有一系列动作，现在它有一个

2535
20:56:16,480 --> 20:56:21,440
弹出菜单按钮对不起，我们需要添加一个新图标

2536
20:56:21,440 --> 20:56:24,960
按钮在那里，让我们继续说图标按钮

2537
20:56:24,960 --> 20:56:30,160
一个图标按钮必须有一个图标和一个按下所以让我们说未按下所以

2538
20:56:30,160 --> 20:56:34,240
记住这将是我们的加号图标

2539
20:56:34,240 --> 20:56:39,440
所以这是我们的新闻，对于图标，我们只会说 const icon

2540
20:56:39,440 --> 20:56:43,280
然后我们会说添加图标，如您所见，我相信您的

2541
20:56:43,280 --> 20:56:47,360
工作室代码也能够直接显示您的图标，因此您可以看到

2542
20:56:47,360 --> 20:56:51,192
这就是按钮的外观，这是一个加号按钮

2543
20:56:51,192 --> 20:56:54,000
正确和一个逗号在这里让它工作

2544
20:56:54,000 --> 20:56:58,872
如果我现在在这里执行命令，我们应该在热重载后看到一个加号按钮

2545
20:56:58,872 --> 20:57:02,080
是的，但是那个按钮没有做任何事情，因为它没有按下它

2546
20:57:02,080 --> 20:57:06,240
空无所谓 所以我们需要做的就是说 uh

2547
20:57:06,240 --> 20:57:10,640
我们上下文的导航器或构建上下文和

2548
20:57:10,640 --> 20:57:15,832
我们只是要推送一个称为新节点路由的路由

2549
20:57:15,832 --> 20:57:18,240
好的，这就是你需要添加逗号的全部内容

2550
20:57:18,240 --> 20:57:22,160
在这里只是为了让代码格式正常工作

2551
20:57:22,160 --> 20:57:25,832
所以让我们实际测试一下，看看它是否有效，所以我要按下

2552
20:57:25,832 --> 20:57:30,240
这里的加号按钮，您可以看到我们的新节点路由正在显示

2553
20:57:30,240 --> 20:57:33,440
带有我们在此处添加的小文本的屏幕

2554
20:57:33,440 --> 20:57:37,440
说在这里写你的新节点然后按下后退按钮

2555
20:57:37,440 --> 20:57:41,120
将我们发送回应用程序的主用户界面，您可能已经注意到

2556
20:57:41,120 --> 20:57:46,240
在注释视图中，我没有说 push name 和 remove until 那是因为

2557
20:57:46,240 --> 20:57:50,480
当您按下加号按钮以创建您希望用户的新笔记时

2558
20:57:50,480 --> 20:57:53,832
能够在需要时返回应用程序的主用户界面

2559
20:57:53,832 --> 20:57:57,360
这就是便利这个背部的设施

2560
20:57:57,360 --> 20:58:02,400
按钮就在这里 好的 好的 那是很棒的东西

2561
20:58:02,400 --> 20:58:06,080
这几乎是我们为这一章所做的一切

2562
20:58:06,080 --> 20:58:10,400
所以说实话，如果你这么问我，简短的一章会让人耳目一新

2563
20:58:10,400 --> 20:58:16,080
这真的很好，就像传统一样，让我们​​投入我们的工作，所以

2564
20:58:16,080 --> 20:58:20,000
我们可以为下一章做好准备 我要换屏幕

2565
20:58:20,000 --> 20:58:25,512
这里的布局有点糟糕，我们进去改变一下

2566
20:58:25,512 --> 20:58:29,920
屏幕布局，让我打开终端

2567
20:58:29,920 --> 20:58:34,160
增加屏幕尺寸，让我看得更清楚

2568
20:58:34,160 --> 20:58:38,960
所以我们要看看我们的 git 状态，我可以看到有一个全新的

2569
20:58:38,960 --> 20:58:43,120
这里的文件夹名为 lib views notes，我们有两个

2570
20:58:43,120 --> 20:58:47,920
下面的文件是我们的注释视图和新注释视图，所以让我们

2571
20:58:47,920 --> 20:58:51,832
说 git 并在这里查看我们的状态

2572
20:58:51,832 --> 20:58:55,680
现在可以看到那里提到的所有内容我要摆脱

2573
20:58:55,680 --> 20:58:59,040
这让它更大一点，所以你看得更清楚

2574
20:58:59,040 --> 20:59:02,552
所以我们需要做的就是先提交这个，然后我们要说一步

2575
20:59:02,552 --> 20:59:06,400
13. 我相信至少是这样

2576
20:59:06,400 --> 20:59:11,360
看看我们的日志，是的，第 12 步是最后一章，所以我们要说

2577
20:59:11,360 --> 20:59:16,240
嗯，第 13 步，我现在要推动我们的承诺

2578
20:59:16,240 --> 20:59:21,192
github 然后我们要说好标签

2579
20:59:21,192 --> 20:59:26,640
第 13 步以及带有推送标签

2580
20:59:26,640 --> 20:59:30,000
好吧，这也是我们的标签，所以如果

2581
20:59:30,000 --> 20:59:34,080
我说标签现在我们可以看到到目前为止我们创建的所有标签 13 个

2582
20:59:34,080 --> 20:59:38,800
对，这就是我们必须做的

2583
20:59:38,800 --> 20:59:42,552
现在再次成为每个人的传统

2584
20:59:42,552 --> 20:59:45,360
这场洪水的一章当然我通常会谈论我们需要做什么

2585
20:59:45,360 --> 20:59:49,040
下一章，这样我们就可以为那一章做好准备

2586
20:59:49,040 --> 20:59:52,320
下一章现在我们有了新的笔记视图

2587
20:59:52,320 --> 20:59:57,192
我们将努力将逻辑添加到新的笔记视图中，以便我们可以

2588
20:59:57,192 --> 21:00:02,240
实际上将新笔记插入到我们的数据库中，以便我们可以开始

2589
21:00:02,240 --> 21:00:05,680
操纵这些笔记，所以下一章将

2590
21:00:05,680 --> 21:00:10,080
有点沉重的章节代码明智有很多代码所以

2591
21:00:10,080 --> 21:00:14,240
如果你想喝点点心，请做我的客人，请继续这样做

2592
21:00:14,240 --> 21:00:18,720
下一章见大家好，欢迎来到第31章

2593
21:00:18,720 --> 21:00:22,240
上一章的这个flutter课程我们做了一些准备工作

2594
21:00:22,240 --> 21:00:26,800
为了创建我们的新笔记视图，我们已经标记了一切

2595
21:00:26,800 --> 21:00:31,192
准备好了只是我们将新的笔记视图创建为有状态的小部件

2596
21:00:31,192 --> 21:00:35,920
几乎没有逻辑它有一个简单的脚手架，带有一个应用栏和一个简单的

2597
21:00:35,920 --> 21:00:39,920
本章中显示在屏幕上的文本

2598
21:00:39,920 --> 21:00:43,760
我们将确保用户不仅能够

2599
21:00:43,760 --> 21:00:48,320
去新的笔记视图或抱歉新的笔记视图，但他

2600
21:00:48,320 --> 21:00:53,600
或者她能够创建一个实际的注释并修改其文本

2601
21:00:53,600 --> 21:00:58,400
然后能够回到主用户界面

2602
21:00:58,400 --> 21:01:01,440
正如我在前面提到的那样，我们有很多工作要做这些章节

2603
21:01:01,440 --> 21:01:04,872
上一章结尾的章节 这章有点意思

2604
21:01:04,872 --> 21:01:08,960
代码很重，但我会确保带你去

2605
21:01:08,960 --> 21:01:12,240
通过我们将逐步编写的所有代码，这样您就不会错过

2606
21:01:12,240 --> 21:01:16,320
一切都好，在我们开始之前，我们需要解决

2607
21:01:16,320 --> 21:01:21,680
在我们的 um notes 视图中，那是为了确保我们正在听

2608
21:01:21,680 --> 21:01:28,160
我们所有节点流的活动状态加上等待，我的意思是

2609
21:01:28,160 --> 21:01:32,240
无需我们实际上无需我解释

2610
21:01:32,240 --> 21:01:36,000
抽象地说，让我提出代码并看看我们做了什么

2611
21:01:36,000 --> 21:01:40,720
嗯，我们如何才能让它变得更好

2612
21:01:40,720 --> 21:01:45,192
让我更改屏幕布局，以便您更好地查看代码让我们转到

2613
21:01:45,192 --> 21:01:48,552
我们的笔记在这里查看，您可以在

2614
21:01:48,552 --> 21:01:53,512
在我们的笔记的实际正文中，我们有未来的建设者，我们得到或

2615
21:01:53,512 --> 21:01:57,760
创建一个具有电子邮件地址的用户，您很快就会明白为什么

2616
21:01:57,760 --> 21:02:01,832
我们正在这样做，我们也有这个部分，它说开关连接

2617
21:02:01,832 --> 21:02:06,720
状态等待，然后在这里说等待所有笔记我们的计划是

2618
21:02:06,720 --> 21:02:11,360
to in the future 很快 实际上 在不久的将来 显示所有的笔记

2619
21:02:11,360 --> 21:02:15,600
用户在此用户界面中创建的，但是现在我们只是

2620
21:02:15,600 --> 21:02:18,480
监听连接状态等待

2621
21:02:18,480 --> 21:02:21,832
如果您查看文档文档以等待它说

2622
21:02:21,832 --> 21:02:25,512
连接到异步计算我正在等待交互但是如果你

2623
21:02:25,512 --> 21:02:30,160
看看它说的活动连接到一个活动的异步计算

2624
21:02:30,160 --> 21:02:34,240
ha 并且该流已返回至少一个值，因此

2625
21:02:34,240 --> 21:02:38,640
现在我们有如果你看我们的流是所有笔记的流所以这个所有笔记

2626
21:02:38,640 --> 21:02:42,552
开头可以是空的，也可以包含一些注释让我们开始吧

2627
21:02:42,552 --> 21:02:46,800
当流为空时流为空，这意味着

2628
21:02:46,800 --> 21:02:50,080
用户尚未创建任何已填充到便笺中的便笺

2629
21:02:50,080 --> 21:02:54,640
服务然后该流的连接状态将等待，因为飞镖

2630
21:02:54,640 --> 21:03:00,400
现在正在等待该流返回第一个值，这很好

2631
21:03:00,400 --> 21:03:03,600
我们说好的

2632
21:03:03,600 --> 21:03:08,400
流包含一个值或一旦流实际返回一个值

2633
21:03:08,400 --> 21:03:12,400
那么它的连接状态将处于活动状态，我们所做的只是我们

2634
21:03:12,400 --> 21:03:16,320
等待等待状态，但一旦进入活动状态，我们就会显示

2635
21:03:16,320 --> 21:03:21,120
循环进度指示器，这不是不正确的逻辑，所以

2636
21:03:21,120 --> 21:03:26,080
我们需要解决这个问题，所以让我们进入我们的笔记视图，等待之后

2637
21:03:26,080 --> 21:03:28,800
我们还要说

2638
21:03:28,800 --> 21:03:35,280
案例连接状态点活动正常所以这个

2639
21:03:35,280 --> 21:03:40,160
紧接着写两个案例，这是我喜欢的隐含失败

2640
21:03:40,160 --> 21:03:43,512
称它为某种语言称为后续，例如 swift

2641
21:03:43,512 --> 21:03:49,040
意思是一个案例没有逻辑，并且从字面上跌到下一个

2642
21:03:49,040 --> 21:03:53,360
案例，所以你在这里没有任何中断语句，好吧

2643
21:03:53,360 --> 21:03:57,192
所以这是一个后续隐含的失败和

2644
21:03:57,192 --> 21:04:01,040
这意味着在等待和活动状态中，我们将显示此文本和

2645
21:04:01,040 --> 21:04:05,120
如果你命令 s 那么你不会看到运行的任何差异

2646
21:04:05,120 --> 21:04:09,192
您的应用程序只是我们修复了一个损坏的逻辑

2647
21:04:09,192 --> 21:04:11,680
好的

2648
21:04:11,680 --> 21:04:17,192
现在到激动人心的部分，我将带来新的笔记视图

2649
21:04:17,192 --> 21:04:20,480
在这里只是要重新组织它你不必这样做但你现在需要去

2650
21:04:20,480 --> 21:04:24,800
到您的新节点视图 dart 文件，因为这是

2651
21:04:24,800 --> 21:04:29,120
现在我们将在本章的大部分内容中工作

2652
21:04:29,120 --> 21:04:31,512
好的，所以我们将在这个新的

2653
21:04:31,512 --> 21:04:36,872
进入屏幕后的便笺视图，我们实际上将创建一个新便笺

2654
21:04:36,872 --> 21:04:42,080
对你来说好吧，我们将保留那个新笔记并创建一个新的

2655
21:04:42,080 --> 21:04:45,832
节点如果你记得我们的节点服务如果你去我们的

2656
21:04:45,832 --> 21:04:49,920
公用事业我们这里有很多人，我们有节点服务，然后我们有很多

2657
21:04:49,920 --> 21:04:54,000
这里的函数至少让我们看看我们是否可以找到创建节点视图抱歉

2658
21:04:54,000 --> 21:04:59,680
这里的创建节点功能你可以看到它是一个未来所以我们不能

2659
21:04:59,680 --> 21:05:05,440
立即从此创建新节点获得结果，因此我们的新节点的目标

2660
21:05:05,440 --> 21:05:11,832
这里的节点视图是在这个函数体内使用future builder

2661
21:05:11,832 --> 21:05:15,832
所以在这个函数的主体内，我们要说

2662
21:05:15,832 --> 21:05:20,800
新节点视图状态已经创建，那么它还需要创建一个新节点

2663
21:05:20,800 --> 21:05:25,920
然而，在数据库中记住颤振我们有热重载意味着

2664
21:05:25,920 --> 21:05:30,800
当你在那个视图上并且你正在编辑你的文本和等等，你可以

2665
21:05:30,800 --> 21:05:33,832
稍微更改一下代码，然后按 command s

2666
21:05:33,832 --> 21:05:38,720
按下 command s 只会再次调用你的构建函数，所以如果你那时

2667
21:05:38,720 --> 21:05:44,400
在您的构建功能 um 脚手架主体中，您将拥有一个未来的构建器

2668
21:05:44,400 --> 21:05:48,640
反过来创建一个新的注释，该函数将再次被调用

2669
21:05:48,640 --> 21:05:52,640
这意味着每次您在该视图上进行热重载时，都会有一个新的

2670
21:05:52,640 --> 21:05:57,440
注意将被创建，为此我们如标题所示

2671
21:05:57,440 --> 21:06:02,320
我们需要保留一个名为 notes 的变量，这样我们就不会重新创建

2672
21:06:02,320 --> 21:06:07,040
每次调用构建函数时都可以，所以让我们继续做吧

2673
21:06:07,040 --> 21:06:11,120
所以在你的状态里面

2674
21:06:11,120 --> 21:06:16,000
新的笔记视图让我们去定义和说数据库

2675
21:06:16,000 --> 21:06:19,600
笔记，我们只会说笔记

2676
21:06:19,600 --> 21:06:23,832
好吧，我们也只是让它成为可选的，因为它

2677
21:06:23,832 --> 21:06:27,920
没有价值开始

2678
21:06:27,920 --> 21:06:35,120
好的，我们还需要的是保持我们的笔记服务

2679
21:06:35,120 --> 21:06:38,480
正如您在前几章中看到的，我们将节点服务器创建为单例，但是

2680
21:06:38,480 --> 21:06:43,120
如果您不必将其称为工厂功能，那您也将非常出色

2681
21:06:43,120 --> 21:06:46,400
每当我们使用节点服务器时，一遍又一遍地为单例

2682
21:06:46,400 --> 21:06:50,720
所以我们还要保持我们的节点服务作为一个后期的最终变量

2683
21:06:50,720 --> 21:06:53,832
在这里，让我们说迟到的决赛，我们是

2684
21:06:53,832 --> 21:07:00,000
要说这是尾注服务现在首先像这样好吧

2685
21:07:00,000 --> 21:07:03,600
嗯，你可能还没有看到

2686
21:07:03,600 --> 21:07:08,320
应用程序，但在我们处理变量以保持控制时，我们还需要

2687
21:07:08,320 --> 21:07:13,192
现在保持文本编辑控制器的方式是这样的 ui

2688
21:07:13,192 --> 21:07:17,040
view is going to work here is that instead of this text in here we're going

2689
21:07:17,040 --> 21:07:22,552
创建一个文本字段，它将随着用户垂直增加大小

2690
21:07:22,552 --> 21:07:27,040
不断在该字段中输入他们的信息或笔记

2691
21:07:27,040 --> 21:07:30,080
所以我们要做的是跟踪

2692
21:07:30,080 --> 21:07:34,080
用户输入的文本，当用户输入新文本时，我们

2693
21:07:34,080 --> 21:07:39,280
将自动将该信息与我们的数据库同步，并在将来

2694
21:07:39,280 --> 21:07:44,160
我们去firebase我们将与firebase同步该信息

2695
21:07:44,160 --> 21:07:50,720
所以我们需要一个文本编辑控制器来跟踪文本的变化

2696
21:07:50,720 --> 21:07:52,872
所以嗯

2697
21:07:52,872 --> 21:07:57,120
让我把这个标题带到这里，然后我们继续

2698
21:07:57,120 --> 21:08:02,320
并按照标题说的做让我们说迟到的最后和文字

2699
21:08:02,320 --> 21:08:05,680
我认为有时会控制这些文档

2700
21:08:05,680 --> 21:08:13,920
我相信只是过度，我们称之为文本控制器好吧

2701
21:08:13,920 --> 21:08:19,120
好吧，嗯，那太好了，所以我们现在需要做的是

2702
21:08:19,120 --> 21:08:23,040
促进我们的呃我的意思是我们还没有真正初始化任何这些但是

2703
21:08:23,040 --> 21:08:27,440
我们很快就会解决这个问题，所以我们没有忘记这一点

2704
21:08:27,440 --> 21:08:30,480
但是我们现在需要什么，正如我在本章开头提到的，当我们

2705
21:08:30,480 --> 21:08:34,080
来到这个屏幕，我们将创建一个新的笔记，我们需要有一个

2706
21:08:34,080 --> 21:08:37,440
在它被称为 create new 的情况下，它作为标题的函数

2707
21:08:37,440 --> 21:08:41,600
注意，它是一个异步函数，我们很快就会知道为什么

2708
21:08:41,600 --> 21:08:46,400
所以让我们继续说数据库节点的未来

2709
21:08:46,400 --> 21:08:50,240
因为它使用我们的节点服务创建了一个节点

2710
21:08:50,240 --> 21:08:54,800
我们将把它称为创建新节点，它是一个异步函数

2711
21:08:54,800 --> 21:08:57,680
所以在这个函数中我们要做什么

2712
21:08:57,680 --> 21:09:02,080
首先是看看我们之前是否在这个节点内创建了这个注释

2713
21:09:02,080 --> 21:09:05,512
变量，如果我们之前创建过这个节点，那么我们不必创建它

2714
21:09:05,512 --> 21:09:09,440
再次我们只是返回，但如果我们还没有创建它，那么我们去节点

2715
21:09:09,440 --> 21:09:13,920
服务并说创建节点，然后将该节点返回给我们所有人

2716
21:09:13,920 --> 21:09:18,000
好吧，让我们继续做吧，让我们

2717
21:09:18,000 --> 21:09:24,240
说最终存在的节点等于这个注释

2718
21:09:24,240 --> 21:09:29,760
然后我们说嗯然后在这里我们说如果现有的笔记

2719
21:09:29,760 --> 21:09:33,600
不为空，那么我们只返回它

2720
21:09:33,600 --> 21:09:38,160
这东西没问题，所以这就是返回声明

2721
21:09:38,160 --> 21:09:42,640
意味着我们已经有一个笔记，如果我们没有，那么我们将创建一个新的

2722
21:09:42,640 --> 21:09:49,120
请注意，但请记住，当我们创建新便笺时，我们的 um 会在其上创建新便笺功能

2723
21:09:49,120 --> 21:09:55,832
笔记服务如果你看这里创建笔记它需要一个所有者所以现在

2724
21:09:55,832 --> 21:09:58,720
突然间我们必须有一个主人好吗

2725
21:09:58,720 --> 21:10:04,800
再次记住进入应用程序主用户界面时的注释视图

2726
21:10:04,800 --> 21:10:10,000
notes 视图在数据库中创建了一个新用户，这意味着您已经登录

2727
21:10:10,000 --> 21:10:13,680
使用firebase，然后您转到您负责创建的注释视图注释

2728
21:10:13,680 --> 21:10:18,400
该用户我们在这里所要做的就是检索该用户，以便我们实际上可以

2729
21:10:18,400 --> 21:10:24,400
算上数据库中已经存在的那个用户好吧

2730
21:10:24,400 --> 21:10:28,240
所以让我们说最终的当前用户

2731
21:10:28,240 --> 21:10:33,040
等于我们的认证服务

2732
21:10:33,040 --> 21:10:36,872
firebase 然后我们会说当前用户

2733
21:10:36,872 --> 21:10:41,192
我们只是要明确地打开它，意思是

2734
21:10:41,192 --> 21:10:46,720
如果您最终以某种方式出现在此新笔记中，我们希望用户在那里

2735
21:10:46,720 --> 21:10:50,640
看你可能在想，但为什么那不安全呢

2736
21:10:50,640 --> 21:10:54,800
这是不安全的，如果当前用户会导致应用程序崩溃

2737
21:10:54,800 --> 21:11:00,480
不存在，但是您永远不应该以这种方式结束

2738
21:11:00,480 --> 21:11:04,872
如果您没有当前用户，则新节点视图因此最终出现在此屏幕上

2739
21:11:04,872 --> 21:11:08,640
并且没有当前用户是值得崩溃的，因为你想要你的

2740
21:11:08,640 --> 21:11:13,920
如果您的应用程序用户符合您的期望，应用程序就会崩溃

2741
21:11:13,920 --> 21:11:18,552
上一个屏幕没有满足界面和逻辑，所以你现在

2742
21:11:18,552 --> 21:11:22,960
在这一点上创建一个期望并让应用程序崩溃实际上是一个

2743
21:11:22,960 --> 21:11:26,800
在我看来是件好事，因为如果当前用户不存在，你应该

2744
21:11:26,800 --> 21:11:30,160
如果您最终进入此视图并且您没有

2745
21:11:30,160 --> 21:11:33,920
当前用户出现严重问题，所以我会完全安全

2746
21:11:33,920 --> 21:11:38,720
说在这里明确解开当前用户

2747
21:11:38,720 --> 21:11:42,400
我们将从当前用户那里提取电子邮件

2748
21:11:42,400 --> 21:11:46,080
所以我们会说 current user.email 我们也会打开它

2749
21:11:46,080 --> 21:11:50,080
因为记住电子邮件是一个可选字段，但同样因为我们知道

2750
21:11:50,080 --> 21:11:53,920
我们现在的身份验证将处理电子邮件

2751
21:11:53,920 --> 21:11:58,160
因为我们所有的用户都使用电子邮件地址和密码注册然后我们

2752
21:11:58,160 --> 21:12:02,800
可以确定邮箱地址是存在的

2753
21:12:02,800 --> 21:12:06,400
所以让我们继续从数据库中获取那个所有者，所以我们要说

2754
21:12:06,400 --> 21:12:14,000
店主等于我们的off our notes服务

2755
21:12:14,000 --> 21:12:19,360
所以我们会说等待笔记服务，然后我们会得到用户

2756
21:12:19,360 --> 21:12:24,480
用那封电子邮件，然后我们将返回我们的

2757
21:12:24,480 --> 21:12:29,600
注意服务创建节点所以我们要在这里创建一个新节点好的

2758
21:12:29,600 --> 21:12:35,600
因此，假设便笺服务与该所有者创建便笺，并且

2759
21:12:35,600 --> 21:12:39,280
你看这返回 um

2760
21:12:39,280 --> 21:12:42,480
数据库注释的未来，这几乎是我们需要返回的

2761
21:12:42,480 --> 21:12:48,320
在这里，让我们等一下吧

2762
21:12:48,320 --> 21:12:53,120
好的，太棒了，这是为了创建新的笔记，在这里

2763
21:12:53,120 --> 21:12:56,320
你可以看到我们没有设置这个

2764
21:12:56,320 --> 21:13:00,640
我们刚刚为此笔记创建的新笔记

2765
21:13:00,640 --> 21:13:03,440
我们将实际处理的变量

2766
21:13:03,440 --> 21:13:07,600
稍晚一点，所以你不必担心

2767
21:13:07,600 --> 21:13:10,480
那

2768
21:13:10,480 --> 21:13:15,760
好的，这是为了创建我们的笔记

2769
21:13:15,760 --> 21:13:22,080
现在我们需要做的是，当这个视图失去意义时

2770
21:13:22,080 --> 21:13:26,640
例如，用户按下此视图上的后退按钮

2771
21:13:26,640 --> 21:13:33,192
我们需要确保数据库中的当前节点被删除，如果

2772
21:13:33,192 --> 21:13:37,512
没有为该节点输入文本，所以

2773
21:13:37,512 --> 21:13:42,720
原因是假设用户在主界面上

2774
21:13:42,720 --> 21:13:46,480
应用程序就在这里，用户然后按下加号按钮，然后说

2775
21:13:46,480 --> 21:13:50,240
嗯，我实际上不想这样做，所以他们按下后退按钮

2776
21:13:50,240 --> 21:13:55,600
如果我们允许用户这样做并按下加号按钮，我们将创建一个

2777
21:13:55,600 --> 21:14:00,240
新的空节点并返回然后视图可能只是充满了空节点，所以它

2778
21:14:00,240 --> 21:14:04,720
就像用户甚至无法看到的空单元格一样，因为

2779
21:14:04,720 --> 21:14:08,400
稍后我们将在接下来的章节中看到，我们将在这个列表中填充

2780
21:14:08,400 --> 21:14:12,552
您笔记的实际内容，因为我们的笔记没有标题，所以

2781
21:14:12,552 --> 21:14:16,872
我们要显示的实际文本是里面的便笺本身

2782
21:14:16,872 --> 21:14:21,280
各种不同的细胞，所以我们要做的是说

2783
21:14:21,280 --> 21:14:25,192
如果你去创建一个新节点并且你没有输入任何文本意味着

2784
21:14:25,192 --> 21:14:29,120
离开此屏幕后，文本为空

2785
21:14:29,120 --> 21:14:33,120
在新笔记屏幕之外，如果它是空的，我们将删除该笔记

2786
21:14:33,120 --> 21:14:36,320
所以这是有道理的

2787
21:14:36,320 --> 21:14:40,080
所以让我们继续创建并找到该函数

2788
21:14:40,080 --> 21:14:47,600
所以我要带那个

2789
21:14:47,600 --> 21:14:54,552
在这里，如果文本为空，我们就说 void delete note 好吧

2790
21:14:54,552 --> 21:14:58,480
然后我们进去现在我们必须看看

2791
21:14:58,480 --> 21:15:01,512
在我们的笔记中

2792
21:15:01,512 --> 21:15:08,000
并且我们只是说我们得到了我们得到的笔记所以我们在这里说最后的笔记

2793
21:15:08,000 --> 21:15:14,960
注意应该填充在我们的状态中，然后我们说如果

2794
21:15:14,960 --> 21:15:19,832
文本控制器的文本为空

2795
21:15:19,832 --> 21:15:26,720
它是空的并且节点不为空然后我们在这里转到我们的节点服务

2796
21:15:26,720 --> 21:15:32,960
然后我们要求它删除那里的节点好吧，然后我们说使用

2797
21:15:32,960 --> 21:15:36,720
像这样的笔记

2798
21:15:36,720 --> 21:15:40,640
好吧，是的，那应该很好

2799
21:15:40,640 --> 21:15:45,680
如果我们里面的文本，那就是从数据库中删除笔记

2800
21:15:45,680 --> 21:15:50,640
文本编辑控制器为空

2801
21:15:50,640 --> 21:15:55,680
好吧，如果它是空的，那是为了删除它实际上怎么样

2802
21:15:55,680 --> 21:16:00,552
如果其中确实有文本，则保存笔记

2803
21:16:00,552 --> 21:16:05,512
以及我们将在我们的视图中执行的操作，您很快就会在用户视图中

2804
21:16:05,512 --> 21:16:09,760
可以编辑他们的笔记或将新文本添加到我们不会有的笔记中

2805
21:16:09,760 --> 21:16:13,680
如果您不是软件，则现代移动应用程序中的保存按钮类型

2806
21:16:13,680 --> 21:16:16,640
您可能不会注意到之前的开发，但如果您是设计师，您

2807
21:16:16,640 --> 21:16:21,120
可能已经注意到，在移动设备上的大多数笔记应用程序中

2808
21:16:21,120 --> 21:16:25,920
设备至少没有保存按钮，您的所有内容都会自动保存

2809
21:16:25,920 --> 21:16:29,832
保存，所以这实际上是一个很好的设计决策，通常在大多数地方你

2810
21:16:29,832 --> 21:16:33,680
通常在移动应用程序中不需要保存按钮，尤其是在

2811
21:16:33,680 --> 21:16:37,600
移动应用程序，所以我们不会有保存按钮

2812
21:16:37,600 --> 21:16:41,192
所以我们为了方便没有保存按钮，我们必须有一个

2813
21:16:41,192 --> 21:16:44,240
自动保存当前的功能

2814
21:16:44,240 --> 21:16:48,480
当前节点，例如，如果用户然后离开这个视图，那么它

2815
21:16:48,480 --> 21:16:52,400
会自动保存好的，所以让我们继续创建一个函数

2816
21:16:52,400 --> 21:16:57,512
在这里，顾名思义，如果没有文本，则称为保存节点

2817
21:16:57,512 --> 21:17:01,120
空的，我要带上 uh 功能

2818
21:17:01,120 --> 21:17:05,440
来自我的节点的签名，所以我不必手动输入，所以你需要

2819
21:17:05,440 --> 21:17:08,720
不幸的是手动输入这个不幸的是我不知道

2820
21:17:08,720 --> 21:17:13,192
但如果文本不为空，您将需要手动输入保存笔记

2821
21:17:13,192 --> 21:17:18,240
我们在这里要做的与我们的代码非常相似

2822
21:17:18,240 --> 21:17:24,000
如果文本为空，则为删除节点写，所以首先我们要获取节点

2823
21:17:24,000 --> 21:17:30,000
是节点，然后我们在文本控制器文本中获取文本

2824
21:17:30,000 --> 21:17:32,640
然后在这里嗯

2825
21:17:32,640 --> 21:17:37,600
我们会说 um if note 不是 null if note 是

2826
21:17:37,600 --> 21:17:40,000
不正常和

2827
21:17:40,000 --> 21:17:44,960
嗯，我们的文本不是空的，那么我们将等待

2828
21:17:44,960 --> 21:17:48,720
我们的笔记服务

2829
21:17:48,720 --> 21:17:52,720
在这里更新笔记功能

2830
21:17:52,720 --> 21:17:56,800
这正是我们在这里所做的，所以这很简单，我们只是在说

2831
21:17:56,800 --> 21:18:03,360
如果有文本不是空的并且我们有一个注释那么就

2832
21:18:03,360 --> 21:18:08,720
在数据库中更新该注释非常非常简单

2833
21:18:08,720 --> 21:18:12,800
好的两个非常重要的函数现在我们必须把这些函数放入

2834
21:18:12,800 --> 21:18:16,400
如您所见，我们从分析仪那里收到警告说

2835
21:18:16,400 --> 21:18:20,000
这是两个未引用的私有函数，用于

2836
21:18:20,000 --> 21:18:23,832
一个很好的理由，因为我们将在处置中引用它们

2837
21:18:23,832 --> 21:18:28,640
当这个新的笔记视图基本上是时，我们的新节点视图状态

2838
21:18:28,640 --> 21:18:32,720
被系统杀死，例如当用户按下后退按钮时

2839
21:18:32,720 --> 21:18:36,720
好的，让我们进入 dispose 函数

2840
21:18:36,720 --> 21:18:42,320
我们必须在这里照顾呃三件事

2841
21:18:42,320 --> 21:18:45,360
所以我们走吧

2842
21:18:45,360 --> 21:18:50,160
假设我们在这里有一个 dispose 函数，那就是

2843
21:18:50,160 --> 21:18:53,040
默认情况下会被覆盖对不起，我会在这里提出来，我会写的

2844
21:18:53,040 --> 21:18:58,552
从一开始，你就可以看到这个姿势没问题，它确实覆盖了我们和

2845
21:18:58,552 --> 21:19:02,872
我们要做的是首先说如果文本为空则删除笔记

2846
21:19:02,872 --> 21:19:06,000
那么我们要做的是我们要说否则保存笔记如果

2847
21:19:06,000 --> 21:19:09,192
text 不为空，然后我们将摆脱

2848
21:19:09,192 --> 21:19:14,320
文本控制器并对其进行处置，以便成为飞镖界的好公民

2849
21:19:14,320 --> 21:19:17,512
当您创建一个新的文本编辑控制器时，我们很快就会这样做

2850
21:19:17,512 --> 21:19:23,920
我们还需要确保我们在这个姿势上处理它

2851
21:19:23,920 --> 21:19:27,832
所以嗯，那是很多代码，我要

2852
21:19:27,832 --> 21:19:31,680
也看看这里我可以看到我实际上没有提供

2853
21:19:31,680 --> 21:19:36,080
我们照顾初始化的任何字幕

2854
21:19:36,080 --> 21:19:42,800
所以嗯，让我们照顾

2855
21:19:42,800 --> 21:19:45,920
所以我基本上现在正在做的事情，因为我只是注意到我没有

2856
21:19:45,920 --> 21:19:51,120
很好地为初始化函数提供了一个标题，我们现在就去做，嗯

2857
21:19:51,120 --> 21:19:56,552
因为这是一个非常重要的功能，我们需要

2858
21:19:56,552 --> 21:20:01,192
程序所以我也为此道歉

2859
21:20:01,192 --> 21:20:06,640
会把它带到这里，然后给你看标题，让你看看我在做什么

2860
21:20:06,640 --> 21:20:11,192
所以我们有这个姿势，但我们还没有初始化状态，我要初始化

2861
21:20:11,192 --> 21:20:15,440
在这里状态，让我们看看还是我们有任何状态

2862
21:20:15,440 --> 21:20:18,000
已经

2863
21:20:18,000 --> 21:20:22,640
我不这么认为

2864
21:20:22,640 --> 21:20:25,920
我可以看到视觉工作室代码并没有真正帮助我

2865
21:20:25,920 --> 21:20:29,440
所以我只想说覆盖无效初始化状态

2866
21:20:29,440 --> 21:20:32,000
像那样

2867
21:20:32,000 --> 21:20:36,552
然后我们必须在其状态下调用 super 好，所以你可能需要输入

2868
21:20:36,552 --> 21:20:40,720
手工以及个人工作室代码对我有点生气

2869
21:20:40,720 --> 21:20:44,000
也许是因为我只是忘了为互联网状态写标题

2870
21:20:44,000 --> 21:20:47,680
然后在这里我们需要做的就是确保我们同时创建

2871
21:20:47,680 --> 21:20:52,080
一个节点服务的实例，也是我们的文本编辑控制器好的，所以我只是

2872
21:20:52,080 --> 21:20:58,240
要说节点服务，这等于节点服务和

2873
21:20:58,240 --> 21:21:02,000
这只是一个单例，所以它不会创建一个真正的新实例，如果

2874
21:21:02,000 --> 21:21:06,240
它从以前就已经存在，我们的文本控制器将成为

2875
21:21:06,240 --> 21:21:12,080
文本编辑编辑控制器的新实例

2876
21:21:12,080 --> 21:21:14,800
好的，所以我要保存这个，然后我

2877
21:21:14,800 --> 21:21:20,000
打算做一个热重启 嗯，scrcpy 这几天有点生气

2878
21:21:20,000 --> 21:21:23,280
当我做热重启时和我一起，我真的不知道为什么

2879
21:21:23,280 --> 21:21:27,600
但我已经学会了忍受它，所以我只想说 scr cpy

2880
21:21:27,600 --> 21:21:32,480
然后我将在不调试的情况下运行应用程序

2881
21:21:32,480 --> 21:21:36,160
把它带到那里好吧

2882
21:21:36,160 --> 21:21:40,232
当它在做它的工作时，我们需要照顾

2883
21:21:40,232 --> 21:21:44,080
其他一些功能

2884
21:21:44,080 --> 21:21:48,320
当用户在

2885
21:21:48,320 --> 21:21:52,320
应用程序的主用户界面，因此当他或她在

2886
21:21:52,320 --> 21:21:57,280
键盘我们需要确保我们不断更新

2887
21:21:57,280 --> 21:22:00,400
我们在数据库中的笔记所以

2888
21:22:00,400 --> 21:22:05,280
例如，我们不会离开更新

2889
21:22:05,280 --> 21:22:08,960
当用户按下后退按钮时，我们会不断地这样做

2890
21:22:08,960 --> 21:22:14,872
用户在屏幕上输入 um 所以

2891
21:22:14,872 --> 21:22:19,512
为此，我们需要一些听众，以便标题在

2892
21:22:19,512 --> 21:22:22,720
无论如何我们都需要一个文本控制器

2893
21:22:22,720 --> 21:22:24,552
听众和

2894
21:22:24,552 --> 21:22:28,400
这个文本控制器监听器要做的就是它会成为一个主体

2895
21:22:28,400 --> 21:22:32,552
of function 它将是一个获取当前节点（如果存在）的函数

2896
21:22:32,552 --> 21:22:37,040
然后它将采用当前的文本编辑控制器文本并更新它

2897
21:22:37,040 --> 21:22:42,800
数据库中的注释没问题，所以让我们去创建那个函数吧

2898
21:22:42,800 --> 21:22:47,360
void 我们将说文本控制器侦听器

2899
21:22:47,360 --> 21:22:52,320
记住这个函数还没有被调用它是给我们的

2900
21:22:52,320 --> 21:22:56,480
然后作为侦听器连接到文本编辑控制器，所以我们很快

2901
21:22:56,480 --> 21:23:00,400
将编写另一个功能，说嘿文本编辑控制器

2902
21:23:00,400 --> 21:23:04,232
每当您的文本更改时，都可以调用此函数，所以不用担心

2903
21:23:04,232 --> 21:23:09,360
它还没有被调用所以在这里我们基本上会得到

2904
21:23:09,360 --> 21:23:14,400
注意，嗯，我也要摆脱这个，我要说最后

2905
21:23:14,400 --> 21:23:17,440
嗯笔记是这个笔记然后我们要去

2906
21:23:17,440 --> 21:23:20,960
说如果 note 为 null 表示我们没有该便笺

2907
21:23:20,960 --> 21:23:25,760
我们只是返回我们不能使用空节点

2908
21:23:25,760 --> 21:23:31,512
然后我们要说从我们的文本控制器中获取文本

2909
21:23:31,512 --> 21:23:36,552
像那样，然后我们将等待我们的笔记服务更新笔记

2910
21:23:36,552 --> 21:23:42,000
使用该文本，然后在末尾使用逗号以使格式正常工作

2911
21:23:42,000 --> 21:23:45,440
所以这很容易 很简单 不需要那么多

2912
21:23:45,440 --> 21:23:48,832
解释也许这只是一个简单的更新说明

2913
21:23:48,832 --> 21:23:52,232
如此完美

2914
21:23:52,232 --> 21:23:57,040
正如我现在提到的，我们有这个文本控制器监听器，我们还需要

2915
21:23:57,040 --> 21:24:01,512
有一个称为设置文本控制器侦听器的功能，它首先

2916
21:24:01,512 --> 21:24:06,160
如果它已经从我们的文本编辑控制器中删除了这个监听器

2917
21:24:06,160 --> 21:24:10,960
被添加，然后它再次添加它，所以让我们继续，我只是

2918
21:24:10,960 --> 21:24:15,040
将复制该函数名称，因此我不必再次编写它

2919
21:24:15,040 --> 21:24:19,920
嗯，然后在这里我们进入我们称之为文本的文本编辑控制器

2920
21:24:19,920 --> 21:24:25,280
控制器，我们说现在为我们删除侦听器和那个侦听器

2921
21:24:25,280 --> 21:24:28,480
被称为文本控制器侦听器好吧

2922
21:24:28,480 --> 21:24:31,512
然后在删除它之后我们要添加它

2923
21:24:31,512 --> 21:24:36,720
所以在这里我要添加监听器和

2924
21:24:36,720 --> 21:24:41,120
只需添加该侦听器，以防此函数被多次调用

2925
21:24:41,120 --> 21:24:43,760
正确的

2926
21:24:43,760 --> 21:24:49,040
所以现在我们要进入本章有趣的部分

2927
21:24:49,040 --> 21:24:53,832
因为你看到我们已经在这里添加了很多编码但没有人真正

2928
21:24:53,832 --> 21:24:58,480
利用这些，或者实际上我们不能这么说，因为

2929
21:24:58,480 --> 21:25:02,320
白痴对不起处置例如利用保存节点，如果不是

2930
21:25:02,320 --> 21:25:05,920
空的，如果文本为空，它会利用删除注释，但我们是

2931
21:25:05,920 --> 21:25:09,040
没有利用这个创建新节点，我们也没有利用

2932
21:25:09,040 --> 21:25:13,192
设置文本控制器侦听器，这就是我们要做的

2933
21:25:13,192 --> 21:25:17,440
在我们的身体里做我们的

2934
21:25:17,440 --> 21:25:20,960
呃小部件现在它只是说的身体

2935
21:25:20,960 --> 21:25:25,760
context 在这里写下你的新节点，但我们要做的是

2936
21:25:25,760 --> 21:25:31,280
用我们未来的建设者替换它

2937
21:25:31,280 --> 21:25:34,480
当你按下

2938
21:25:34,480 --> 21:25:38,232
应用程序主 ui 上的加号按钮 没有人在创建新的

2939
21:25:38,232 --> 21:25:42,480
请注意您需要在这个新的笔记视图中自己做

2940
21:25:42,480 --> 21:25:47,440
name 表示所以让我们去替换 this 的这个函数的主体

2941
21:25:47,440 --> 21:25:52,552
未来建造者的参数记住未来建造者必须有

2942
21:25:52,552 --> 21:25:56,080
两个变量一个是未来本身和

2943
21:25:56,080 --> 21:25:59,920
另一个将是它的构建器功能，所以

2944
21:25:59,920 --> 21:26:06,000
对于未来，我们需要调用返回未来的创建新节点

2945
21:26:06,000 --> 21:26:11,512
记住它实际上返回了数据库注释，我们已经

2946
21:26:11,512 --> 21:26:16,400
编码这个函数没问题，所以这就是未来

2947
21:26:16,400 --> 21:26:22,232
由未来的构建器调用，然后我们将编写构建器

2948
21:26:22,232 --> 21:26:25,040
我将从 Visual Studio 代码中获得帮助来完成这项工作

2949
21:26:25,040 --> 21:26:28,960
请记住，在您的构建器中，您必须返回一个小部件

2950
21:26:28,960 --> 21:26:31,680
所以我们要做的是因为这是一个

2951
21:26:31,680 --> 21:26:36,552
未来我们需要寻找它的完成状态它不会是我们没有的地方

2952
21:26:36,552 --> 21:26:41,120
必须寻找活动和等待我们只需要寻找完成

2953
21:26:41,120 --> 21:26:46,160
否则我们将显示一个进度指示器好吧，所以让我们说 switch

2954
21:26:46,160 --> 21:26:52,400
快照状态连接状态和来自 Visual Studio 代码的帮助以添加

2955
21:26:52,400 --> 21:26:56,160
这些缺失的案例条款对我来说是这样，嗯

2956
21:26:56,160 --> 21:27:00,800
非等待，所以这些都不重要，除了完成

2957
21:27:00,800 --> 21:27:04,000
对，所以我们就这样离开它

2958
21:27:04,000 --> 21:27:07,920
那么在 uh 默认的情况下，我们只会说

2959
21:27:07,920 --> 21:27:13,120
默认 oops 返回 cons 循环进度指示器

2960
21:27:13,120 --> 21:27:17,680
所以现在我们说当这个创建新节点完成时

2961
21:27:17,680 --> 21:27:20,960
已在我们即将完成的数据库中创建了一个新节点，但我们没有

2962
21:27:20,960 --> 21:27:24,720
返回任何东西，这就是你在这里看到这个小错误的原因，但是

2963
21:27:24,720 --> 21:27:28,552
如果连接状态没有完成，例如如果它正在等待创建

2964
21:27:28,552 --> 21:27:32,160
节点发生然后我们将显示一个小的圆形进度指示器

2965
21:27:32,160 --> 21:27:35,440
用户并记住这将发生得如此之快，以至于您甚至都没有

2966
21:27:35,440 --> 21:27:40,000
会看到这个但是我完全知道循环进展

2967
21:27:40,000 --> 21:27:43,600
指标可能不是以前的解决方案，但我们将在这里做

2968
21:27:43,600 --> 21:27:47,920
我们不会花太多时间来预定义这段代码，因为它是

2969
21:27:47,920 --> 21:27:51,440
可能会在现代硬件上向用户显示

2970
21:27:51,440 --> 21:27:56,480
电话只是几毫秒，所以可能不值得预先定义

2971
21:27:56,480 --> 21:28:00,232
现在代码这么多，至少可以，因为我们在这门课程中进行，但是如果你

2972
21:28:00,232 --> 21:28:04,800
有无限的时间，你和你真的是注意力和你

2973
21:28:04,800 --> 21:28:09,192
对细节有很多关注，那么您可能需要稍微修复一下

2974
21:28:09,192 --> 21:28:14,400
也许把它放在某种中心，或者改变颜色等

2975
21:28:14,400 --> 21:28:18,480
但我们现在不会那样做

2976
21:28:18,480 --> 21:28:21,920
记住我们未来的建设者现在只是

2977
21:28:21,920 --> 21:28:26,000
创建一个未来的构建器，它是并且它被理解为一个数据库

2978
21:28:26,000 --> 21:28:30,552
请注意，如果我们进入 don 连接状态并说

2979
21:28:30,552 --> 21:28:35,760
snapchat 快照数据，虽然它说的是对象

2980
21:28:35,760 --> 21:28:39,680
好吧，我们已经知道这个快照数据是类型

2981
21:28:39,680 --> 21:28:44,000
数据库节点，因为它是未来本身，所以我们只说最终

2982
21:28:44,000 --> 21:28:48,400
实际上不，我们将把它分配给我们的节点变量记住我们有

2983
21:28:48,400 --> 21:28:52,960
这个节点变量在这里，几乎所有这些功能都是

2984
21:28:52,960 --> 21:28:56,640
依靠那个节点变量在那里，这就是我们正在做的事情

2985
21:28:56,640 --> 21:28:59,832
创建一个创建节点的未来构建器，然后我们将其分配给我们的

2986
21:28:59,832 --> 21:29:04,000
节点变量好的，所以我们会说快照

2987
21:29:04,000 --> 21:29:06,720
数据添加

2988
21:29:06,720 --> 21:29:10,000
数据库节点，这就是我们的方式

2989
21:29:10,000 --> 21:29:15,280
从我们的快照中获取我们的节点

2990
21:29:15,280 --> 21:29:18,872
完成此操作后，我们将调用我们的设置

2991
21:29:18,872 --> 21:29:24,000
文本控制器侦听器，因为这就是我们要开始的地方

2992
21:29:24,000 --> 21:29:30,480
在我们的主 UI 上监听用户文本的变化

2993
21:29:30,480 --> 21:29:34,160
好吧，在这一点上我们已经做了什么

2994
21:29:34,160 --> 21:29:38,872
除了实际返回和返回文本外，我们必须做

2995
21:29:38,872 --> 21:29:42,480
用户可以使用的字段

2996
21:29:42,480 --> 21:29:46,960
编辑 ui 上的文本，让我们继续这样做，删除中断

2997
21:29:46,960 --> 21:29:49,832
在这里声明，因为我们不再需要它，我们只想说

2998
21:29:49,832 --> 21:29:54,232
我相信返回添加文本字段

2999
21:29:54,232 --> 21:29:58,640
我们将把我们的文本分配给我们要使用的控制器参数

3000
21:29:58,640 --> 21:30:04,960

