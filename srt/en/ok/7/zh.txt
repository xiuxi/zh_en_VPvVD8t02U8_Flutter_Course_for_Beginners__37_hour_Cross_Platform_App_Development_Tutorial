1
00:54:36,319 --> 00:54:39,116
我在这里即兴创作，因为这就像我

2
00:54:39,116 --> 00:54:42,955
打算给你看，但我实际上还没有准备任何笔记，所以让我们就

3
00:54:42,955 --> 00:54:47,199
继续在此处创建一个名为 user 的表，如您所见，我们将

4
00:54:47,199 --> 00:54:50,720
能够有一些嗯

5
00:54:50,720 --> 00:54:55,360
这里的字段 这里所谓的字段几乎就像一列

6
00:54:55,360 --> 00:54:58,160
因此，通过创建一个字段，您正在创建一个

7
00:54:58,160 --> 00:55:03,040
列好吧，关于sqlite的db浏览器的好处是你可以看到

8
00:55:03,040 --> 00:55:06,635
将为您生成的 sql 代码

9
00:55:06,635 --> 00:55:10,796
当我们将 sqlite 集成到我们的

10
00:55:10,796 --> 00:55:14,319
颤振应用程序，但现在我只想让您了解 sqlite 如何

11
00:55:14,319 --> 00:55:17,680
工作它如何创建表格等等

12
00:55:17,680 --> 00:55:22,796
所以现在我们有用户呃空表它没有任何字段

13
00:55:22,796 --> 00:55:27,116
或列我需要你在这里按下这个添加按钮，我们要做什么

14
00:55:27,116 --> 00:55:31,839
我们要做的是创建一个 id

15
00:55:31,839 --> 00:55:34,796
如果您不是开发人员或

16
00:55:34,796 --> 00:55:37,199
你之前的软件工程师朋友可能不会

17
00:55:37,199 --> 00:55:41,275
了解 id 字段及其重要性，或者您是否是来自

18
00:55:41,275 --> 00:55:44,400
之前你可能知道 id 是以前的主键

19
00:55:44,400 --> 00:55:48,480
所以嗯，一个 id 通常只是一个整数

20
00:55:48,480 --> 00:55:54,080
identifier an integer 是一个数字，因此您输入的每一行的数字标识符

21
00:55:54,080 --> 00:55:59,199
稍后插入您的表中，为什么它很重要，因为

22
00:55:59,199 --> 00:56:04,080
通常一个 id 是一个叫做主键的东西，默认情况下是一个主键

23
00:56:04,080 --> 00:56:06,319
伊斯兰国

24
00:56:06,319 --> 00:56:10,955
独特的，这意味着您能够在此创建用户

25
00:56:10,955 --> 00:56:15,116
表现在必须有它的唯一标识符

26
00:56:15,116 --> 00:56:21,116
如果你还记得我们的嗯我们基本上是如何对待用户的

27
00:56:21,116 --> 00:56:24,480
我们的用户界面是我们正在通过他们的电子邮件对待他们，因此您可以

28
00:56:24,480 --> 00:56:28,559
好好想想，电子邮件也是一个独特的东西，所以我们为什么不一起去呢？

29
00:56:28,559 --> 00:56:33,199
电子邮件的唯一性很好，我们可以对电子邮件应用唯一性约束

30
00:56:33,199 --> 00:56:39,199
电子邮件字段和/或电子邮件列，但它是非常成熟的模式

31
00:56:39,199 --> 00:56:42,879
您正在使用的数据库嗯世界

32
00:56:42,879 --> 00:56:48,160
我的意思是你可以创建一个字符串列的数据库

33
00:56:48,160 --> 00:56:54,000
唯一的，例如电子邮件，但主键通常是整数，例如

34
00:56:54,000 --> 00:57:00,720
作为 pk 或 id 所以这只是一个约定，不去也是一个好习惯

35
00:57:00,720 --> 00:57:04,400
具有字符串的唯一性，因为它

36
00:57:04,400 --> 00:57:07,595
需要更多资源来计算字符串的唯一性

37
00:57:07,595 --> 00:57:14,080
比整数需要的多，所以我们将调用这个字段 id

38
00:57:14,080 --> 00:57:17,839
将是整数，这里有一些字段没有被渲染

39
00:57:17,839 --> 00:57:20,480
好吧，我要增加这个的大小，我要做

40
00:57:20,480 --> 00:57:24,160
像这样可以

41
00:57:24,160 --> 00:57:28,239
所以我们要在这里做什么

42
00:57:28,239 --> 00:57:32,080
我们将带你在这里看到我们将要离开的类型

43
00:57:32,080 --> 00:57:38,160
很好的整数 n n 表示不为空，这意味着该字段应始终为

44
00:57:38,160 --> 00:57:42,796
呈现它绝不应该允许价值或价值的价值和空虚

45
00:57:42,796 --> 00:57:46,796
没有要存在的价值 好的 没有要存在的价值

46
00:57:46,796 --> 00:57:50,400
我希望这是有道理的，基本上只是意味着价值不能不是

47
00:57:50,400 --> 00:57:55,519
要么，所以我们将保留它，就像 pk 代表主键和

48
00:57:55,519 --> 00:57:59,040
这就是我哦，实际上我可以将鼠标移到它们上面，这是很棒的主键

49
00:57:59,040 --> 00:58:03,595
所以嗯，这意味着它是使用 which 的关键

50
00:58:03,595 --> 00:58:09,116
是此表中的唯一键，我们应该能够使用它

51
00:58:09,116 --> 00:58:14,720
然后轻松地从这个表中查询不同的用户，那么什么

52
00:58:14,720 --> 00:58:18,160
我们要做的是我们要把这个项目就在这里好吗

53
00:58:18,160 --> 00:58:22,080
我相信人工智能是自动增量，自动增量是一个很棒的功能

54
00:58:22,080 --> 00:58:27,116
sqlite 和许多其他 uh 数据库，让您如其名 uh

55
00:58:27,116 --> 00:58:31,436
建议，正如名称所示，由您

56
00:58:31,436 --> 00:58:36,879
例如，使用特定电子邮件创建用户，然后插入该用户

57
00:58:36,879 --> 00:58:41,275
进入此表中的数据库，您甚至不必分配 id

58
00:58:41,275 --> 00:58:46,559
对于你刚才说的那个用户，这里是用户电子邮件 boof 把它放在数据库中

59
00:58:46,559 --> 00:58:50,879
那么对不起，那么 sqlite 足够聪明

60
00:58:50,879 --> 00:58:55,040
说哦我，但我也需要一个 id 字段，你还没有提供它然后它

61
00:58:55,040 --> 00:58:59,360
看着这个字段，说哦 id 是自动递增的，所以它会创建

62
00:58:59,360 --> 00:59:04,080
该 id 为您增加先前生成的 id 并分配

63
00:59:04,080 --> 00:59:10,239
例如，如果您在此表中没有对象，则为您的对象添加新 ID

64
00:59:10,239 --> 00:59:15,275
然后您添加一个新用户，然后它会自动获取 id 零

65
00:59:15,275 --> 00:59:18,635
然后如果您生成下一个用户并将其放入其中，那么它将获得

66
00:59:18,635 --> 00:59:23,199
id 为 1，这样你就明白了，这正是我们要做的

67
00:59:23,199 --> 00:59:27,436
这个特殊的领域和独特的就像它的名字一样

68
00:59:27,436 --> 00:59:31,116
表示此字段必须是唯一的，但如果您将某些内容指定为主要字段

69
00:59:31,116 --> 00:59:36,480
key 隐含地它是一个独特的领域，好吧，老实说，我们可以

70
00:59:36,480 --> 00:59:39,839
实际上检查 not null 也意味着是的，它应该总是在那里

71
00:59:39,839 --> 00:59:44,480
以防万一，这是用户字段的好

72
00:59:44,480 --> 00:59:48,955
抱歉，这是 id 字段，现在让我们继续创建一个新的

73
00:59:48,955 --> 00:59:53,680
像这样的用户电子邮件和您应该使用的电子邮件的字段

74
00:59:53,680 --> 00:59:58,796
说这是一个文本好的，我们会做什么，我们会说它不应该

75
00:59:58,796 --> 01:00:06,080
为空，而且电子邮件是唯一的，所以现在看看它生成的

76
01:00:06,080 --> 01:00:11,199
它的代码说创建表用户 id 整数不为空电子邮件文本不是现在

77
01:00:11,199 --> 01:00:17,519
唯一的，它使用自动增量设置 id 的主键，所以

78
01:00:17,519 --> 01:00:22,879
这有点像我们在颤振中实际使用的代码

79
01:00:22,879 --> 01:00:27,116
应用程序，以便以编程方式创建此表

80
01:00:27,116 --> 01:00:31,040
稍后，但现在请记住，这有点像

81
01:00:31,040 --> 01:00:37,360
以编程方式创建一个 sqlite 表

82
01:00:37,360 --> 01:00:40,080
好的，那么你可以在这里按确定

83
01:00:40,080 --> 01:00:43,436
现在您可以看到已为您创建了用户表，这是代码

84
01:00:43,436 --> 01:00:48,480
为它或它在那里所说的模式

85
01:00:48,480 --> 01:00:52,559
现在好了，就像我们做用户表一样

86
01:00:52,559 --> 01:00:57,040
我们需要去创建我们的笔记表，因为记得我之前说过

87
01:00:57,040 --> 01:00:59,680
我们将允许用户在登录时创建笔记

88
01:00:59,680 --> 01:01:02,879
应用程序，当他们实际登录到应用程序时，我们

89
01:01:02,879 --> 01:01:07,436
应该已经为他们创建了一个用户 uh 行

90
01:01:07,436 --> 01:01:12,400
在用户表中，然后通过创建每个注释，我们

91
01:01:12,400 --> 01:01:16,480
还要在我们的笔记表中的数据库中创建一个新笔记

92
01:01:16,480 --> 01:01:18,796
就像标题所示的那样创建

93
01:01:18,796 --> 01:01:24,000
然后我们将该注释绑定到数据库中的那个用户，所以

94
01:01:24,000 --> 01:01:27,839
我需要你到这里然后我们需要通过按来创建一个新表

95
01:01:27,839 --> 01:01:31,839
创建表格按钮好吧，这里的案例中的标题让我们

96
01:01:31,839 --> 01:01:36,480
调用这个新的表格注释，然后我们将首先创建一个

97
01:01:36,480 --> 01:01:40,000
名为 id 的新字段，我们已经完成了这个你知道什么

98
01:01:40,000 --> 01:01:44,796
在这里做一个 id 字段作为整数，我们说它不应该在它不应该

99
01:01:44,796 --> 01:01:48,879
为 null 它应该是主键

100
01:01:48,879 --> 01:01:51,595
和

101
01:01:51,595 --> 01:01:55,275
我认为这就是对你说实话所以不是空的

102
01:01:55,275 --> 01:02:00,160
当然，自动增量也是如此，所以这是为了那是为了

103
01:02:00,160 --> 01:02:05,199
现在我们需要什么其他字段

104
01:02:05,199 --> 01:02:10,480
例如，我们可以说你有一个用户 ID，所以你想

105
01:02:10,480 --> 01:02:16,080
将用户绑定到节点，我们将在这里做什么

106
01:02:16,080 --> 01:02:20,879
要绑定这个我们要从字面上说这个哎呀它去哪儿了

107
01:02:20,879 --> 01:02:25,116
哦，这里的接口有点奇怪，所以也没关系

108
01:02:25,116 --> 01:02:31,519
嗯，所以用户 id 整数，我们要说它不为空

109
01:02:31,519 --> 01:02:36,160
而且我们要做的是我们想要做的是这个用户ID

110
01:02:36,160 --> 01:02:42,879
有点像绑定到用户表 id 字段，就是这样

111
01:02:42,879 --> 01:02:47,199
称为外键，所以你有一个主键

112
01:02:47,199 --> 01:02:51,756
这是您的表本身作为自己的字段管理的键，然后您将

113
01:02:51,756 --> 01:02:56,796
有一个外键，因为它的名字表明它是你里面的一个字段

114
01:02:56,796 --> 01:03:01,756
绑定到另一个表的表是其他列所以在这种情况下

115
01:03:01,756 --> 01:03:06,160
我们的用户 id 应该绑定到用户表 id 列，您可以创建它

116
01:03:06,160 --> 01:03:10,080
使用 db 浏览器用于 sqlite 内部约束

117
01:03:10,080 --> 01:03:14,080
在这里让我们看看我们添加了一个约束，我们说我们有一个

118
01:03:14,080 --> 01:03:16,879
外键和在这里

119
01:03:16,879 --> 01:03:20,955
所以让我们说sqlite外键

120
01:03:20,955 --> 01:03:26,239
我们说用户 id 我们说应用

121
01:03:26,239 --> 01:03:30,239
你现在可以看到它说外键或 id 引用它现在不是

122
01:03:30,239 --> 01:03:32,720
引用任何东西

123
01:03:32,720 --> 01:03:38,319
我想知道那个字段是否隐藏在右边的某个地方

124
01:03:38,319 --> 01:03:41,519
手边

125
01:03:41,519 --> 01:03:47,436
以及我们如何创建它让我们看看我之前记得的

126
01:03:47,436 --> 01:03:51,519
从一开始就开始工作有点奇怪，所以

127
01:03:51,519 --> 01:03:56,160
名字哦，也许是它的名字就在那里所以

128
01:03:56,160 --> 01:04:01,436
所以假设用户 id 引用 sqlite 外键让我们看看它是怎么回事

129
01:04:01,436 --> 01:04:04,720
创建外键用户 ID 引用

130
01:04:04,720 --> 01:04:10,000
如果我说 blob，我们应该在这里说 um 吗？

131
01:04:10,000 --> 01:04:13,199
会发生什么外键准备引用

132
01:04:13,199 --> 01:04:17,436
包含等等，所以那不是我真正想要的

133
01:04:17,436 --> 01:04:20,955
想要在那里，所以我要删除我刚刚创建的这个情节，让我们

134
01:04:20,955 --> 01:04:26,796
看看我们能不能改变我们不能改变的续集这里没有其他可用的字段

135
01:04:26,796 --> 01:04:30,720
我们可以玩的也许不是

136
01:04:30,720 --> 01:04:34,796
我想删除它只是为了看看我是否在那里犯了任何错误所以

137
01:04:34,796 --> 01:04:38,319
假设在这里我可以看到我们有一个用户 ID 和

138
01:04:38,319 --> 01:04:43,275
然后有一个外键，我可以在这里看到这也许是正确的

139
01:04:43,275 --> 01:04:46,635
实际的做事方式我记得有一些非常奇怪的东西

140
01:04:46,635 --> 01:04:53,116
现在我记得不幸的是它隐藏在这个外键 um 列下

141
01:04:53,116 --> 01:04:57,360
我相信这是一个有点奇怪的界面没关系我只是还在

142
01:04:57,360 --> 01:05:02,480
非常感谢我们有用于 sqlite 的 db browser 作为免费软件

143
01:05:02,480 --> 01:05:06,720
甚至可能是一个开源软件，我对此不确定，我非常

144
01:05:06,720 --> 01:05:09,519
感谢每一位为此工作的开发人员

145
01:05:09,519 --> 01:05:13,360
我只是希望它是理解的，但我们要做什么

146
01:05:13,360 --> 01:05:17,360
在这里我们想把这个用户 id 绑定到用户的 id 字段

147
01:05:17,360 --> 01:05:21,839
表所以只需在外键下单击此处并双击实际上我可以看到

148
01:05:21,839 --> 01:05:27,360
然后这个神奇的东西出现了所以让我们继续说我们想要

149
01:05:27,360 --> 01:05:32,796
将此绑定到用户表 id 字段和

150
01:05:32,796 --> 01:05:38,000
我相信应该是的，你现在可以看到这里生成的代码说

151
01:05:38,000 --> 01:05:44,319
我们有一个名为 user id 的外键，它引用了用户表 id 字段

152
01:05:44,319 --> 01:05:49,436
好吧完美嗯现在我们还需要做的是

153
01:05:49,436 --> 01:05:54,160
在此处创建另一个字段，这是每个注释的文本

154
01:05:54,160 --> 01:05:58,480
所以我们要为笔记做的将非常简单，我们的笔记是

155
01:05:58,480 --> 01:06:01,915
不包括任何形式的嗯

156
01:06:01,915 --> 01:06:06,000
他们不会包括任何类型的，例如嗯

157
01:06:06,000 --> 01:06:10,955
他们不会包含任何类型的图像

158
01:06:10,955 --> 01:06:15,116
有序列表或无序列表，它们将是简单的文本，好吧，它们

159
01:06:15,116 --> 01:06:19,040
甚至没有标题我们将从文本中得出的注释的标题

160
01:06:19,040 --> 01:06:21,839
笔记，所以很简单

161
01:06:21,839 --> 01:06:26,559
所以对于笔记的文本，我们就说它是文本类型

162
01:06:26,559 --> 01:06:31,116
呃，我相信我相信这就是我们所需要的

163
01:06:31,116 --> 01:06:36,160
现在所以用户 id 文本，是的，这很好，

164
01:06:36,160 --> 01:06:40,796
说实话，如果你愿意，你也可以创建一个其他领域

165
01:06:40,796 --> 01:06:45,360
在这里你可以看到这个呃在这个课程中我想做什么

166
01:06:45,360 --> 01:06:50,635
开始是允许我们创建一个本地数据库，你可以存储所有

167
01:06:50,635 --> 01:06:54,400
用户在其中的注释，但我希望您也能够

168
01:06:54,400 --> 01:06:57,595
以后以后摆脱这个本地数据库并将其替换为

169
01:06:57,595 --> 01:07:02,720
firebase 这就像目标，但是你们中的一些人实际上可能决定保留

170
01:07:02,720 --> 01:07:07,436
此本地数据库将用户的信息存储在此本地数据库中，并且

171
01:07:07,436 --> 01:07:11,116
不是用户的信息用户在这个数据库中的笔记然后你可以

172
01:07:11,116 --> 01:07:15,436
想要决定在

173
01:07:15,436 --> 01:07:20,080
背景并在适当的时候将这些笔记与firebase同步，以便

174
01:07:20,080 --> 01:07:22,955
如果您想这样做，这取决于您，那么您可能想要实际创建一个

175
01:07:22,955 --> 01:07:27,595
这里的小填充被称为与服务器同步或类似的东西

176
01:07:27,595 --> 01:07:32,239
没关系，或者它已与云同步，我已经

177
01:07:32,239 --> 01:07:35,519
在我的笔记中提到了它，所以让我们继续做吧，尽管我们实际上并没有

178
01:07:35,519 --> 01:07:38,796
打算使用这个字段，但我只是想向你证明这个字段是

179
01:07:38,796 --> 01:07:42,160
可以实现

180
01:07:42,160 --> 01:07:47,519
sqlite 然后在这里假设它是一个整数

181
01:07:47,519 --> 01:07:51,436
还有嗯，我们会说默认是

182
01:07:51,436 --> 01:07:57,116
0 表示它基本上没有同步 true 或 false

183
01:07:57,116 --> 01:08:01,680
true 可以翻译成任何非 0 的值，并且 0 可以翻译

184
01:08:01,680 --> 01:08:03,915
到 false 的值，所以把值

185
01:08:03,915 --> 01:08:08,480
这里的零意味着它不与任何云同步

186
01:08:08,480 --> 01:08:12,559
存储所以让我们继续说吧

187
01:08:12,559 --> 01:08:18,480
这是整数，嗯，我们应该说它不是空的，嗯，它不是

188
01:08:18,480 --> 01:08:22,879
必须是独一无二的，所以现在你可以看到这是创造的结果

189
01:08:22,879 --> 01:08:27,595
在我们的表中，这是 id integer not null 并且 id 也是主键

190
01:08:27,595 --> 01:08:31,595
自动递增然后有一个用户 ID，它是整数不为空，但它也是

191
01:08:31,595 --> 01:08:35,040
id 列下用户表的外键

192
01:08:35,040 --> 01:08:40,080
或 id 字段，然后我们这里有另一个字段表示 text 类型的 text 和

193
01:08:40,080 --> 01:08:44,480
然后另一个名为 isync 的字段，云整数不为空，默认为零

194
01:08:44,480 --> 01:08:48,319
好的，这就是我们需要做的一切

195
01:08:48,319 --> 01:08:52,000
我会按好，我需要在你这边做同样的事情

196
01:08:52,000 --> 01:08:56,400
现在我们有两个嗯

197
01:08:56,400 --> 01:09:00,955
我们的数据库中有两个表

198
01:09:00,955 --> 01:09:06,319
所以让我们继续前进，嗯，让我们继续前进，继续下一个

199
01:09:06,319 --> 01:09:09,519
指出我们将要谈论的问题是，我们需要将您视为字幕案例

200
01:09:09,519 --> 01:09:14,559
以编程方式创建这些，否则我们必须移动它

201
01:09:14,559 --> 01:09:17,436
我们刚刚创建的名为 testingdb 的数据库

202
01:09:17,436 --> 01:09:21,199
手动进入应用程序的文档文件夹我将解释什么

203
01:09:21,199 --> 01:09:27,040
这实际上意味着您现在看到我们有一个名为 testingdb 的文件

204
01:09:27,040 --> 01:09:32,080
有我们应用程序的数据库和一些表好吗

205
01:09:32,080 --> 01:09:35,040
但是我们需要能够创建这些

206
01:09:35,040 --> 01:09:40,080
如果您看到的应用程序中不存在表格，则以编程方式

207
01:09:40,080 --> 01:09:44,239
这个测试数据库对我来说是坐在我的桌面上它完全没有任何关系

208
01:09:44,239 --> 01:09:49,040
使用我们的颤振应用程序，您可以很聪明，喜欢拖动这个数据库

209
01:09:49,040 --> 01:09:53,595
进入你的firebase应用程序颤动应用程序，然后将其复制到

210
01:09:53,595 --> 01:09:58,400
应用程序在用户电话中执行时的正确位置或

211
01:09:58,400 --> 01:10:01,680
在平板电脑上，然后尝试从该数据库中读取

212
01:10:01,680 --> 01:10:05,839
这是可能的，但我要在这里做的是我要告诉你

213
01:10:05,839 --> 01:10:10,160
一种更好的方法是我们将实际创建这些表

214
01:10:10,160 --> 01:10:13,839
以编程方式在我们的颤振应用程序中，以便

215
01:10:13,839 --> 01:10:17,756
您还看到了该过程以及它是如何工作的，您如何与

216
01:10:17,756 --> 01:10:22,000
在你的颤振应用程序中使用 sqlite

217
01:10:22,000 --> 01:10:25,519
好吧，为了做到这一点，作为字幕案例，我们需要一些

218
01:10:25,519 --> 01:10:32,080
依赖关系呃我们需要 sql sqflight 路径提供程序和路径

219
01:10:32,080 --> 01:10:36,879
然后我会向你解释为什么我们需要这些依赖项，你看 sql

220
01:10:36,879 --> 01:10:40,720
sqflight 是一个包它是我们需要添加到我们的第三方包

221
01:10:40,720 --> 01:10:45,040
应用程序，以便我们的颤振应用程序能够与 sql 对话

222
01:10:45,040 --> 01:10:48,635
飞行，就是这样，那是为了

223
01:10:48,635 --> 01:10:54,955
storage 实际存储并与该软件包使用的数据库进行对话

224
01:10:54,955 --> 01:10:58,955
现在有一个依赖项我们必须拖到我们的应用程序中，称为路径

225
01:10:58,955 --> 01:11:05,595
路径用于我们能够抓取应用程序文档文件夹

226
01:11:05,595 --> 01:11:10,796
这样我们就可以在文档文件夹中创建一个文件并将我们的

227
01:11:10,796 --> 01:11:15,839
该文件中的数据就像我为节点和用户放置数据一样

228
01:11:15,839 --> 01:11:18,955
在我桌面上的这个测试数据库文件中，所以

229
01:11:18,955 --> 01:11:23,756
路径 uh 提供者和路径提供者 uh i

230
01:11:23,756 --> 01:11:27,680
可能实际上已经教过设置路径，但它实际上被称为路径提供者路径

231
01:11:27,680 --> 01:11:32,239
提供者依赖允许我们获取应用程序

232
01:11:32,239 --> 01:11:35,756
文档文件夹，如果您不熟悉移动应用程序

233
01:11:35,756 --> 01:11:40,080
开发你可能不知道，但是坐在呃上的应用程序

234
01:11:40,080 --> 01:11:45,915
android 手机或平板电脑以及 ios 手机或 ipad os 平板电脑

235
01:11:45,915 --> 01:11:50,480
它们有自己的文件结构，因此每个应用程序本身都有一个

236
01:11:50,480 --> 01:11:53,199
文档目录所以

237
01:11:53,199 --> 01:11:57,915
而在您的计算机上，就像您坐在笔记本电脑或台式机上一样

238
01:11:57,915 --> 01:12:03,360
您有一个文档文件夹，其他应用程序在您的操作系统上运行

239
01:12:03,360 --> 01:12:08,160
系统可以访问，因此它是每个应用程序都可以访问的一个文档文件夹

240
01:12:08,160 --> 01:12:12,400
请求访问并在其中存储信息并从中读取信息，但事实并非如此

241
01:12:12,400 --> 01:12:17,755
在移动设备和平板电脑上的每个应用程序都具有相同的概念

242
01:12:17,755 --> 01:12:23,279
在一个叫做沙箱的东西里面运行沙箱就像一个它就像一个

243
01:12:23,279 --> 01:12:27,755
应用程序所在的笼子和所有应用程序数据

244
01:12:27,755 --> 01:12:32,555
驻留在该沙箱中，因此每个应用程序都可以请求访问

245
01:12:32,555 --> 01:12:37,919
从操作系统读取它自己的文件夹没问题，那就是

246
01:12:37,919 --> 01:12:40,960
路径提供者是什么

247
01:12:40,960 --> 01:12:45,600
包将允许我们找到我们的应用程序文件

248
01:12:45,600 --> 01:12:50,639
我们将在其中存储数据库文件的文件夹

249
01:12:50,639 --> 01:12:53,755
现在我们还需要正如我提到的

250
01:12:53,755 --> 01:12:57,039
一个名为 path 的包和

251
01:12:57,039 --> 01:13:01,600
我们需要这条路径只是为了一个非常简单的操作和

252
01:13:01,600 --> 01:13:06,720
假设我们现在使用路径提供程序来获取我们的文档文件夹

253
01:13:06,720 --> 01:13:11,039
我们想在这个文档文件夹中创建一个文件

254
01:13:11,039 --> 01:13:15,115
有点像获取此文件文档文件夹斜杠的完整路径

255
01:13:15,115 --> 01:13:18,720
这个文件，这就是我们需要的路径包，因为它有一个很棒的

256
01:13:18,720 --> 01:13:23,516
名为 join 的函数允许我们获取目录的路径或

257
01:13:23,516 --> 01:13:28,000
文件夹并使用文件名加入该路径，然后

258
01:13:28,000 --> 01:13:32,555
给我们完整的路径，这样我们就可以访问那个文件了

259
01:13:32,555 --> 01:13:36,320
所以很多信息我要接受这个

260
01:13:36,320 --> 01:13:41,600
嗯到另一个屏幕，所以你看不到它，我可以看到

261
01:13:41,600 --> 01:13:44,876
这里它要求控制这台计算机的访问现在我要拒绝

262
01:13:44,876 --> 01:13:48,320
现在，嗯，好吧，所以我们要做什么

263
01:13:48,320 --> 01:13:51,600
如果我能找到它，我会提出我们的代码

264
01:13:51,600 --> 01:13:55,755
这是我们在前几章中留下的代码

265
01:13:55,755 --> 01:13:59,755
我可以看到它正在运行，对不起，我要带上 scrcpy

266
01:13:59,755 --> 01:14:03,600
它在这里我实际上不确定你是否需要在本章中使用 crcpy，所以它可能

267
01:14:03,600 --> 01:14:07,516
对我来说最好只是最小化 scr cpy

268
01:14:07,516 --> 01:14:11,516
我也会让这段代码在这里更大一点

269
01:14:11,516 --> 01:14:15,436
所以我们现在需要什么

270
01:14:15,436 --> 01:14:20,156
首先是在我们继续并实际创建我们的笔记服务之前

271
01:14:20,156 --> 01:14:24,080
引入这些依赖项好吧让我改变这个屏幕布局

272
01:14:24,080 --> 01:14:27,835
一点点让你看得更清楚我也会增加字体

273
01:14:27,835 --> 01:14:33,835
所以我需要你去你的编辑器文本编辑器或 id 如果你正在使用

274
01:14:33,835 --> 01:14:38,156
我们需要引入那些依赖关系好吗

275
01:14:38,156 --> 01:14:44,320
所以让我们打开你的网络浏览器，然后在公共场合说 pop.dev

276
01:14:44,320 --> 01:14:49,516
开发人员搜索 sql 航班没问题，您可以看到它就在那里以及前往的方式

277
01:14:49,516 --> 01:14:53,195
安装它很简单你应该可以说

278
01:14:53,195 --> 01:14:59,279
呃，在 sqflight 上扑腾扑腾，所以让我们继续手动做吧

279
01:14:59,279 --> 01:15:07,516
让我们试一试记住它不是 sqlite 它是 sqlite

280
01:15:07,516 --> 01:15:12,399
好的，已经添加了依赖项，然后我会说颤振流行添加提供

281
01:15:12,399 --> 01:15:18,399
一个路径提供者，我们实际上可以在 popdev 路径提供者中搜索它

282
01:15:18,399 --> 01:15:22,796
它就在那里，它是由那些拥有的人开发的

283
01:15:22,796 --> 01:15:27,436
给我们带来了颤抖，所以从谷歌开始，所以它不是真正的三分之一

284
01:15:27,436 --> 01:15:31,360
方应用程序或第三方呃包，我们实际上可以看看

285
01:15:31,360 --> 01:15:35,679
在 sql flight 上，看看是谁开发的

286
01:15:35,679 --> 01:15:40,156
哦，这是另一个，是的，这是另一个出版商自己不会颤抖，所以

287
01:15:40,156 --> 01:15:45,279
让我们回到路径提供者，我只想说

288
01:15:45,279 --> 01:15:50,960
如我们所见，安装是颤振弹出添加路径提供程序让我复制它

289
01:15:50,960 --> 01:15:55,516
并将其粘贴到那里添加路径提供程序

290
01:15:55,516 --> 01:16:00,399
然后我们还需要路径，所以让我们回到这里并输入路径 i

291
01:16:00,399 --> 01:16:05,195
相信这是我的颤振团队是的黑暗开发所以让我们说颤振流行

292
01:16:05,195 --> 01:16:10,796
添加路径

293
01:16:10,796 --> 01:16:16,475
好吧，这将完成它的工作，现在如果你去我们的 um

294
01:16:16,475 --> 01:16:21,360
pop special 那么你应该可以看到那些

295
01:16:21,360 --> 01:16:26,876
依赖项 sqflight 路径提供程序和路径就在那里

296
01:16:26,876 --> 01:16:31,755
现在我们已经完成了，我们可以去做我们应该在这里做的事情

297
01:16:31,755 --> 01:16:35,835
这是创建我们的笔记服务，您可以在

298
01:16:35,835 --> 01:16:38,720
呃，在我在标题中提供的描述中，我说我们在

299
01:16:38,720 --> 01:16:43,115
在名为 crud 的文件夹中创建，我们已经有你可以使用的 lib 服务

300
01:16:43,115 --> 01:16:48,960
在这里看到 lib services 和 lib services auth 但我们没有 crud 所以

301
01:16:48,960 --> 01:16:54,960
我要在 lib 中进入这里，只说新文件，我要说服务

302
01:16:54,960 --> 01:16:56,960
好斜线绝对是说它已经

303
01:16:56,960 --> 01:17:01,195
存在所以在服务内部我要说新文件然后我要带它

304
01:17:01,195 --> 01:17:04,796
所以你也可以看到它哦它去哪儿了

305
01:17:04,796 --> 01:17:08,320
服务新文件 crud

306
01:17:08,320 --> 01:17:13,360
我想我需要更改屏幕布局，所以很遗憾，你会看到的

307
01:17:13,360 --> 01:17:21,600
更好的服务再次新文件在这里一个新文件呃第三次或第四次

308
01:17:21,600 --> 01:17:28,475
幸运的 crud 然后是节点服务点

309
01:17:28,475 --> 01:17:31,279
好的，那么我们将如何处理这个节点

310
01:17:31,279 --> 01:17:36,244
服务是要呃是要基本抢

311
01:17:36,244 --> 01:17:41,516
持有我们的数据库，它是要使用的主要服务

312
01:17:41,516 --> 01:17:45,115
我们的 sqlite 数据库 它会抓住用户 它会

313
01:17:45,115 --> 01:17:51,115
创建新用户 删除用户 它会找到用户 它会创建笔记

314
01:17:51,115 --> 01:17:55,195
删除节点 更新节点 用户需要的一切

315
01:17:55,195 --> 01:17:59,600
此节点服务将要访问的接口

316
01:17:59,600 --> 01:18:04,320
为我们提供便利，好吧

317
01:18:04,320 --> 01:18:12,080
好的，所以我们需要在里面做的是

318
01:18:12,080 --> 01:18:16,156
所以我们现在需要做的是实际上我认为在我们这样做之前我们需要

319
01:18:16,156 --> 01:18:20,244
导入我们的依赖项，让我们导入我们需要的依赖项

320
01:18:20,244 --> 01:18:24,960
如果您还记得路径路径提供程序和 sqlite，则三个依赖项

321
01:18:24,960 --> 01:18:29,755
嗯，我会把那些带到这里，这样我们就不必

322
01:18:29,755 --> 01:18:35,039
再次输入，所以进口有点无聊，我

323
01:18:35,039 --> 01:18:38,796
我宁愿不输入它们所以让我们进入这里你可以看看什么

324
01:18:38,796 --> 01:18:42,475
我在这里导入了包 sql flight，然后我们导入它

325
01:18:42,475 --> 01:18:46,244
然后我们还可以使用路径提供程序，以便我们可以获取文档文件夹

326
01:18:46,244 --> 01:18:50,555
对于这个应用程序，然后我们也正在导入包路径路径，然后

327
01:18:50,555 --> 01:18:56,555
我这样做是为了引入这个名为的特定函数

328
01:18:56,555 --> 01:18:59,195
加入好吧

329
01:18:59,195 --> 01:19:03,600
你也可以跳过它，但问题是你把所有东西都放在里面

330
01:19:03,600 --> 01:19:07,755
飞镖的路径，这不是我想要的，所以我只想让我们得到这个特别的

331
01:19:07,755 --> 01:19:10,876
path.dart 中的函数，你也可以这样做

332
01:19:10,876 --> 01:19:15,279
在这里说实话，你可以说show um，我认为

333
01:19:15,279 --> 01:19:19,600
函数被称为获取应用程序文档目录所以让我们这样做为什么

334
01:19:19,600 --> 01:19:24,080
不要让我们从路径提供者那里得到那个特定的功能，好吧

335
01:19:24,080 --> 01:19:27,600
我们不需要整个路径提供者好吧

336
01:19:27,600 --> 01:19:32,475
好吧，那太好了

337
01:19:32,475 --> 01:19:36,320
我们需要的是让我们能够

338
01:19:36,320 --> 01:19:41,679
抓住我们当前的数据库路径，正如我提到的那样

339
01:19:41,679 --> 01:19:45,516
您使用 Flutter 为移动应用程序开发的每个应用程序

340
01:19:45,516 --> 01:19:50,244
android和ios以及ipad os等设备都有自己的文档

341
01:19:50,244 --> 01:19:54,475
目录，我们要创建，我们要得到的路径

342
01:19:54,475 --> 01:19:58,475
文件目录，然后我们就是我们要说的是我们要

343
01:19:58,475 --> 01:20:02,399
使用路径依赖加入它

344
01:20:02,399 --> 01:20:07,679
使用我们将为我们的数据库指定的名称

345
01:20:07,679 --> 01:20:10,156
所以嗯

346
01:20:10,156 --> 01:20:14,244
那么我们需要做的是让我们先实际并照顾好

347
01:20:14,244 --> 01:20:20,000
在我们真正开始之前需要处理的其他一些重要事项

348
01:20:20,000 --> 01:20:24,475
为我们的数据库创建函数功能，呃实现你

349
01:20:24,475 --> 01:20:28,080
请参阅注释服务将与数据库交谈，但在您执行此操作之前

350
01:20:28,080 --> 01:20:32,639
需要对这两个非常有某种飞镖表示

351
01:20:32,639 --> 01:20:38,960
我们创建了用户并注意的重要表，因此如果您从中读取该数据

352
01:20:38,960 --> 01:20:43,115
数据库我们将如何在我们的 dart 应用程序中表示它

353
01:20:43,115 --> 01:20:48,876
为此，我们需要飞镖课程

354
01:20:48,876 --> 01:20:53,755
我们现在需要的是作为标题，以防我们需要数据库用户创建一个

355
01:20:53,755 --> 01:20:59,516
在笔记服务飞镖内称为数据库用户的类

356
01:20:59,516 --> 01:21:03,919
好吧，这将是一些代码，所以我希望你已经准备好了

357
01:21:03,919 --> 01:21:07,679
让我们继续吧 我正在看我的笔记

358
01:21:07,679 --> 01:21:12,000
让我们继续创建，因为标题表明我们在这里创建了一个类

359
01:21:12,000 --> 01:21:15,919
我做了一个更大的班级，我只是

360
01:21:15,919 --> 01:21:22,720
如果您还记得从 db browser for

361
01:21:22,720 --> 01:21:26,320
sqlite 我要把它带到这里每个用户都有

362
01:21:26,320 --> 01:21:29,679
我们真的可以吗，哦，我们可以浏览它，但我想去

363
01:21:29,679 --> 01:21:33,919
回到用户并修改表保存它，你

364
01:21:33,919 --> 01:21:37,919
记住它有一个 id 和一个电子邮件 id 是整数和电子邮件是文本所以这是

365
01:21:37,919 --> 01:21:42,555
我们要在这里定义什么好的，所以我们要说 final 和 id 和

366
01:21:42,555 --> 01:21:46,320
最终字符串电子邮件

367
01:21:46,320 --> 01:21:49,436
从视觉工作室获得帮助以完全完成这个我不去

368
01:21:49,436 --> 01:21:53,115
一次又一次地解释这些，因为我们已经解释了很多

369
01:21:53,115 --> 01:21:58,475
之前的章节，所以到这里我只是假设你知道这些是什么

370
01:21:58,475 --> 01:22:02,244
让我们让它成为一个常量初始化器，然后让我们继续说这些

371
01:22:02,244 --> 01:22:05,039
两个参数是必需的参数所以

372
01:22:05,039 --> 01:22:09,755
默认情况下它们也成为命名参数

373
01:22:09,755 --> 01:22:15,360
这就是在这里放一个逗号所以我们得到暗格式化程序来发挥它的魔力

374
01:22:15,360 --> 01:22:19,436
我们要做的是记住我们什么时候

375
01:22:19,436 --> 01:22:23,195
实际上你不应该记得，因为你可能还不知道，但是当

376
01:22:23,195 --> 01:22:28,796
我们与我们将要阅读的数据库交谈

377
01:22:28,796 --> 01:22:33,755
就像我们从 for 中读取的每一行的哈希表

378
01:22:33,755 --> 01:22:38,399
从该表中，因此该数据库中的每个用户

379
01:22:38,399 --> 01:22:43,436
名为 user 的表将由该对象表示

380
01:22:43,436 --> 01:22:50,399
字符串和一个可选对象可以，所以这是用户表中的一行

381
01:22:50,399 --> 01:22:53,600
现在想象这个

382
01:22:53,600 --> 01:22:56,796
我们即将创建的节点服务

383
01:22:56,796 --> 01:22:59,919
从数据库中读取这些用户，它应该是

384
01:22:59,919 --> 01:23:04,475
能够将它传递给我们的数据库用户类，并且数据库用户类应该

385
01:23:04,475 --> 01:23:09,600
根据此地图中的值创建自身的实例

386
01:23:09,600 --> 01:23:15,115
好吧，让我们继续创建一个构造函数，我们称之为数据库用户

387
01:23:15,115 --> 01:23:20,080
然后我们说前排然后我们说我们得到一个字符串的映射

388
01:23:20,080 --> 01:23:25,436
和一个可选对象，然后我们就称它为 map 好吧

389
01:23:25,436 --> 01:23:29,115
所以我们要在这里做的是我们要为

390
01:23:29,115 --> 01:23:33,919
创建和构造我们的对象，我们会说 id 等于 this

391
01:23:33,919 --> 01:23:38,555
map 需要有某种称为 id 列的列，而不是

392
01:23:38,555 --> 01:23:42,796
像这样在这里进行硬编码让我们在这里定义一个常量

393
01:23:42,796 --> 01:23:47,679
称它为 id 列，让我们说这等于 id 并且在这里

394
01:23:47,679 --> 01:23:52,156
我们只是说id等于ib列就好了

395
01:23:52,156 --> 01:23:59,115
然后我们要说的是我们还需要电子邮件，电子邮件等于

396
01:23:59,115 --> 01:24:02,720
映射并记住我们有我要去的电子邮件

397
01:24:02,720 --> 01:24:06,320
在这里打开用户

398
01:24:06,320 --> 01:24:11,360
修改表

399
01:24:11,360 --> 01:24:17,039
让我们去看看这封电子邮件，里面有文字，好吗

400
01:24:17,039 --> 01:24:20,320
所以该列的表基本上是

401
01:24:20,320 --> 01:24:24,720
调用电子邮件，所以让我们继续创建 const 我将要做这个

402
01:24:24,720 --> 01:24:28,156
一个单一的代码，因为这就像做的首选方式

403
01:24:28,156 --> 01:24:32,720
它，我们称之为电子邮件列，我将把它分配给

404
01:24:32,720 --> 01:24:36,156
完整的电子邮件，在这里我只想说电子邮件专栏

405
01:24:36,156 --> 01:24:41,039
作为一个字符串，这应该是这样的

406
01:24:41,039 --> 01:24:43,679
这是我的意思是它看起来很复杂，但它

407
01:24:43,679 --> 01:24:48,555
真的不是这样，你可以看到它是一个常数，所以我们实际上也可以标记

408
01:24:48,555 --> 01:24:54,244
这是不可变的，我们需要导入基础才能能够

409
01:24:54,244 --> 01:24:57,115
这样做没关系

410
01:24:57,115 --> 01:25:01,516
现在我们有了数据库用户，我们还需要实现更多

411
01:25:01,516 --> 01:25:05,360
在我们真正完成之前这个类的功能

412
01:25:05,360 --> 01:25:09,039
有了它，我们需要做的三件事

413
01:25:09,039 --> 01:25:13,679
因为它首先为这个类创建一个字符串描述符，这样如果

414
01:25:13,679 --> 01:25:17,360
我们正在将此用户打印到调试控制台

415
01:25:17,360 --> 01:25:20,156
否则，我的意思是在我说否则之前，如果我们是

416
01:25:20,156 --> 01:25:25,279
将数据库用户的实例打印到调试控制台，所以我们

417
01:25:25,279 --> 01:25:29,835
查看我们数据库中的各种用户

418
01:25:29,835 --> 01:25:34,244
如果我们没有在我们的类上实现两个字符串，它实际上只会说

419
01:25:34,244 --> 01:25:39,039
控制台中数据库用户的实例，这不是那么有用，所以它是我的

420
01:25:39,039 --> 01:25:42,876
如果我打算打印出来，我的习惯

421
01:25:42,876 --> 01:25:46,960
这些东西到控制台我习惯去实现两个字符串所以

422
01:25:46,960 --> 01:25:51,835
让我们在这里对字符串说，它给了我们覆盖和什么

423
01:25:51,835 --> 01:25:55,919
我们要在这里做的只是我们要说一个人

424
01:25:55,919 --> 01:26:00,639
并且个人ID等于美元ID

425
01:26:00,639 --> 01:26:05,679
并且电子邮件等于美元电子邮件，好吧，这是您的字符串

426
01:26:05,679 --> 01:26:10,720
那么我们需要做的也是实现某种平等

427
01:26:10,720 --> 01:26:15,115
你看到的我们班级的行为我们希望能够看到两个不同的

428
01:26:15,115 --> 01:26:18,720
我们从数据库中检索到的人彼此是否相等

429
01:26:18,720 --> 01:26:24,876
所以如果我说如果人 x 等于人 y 那么就像明智地阅读这个人

430
01:26:24,876 --> 01:26:29,835
诸如此类的注释，所以让我们开始为我们的实现平等吧

431
01:26:29,835 --> 01:26:33,835
类和做到这一点的方法是你覆盖

432
01:26:33,835 --> 01:26:39,516
一个布尔运算符，它被称为布尔运算符 equal equal

433
01:26:39,516 --> 01:26:45,115
在这里你会有一个我们还没有讨论过的协变，我

434
01:26:45,115 --> 01:26:49,115
现在会和你谈谈

435
01:26:49,115 --> 01:26:53,436
协方差是飞镖中的一个关键字，很少有人知道，但它

436
01:26:53,436 --> 01:26:58,080
允许您更改输入参数的行为，以便它们执行

437
01:26:58,080 --> 01:27:03,436
不一定符合该参数的签名

438
01:27:03,436 --> 01:27:07,679
超级类所以记住我们在这里覆盖意味着那里

439
01:27:07,679 --> 01:27:12,555
此运算符的功能已经在对象级别定义，所以让我们开始吧

440
01:27:12,555 --> 01:27:16,960
对象只是在某处键入对象，例如

441
01:27:16,960 --> 01:27:20,720
void hello 然后说对象然后命令

442
01:27:20,720 --> 01:27:25,516
点击它，这样你就可以去那里搜索运营商

443
01:27:25,516 --> 01:27:29,516
equal equal 并且你会在这里看到它表示外部运算符 equal 和

444
01:27:29,516 --> 01:27:35,436
参数应该是 object 类型的，现在我们不想这样做，我们想要我们的

445
01:27:35,436 --> 01:27:40,555
要与相同类型的其他类进行比较的类，所以如果你不这样做

446
01:27:40,555 --> 01:27:43,835
把协变量放在这里你会得到一个错误

447
01:27:43,835 --> 01:27:47,115
分析器，你很快就会看到实际上我们很快就会删除它

448
01:27:47,115 --> 01:27:49,195
所以在这里我们说我们要

449
01:27:49,195 --> 01:27:53,360
比较我们的类与相等相等和我们类的实例相等相等

450
01:27:53,360 --> 01:27:57,835
我们将与同一类的另一个用户进行比较，然后

451
01:27:57,835 --> 01:28:01,679
在这里我们只是说我们的 id 应该等于另一个 id

452
01:28:01,679 --> 01:28:06,320
我们的平等现在让我们继续然后删除它

453
01:28:06,320 --> 01:28:10,156
正如我向你承诺的那样协变，现在你会看到你会得到一个错误

454
01:28:10,156 --> 01:28:15,115
说哦等一下根据对象等于等于应该比较

455
01:28:15,115 --> 01:28:19,755
当前对象与另一个对象但使用协变​​你告诉飞镖

456
01:28:19,755 --> 01:28:24,000
嘿，我不能与任何其他类的其他对象相提并论，我只会

457
01:28:24,000 --> 01:28:28,475
可与数据库用户实例相媲美，因此一切正常

458
01:28:28,475 --> 01:28:31,115
所以在你实施 equal 之后，你有

459
01:28:31,115 --> 01:28:34,320
还按照分析器的建议实施哈希码，所以我要去

460
01:28:34,320 --> 01:28:38,244
从视觉工作室代码的飞镖获得帮助，我要去

461
01:28:38,244 --> 01:28:42,960
说创建方法哈希码并在覆盖哈希码时我

462
01:28:42,960 --> 01:28:49,195
只是要返回我的 id 的哈希码，所以这基本上是 id

463
01:28:49,195 --> 01:28:53,919
成为这个类的主键，它会使用它来散列自己，所以它

464
01:28:53,919 --> 01:28:59,115
可以放置在地图或哈希节点中，如果你

465
01:28:59,115 --> 01:29:04,876
如果您是 ros 开发人员或字典 如果您是 swift 开发人员

466
01:29:04,876 --> 01:29:08,876
所以呃，这很好，所以感觉就像

467
01:29:08,876 --> 01:29:16,876
我们现在已经用我们的数据库用户完成了这个 um 所以

468
01:29:16,876 --> 01:29:20,639
那是相当多的代码，但我们做到了

469
01:29:20,639 --> 01:29:23,516
好了，现在我们已经完成了数据库用户，我们需要做一些事情

470
01:29:23,516 --> 01:29:28,960
类似，但这次我们需要为我们的节点做这件事，所以我们有一个数据库用户

471
01:29:28,960 --> 01:29:32,876
现在我们必须创建一个叫做数据库节点的东西

472
01:29:32,876 --> 01:29:36,555
不是节点，我将在

473
01:29:36,555 --> 01:29:41,279
数据库用户，以便我们可以更接近地访问这些常量

474
01:29:41,279 --> 01:29:43,835
对，所以我建议你做同样的事情

475
01:29:43,835 --> 01:29:47,919
假设我们创建了一个类，我们称之为数据库注释

476
01:29:47,919 --> 01:29:52,000
并从我们的数据库模式中记住一个注释，所以如果我进去说

477
01:29:52,000 --> 01:29:58,000
右键单击右键并修改表然后我们有 id 用户 id 文本和一个

478
01:29:58,000 --> 01:30:02,080
现场呼叫已与云同步，所以让我们继续做那个 id

479
01:30:02,080 --> 01:30:07,516
是整数用户 ID 整数文本是文本或字符串，因为 ins 与云同步

480
01:30:07,516 --> 01:30:09,835
这里只是一个整数，但我们要

481
01:30:09,835 --> 01:30:14,320
可以将其表示为布尔值，因此请记住这四个字段

482
01:30:14,320 --> 01:30:19,436
让我们继续说 final id 和 mint id

483
01:30:19,436 --> 01:30:23,919
我们在我们的数据库中有一个最终的 int 我们称之为用户下划线 id 因为

484
01:30:23,919 --> 01:30:28,796
这是 sqlite 或 sql 中的一个约定，通常你不会把你放在

485
01:30:28,796 --> 01:30:32,720
就像你不和用户一起写你的字段

486
01:30:32,720 --> 01:30:36,639
id 通常你不会像我们在 dart 中使用驼峰式大小写那样输入

487
01:30:36,639 --> 01:30:40,080
其他语言我们只是说用户一切都在一切之下

488
01:30:40,080 --> 01:30:43,516
小写字母和不同的单词用

489
01:30:43,516 --> 01:30:47,279
下划线，但在 dart 和其他语言中并非如此，而是我们说

490
01:30:47,279 --> 01:30:51,436
像这样的用户用户 ID 与面板案例全部

491
01:30:51,436 --> 01:30:54,876
对，我们也会创造让我

492
01:30:54,876 --> 01:30:59,360
把它移到那里一点，我们也将创建 um

493
01:30:59,360 --> 01:31:04,244
我们文本的字符串和

494
01:31:04,244 --> 01:31:09,436
最后我们要说的是与云同步这样的东西

495
01:31:09,436 --> 01:31:13,279
再次记住我们不会使用这个输入云，它只是为了你

496
01:31:13,279 --> 01:31:16,399
了解我们如何在数据库中创建不同的字段

497
01:31:16,399 --> 01:31:20,796
是的，这只是你未来保护自己的东西

498
01:31:20,796 --> 01:31:25,360
针对您的数据库架构中的未来更改，因此通过这样做您允许

499
01:31:25,360 --> 01:31:29,679
自己玩这个领域，这样你就知道本地的每一个音符

500
01:31:29,679 --> 01:31:33,600
在本地数据库中创建默认不与云端同步好吗

501
01:31:33,600 --> 01:31:36,720
我想从 Visual Studio 代码中获得帮助来完成构造函数

502
01:31:36,720 --> 01:31:41,919
这个，我要去按照要求做所有这些领域，所以我

503
01:31:41,919 --> 01:31:46,399
会说需要，我要复制那个粘贴它那里粘贴它

504
01:31:46,399 --> 01:31:51,039
就在那里，然后我要在最后加上一个逗号并命令 s

505
01:31:51,039 --> 01:31:56,720
在 mac 或 windows 和 linux 中的 control 上保存并获取 dart 格式化程序

506
01:31:56,720 --> 01:32:00,639
为我格式化这个文件，这就是初始化程序

507
01:32:00,639 --> 01:32:04,320
我们也需要做和我们在这里为我们的数据库做的一样的事情

508
01:32:04,320 --> 01:32:09,195
用户，我们需要从一行实例化它，所以让我复制这段代码

509
01:32:09,195 --> 01:32:12,000
它就在那里，我要把它带进我们的

510
01:32:12,000 --> 01:32:16,000
数据库注释我将把它粘贴在那里，而不是我要说

511
01:32:16,000 --> 01:32:21,919
来自行初始化程序的 this 创建了一个数据库注释

512
01:32:21,919 --> 01:32:26,639
在我们的数据库注释中，我们有一个 ID，但我们没有电子邮件，所以在这里我们

513
01:32:26,639 --> 01:32:31,436
只是说用户 id 是地图然后我们需要一个新列

514
01:32:31,436 --> 01:32:36,475
被称为用户 ID 列好吧，所以让我看看我的笔记我是如何创建它的

515
01:32:36,475 --> 01:32:40,399
是的，我可以看到它被称为只是用户 ID 调用，所以继续创建一个新的

516
01:32:40,399 --> 01:32:43,919
在这里保持不变并称之为

517
01:32:43,919 --> 01:32:48,796
用户 id 列，如果您记得我们的架构中它被称为用户

518
01:32:48,796 --> 01:32:52,796
下划线 id 所以用户 id

519
01:32:52,796 --> 01:32:56,080
好的，这里我们说用户 ID 等于地图

520
01:32:56,080 --> 01:33:00,244
用户 id 列作为字符串，它在抱怨

521
01:33:00,244 --> 01:33:03,436
现在因为我们还有两个要初始化的字段，但我们还没有真正阅读

522
01:33:03,436 --> 01:33:07,600
它们来自地图的值，因此文本并与云同步，因此对于文本，我们只是

523
01:33:07,600 --> 01:33:11,755
说文本等于地图，让我们去创建一个新的

524
01:33:11,755 --> 01:33:16,960
辅音在这里我们说文本列，它等于文本，所以它只是

525
01:33:16,960 --> 01:33:20,876
您在此处看到的字段或列的名称

526
01:33:20,876 --> 01:33:24,320
所以让我们继续说这是文本，在这里我们说文本

527
01:33:24,320 --> 01:33:27,195
柱子

528
01:33:27,195 --> 01:33:32,796
我们说添加字符串，我相信这就是我们所说的

529
01:33:32,796 --> 01:33:36,399
我们将调用一个可以初始化的字符串哦，对不起，用户

530
01:33:36,399 --> 01:33:40,320
id 不能是应该添加的字符串，所以我们只说它是一个 int 和

531
01:33:40,320 --> 01:33:43,835
最后但并非最不重要的是与云同步，所以我们要说

532
01:33:43,835 --> 01:33:50,720
async with cloud 实际上是从我们的数据库中读取的整数，记住

533
01:33:50,720 --> 01:33:54,080
以整数形式与云同步，所以我们要说

534
01:33:54,080 --> 01:33:57,679
我们将首先定义一个列，因为它是同步的

535
01:33:57,679 --> 01:34:00,876
带云柱

536
01:34:00,876 --> 01:34:04,796
我们将把它称为与云异步和

537
01:34:04,796 --> 01:34:08,639
我的意思是我说我们要调用它但实际上我们已经调用它了

538
01:34:08,639 --> 01:34:13,115
我们称它与云同步，因此只需将其复制并粘贴到此处

539
01:34:13,115 --> 01:34:17,835
你看没问题，然后我们要说的是

540
01:34:17,835 --> 01:34:24,156
与云同步等于现在你看到我们没有这个呃

541
01:34:24,156 --> 01:34:27,195
数据我们没有将此字段作为数据库中的布尔值我们将其作为

542
01:34:27,195 --> 01:34:31,279
整数，所以我们必须将其读取为整数，所以我们要在地图中说

543
01:34:31,279 --> 01:34:37,919
有一个名为 async with cloud 列的列，它是一个整数

544
01:34:37,919 --> 01:34:42,244
如果等于 1 则返回 true

545
01:34:42,244 --> 01:34:47,516
否则 uh 等于一个 true 否则为 false 所以

546
01:34:47,516 --> 01:34:51,039
你看这里发生了什么我们将列读取为整数

547
01:34:51,039 --> 01:34:55,919
哦，如果它等于一，那么这个人就等于真，否则这个人

548
01:34:55,919 --> 01:35:00,796
等于 false 好了，既然我们已经完成了初始化

549
01:35:00,796 --> 01:35:05,755
从我们的行中我们的数据库注释

550
01:35:05,755 --> 01:35:10,960
需要继续，我们还需要创建 tostring

551
01:35:10,960 --> 01:35:18,399
对于我们的数据库注释好的所以让我们去覆盖到字符串

552
01:35:18,399 --> 01:35:21,600
像这样，我们只会说这是一个

553
01:35:21,600 --> 01:35:24,555
我们要说的简单说明

554
01:35:24,555 --> 01:35:29,919
等于 note 并且其 id 等于美元 id 是文本

555
01:35:29,919 --> 01:35:33,755
等于或只是它的用户 ID 等于美元

556
01:35:33,755 --> 01:35:37,679
用户 ID，这是我们拥有的字段

557
01:35:37,679 --> 01:35:41,835
然后我们不会打印它的整个场景而是整个文本

558
01:35:41,835 --> 01:35:46,475
我们要说的是与云同步的是

559
01:35:46,475 --> 01:35:52,555
其他的就这样跟云同步了

560
01:35:52,555 --> 01:35:57,679
好吧，是的，我的意思是，如果您愿意，您也可以添加文本

561
01:35:57,679 --> 01:36:01,195
这取决于你，但问题是注释的文本

562
01:36:01,195 --> 01:36:05,039
可能会很长，以至于它实际上会妨碍您获取以下信息

563
01:36:05,039 --> 01:36:10,080
你的类实例，例如它的 id 用户 id 和一个单一的类，所以如果你

564
01:36:10,080 --> 01:36:14,796
希望文本在那里只需将其添加到末尾，这样它基本上不会中断

565
01:36:14,796 --> 01:36:19,755
您实际上可能有兴趣阅读的其他领域

566
01:36:19,755 --> 01:36:23,039
所以我们做了实现

567
01:36:23,039 --> 01:36:27,279
从 uh tostring 现在，但我们还没有完成相等，所以让我们走吧

568
01:36:27,279 --> 01:36:31,516
并覆盖相等以及哈希节点哈希码抱歉

569
01:36:31,516 --> 01:36:36,399
我将从我们的数据库用户那里复制该代码并将其带入

570
01:36:36,399 --> 01:36:40,876
数据库节点，然后我将其粘贴到此处，以便您将其视为

571
01:36:40,876 --> 01:36:43,919
好吧，我们处于平等地位，我们正在说

572
01:36:43,919 --> 01:36:49,115
只要我们的 id 等于另一个 id，我们就可以与数据库注释进行比较

573
01:36:49,115 --> 01:36:52,244
那么我们就可以使用哈希码然后我们将

574
01:36:52,244 --> 01:36:58,244
就像我们为其他类所做的那样，得到我们的 id 的哈希码

575
01:36:58,244 --> 01:37:03,600
哇，现在我们已经创建了数据库注释，这需要做很多工作

576
01:37:03,600 --> 01:37:08,639
以及标题表明嗯所以我们现在需要做的就是

577
01:37:08,639 --> 01:37:14,720
在我们继续之前确保我们所有的常量都到位现在记住

578
01:37:14,720 --> 01:37:18,475
在完成这些课程之后，我们将继续创建

579
01:37:18,475 --> 01:37:24,244
我们的 um 与我们的数据库对话的实际便笺服务，所以

580
01:37:24,244 --> 01:37:28,876
在我们这样做之前，让我们创建所有必要的常量，例如

581
01:37:28,876 --> 01:37:33,516
我们的数据库将被保存到的文件，所以我们就叫它吧

582
01:37:33,516 --> 01:37:38,720
bb 名称，我们只是将其命名为 notes.db 好吧，记住这就像

583
01:37:38,720 --> 01:37:43,279
文件名好，现在我们要创建，你可以在我们的 um 中看到

584
01:37:43,279 --> 01:37:48,244
文件在这里作为sqlite的db浏览器，我们称这个文件为testing.db，在我们的

585
01:37:48,244 --> 01:37:52,000
在这种情况下，我们只是将其称为nodesdb，并将其存储在文档中

586
01:37:52,000 --> 01:37:57,436
该应用程序内的文件夹可以，然后我们有两个表格和注释

587
01:37:57,436 --> 01:38:01,835
表和用户表，所以让我们继续创建它们的注释表是

588
01:38:01,835 --> 01:38:04,244
嗯投票

589
01:38:04,244 --> 01:38:08,876
和 const user 表表示用户，这些就像

590
01:38:08,876 --> 01:38:13,600
我们在这里定义的表名节点和用户没问题

591
01:38:13,600 --> 01:38:17,835
所以这些就是那些，我们还需要什么，嗯，我认为我认为这很漂亮

592
01:38:17,835 --> 01:38:21,436
老实说，我认为这些都是常数

593
01:38:21,436 --> 01:38:26,080
需要我们才能创建我们的笔记服务

594
01:38:26,080 --> 01:38:31,039
好吧，让我们现在开始，从我们的笔记服务器开始，所以我要清除

595
01:38:31,039 --> 01:38:35,360
这转到该文件的顶部，然后我将在此处留出一些空白空间

596
01:38:35,360 --> 01:38:40,240
并实际创建我们的笔记服务，让我们继续创建一个电路

597
01:38:40,240 --> 01:38:44,399
在这里上课并称之为节点服务非常令人兴奋这是开始

598
01:38:44,399 --> 01:38:48,551
我们创建了一个与我们的数据库一起使用的交叉服务，我们很快就会

599
01:38:48,551 --> 01:38:52,240
将创建实际上没问题，因为缓存表明我们需要一个

600
01:38:52,240 --> 01:38:57,600
function 一个打开数据库的异步函数，您看到打开数据库

601
01:38:57,600 --> 01:39:02,399
不是一个功能，你可以说现在它会发生

602
01:39:02,399 --> 01:39:07,191
异步，因为我们可能需要例如获取当前的 um

603
01:39:07,191 --> 01:39:12,080
当前 uh 文件夹做文档文件夹，然后追加或

604
01:39:12,080 --> 01:39:16,320
使用我们在此处定义的数据库名称加入该文档文件夹

605
01:39:16,320 --> 01:39:18,551
作为一个控制台，所以我们要处理很多异步的东西

606
01:39:18,551 --> 01:39:22,080
在那里发生的不是很多，但至少有一些

607
01:39:22,080 --> 01:39:25,512
这就是这个开放函数将是异步的原因

608
01:39:25,512 --> 01:39:28,240
好的，所以我在任何情况下加上标题，让我们继续吧

609
01:39:28,240 --> 01:39:32,399
创造一个未来的虚空并称之为

610
01:39:32,399 --> 01:39:37,119
刚刚打开，我们称之为异步

611
01:39:37,119 --> 01:39:41,440
现在这个开放的功能将保持延迟

612
01:39:41,440 --> 01:39:45,191
我的意思是在它打开数据库之后实际上会

613
01:39:45,191 --> 01:39:49,279
将它存储在我们的节点服务中的某个地方，所以它会说嘿我已经打开了

614
01:39:49,279 --> 01:39:52,551
这里的数据库是对象，以便其他

615
01:39:52,551 --> 01:39:55,360
未来的功能，例如功能将让我们

616
01:39:55,360 --> 01:39:58,960
从数据库中读取用户或您读取

617
01:39:58,960 --> 01:40:02,800
数据库中的注释那些函数然后他们会说 ah oh here's

618
01:40:02,800 --> 01:40:07,039
数据库实例我知道如何从中获取值好吧

619
01:40:07,039 --> 01:40:11,759
我们要做的是说我们有一个数据库

620
01:40:11,759 --> 01:40:16,639
如您所见，它是由我们的 sqflite 带来的

621
01:40:16,639 --> 01:40:19,600
库，我们只是将其称为 db all

622
01:40:19,600 --> 01:40:23,360
对，所以一开始是空的，我们要

623
01:40:23,360 --> 01:40:26,639
分配给它

624
01:40:26,639 --> 01:40:30,479
好的 嗯

625
01:40:30,479 --> 01:40:36,800
那么我们现在应该怎么做呢，嗯，让我们继续，然后开始做一个

626
01:40:36,800 --> 01:40:41,191
测试看看这个数据库是否已经打开你看看我们是否有一个实例

627
01:40:41,191 --> 01:40:44,639
这个数据库然后我们可以假设这个数据库文件有

628
01:40:44,639 --> 01:40:48,240
已经打开了，我们不必再打开了，所以我们就说如果

629
01:40:48,240 --> 01:40:51,919
数据库不为空

630
01:40:51,919 --> 01:40:54,240
然后扔

631
01:40:54,240 --> 01:40:59,831
呃，一个新的例外，我们就称它为一个已经打开的数据库

632
01:40:59,831 --> 01:41:04,240
异常所以让我们去定义一个异常

633
01:41:04,240 --> 01:41:07,039
呃这里

634
01:41:07,039 --> 01:41:12,639
让我看看我是否可以从我的笔记中复制并粘贴它

635
01:41:12,639 --> 01:41:15,512
但是你看到这只是一个例外，它是一个数据库已经打开的例外

636
01:41:15,512 --> 01:41:20,080
好的，所以在这里我们只是说数据库已经打开异常

637
01:41:20,080 --> 01:41:23,440
如果你调用 open 函数就很简单

638
01:41:23,440 --> 01:41:27,119
在数据库已经打开的情况下多次您将获得一个

639
01:41:27,119 --> 01:41:30,160
例外好吧，所以这种情况是有道理的

640
01:41:30,160 --> 01:41:34,160
所以让我们继续，现在获取文档

641
01:41:34,160 --> 01:41:37,360
目录路径，我们必须在这里尝试

642
01:41:37,360 --> 01:41:42,399
因为这实际上可以抛出异常所以让我们说find final

643
01:41:42,399 --> 01:41:46,000
文档路径等于

644
01:41:46,000 --> 01:41:50,960
如果你需要，你需要说获取文件获取应用程序文件目录

645
01:41:50,960 --> 01:41:54,960
看看这个方法的签名它说我返回一个未来

646
01:41:54,960 --> 01:41:59,191
目录，所以让我们继续这样做，所以我们需要等待它，这就是

647
01:41:59,191 --> 01:42:02,320
我们的函数是异步的，这就是我们等待的原因，因为这个

648
01:42:02,320 --> 01:42:06,080
如果您查看，现在异步返回路径

649
01:42:06,080 --> 01:42:10,639
这个文档你可以看到它实际上可以抛出一个异常

650
01:42:10,639 --> 01:42:14,240
如果系统无法访问，则称为缺少平台目录异常

651
01:42:14,240 --> 01:42:18,160
如果出于某种原因，请提供目录

652
01:42:18,160 --> 01:42:21,440
系统无法提供文档目录

653
01:42:21,440 --> 01:42:25,191
嗯，我们会抛出这个异常，这正是我们为什么

654
01:42:25,191 --> 01:42:29,600
将我们的代码放在这里的 try 语句中，所以让我们说如果该异常是

655
01:42:29,600 --> 01:42:34,639
像这样抛出然后我们将抛出我们自己的异常，所以让我们定义

656
01:42:34,639 --> 01:42:40,720
我们称之为无法获取文档目录的异常

657
01:42:40,720 --> 01:42:44,800
这只是一个无法获取文档目录的类

658
01:42:44,800 --> 01:42:49,039
例外没什么特别的

659
01:42:49,039 --> 01:42:53,831
然后我们在这里说投掷

660
01:42:53,831 --> 01:42:56,872
呃名字缺少平台哦我看到你了

661
01:42:56,872 --> 01:43:00,872
看到它现在在抱怨，我可以看到你看不到我的代码

662
01:43:00,872 --> 01:43:04,479
为它在抱怨并说我找不到这个丢失而道歉

663
01:43:04,479 --> 01:43:10,000
平台目录异常，那是因为在这个um中指定了这个

664
01:43:10,000 --> 01:43:14,160
路径提供者，但对于我们的路径提供者，我们只说 show get

665
01:43:14,160 --> 01:43:18,000
获取应用程序文档目录，以便对我们隐藏所有其他符号

666
01:43:18,000 --> 01:43:21,679
我们可以删除它并导入整个路径提供程序，然后

667
01:43:21,679 --> 01:43:26,399
错误消失了

668
01:43:26,399 --> 01:43:31,440
好的，现在让我们这样做现在让我们说

669
01:43:31,440 --> 01:43:35,600
抱歉，让我们了解一下我们的实际路径

670
01:43:35,600 --> 01:43:41,119
数据库，这样做你会说，我们叫它什么 db path is equal

671
01:43:41,119 --> 01:43:45,831
加入请记住，我们在这里加入了我们从路径导入的这个函数

672
01:43:45,831 --> 01:43:51,759
我们说加入文档路径路径和我们的数据库名称

673
01:43:51,759 --> 01:43:55,512
记住数据库名称是一个常量作为字符串，我们在这里定义它，我们只是

674
01:43:55,512 --> 01:43:59,440
调用将要加入的 notes db

675
01:43:59,440 --> 01:44:04,240
我们文档文件夹的实际路径

676
01:44:04,240 --> 01:44:07,512
我们要做的是我们要说我们现在想要

677
01:44:07,512 --> 01:44:11,919
使用名为 open database 的函数打开数据库，该函数来自

678
01:44:11,919 --> 01:44:16,240
skflight 并且路径是 dbpath 并记住这一点

679
01:44:16,240 --> 01:44:22,479
我相信开放数据库是您看到的我们数据库的未来，所以我们等待它

680
01:44:22,479 --> 01:44:25,039
好的和

681
01:44:25,039 --> 01:44:29,831
然后我们将它分配给我们的本地数据库实例

682
01:44:29,831 --> 01:44:34,320
所以这基本上是在打开数据库所以我们现在已经打开了

683
01:44:34,320 --> 01:44:37,279
但记住

684
01:44:37,279 --> 01:44:44,320
我们现在所做的只是在这个用于 sqlite 的数据库浏览器中

685
01:44:44,320 --> 01:44:47,679
这个程序在这里管理它的东西

686
01:44:47,679 --> 01:44:52,160
自己的数据库文件这个数据库文件不会存在于你的颤振中

687
01:44:52,160 --> 01:44:56,160
我们刚刚玩过的应用程序 我刚刚向您展示了如何创建一个 sqlite

688
01:44:56,160 --> 01:45:01,039
数据库如何创建不同的表什么字段是什么主键是什么

689
01:45:01,039 --> 01:45:05,191
你需要有点像忘记这个应用程序以及它在哪里

690
01:45:05,191 --> 01:45:09,039
存储您现在需要的数据

691
01:45:09,039 --> 01:45:12,399
颤振应用程序将能够创建这些表你的颤振怎么样

692
01:45:12,399 --> 01:45:16,551
应用程序将从表中重新读取数据或从表中删除数据

693
01:45:16,551 --> 01:45:19,679
这张桌子，所以如果你考虑一下，如果你有

694
01:45:19,679 --> 01:45:24,800
完全忘记了sqlite的db浏览器，那么你可以

695
01:45:24,800 --> 01:45:28,479
只是说此时你看到打开的数据库也可以创建

696
01:45:28,479 --> 01:45:33,279
如果数据库不存在，我们可以查看它的文档

697
01:45:33,279 --> 01:45:37,279
在这里，哦，天哪，在给定的路径上打开数据库

698
01:45:37,279 --> 01:45:41,360
系统 uh on 是第一个让我们看看 encrypt 是

699
01:45:41,360 --> 01:45:45,191
如果在调用 opendatabase 之前数据库不存在，则调用它

700
01:45:45,191 --> 01:45:48,872
可以为您创建数据库，这就是它要做的，但那些表是

701
01:45:48,872 --> 01:45:52,639
不会存在，我们必须有一种方法来创建这些表，如果他们

702
01:45:52,639 --> 01:45:57,279
在我们打开数据库时就不存在了，这就是我们要在这里做的

703
01:45:57,279 --> 01:46:04,960
所以让我们继续并实际获取用于创建用户表的代码，所以我

704
01:46:04,960 --> 01:46:11,191
只是说 const create user table 等于，现在是

705
01:46:11,191 --> 01:46:14,240
我将实际使用我们以前没有使用过的语法，那就是

706
01:46:14,240 --> 01:46:18,320
三引号没问题，然后三引号上

707
01:46:18,320 --> 01:46:23,119
下一行，然后是分号，现在它的作用是它允许您放置

708
01:46:23,119 --> 01:46:27,119
该字符串中的几乎所有内容，而无需转义该字符串

709
01:46:27,119 --> 01:46:31,831
因为三引号非常独特，所以如果您粘贴任何其他程序

710
01:46:31,831 --> 01:46:34,960
这里的编程语言代码很可能是编程语言

711
01:46:34,960 --> 01:46:40,479
代码不会包含三个三个引号，所以目的

712
01:46:40,479 --> 01:46:45,279
这就是现在您可以在您的 sqlite uh db 浏览器中继续使用 sqlite 和

713
01:46:45,279 --> 01:46:51,279
抓住那些用户，嗯，如果我去这里数据库结构用户修改表和

714
01:46:51,279 --> 01:46:55,279
您现在可以从字面上获取由 db 浏览器创建的代码

715
01:46:55,279 --> 01:47:02,872
sqlite 并将其粘贴在这里你看到所以我们现在你有一个漂亮的

716
01:47:02,872 --> 01:47:06,720
此处的数据库创建代码对不起表创建代码说创建

717
01:47:06,720 --> 01:47:11,919
table user blah blah id integer not null 但是我们需要注意

718
01:47:11,919 --> 01:47:17,831
这里有一些东西，我们只是说如果不存在，我相信

719
01:47:17,831 --> 01:47:22,080
我们也必须把它放在用户面前，所以这是我们唯一的事情

720
01:47:22,080 --> 01:47:26,240
在这里添加我们基本上是说如果没有创建一个表调用用户

721
01:47:26,240 --> 01:47:29,440
存在是因为您看到我们不想出错

722
01:47:29,440 --> 01:47:32,800
因为如果您创建一个已经存在于数据库中的表，那么

723
01:47:32,800 --> 01:47:35,512
skflight 会抛出一个错误，说这个表已经存在

724
01:47:35,512 --> 01:47:42,160
好的，这就是为什么如果不存在我们需要，然后我们需要做的是告诉

725
01:47:42,160 --> 01:47:46,240
我们的数据库 我们在此处创建的用于执行该命令的数据库

726
01:47:46,240 --> 01:47:49,440
所以我们只会说执行，你看它说给我一个续集

727
01:47:49,440 --> 01:47:52,720
执行，我会给你一个未来的空虚，我们说好吧执行

728
01:47:52,720 --> 01:47:59,679
创建用户表，我们等待它

729
01:47:59,679 --> 01:48:04,960
一些评论在这里我们只是说创建用户表

730
01:48:04,960 --> 01:48:10,872
然后在我们执行完创建用户后在这里为嗯

731
01:48:10,872 --> 01:48:17,191
表我们还必须照顾呃创建我们的笔记表

732
01:48:17,191 --> 01:48:20,639
所以我会做和我们在这里做的一样的事情，然后说创建

733
01:48:20,639 --> 01:48:23,440
笔记表

734
01:48:23,440 --> 01:48:28,479
等于单引号 三单引号分号 让我们去 db

735
01:48:28,479 --> 01:48:34,240
sqlite 的浏览器并在此处获取此节点并说修改表并获取

736
01:48:34,240 --> 01:48:38,080
为您生成的代码并将其粘贴到此处进行一些格式化，因此

737
01:48:38,080 --> 01:48:42,399
它变得更容易阅读和查看，我们会做

738
01:48:42,399 --> 01:48:47,600
和我们在上面做的一样，我们说如果不存在就好了

739
01:48:47,600 --> 01:48:50,479
所以我想我想对你说实话

740
01:48:50,479 --> 01:48:53,600
我们很高兴去那里我认为我们不需要在那里做任何特别的事情

741
01:48:53,600 --> 01:48:57,679
还必须执行该命令，所以我要从那里获取代码

742
01:48:57,679 --> 01:49:02,399
把它贴在这里，就像那样，我要说

743
01:49:02,399 --> 01:49:07,679
创建便笺表，以便将便笺表创建为

744
01:49:07,679 --> 01:49:11,600
干得好，这是一个很大的

745
01:49:11,600 --> 01:49:14,479
功能我的意思是我们所拥有的标准

746
01:49:14,479 --> 01:49:17,512
到目前为止，这是一个相当大的功能，可以，但通常不是

747
01:49:17,512 --> 01:49:21,191
考虑到这么大的功能，我现在记得你实际上有常量

748
01:49:21,191 --> 01:49:27,831
在这里你能不能我的意思是如果是我决定我会带这个

749
01:49:27,831 --> 01:49:32,639
不在这个函数内的其他地方的常量，我们可以从字面上继续我

750
01:49:32,639 --> 01:49:36,080
意思是我没有为此计划，但让我们继续从

751
01:49:36,080 --> 01:49:39,191
在这里，把它带到这个文件的末尾好吧，我们有所有其他的

752
01:49:39,191 --> 01:49:42,720
像这样的常量，让我们去抓取另一个常量

753
01:49:42,720 --> 01:49:44,639
从这里嘘

754
01:49:44,639 --> 01:49:49,831
把它也记下来，所以我们把它放在我们文件的末尾

755
01:49:49,831 --> 01:49:52,080
好吧，就像我说的那样我没有计划，但是

756
01:49:52,080 --> 01:49:55,831
我只是认为这是有道理的，因为现在我们的功能更干净了

757
01:49:55,831 --> 01:49:58,551
看这里我们有一个创建用户表的评论让我们创建一个

758
01:49:58,551 --> 01:50:03,440
在这里我们也说创建注释表

759
01:50:03,440 --> 01:50:08,800
并删除那些空白空间并完美保存您的文件

760
01:50:08,800 --> 01:50:14,551
现在我们有了 open 函数，让我们继续看看我们如何

761
01:50:14,551 --> 01:50:19,600
可以关闭我们的数据库吗让我们看看

762
01:50:19,600 --> 01:50:24,000
我的笔记在这里好吧让我们看看我们的

763
01:50:24,000 --> 01:50:28,160
关闭代码所以我要在这里折叠 open 函数所以我们看不到它

764
01:50:28,160 --> 01:50:32,320
让我们继续进行创作，正如您在我们必须要做的标题中看到的那样

765
01:50:32,320 --> 01:50:39,360
说future void close um好的，它是异步的，所以

766
01:50:39,360 --> 01:50:43,759
那么我们需要做的是我们不应该允许任何人关闭数据库

767
01:50:43,759 --> 01:50:47,919
如果数据库没有打开，那么让我们继续为它定义一个异常

768
01:50:47,919 --> 01:50:52,720
我们将调用数据库未打开好吧，所以我要复制它

769
01:50:52,720 --> 01:50:56,479
例外，所以我不必手动手动输入，因为此时

770
01:50:56,479 --> 01:51:00,399
你知道如何创建异常，所以对你来说没什么特别的

771
01:51:00,399 --> 01:51:02,960
学习数据库未打开，这是一个新的

772
01:51:02,960 --> 01:51:06,160
例外好吧，所以我们要做的是我们要去

773
01:51:06,160 --> 01:51:10,000
说我们有我们的数据库最终数据库是相等的

774
01:51:10,000 --> 01:51:15,831
到我们当地的数据库，我们说如果数据库为空

775
01:51:15,831 --> 01:51:22,960
然后我们抛出数据库未打开 oops 数据库

776
01:51:22,960 --> 01:51:28,720
没有打开，否则我们会要求 skflight 关闭

777
01:51:28,720 --> 01:51:33,119
该数据库对我们来说以及做到这一点的方法就是说 db.close 并且您可以

778
01:51:33,119 --> 01:51:37,119
看到这是一个虚无的未来，所以这就是我们等待它的原因

779
01:51:37,119 --> 01:51:40,639
然后到那时我们还必须重置这个本地数据库

780
01:51:40,639 --> 01:51:45,512
称为下划线数据 underscore db 所以我们说 db 等于 no

781
01:51:45,512 --> 01:51:52,479
就这么简单 peasy close 实际上很快

782
01:51:52,479 --> 01:51:55,039
好的

783
01:51:55,039 --> 01:51:58,960
现在我们需要你看到我们现在因为我们必须打开和关闭现在我们是

784
01:51:58,960 --> 01:52:02,160
将开始处理数据库中的数据，但是

785
01:52:02,160 --> 01:52:06,240
为了让你变得像你的嗯

786
01:52:06,240 --> 01:52:11,919
数据库，以便它可以例如实际抓取

787
01:52:11,919 --> 01:52:15,279
就像每个试图从数据库中读取内容的函数一样

788
01:52:15,279 --> 01:52:18,399
有一些代码以确保数据库是打开的，否则它

789
01:52:18,399 --> 01:52:21,919
必须抛出一个错误，所以我们将拥有 5 6 个这样的函数

790
01:52:21,919 --> 01:52:25,360
每个人都会检查数据库然后做同样的事情是

791
01:52:25,360 --> 01:52:28,960
数据库打开是的，如果它没有打开抛出这个错误，我们可以把那个

792
01:52:28,960 --> 01:52:33,360
我们将调用 getdatabase 或函数的特定代码

793
01:52:33,360 --> 01:52:38,240
throw 好吧，让我们继续在这里，只是说这个函数返回一个

794
01:52:38,240 --> 01:52:43,119
数据库它数据库或抛出

795
01:52:43,119 --> 01:52:45,600
并在它前面加上下划线表示

796
01:52:45,600 --> 01:52:50,479
这是一个私有函数，然后我们会说 final db is db

797
01:52:50,479 --> 01:52:54,399
如果 db 为空

798
01:52:54,399 --> 01:52:59,600
我们说throw um database is not open

799
01:52:59,600 --> 01:53:04,080
否则我们会返回数据库，所以这是一个

800
01:53:04,080 --> 01:53:08,720
我们在这个类中读写内部函数的私有函数

801
01:53:08,720 --> 01:53:12,160
将使用以获取当前数据库，以便他们避免

802
01:53:12,160 --> 01:53:16,399
到处都做同样的 if 语句没问题

803
01:53:16,399 --> 01:53:21,360
好的，现在我们将从实际代码开始，所以

804
01:53:21,360 --> 01:53:24,240
在这种情况下，从数据库读取和写入，我们将从一个

805
01:53:24,240 --> 01:53:29,440
称为删除用户的功能，允许我们提供您可以看到的电子邮件

806
01:53:29,440 --> 01:53:32,320
地址并使用该电子邮件地址，然后我们

807
01:53:32,320 --> 01:53:36,160
将从我们的数据库中删除该用户，以便您学习如何操作

808
01:53:36,160 --> 01:53:40,960
来自我们或我们数据库中的数据

809
01:53:40,960 --> 01:53:44,399
所以让我们继续做那个函数签名，因为它在这里表明我是

810
01:53:44,399 --> 01:53:47,512
只是说未来无效删除用户

811
01:53:47,512 --> 01:53:54,479
并且需要 uh string email 并使这个函数异步好

812
01:53:54,479 --> 01:53:57,440
那么我们要做的就是得到我们的

813
01:53:57,440 --> 01:54:01,440
数据库具有这个绝对漂亮的获取数据库或抛出函数，我们

814
01:54:01,440 --> 01:54:06,160
在这里创建，所以我只想说最终的 vb 是获取数据库或抛出

815
01:54:06,160 --> 01:54:10,160
这反过来又会抛出一个名为 database it's not open 的异常

816
01:54:10,160 --> 01:54:12,720
如果数据库没有打开所以我们不必

817
01:54:12,720 --> 01:54:17,679
手动这样做没关系，所以为了删除一些东西

818
01:54:17,679 --> 01:54:22,639
从 sql flight uh 或者在这种情况下由 sqflight 管理的 sqlite 我们

819
01:54:22,639 --> 01:54:28,872
可以说 db dot db dot delete ，如您所见

820
01:54:28,872 --> 01:54:33,039
返回被删除的行数的未来，然后它说好的

821
01:54:33,039 --> 01:54:37,759
哪个表，然后是 where 子句和要传递给您的单词的对象列表

822
01:54:37,759 --> 01:54:42,831
子句，所以我们要说从用户表中删除

823
01:54:42,831 --> 01:54:46,800
呃这个词从句将是

824
01:54:46,800 --> 01:54:52,160
电子邮件等于某物，在这种情况下，艺术在哪里

825
01:54:52,160 --> 01:54:56,960
将电子邮件转为小写好的，所以我要放这个

826
01:54:56,960 --> 01:55:00,720
那里的分号和这里的电话，然后我们将等待它，我们

827
01:55:00,720 --> 01:55:05,600
要说最终和删除帐户是一个重量

828
01:55:05,600 --> 01:55:09,039
所以在这种情况下，我的意思是如你所见，我们基本上在做的是

829
01:55:09,039 --> 01:55:12,720
只是我们正在格式化我们要说我们要说删除

830
01:55:12,720 --> 01:55:17,119
用户表中的某些内容，只要该内容的电子邮件等于

831
01:55:17,119 --> 01:55:21,679
某事，那某事又是那封电子邮件，所以您基本上是在说

832
01:55:21,679 --> 01:55:25,191
在用户中删除尽可能多的对象

833
01:55:25,191 --> 01:55:29,512
表，只要他们的电子邮件与此相同，并记住我们使电子邮件独一无二

834
01:55:29,512 --> 01:55:34,399
因此，如果我们正确地完成了作业，那么删除计数应该是

835
01:55:34,399 --> 01:55:40,000
为零表示没有个人帐户或没有使用此电子邮件的用户

836
01:55:40,000 --> 01:55:45,600
存在于表中，或者它应该是一个意思，是的，我可以删除呃

837
01:55:45,600 --> 01:55:49,039
没有问题所以

838
01:55:49,039 --> 01:55:53,360
我们实际上会断言我们会说如果删除计数

839
01:55:53,360 --> 01:55:55,600
不是一个

840
01:55:55,600 --> 01:55:59,279
好吧，那么我们将抛出一个错误，无法删除用户，所以我

841
01:55:59,279 --> 01:56:04,000
我会抓住那个例外我会把它放在这里

842
01:56:04,000 --> 01:56:07,831
所以我们说如果我们不能删除那个用户，我们只会说 throw 可以

843
01:56:07,831 --> 01:56:12,960
不删除用户好吗

844
01:56:12,960 --> 01:56:18,872
所以我们不能删除那个用户

845
01:56:18,872 --> 01:56:22,399
嗯，好吧，让我们继续吧

846
01:56:22,399 --> 01:56:26,872
现在我们已经完成了删除用户并且记住你可能会问好的

847
01:56:26,872 --> 01:56:30,080
为什么我们要抛出一个用户，也许那个用户不存在，它应该只是

848
01:56:30,080 --> 01:56:33,831
工作正常，当然我的意思是如果你有它会正常工作

849
01:56:33,831 --> 01:56:37,191
调用此函数时的 try 和 catch 语句

850
01:56:37,191 --> 01:56:40,639
我们所说的是节点服务的接口将抛出一个

851
01:56:40,639 --> 01:56:45,119
如果您使用不存在的电子邮件呼叫主要用户，则会因异常而出错

852
01:56:45,119 --> 01:56:49,512
这对于服务来说完全没问题，但是你在哪里消费

853
01:56:49,512 --> 01:56:53,919
服务然后你可以管理并说哦这个删除功能会抛出

854
01:56:53,919 --> 01:56:57,039
一个例外，例如查看文档查看

855
01:56:57,039 --> 01:57:01,600
代码然后我将在调用站点处理它

856
01:57:01,600 --> 01:57:06,080
这被称为好的，所以这完全没问题

857
01:57:06,080 --> 01:57:10,080
做一个服务然后我们接下来要做的

858
01:57:10,080 --> 01:57:13,512
重点是创建一个用户，你可以看到

859
01:57:13,512 --> 01:57:16,960
这将是数据库用户的未来，所以这很漂亮

860
01:57:16,960 --> 01:57:20,160
实际上创建一个给定电子邮件地址的用户，然后它会返回

861
01:57:20,160 --> 01:57:23,919
那个数据库用户给我们，所以让我们继续做吧，让我们说

862
01:57:23,919 --> 01:57:27,191
未来的数据库用户

863
01:57:27,191 --> 01:57:33,919
我们会说创建用户和电子邮件的必需字符串字段

864
01:57:33,919 --> 01:57:37,119
我们要让它异步

865
01:57:37,119 --> 01:57:40,000
所以在这里我们要做的就是获取我们正在使用的数据库

866
01:57:40,000 --> 01:57:44,960
要说最终的vb等于获取db数据库或抛出

867
01:57:44,960 --> 01:57:49,191
然后我们会说 um db.query

868
01:57:49,191 --> 01:57:53,600
嗯，因为我们实际上要向数据库发出查询

869
01:57:53,600 --> 01:57:56,160
好的，你可以看到这是一个帮助

870
01:57:56,160 --> 01:57:59,759
查询表和返回项发现所有可选子句都未过滤或

871
01:57:59,759 --> 01:58:03,512
格式化为 sql 查询没问题

872
01:58:03,512 --> 01:58:08,800
所以嗯，让我们继续，在这里我们首先要做的是

873
01:58:08,800 --> 01:58:13,119
我们要加密用户的第一件事现在我们要实际检查一个

874
01:58:13,119 --> 01:58:17,600
具有给定电子邮件的用户已经存在，这就是我们这样做的原因

875
01:58:17,600 --> 01:58:20,720
查询，我们不喜欢在数据库中插入一些东西来开始

876
01:58:20,720 --> 01:58:26,551
我们要求数据在用户表中说嘿

877
01:58:26,551 --> 01:58:31,679
我们正在寻找并且我们正在为一个人或一个用户获取数据库

878
01:58:31,679 --> 01:58:36,639
谁的电子邮件是这个，这个东西实际上会返回，让我们

879
01:58:36,639 --> 01:58:41,759
看看它，它将返回一个可用的行列表

880
01:58:41,759 --> 01:58:47,191
数据库没问题，如果没有，该列表将为空

881
01:58:47,191 --> 01:58:51,919
没有实体与我们的查询相匹配，所以我们称之为最终结果是

882
01:58:51,919 --> 01:58:57,440
我们正在查询用户表，我们会说嗯

883
01:58:57,440 --> 01:59:00,720
我们只寻找一件商品

884
01:59:00,720 --> 01:59:05,831
我们有一个词等于我们正在寻找电子邮件以及在哪里

885
01:59:05,831 --> 01:59:09,119
艺术将是

886
01:59:09,119 --> 01:59:15,600
电子邮件末尾的小写分号并像这样带来

887
01:59:15,600 --> 01:59:21,039
等于 bb，我们等着没关系

888
01:59:21,039 --> 01:59:25,512
所以我们首先对数据库进行查询，然后

889
01:59:25,512 --> 01:59:30,399
检查是否存在使用相同电子邮件的用户，我们基本上是在避免

890
01:59:30,399 --> 01:59:34,551
稍后收到该电子邮件唯一性的错误

891
01:59:34,551 --> 01:59:38,080
在 sql 层

892
01:59:38,080 --> 01:59:43,512
所以在这种情况下，如果我将鼠标移到它上面，你可以看到结果，它说

893
01:59:43,512 --> 01:59:48,479
它是行列表，如果此列表不为空

894
01:59:48,479 --> 01:59:52,960
它的字面意思是已经存在具有该公司但没有电子邮件地址的用户

895
01:59:52,960 --> 01:59:56,240
在数据库中所以让我们说如果

896
01:59:56,240 --> 02:00:00,720
results 不为空，然后我们会说 throw

897
02:00:00,720 --> 02:00:04,872
用户已经存在呃异常，我们没有那个

898
02:00:04,872 --> 02:00:10,160
例外，所以让我们继续，至少为我找到那个例外，

899
02:00:10,160 --> 02:00:14,479
我可以在这里粘贴它，所以已经定义了这个异常使用

900
02:00:14,479 --> 02:00:18,000
存在，让我们继续扔那个

901
02:00:18,000 --> 02:00:22,320
异常用户已经存在好吧

902
02:00:22,320 --> 02:00:25,512
这就是我们的 if 语句，所以那时我们已经

903
02:00:25,512 --> 02:00:30,639
基本上确定数据库中不存在那个用户就好了

904
02:00:30,639 --> 02:00:35,600
所以我们需要做的是现在去插入那个用户

905
02:00:35,600 --> 02:00:38,399
我们已经检查了他或她在数据库中不存在所以我们必须去

906
02:00:38,399 --> 02:00:42,639
并插入该用户，所以我们这样做的方式是去告诉我们的

907
02:00:42,639 --> 02:00:47,831
数据库我们说 db insert ，你可以看到它说在哪个表中，然后给出

908
02:00:47,831 --> 02:00:52,639
我是键和值的映射，它是列名

909
02:00:52,639 --> 02:00:56,800
并且该列的值没问题，所以假设我们插入

910
02:00:56,800 --> 02:01:00,160
用户表，这是我们定义的常量

911
02:01:00,160 --> 02:01:03,440
在记住之前，然后地图将是

912
02:01:03,440 --> 02:01:09,679
对于呃，让我们回到我们的 sql 数据库浏览器，请注意对不起用户

913
02:01:09,679 --> 02:01:13,360
哎呀用户

914
02:01:13,360 --> 02:01:18,160
我们有 id 这是主键不为空和自动递增，所以我们不必

915
02:01:18,160 --> 02:01:22,720
插入 id 但我们需要插入电子邮件所以让我们继续说我们有

916
02:01:22,720 --> 02:01:26,960
电子邮件呼叫等于 b 它将等于

917
02:01:26,960 --> 02:01:32,800
电子邮件转为小写就可以了，如果可以的话，请插入

918
02:01:32,800 --> 02:01:37,119
看看这里它会返回一个 pin 的功能，如果你阅读了文档

919
02:01:37,119 --> 02:01:42,479
呃，让我们看看它是否在这里给我们提供了一些文档

920
02:01:42,479 --> 02:01:46,320
某些特定的冲突算法算法算法可以返回零

921
02:01:46,320 --> 02:01:50,399
如果没有插入，那么这基本上会给我们

922
02:01:50,399 --> 02:01:53,440
呃，在这种情况下它要做的是

923
02:01:53,440 --> 02:01:57,039
实际上会给我们一个用户ID我希望有一些好的文档

924
02:01:57,039 --> 02:02:01,360
关于它哦，在这里你可以看到它说插入

925
02:02:01,360 --> 02:02:06,080
返回 id 所以这非常非常好这是

926
02:02:06,080 --> 02:02:10,551
实际上真的很酷，因为记得我们说过我们返回一个数据库用户和一个

927
02:02:10,551 --> 02:02:13,360
数据库用户实际上有一个 id 所以

928
02:02:13,360 --> 02:02:18,240
如果这里的这个函数没有返回 id 那么我们将如何获得 id

929
02:02:18,240 --> 02:02:21,831
我们必须插入然后读取同一个用户才能获得 id 但我们

930
02:02:21,831 --> 02:02:25,440
不必这样做所以在这里然后我们说最终

931
02:02:25,440 --> 02:02:30,551
我们说用户 id 等于等待这个函数功能

932
02:02:30,551 --> 02:02:37,191
然后我们只返回一个数据库用户，这样你就可以看到代码然后我们

933
02:02:37,191 --> 02:02:41,679
说用户 ID，电子邮件是以前的电子邮件

934
02:02:41,679 --> 02:02:46,800
他们在那里添加了一个很棒的专栏，现在我们已经处理好了

935
02:02:46,800 --> 02:02:49,191
创建用户呃

936
02:02:49,191 --> 02:02:52,551
在我们的数据库中运行，这样就创建了我要关注的用户，所以现在我们

937
02:02:52,551 --> 02:02:56,320
有创建用户删除用户和打开和关闭和私有功能

938
02:02:56,320 --> 02:03:00,639
为了获取当前数据库没问题

939
02:03:00,639 --> 02:03:05,119
正如标题所示，现在我们必须处理一个名为 get user 的函数

940
02:03:05,119 --> 02:03:10,240
它可以检索给定其电子邮件地址的用户，所以

941
02:03:10,240 --> 02:03:14,551
我要继续，基本上写那个函数签名

942
02:03:14,551 --> 02:03:18,551
在这里通过从我的笔记中粘贴它，所以我不必手动输入它，但你

943
02:03:18,551 --> 02:03:22,720
把它放在标题中，以防你需要去看它，我们就像我们在

944
02:03:22,720 --> 02:03:25,360
我们将获取当前数据库或抛出错误的其他函数

945
02:03:25,360 --> 02:03:31,360
如果数据库没有打开，那么我们会说 db 是获取数据库或抛出

946
02:03:31,360 --> 02:03:35,191
那么我们要做的是查询数据库

947
02:03:35,191 --> 02:03:38,551
电子邮件地址，如果您记得在创建用户中我们已经这样做了，那么让我们

948
02:03:38,551 --> 02:03:41,039
去复制那个书包

949
02:03:41,039 --> 02:03:44,479
像这样，我将折叠创建用户和

950
02:03:44,479 --> 02:03:49,679
让我们在这里粘贴代码我们有结果

951
02:03:49,679 --> 02:03:53,512
所以在这种情况下，我们必须做与你在创建用户中看到的相反的事情

952
02:03:53,512 --> 02:03:56,800
检查以确保

953
02:03:56,800 --> 02:03:58,800
嗯

954
02:03:58,800 --> 02:04:02,080
结果实际上是空的，因为我们想在创建一个新的

955
02:04:02,080 --> 02:04:06,720
使用该电子邮件的用户该电子邮件尚不存在，但在这种情况下，我们

956
02:04:06,720 --> 02:04:09,759
当您想要获得我们想要创建的用户时，实际上必须做相反的事情

957
02:04:09,759 --> 02:04:15,360
确定它确实存在，所以我们必须说结果是否为空，这意味着我们

958
02:04:15,360 --> 02:04:20,240
找不到具有给定电子邮件地址的用户，然后我们说抛出

959
02:04:20,240 --> 02:04:24,800
找不到用户实际上我们还没有，所以我们

960
02:04:24,800 --> 02:04:28,639
需要定义一个名为找不到用户的新异常，我要带来

961
02:04:28,639 --> 02:04:33,191
它在这里就像我们必须删除用户一样

962
02:04:33,191 --> 02:04:36,800
找不到用户好吗，然后在这里我们必须抛出无法

963
02:04:36,800 --> 02:04:42,080
如果结果为空，则可以找到用户，然后我们抛出

964
02:04:42,080 --> 02:04:46,479
否则我们必须为用户构建一个数据库，所以我们说

965
02:04:46,479 --> 02:04:53,039
从行返回数据库用户，我们说结果

966
02:04:53,039 --> 02:04:57,279
dot first 这是读取的第一行

967
02:04:57,279 --> 02:04:59,191
来自

968
02:04:59,191 --> 02:05:03,831
用户表还记得我们设置了一个限制，所以它应该是

969
02:05:03,831 --> 02:05:08,000
它应该是零行或一行是用户

970
02:05:08,000 --> 02:05:11,512
给定的电子邮件地址没问题

971
02:05:11,512 --> 02:05:15,119
好吧，完美，嗯，让我们继续下一个我们必须做的功能

972
02:05:15,119 --> 02:05:19,279
实施，那是为了让我们能够创造新的

973
02:05:19,279 --> 02:05:23,440
节点，所以如果你想像我一样在这里清理一下代码

974
02:05:23,440 --> 02:05:28,000
把所有东西都折叠起来，这样你就只能看到函数签名了，现在我们可以专注于

975
02:05:28,000 --> 02:05:31,919
下一个创建节点的函数我只是要找到它

976
02:05:31,919 --> 02:05:37,440
在我的笔记中只是为了确保我给你准确的

977
02:05:37,440 --> 02:05:42,320
创建注释功能所需的代码

978
02:05:42,320 --> 02:05:47,831
呃，如果我能找到它，嗯，就在那里创建笔记，好吧

979
02:05:47,831 --> 02:05:50,639
正如标题所示，我们必须拥有

980
02:05:50,639 --> 02:05:55,759
一个称为创建节点的异步函数它返回一个数据库节点，它

981
02:05:55,759 --> 02:06:00,872
还说谁是这个节点的所有者，它只是要创建一个新节点

982
02:06:00,872 --> 02:06:06,551
带有一个空文本，它将把它和节点与给定的

983
02:06:06,551 --> 02:06:11,759
数据库用户，您可以看到参数的类型为数据库用户和

984
02:06:11,759 --> 02:06:16,000
获取用户的方法是创建一个，如果它不存在并且你得到

985
02:06:16,000 --> 02:06:20,000
数据库用户，或者你得到一个现有用户，所以

986
02:06:20,000 --> 02:06:24,551
对不起，让我们继续说未来的数据库用户

987
02:06:24,551 --> 02:06:28,160
我们称这个函数为节点表示创建节点，我们说它是一个

988
02:06:28,160 --> 02:06:33,512
数据库用户的必填字段糟糕，它不应该返回

989
02:06:33,512 --> 02:06:37,759
数据库用户应该是数据库节点，参数是

990
02:06:37,759 --> 02:06:43,440
owner 是数据库用户，它是一个异步函数

991
02:06:43,440 --> 02:06:48,080
所以就像我们在其他地方所做的那样，我们会说 final db 是 get

992
02:06:48,080 --> 02:06:53,512
或 throw 获取当前数据库或 throw

993
02:06:53,512 --> 02:06:57,600
所以我们首先需要做的就是确保我们的当前用户

994
02:06:57,600 --> 02:07:01,679
正在传递这里已经存在于数据库中，因为记住数据库用户

995
02:07:01,679 --> 02:07:06,240
只是一个类，它可以通过调用它的构造函数来创建，这是正确的

996
02:07:06,240 --> 02:07:09,919
在这里，嗯，这里的某个地方

997
02:07:09,919 --> 02:07:12,720
所以我可以创建一个新的数据库用户

998
02:07:12,720 --> 02:07:17,119
实例作为数据库用户和随机电子邮件和随机 id

999
02:07:17,119 --> 02:07:21,600
但是在这里，当我们尝试为该特定数据库用户创建节点时

1000
02:07:21,600 --> 02:07:24,800
我们需要首先确保该数据库用户实际上在

1001
02:07:24,800 --> 02:07:27,679
数据库没问题，我们说最后

1002
02:07:27,679 --> 02:07:31,119
bb用户等于await

1003
02:07:31,119 --> 02:07:36,479
我们实际上在这里调用了我们自己的 get user 函数，我们说 get user with

1004
02:07:36,479 --> 02:07:41,191
um 所有者的电子邮件在我们的电子邮件中

1005
02:07:41,191 --> 02:07:46,872
所以在这里我们实际上是在重用我们创建的代码

1006
02:07:46,872 --> 02:07:49,600
那么我们要做的是

1007
02:07:49,600 --> 02:07:54,551
检查这个数据库用户是否真的是所有者

1008
02:07:54,551 --> 02:07:58,320
看看我的意思是什么 我的意思是让我们

1009
02:07:58,320 --> 02:08:02,160
说我去把事情搞砸了，我说哦，我创建了一个新的实例

1010
02:08:02,160 --> 02:08:05,919
手动数据库用户而不插入数据库，这是一些 id

1011
02:08:05,919 --> 02:08:10,240
一种随机的 id，然后这是我知道存在于

1012
02:08:10,240 --> 02:08:12,960
数据库现在我们需要在我们的代码中做的是

1013
02:08:12,960 --> 02:08:18,160
只是为了确保您在数据库中提供的 id

1014
02:08:18,160 --> 02:08:22,160
这里的用户实际上是我们数据库中现有用户的 id 并做

1015
02:08:22,160 --> 02:08:26,551
我们可以从字面上使用我们之前编写的这个漂亮的小函数

1016
02:08:26,551 --> 02:08:30,240
这是我们的数据库用户的相等函数，它实际上检查了我们的

1017
02:08:30,240 --> 02:08:34,639
id 相对于其他数据库用户的 id 所以如果我们从字面上看

1018
02:08:34,639 --> 02:08:40,399
在这里说在这里我们说如果数据库用户不是进入我们的所有者

1019
02:08:40,399 --> 02:08:45,679
equal 等于运算符并取反它说 oh 如果它不等于 then

1020
02:08:45,679 --> 02:08:51,279
我们说 throw 找不到用户好吗

1021
02:08:51,279 --> 02:08:53,679
所以在这个地方之后

1022
02:08:53,679 --> 02:08:58,479
如果我们真的找到了该电子邮件的 db 用户并且 id 是确切的 id

1023
02:08:58,479 --> 02:09:01,759
作为所有者，我们实际上可以确定该用户确实存在于

1024
02:09:01,759 --> 02:09:05,360
具有正确电子邮件和正确 ID 的数据库可以，所以让我们输入

1025
02:09:05,360 --> 02:09:11,831
在这里发表评论并说确保所有者存在于数据库中

1026
02:09:11,831 --> 02:09:16,399
正确的 id 没关系

1027
02:09:16,399 --> 02:09:20,479
好吧，在我们完成之后，我们还必须注意实际创建

1028
02:09:20,479 --> 02:09:24,831
嗯，所以让我们继续创建一个

1029
02:09:24,831 --> 02:09:30,479
嗯文字在这里我们说文字是呃对不起我注意到你不能

1030
02:09:30,479 --> 02:09:35,440
看到那个代码我希望你至少看到这个代码

1031
02:09:35,440 --> 02:09:39,279
我在这里写的，但如果你不这样做，我会为此道歉，因为只是因为

1032
02:09:39,279 --> 02:09:43,759
我正在使用一个软件，我在我的主机上一直看不到该软件

1033
02:09:43,759 --> 02:09:47,759
监视器是我正在编码的监视器我必须查看辅助监视器

1034
02:09:47,759 --> 02:09:51,831
这是在这里，所以我正在尽我所能看看那个辅助显示器

1035
02:09:51,831 --> 02:09:54,639
确保您看到所有内容，但有时我可能会错过

1036
02:09:54,639 --> 02:09:57,831
我为此道歉，让我们看看

1037
02:09:57,831 --> 02:10:01,191
现在你可以看到这段代码了

1038
02:10:01,191 --> 02:10:05,039
所以让我们继续创建笔记，所以我要发表评论

1039
02:10:05,039 --> 02:10:10,160
在这里说我们现在的工作是创建笔记创建笔记

1040
02:10:10,160 --> 02:10:12,960
以及我们要说的我们要说的

1041
02:10:12,960 --> 02:10:16,800
db insert 就像我们之前为创建用户所做的插入一样

1042
02:10:16,800 --> 02:10:19,512
为笔记做一个数据库插入，它在

1043
02:10:19,512 --> 02:10:23,440
注释表，你会看到这里的值

1044
02:10:23,440 --> 02:10:27,679
成为一张地图，如果你看地图

1045
02:10:27,679 --> 02:10:31,440
插入函数实际上是字符串和对象的映射，所以

1046
02:10:31,440 --> 02:10:35,360
让我们看看这里的笔记表，您可以右键单击查看笔记

1047
02:10:35,360 --> 02:10:41,512
修改需要用户 ID 文本并与云列同步的表，让我们开始吧

1048
02:10:41,512 --> 02:10:46,160
提前说用户 ID 列用户 ID 调用

1049
02:10:46,160 --> 02:10:50,639
这是业主的身份证，我们还有什么我们有

1050
02:10:50,639 --> 02:10:54,800
文本列，这等于我们的文本

1051
02:10:54,800 --> 02:10:57,759
刚刚创建出来，基本上是一个空文本

1052
02:10:57,759 --> 02:11:00,960
你不必这样做 你不必做那部分 你可以从字面上看

1053
02:11:00,960 --> 02:11:03,440
就这么说

1054
02:11:03,440 --> 02:11:09,191
对我来说，如果我像这样事先定义这些东西会更易读

1055
02:11:09,191 --> 02:11:13,512
然后在这里我们只是说是同步的

1056
02:11:13,512 --> 02:11:19,039
cloud 列，在这种情况下它的值是 1 所以我们基本上是说

1057
02:11:19,039 --> 02:11:23,919
我们从那开始，好吧，我只是注意到我错过了一个

1058
02:11:23,919 --> 02:11:28,240
那里的列记住插入它返回插入对象的ID

1059
02:11:28,240 --> 02:11:34,160
数据库，它是一个未来，所以让我们说最后的注释 id 等于

1060
02:11:34,160 --> 02:11:41,512
等待该函数将注释插入注释表

1061
02:11:41,512 --> 02:11:44,960
好了，现在完成了，我们要

1062
02:11:44,960 --> 02:11:49,600
实际上返回一个新的笔记实例并返回一个数据库笔记所以我们是什么

1063
02:11:49,600 --> 02:11:51,831
在这里我们要说最后

1064
02:11:51,831 --> 02:11:56,479
note 等于数据库注释注释

1065
02:11:56,479 --> 02:12:00,160
对于 id，我们要说 note id，我会提出来，所以你看

1066
02:12:00,160 --> 02:12:02,872
更好

1067
02:12:02,872 --> 02:12:07,759
对于用户 ID，我们将说所有者 ID 文本是文本，所以这是另一个

1068
02:12:07,759 --> 02:12:11,440
有理由像我一样将它定义为常量，以便我们可以重用

1069
02:12:11,440 --> 02:12:14,639
它在这里和那里并与云同步我们应该做什么

1070
02:12:14,639 --> 02:12:19,279
我们应该说真的好吗

1071
02:12:19,279 --> 02:12:23,440
创建一个便笺，您必须将其返回，然后在您的 um 异步中

1072
02:12:23,440 --> 02:12:26,639
功能没问题，我也要在这里加一个逗号，以确保

1073
02:12:26,639 --> 02:12:31,360
格式已经到位，现在我们将注释插入到

1074
02:12:31,360 --> 02:12:37,119
数据库，我们还创建了一个数据库节点来从我们的函数中返回它

1075
02:12:37,119 --> 02:12:40,720
哇很多代码很多代码，但我希望

1076
02:12:40,720 --> 02:12:44,639
你在本章中一直坚持我，所以现在我们已经创建了笔记

1077
02:12:44,639 --> 02:12:47,759
正如标题所示，现在我们必须开发一个功能，使我们能够

1078
02:12:47,759 --> 02:12:52,000
删除一个节点，因为记住我们将允许用户选择一个节点

1079
02:12:52,000 --> 02:12:56,080
在数据库中稍后抱歉选择用户界面上的节点

1080
02:12:56,080 --> 02:12:59,831
用户自己已经创建并能够删除该注释，所以我们

1081
02:12:59,831 --> 02:13:04,720
需要一个允许我们使用它的 id 删除节点的函数

1082
02:13:04,720 --> 02:13:08,479
所以我们走吧，我只是要带上

1083
02:13:08,479 --> 02:13:12,160
此功能的基础知识或几乎整个功能实际上在这里

1084
02:13:12,160 --> 02:13:16,479
所以我们不必手动编写代码，我将把它粘贴到这里

1085
02:13:16,479 --> 02:13:19,512
正如你在这里看到的这个函数的签名我将解释它

1086
02:13:19,512 --> 02:13:23,279
直到这个函数的所有签名都被称为删除节点作为异步

1087
02:13:23,279 --> 02:13:27,600
作为屏幕底部的标题，以防我们执行 get db

1088
02:13:27,600 --> 02:13:31,512
然后我们实际上只是调用了删除函数，这正是

1089
02:13:31,512 --> 02:13:35,440
我相信我们在删除用户时所做的同样的事情让我们来看看

1090
02:13:35,440 --> 02:13:39,512
你在表中看到 delete count db delete

1091
02:13:39,512 --> 02:13:44,720
然后是你的工作条款，在这种情况下，在我们所说的删除注释中

1092
02:13:44,720 --> 02:13:50,000
从注释表中删除其列 id 等于的对象

1093
02:13:50,000 --> 02:13:54,720
一些东西，然后我们在 where arcs 中传递一些东西

1094
02:13:54,720 --> 02:14:00,160
现在，如果给定 id 的笔记不存在，我们无法删除任何内容

1095
02:14:00,160 --> 02:14:03,600
我们抛出了一个异常，称为无法删除节点，这是一个

1096
02:14:03,600 --> 02:14:07,119
我们尚未定义的异常，我们将不得不在

1097
02:14:07,119 --> 02:14:10,639
到目前为止我们已经定义的所有其他例外的底部，所以这是不可能的

1098
02:14:10,639 --> 02:14:14,320
删除节点可以执行异常

1099
02:14:14,320 --> 02:14:18,872
所以我想我的意思是我通常不会复制粘贴代码，即使它是我自己的代码

1100
02:14:18,872 --> 02:14:23,191
但我认为这是一个如此简单的代码，我们实际上已经完成了每个部分

1101
02:14:23,191 --> 02:14:28,000
在我们完成 get db 之前类似的事情我们之前已经完成了删除

1102
02:14:28,000 --> 02:14:32,479
我们以前做过这个 if 语句，所以这不是什么新鲜事，我不认为你

1103
02:14:32,479 --> 02:14:36,240
必须让我在这里花时间解释

1104
02:14:36,240 --> 02:14:38,872
同样的事情一遍又一遍，这就是为什么我复制粘贴这个删除

1105
02:14:38,872 --> 02:14:41,831
注意这里好

1106
02:14:41,831 --> 02:14:47,191
好吧，那么我们还需要能够删除所有节点

1107
02:14:47,191 --> 02:14:51,360
我们的数据库我们如何做到这一点，正如您所见，我们需要一个名为 future 的函数

1108
02:14:51,360 --> 02:14:55,759
表示从

1109
02:14:55,759 --> 02:14:59,919
我们称之为删除所有节点的数据库，它是一个异步函数

1110
02:14:59,919 --> 02:15:04,800
好的，我们需要在这里做的是

1111
02:15:04,800 --> 02:15:10,160
只是非常简单，我们要说 final db 等于 get 或 throw

1112
02:15:10,160 --> 02:15:14,800
然后我们说 db delete 然后我们就直接说 uh

1113
02:15:14,800 --> 02:15:22,000
注意 哎呀 注意 表 呃 繁荣 繁荣 等待 它 好吧

1114
02:15:22,000 --> 02:15:25,679
如果您发出删除命令，您会看到这一点

1115
02:15:25,679 --> 02:15:30,479
在具有给定表的数据库上，它所做的就是删除每个

1116
02:15:30,479 --> 02:15:35,831
在那个 uh 表中为您提供的行，它将返回之前的行数

1117
02:15:35,831 --> 02:15:38,872
受影响，因此您可以看到它返回受影响的行数，因此

1118
02:15:38,872 --> 02:15:44,960
正是我们想要返回的，所以只需在这个函数中返回那个值就行了

1119
02:15:44,960 --> 02:15:48,800
完美的好东西我们已经完成了一些大功能和一些

1120
02:15:48,800 --> 02:15:52,399
小功能，所以有一些小功能也很令人耳目一新

1121
02:15:52,399 --> 02:15:57,360
即使对我来说，所以我们现在需要做的是创造

1122
02:15:57,360 --> 02:16:02,240
获取您实际看到的特定节点的功能

1123
02:16:02,240 --> 02:16:05,919
进入我们将数据库内的所有节点渲染到的 ui

1124
02:16:05,919 --> 02:16:09,679
我们的用户在我们应用程序的主用户界面中，我们将列出所有

1125
02:16:09,679 --> 02:16:13,039
节点，然后如果用户按下任何特定节点，那么我们将

1126
02:16:13,039 --> 02:16:17,360
获取该节点的 id，然后从

1127
02:16:17,360 --> 02:16:21,191
数据库，这就是为什么我们需要一个函数来获取节点的 id 和

1128
02:16:21,191 --> 02:16:25,512
实际上从数据库中为我们抓取了那个节点，好吧

1129
02:16:25,512 --> 02:16:30,080
所以让我们继续编程，所以我要带上呃

1130
02:16:30,080 --> 02:16:33,759
我要带上函数签名，我们不会

1131
02:16:33,759 --> 02:16:37,831
这次复制粘贴它让我复制粘贴功能实际上我的意思是这样

1132
02:16:37,831 --> 02:16:43,039
让我们继续获取数据库，这样对您来说很容易，现在您知道该怎么做

1133
02:16:43,039 --> 02:16:46,399
我们要查询数据库所以我们只说最后的笔记

1134
02:16:46,399 --> 02:16:48,872
这将像

1135
02:16:48,872 --> 02:16:54,160
sqlite 数据库可以读取的地图的可迭代列表

1136
02:16:54,160 --> 02:16:58,639
所以我们要说等待数据库查询

1137
02:16:58,639 --> 02:17:01,919
我们要在注释表中说我要删除所有这些

1138
02:17:01,919 --> 02:17:06,872
覆盖，以便您看到代码更好的注释表，我们只会说

1139
02:17:06,872 --> 02:17:12,080
嗯，汇款一张，因为我们想得到一张纸条

1140
02:17:12,080 --> 02:17:17,039
并且单词从句将使用它的 id 你看我们要说

1141
02:17:17,039 --> 02:17:21,600
id 等于某物，而艺术将只是 id 本身

1142
02:17:21,600 --> 02:17:26,960
那种隆隆声和这样的分号

1143
02:17:26,960 --> 02:17:31,919
现在，如果这说明 uh 这是

1144
02:17:31,919 --> 02:17:36,080
如果 notes 为空，你可以看到它是一个列表，我们将抛出一个

1145
02:17:36,080 --> 02:17:40,551
例外所以我们会说嗯找不到笔记我们有吗

1146
02:17:40,551 --> 02:17:45,360
呃找不到用户我们找不到我们没有的笔记所以让我们去吧

1147
02:17:45,360 --> 02:17:48,800
定义它，我将把它从

1148
02:17:48,800 --> 02:17:52,399
我自己的笔记，所以我们不必手动编写

1149
02:17:52,399 --> 02:17:56,479
所以定义一个异常叫做找不到节点实现异常没关系

1150
02:17:56,479 --> 02:18:01,440
然后在这里我们只是抛出它找不到节点所以如果你给我们一个 id 我们

1151
02:18:01,440 --> 02:18:04,639
在数据库中找不到它，否则我们只是抛出一个异常

1152
02:18:04,639 --> 02:18:09,440
我们需要实际创建数据库节点的一个实例，所以我们说返回

1153
02:18:09,440 --> 02:18:17,600
来自行和节点的数据库注释首先可以，这与我们的操作方式相似

1154
02:18:17,600 --> 02:18:22,320
在获得用户之前

1155
02:18:22,320 --> 02:18:25,759
好吧，现在我们还需要

1156
02:18:25,759 --> 02:18:31,191
一种功能，使我们能够获取您看到的系统中的所有节点

1157
02:18:31,191 --> 02:18:35,440
获取节点以删除所有节点删除节点创建节点但我们没有任何节点

1158
02:18:35,440 --> 02:18:39,119
可以获取所有节点的功能，这就是我们的确切功能

1159
02:18:39,119 --> 02:18:42,872
将使用我们应用程序的主界面来渲染所有节点

1160
02:18:42,872 --> 02:18:46,872
给定的用户好吧

1161
02:18:46,872 --> 02:18:50,720
让我确保我在这里有这个功能

1162
02:18:50,720 --> 02:18:59,440
它被称为获取所有节点

1163
02:18:59,440 --> 02:19:03,440
让我们看看我们可以找到一个功能得到所有

1164
02:19:03,440 --> 02:19:06,479
某处的节点

1165
02:19:06,479 --> 02:19:11,919
创建我们有的注释得到我们有的用户

1166
02:19:11,919 --> 02:19:15,919
也许我现在实际上没有功能，我可以在我的

1167
02:19:15,919 --> 02:19:20,872
注意到我实际上并没有得到所有的笔记，但这实际上不是问题

1168
02:19:20,872 --> 02:19:25,831
在这里的获取说明中，您看到我们必须定义此获取

1169
02:19:25,831 --> 02:19:30,240
所有的笔记，所以让我们继续做吧，我要复制这个的签名

1170
02:19:30,240 --> 02:19:33,360
功能，我要把它带到这里，我们

1171
02:19:33,360 --> 02:19:35,759
会说我们要回归未来

1172
02:19:35,759 --> 02:19:39,831
数据库注释列表，我们说的是

1173
02:19:39,831 --> 02:19:46,551
像这样的所有笔记都可以，对不起，它不应该需要任何参数

1174
02:19:46,551 --> 02:19:50,320
我们只是要让数据库返回所有的笔记就好了

1175
02:19:50,320 --> 02:19:54,160
再次抱歉，我将复制该功能

1176
02:19:54,160 --> 02:19:58,399
从这里获取笔记

1177
02:19:58,399 --> 02:20:02,872
再次对不起，在这里我们现在不会限制

1178
02:20:02,872 --> 02:20:07,279
任何东西，我们没有任何地方的条款，好吧，就像我们一样

1179
02:20:07,279 --> 02:20:12,160
会从笔记表中说数据库查询，然后我们得到所有笔记，然后如果

1180
02:20:12,160 --> 02:20:15,440
笔记是空的，然后我们说找不到笔记

1181
02:20:15,440 --> 02:20:20,479
或者我们可以只说注释我们可以看到这是我们可以看到的列表

1182
02:20:20,479 --> 02:20:23,279
从字面上看，这里没有任何特殊的逻辑

1183
02:20:23,279 --> 02:20:27,191
说找不到笔记或任何东西，我要看看我的笔记

1184
02:20:27,191 --> 02:20:30,479
这里

1185
02:20:30,479 --> 02:20:33,600
很好，我们现在需要做的是

1186
02:20:33,600 --> 02:20:38,320
我们的笔记，我们可以映射它们，所以我们说笔记映射，你可以命名这个

1187
02:20:38,320 --> 02:20:42,960
参数 and 在你的映射中你需要说好的我得到一个数据库注释

1188
02:20:42,960 --> 02:20:46,479
你可以看到哪个类型让我看看我能不能把鼠标移到这里

1189
02:20:46,479 --> 02:20:51,600
这是一个字符串对象的映射，与我们的数据库注释完美匹配

1190
02:20:51,600 --> 02:20:56,320
但是从行然后你说从这个 n

1191
02:20:56,320 --> 02:21:00,720
让我们实际上称它为笔记行或类似的东西，我们把它放在那里

1192
02:21:00,720 --> 02:21:03,679
如果你说最终结果

1193
02:21:03,679 --> 02:21:06,639
现在我认为老实说这是一个高音，所以你可以看到它

1194
02:21:06,639 --> 02:21:10,639
一个可迭代的数据库注释好的，所以我们可以做的实际上是改变我们的

1195
02:21:10,639 --> 02:21:14,800
未来在这里而不是说列表我们返回 iturble 好吧

1196
02:21:14,800 --> 02:21:20,080
为了呃清洁，我也要改变我们的字幕

1197
02:21:20,080 --> 02:21:24,872
在这里说 iterable 以便您在屏幕上看到正确的信息

1198
02:21:24,872 --> 02:21:27,600
好吧好吧

1199
02:21:27,600 --> 02:21:32,160
所以这就是我们的结果所以我们需要在这里做的只是返回它就是这样

1200
02:21:32,160 --> 02:21:34,639
就这样

1201
02:21:34,639 --> 02:21:38,479
完美，嗯，这就是 get 的功能

1202
02:21:38,479 --> 02:21:43,759
所有节点，所以它很简单没什么特别的

1203
02:21:43,759 --> 02:21:47,679
现在我们需要做的就是

1204
02:21:47,679 --> 02:21:51,119
最后一个我们必须实现并记住的功能

1205
02:21:51,119 --> 02:21:54,080
当我们进入应用程序的主界面时，我们将允许

1206
02:21:54,080 --> 02:21:57,759
用户创建节点列出所有他们创建的节点，也可以点击

1207
02:21:57,759 --> 02:22:01,759
在任何特定节点上以更新该节点的内容，因此我们需要一个

1208
02:22:01,759 --> 02:22:08,800
函数名为 update note 所以让我们把我的笔记带到这里 update notes

1209
02:22:08,800 --> 02:22:13,600
所以让我们继续为该功能和未来创建签名

1210
02:22:13,600 --> 02:22:18,399
数据库注释，我们说更新注释

1211
02:22:18,399 --> 02:22:22,479
像这样，我们将有一些我们实际上需要的参数

1212
02:22:22,479 --> 02:22:27,512
抓取一个现有的数据库注释对象，然后我们

1213
02:22:27,512 --> 02:22:31,360
期望用户也提供一个新文本，所以我们只说需要

1214
02:22:31,360 --> 02:22:36,720
数据库注释注释然后我们说它是必需的

1215
02:22:36,720 --> 02:22:43,679
像这样的文本字符串

1216
02:22:43,679 --> 02:22:46,872
你已经熟悉了我们会得到我们说的数据库

1217
02:22:46,872 --> 02:22:50,160
扔好

1218
02:22:50,160 --> 02:22:54,240
我们只是要发布我们的更新

1219
02:22:54,240 --> 02:22:59,440
数据库我们之前没有为我们的 sql 类数据库进行过更新，所以这就是

1220
02:22:59,440 --> 02:23:02,320
我们现在要做，所以我们只说 db.update

1221
02:23:02,320 --> 02:23:06,160
你可以看到上面写着给我们一张桌子或者给我一张桌子

1222
02:23:06,160 --> 02:23:10,831
你的更新列表，所以让我们进去说

1223
02:23:10,831 --> 02:23:15,512
更新 uh note 表

1224
02:23:15,512 --> 02:23:18,240
嗯，实际上在这样做之前我们怎么做

1225
02:23:18,240 --> 02:23:22,720
确保该注释的表已存在于数据库中，因为

1226
02:23:22,720 --> 02:23:27,831
就像我们之前看到的那样，任何人都可以去添加

1227
02:23:27,831 --> 02:23:30,800
或创建一个数据库节点的实例，它不一定必须在

1228
02:23:30,800 --> 02:23:33,919
数据库，但我们需要确保它已经存储在

1229
02:23:33,919 --> 02:23:38,800
数据库，因为在我们可以更新以更新其文本之前，我们已经有了一个

1230
02:23:38,800 --> 02:23:42,551
记住的功能会获取带有 id 的注释，因此我们可以

1231
02:23:42,551 --> 02:23:46,872
字面上只是说等待

1232
02:23:46,872 --> 02:23:50,872
它是便笺，然后我们说便笺 ID

1233
02:23:50,872 --> 02:23:54,399
你看到这实际上引发了一个错误

1234
02:23:54,399 --> 02:23:58,080
如果你去这个函数它会抛出一个错误，叫做找不到注释

1235
02:23:58,080 --> 02:24:02,720
正是我们所追求的，但我们实际上并不追求它的结果

1236
02:24:02,720 --> 02:24:06,399
我们不想要实际的注释，因为我们假设那是相同的

1237
02:24:06,399 --> 02:24:12,080
这样的对象，所以我们只是忽略它的返回值

1238
02:24:12,080 --> 02:24:14,479
在更新中我们会说笔记表

1239
02:24:14,479 --> 02:24:17,512
我们要提供的值是两个我们要说的

1240
02:24:17,512 --> 02:24:21,279
文本列我需要一个新文本

1241
02:24:21,279 --> 02:24:25,679
我们将在您更新节点的文本时，我们还将假设

1242
02:24:25,679 --> 02:24:30,479
突然之间，这个节点没有与后端或与

1243
02:24:30,479 --> 02:24:34,320
数据用 uh 用云数据库好了

1244
02:24:34,320 --> 02:24:39,512
这又回到了我们的 um async with cloud 专栏

1245
02:24:39,512 --> 02:24:43,440
所以让我们进入这里并说与云列同步然后它将是

1246
02:24:43,440 --> 02:24:47,759
设置为零记住那是一个整数字段好吧更新是一个

1247
02:24:47,759 --> 02:24:50,399
异步函数，所以你有它的重量

1248
02:24:50,399 --> 02:24:54,320
它还返回感觉更新的行数

1249
02:24:54,320 --> 02:24:59,119
我们要说更新的更新计数

1250
02:24:59,119 --> 02:25:01,119
抱歉最后

1251
02:25:01,119 --> 02:25:06,872
更新计数等于您现在对 db update 的权重

1252
02:25:06,872 --> 02:25:11,039
在调用更新注释函数的调用端，我们假设

1253
02:25:11,039 --> 02:25:15,191
注意应该已经存在于数据库中，所以在这种情况下

1254
02:25:15,191 --> 02:25:22,080
更新计数应该是一个非零的值好吧，所以我们说如果

1255
02:25:22,080 --> 02:25:27,119
更新计数等于 0 调出代码，以便您可以看到它

1256
02:25:27,119 --> 02:25:30,831
然后我们必须抛出一个名为无法更新的新异常

1257
02:25:30,831 --> 02:25:35,279
从我的笔记中记下并粘贴该异常

1258
02:25:35,279 --> 02:25:38,720
所以它应该看起来像这个类无法更新节点实现所有异常

1259
02:25:38,720 --> 02:25:41,919
对，所以我也需要你写这段代码

1260
02:25:41,919 --> 02:25:46,320
如果更新记录如果更新计数为零，那么我们是

1261
02:25:46,320 --> 02:25:51,119
会说 throw 无法更新笔记

1262
02:25:51,119 --> 02:25:53,831
否则现在你可以看到我们承诺的是

1263
02:25:53,831 --> 02:25:58,960
返回一个新的数据库注释，所以让我们说吧

1264
02:25:58,960 --> 02:26:04,080
那我们是不是我的意思是这就是我们更新的东西，呃，怎么做

1265
02:26:04,080 --> 02:26:09,759
我们向您返回更新数据库注释我们可以这样做

1266
02:26:09,759 --> 02:26:14,399
用那个笔记 id 转动它的 uh 笔记，因为

1267
02:26:14,399 --> 02:26:19,440
我们已经很好地实现了获取笔记功能

1268
02:26:19,440 --> 02:26:23,039
哇，如果你能坚持的话，做得很好

1269
02:26:23,039 --> 02:26:28,399
我贯穿这一章，因为我们做了很多工作，所以我要弃牌

1270
02:26:28,399 --> 02:26:32,000
this fold this 你可以看到我们这里有很多功能

1271
02:26:32,000 --> 02:26:36,080
相当多的工作，我认为到目前为止这是最大的一章

1272
02:26:36,080 --> 02:26:40,800
这门课程，但我们也有很多事情要做很多信息我

1273
02:26:40,800 --> 02:26:44,320
希望你能坚持我让我们现在继续清理我们的

1274
02:26:44,320 --> 02:26:48,080
标题所示的异常让我们将所有人群异常放入

1275
02:26:48,080 --> 02:26:54,399
lib services 中的一个文件 crowd crud 下划线 quad 例外 好的

1276
02:26:54,399 --> 02:26:58,479
所以让我们进去看看

1277
02:26:58,479 --> 02:27:04,399
呃实际上它应该说人群削减人群例外所以嗯，如果我看看我的

1278
02:27:04,399 --> 02:27:10,479
服务杂物内的注释我要修复这个标题，我为此道歉

1279
02:27:10,479 --> 02:27:18,000
我会像这样在旅途中修复它，我会提出来

1280
02:27:18,000 --> 02:27:22,160
实际上它应该说 crowd slash crud 强调异常所以我认为

1281
02:27:22,160 --> 02:27:25,360
那里有不止一个错误和 cros

1282
02:27:25,360 --> 02:27:30,320
必需的例外，所以它应该是口头服务斜线四边形

1283
02:27:30,320 --> 02:27:34,080
例外好吧，让我们去解决它

1284
02:27:34,080 --> 02:27:37,831
在服务内部，我们已经有人群了，我们有节点服务飞镖让我们

1285
02:27:37,831 --> 02:27:42,720
在那里创建一个新文件，我们现在称之为 crud exceptions dot art

1286
02:27:42,720 --> 02:27:46,800
需要您进入节点服务 dart 文件并获取所有这些异常

1287
02:27:46,800 --> 02:27:52,000
您在此处定义并在 macintosh 或 control x 上使用命令 x 剪切它们

1288
02:27:52,000 --> 02:27:57,119
在 linux 和 windows 中，然后把它带入你的 quad 异常中

1289
02:27:57,119 --> 02:28:00,160
保存这个文件

1290
02:28:00,160 --> 02:28:06,551
让我也看看这里

1291
02:28:06,551 --> 02:28:09,919
只是为了确保我的笔记对你来说也是干净的

1292
02:28:09,919 --> 02:28:14,399
嗯，因为我注意到下一个标题也有点不正确

1293
02:28:14,399 --> 02:28:18,000
现在我们需要在我们的笔记系列中使用人群异常，因为

1294
02:28:18,000 --> 02:28:21,600
你可以看到它现在被标记为红色，因为有很多

1295
02:28:21,600 --> 02:28:26,080
抛出异常，这个文件无法再访问了，所以我

1296
02:28:26,080 --> 02:28:29,119
将在此处使用命令点从 Visual Studio 代码中获得帮助并说导入

1297
02:28:29,119 --> 02:28:34,320
人群异常和所有这些错误都会消失

1298
02:28:34,320 --> 02:28:39,039
好吧，干得好，巨大的章节完成了很多工作，祝贺你

1299
02:28:39,039 --> 02:28:44,080
现在和我一起度过这一章，就像我们现在要遵循的传统一样

1300
02:28:44,080 --> 02:28:50,872
继续提交我们的工作，嗯，也给它贴上标签，所以我要让屏幕成为

1301
02:28:50,872 --> 02:28:54,872
大一点，让我们去我们的终端

1302
02:28:54,872 --> 02:29:00,551
然后我要在这里说我们将标记并提交我们的工作作为步骤

1303
02:29:00,551 --> 02:29:05,039
11 所以让我们先获取状态然后我们说 git add all

1304
02:29:05,039 --> 02:29:09,679
再次点击状态这里是我们所做的事情 pop spec 被改变了，因为

1305
02:29:09,679 --> 02:29:14,479
我们添加了三个依赖 uh 提供了一个路径 provider path

1306
02:29:14,479 --> 02:29:18,800
而且我相信实际上它被称为路径和路径提供者

1307
02:29:18,800 --> 02:29:22,551
是的路径路径提供程序和 sqlite 就是这样

1308
02:29:22,551 --> 02:29:25,919
为什么这两个文件被更改了节点服务是全新的和人群

1309
02:29:25,919 --> 02:29:30,720
异常也是新的，所以 git commit

1310
02:29:30,720 --> 02:29:36,000
呃，第 11 步，因为标题表明 git push

1311
02:29:36,000 --> 02:29:40,399
他们首先要记住，然后我们将其标记为第 11 步

1312
02:29:40,399 --> 02:29:45,831
我们也推我们的标签太棒了

1313
02:29:45,831 --> 02:29:49,512
现在再次祝贺你和我一起读完这一章

1314
02:29:49,512 --> 02:29:52,872
巨大的一章，我认为是迄今为止最大的一章，我们需要为下一章做好准备

1315
02:29:52,872 --> 02:29:56,800
章节作为其他章节的传统最后我们谈了一点

1316
02:29:56,800 --> 02:30:00,240
关于我们在下一章中要做的事情只是为了做好准备

1317
02:30:00,240 --> 02:30:03,679
所以我们现在在数据上做了很多工作

1318
02:30:03,679 --> 02:30:08,639
我们需要将它与我们的 uh 与我们的 ui 融合在一起，为了做到这一点，我们

1319
02:30:08,639 --> 02:30:12,399
需要谈谈你看到的流和流控制器

1320
02:30:12,399 --> 02:30:16,160
登录后，当您在应用程序的主用户界面中时

1321
02:30:16,160 --> 02:30:20,960
需要查看您的笔记列表，但是如果您看到了笔记列表会发生什么

1322
02:30:20,960 --> 02:30:24,000
你的笔记，然后你按下加号按钮来创建一个新的笔记，这

1323
02:30:24,000 --> 02:30:27,191
加号按钮是我们将在接下来的章节中创建的按钮

1324
02:30:27,191 --> 02:30:31,512
如果您按下加号按钮然后手动发送信号，则会发生

1325
02:30:31,512 --> 02:30:37,191
对你的用户界面说，嘿，一个新的笔记被创建了更新列表，这是很多

1326
02:30:37,191 --> 02:30:42,551
工作，如果你使用流和

1327
02:30:42,551 --> 02:30:46,551
流控制器，这就是我们将在下一章中讨论的内容

1328
02:30:46,551 --> 02:30:49,600
所以你可能想在之后稍作停顿

1329
02:30:49,600 --> 02:30:53,759
这一章，因为它太大了，所以请喝点咖啡

1330
02:30:53,759 --> 02:30:57,279
随便喝茶，下一章见

1331
02:30:57,279 --> 02:31:01,919
大家好，欢迎来到前几章的 swata 课程第 28 章

1332
02:31:01,919 --> 02:31:05,831
我们一直在谈论很多关于 crud create read update delete 的事情，我们

1333
02:31:05,831 --> 02:31:10,160
谈到了我们如何在我们的节点中拥有原始功能

1334
02:31:10,160 --> 02:31:13,759
服务，以便我们可以从数据库中读取删除数据库中的内容

1335
02:31:13,759 --> 02:31:19,279
创建用户等现在我们在过去的两章中还没有真正工作过

1336
02:31:19,279 --> 02:31:23,039
我们的用户界面有这么多，这完全没问题，因为有时

1337
02:31:23,039 --> 02:31:25,759
在开发应用程序或开发软件时，您可能拥有

1338
02:31:25,759 --> 02:31:29,512
走弯路以创建稍后将要实现的功能

1339
02:31:29,512 --> 02:31:32,080
你的用户界面需要，你会做

1340
02:31:32,080 --> 02:31:35,831
如果你在做像 uh web 这样的后端开发，同样的事情

1341
02:31:35,831 --> 02:31:39,191
开发所以我自己用 django 做 web 开发，有时我

1342
02:31:39,191 --> 02:31:43,279
必须先在后端创建很多功能

1343
02:31:43,279 --> 02:31:47,679
在我真正去镜像 UI 上的功能之前

1344
02:31:47,679 --> 02:31:51,119
以用户消费内容的网络浏览器为例

1345
02:31:51,119 --> 02:31:53,360
即使你是设计师

1346
02:31:53,360 --> 02:31:58,080
例如，你正在使用 figma，你不能总是制作面向用户的内容

1347
02:31:58,080 --> 02:32:01,191
就像原型一样，你有时可能不得不去设计

1348
02:32:01,191 --> 02:32:04,551
组件，然后在你完成组件之后，你就可以准备好了

1349
02:32:04,551 --> 02:32:08,479
将这些组件放入屏幕并将其显示给您的产品所有者或

1350
02:32:08,479 --> 02:32:11,440
你的开发人员

1351
02:32:11,440 --> 02:32:15,360
嗯，到目前为止，我们一直在合作

1352
02:32:15,360 --> 02:32:19,600
用户看不到的东西，我们必须喜欢缝合

1353
02:32:19,600 --> 02:32:23,440
在我们真正进入 ui 并进行操作之前，先整理一下最后的点点滴滴

1354
02:32:23,440 --> 02:32:29,360
我们的笔记服务现在可以处理的数据我们缺少一些

1355
02:32:29,360 --> 02:32:32,320
我们将在本章中在节点中开发的功能

1356
02:32:32,320 --> 02:32:34,399
服务和

1357
02:32:34,399 --> 02:32:38,160
我们将在本章中使用的尤其是流和

1358
02:32:38,160 --> 02:32:42,320
流控制器，所以让我调出标题

1359
02:32:42,320 --> 02:32:45,679
我现在要谈的是什么是流，什么是流

1360
02:32:45,679 --> 02:32:49,440
如果您已经是开发人员，那么控制器很好

1361
02:32:49,440 --> 02:32:52,720
做过软件开发你可能知道一些

1362
02:32:52,720 --> 02:32:58,000
关于反应式编程和反应式编程是你所拥有的

1363
02:32:58,000 --> 02:33:02,000
例如，一堆数据放在某个地方，然后你执行一些

1364
02:33:02,000 --> 02:33:06,080
对该数据的操作，该数据会更新，您将收到通知

1365
02:33:06,080 --> 02:33:10,479
这些更新是通过某种信息管道进行的，所以

1366
02:33:10,479 --> 02:33:13,759
如果你之前没有做过软件开发，那么被动

1367
02:33:13,759 --> 02:33:16,000
编程和流和流控制可能有点

1368
02:33:16,000 --> 02:33:20,160
压倒性的，但我们将开始非常缓慢，所以没有什么可做的

1369
02:33:20,160 --> 02:33:24,160
担心我会尽我所能解释一切

1370
02:33:24,160 --> 02:33:27,440
事情对你来说更容易，但如果你没有发展

1371
02:33:27,440 --> 02:33:30,800
软件工程背景之前的背景不是这样

1372
02:33:30,800 --> 02:33:34,320
我可以为您解释有关流和流控制器的很多内容

1373
02:33:34,320 --> 02:33:39,360
完全理解它们是如何工作的我只能说想象一个流是

1374
02:33:39,360 --> 02:33:44,479
只是一个时间点或一个流基本上是一个控制数据的实体

1375
02:33:44,479 --> 02:33:48,800
好吧，只要说一些保留数据的东西，然后你执行一些事情

1376
02:33:48,800 --> 02:33:53,512
在它上面所以你说添加这个数据或删除这个数据用这个数据添加这个数据

1377
02:33:53,512 --> 02:33:58,080
并给我结果，这样它就可以保存它的数据并且它有一个

1378
02:33:58,080 --> 02:34:03,119
时间线，因此它从某个时间点开始操作其数据，然后它要么

1379
02:34:03,119 --> 02:34:07,512
最后错误说哎呀我不能这样做然后它就死了或

1380
02:34:07,512 --> 02:34:11,191
它会在某个时候完成，还有第三类

1381
02:34:11,191 --> 02:34:14,479
数据一直存在的流

1382
02:34:14,479 --> 02:34:16,960
它从来没有基本上嗯

1383
02:34:16,960 --> 02:34:20,240
完成或出错

1384
02:34:20,240 --> 02:34:25,039
因此，只需将流视为数据类型的信息管道，您可以

1385
02:34:25,039 --> 02:34:28,960
操作，您还可以对

1386
02:34:28,960 --> 02:34:33,679
所以如果这就是流，那么什么是 dart 中的流流控制器

1387
02:34:33,679 --> 02:34:40,639
流控制器是您的流的接口，所以

1388
02:34:40,639 --> 02:34:45,600
你有坐在这里的溪流，你不能

1389
02:34:45,600 --> 02:34:49,831
你基本上不会去直接向流中添加内容或阅读

1390
02:34:49,831 --> 02:34:54,000
来自流的东西你可以做的是在你所在的地方有一个流控制器

1391
02:34:54,000 --> 02:34:58,320
操作流，例如我们的节点服务和这个流控制器

1392
02:34:58,320 --> 02:35:02,551
例如，能够向流中添加内容或从流中读取内容，因此

1393
02:35:02,551 --> 02:35:05,759
想象一下流控制器有点像那个流的管理者

1394
02:35:05,759 --> 02:35:10,160
所以如果这一切听起来有点高层次和抽象我完全

1395
02:35:10,160 --> 02:35:13,679
了解这通常是在您使用响应式编程时

1396
02:35:13,679 --> 02:35:17,191
有些人实际上讨厌反应式编程，但是

1397
02:35:17,191 --> 02:35:20,639
正如我的一位同事曾经说过的那样，总是更容易

1398
02:35:20,639 --> 02:35:25,512
讨厌比学习，我的方法通常是如果我讨厌某事是因为

1399
02:35:25,512 --> 02:35:29,039
也许我还没有真正完全理解它，所以我的东西很少

1400
02:35:29,039 --> 02:35:34,551
我真正学到的生活，我在学习后讨厌的生活

1401
02:35:34,551 --> 02:35:38,399
如果您对流和流控制器或反应式有点不知所措

1402
02:35:38,399 --> 02:35:41,600
如果你知道如何使用它们，它们实际上并不好

1403
02:35:41,600 --> 02:35:46,160
所以只要你掌握 uh 的句柄，它们就很容易使用

1404
02:35:46,160 --> 02:35:50,720
基本上它是如何掌握正确使用它们的方法的

1405
02:35:50,720 --> 02:35:52,960
我将在本章中向您展示什么，然后

1406
02:35:52,960 --> 02:35:57,831
即将到来的章节，所以让我们走吧，对不起，让我们去我们的

1407
02:35:57,831 --> 02:36:00,960
应用程序我要把代码放在这里让我们看看什么

1408
02:36:00,960 --> 02:36:04,639
到目前为止，我们已经写过，我将增加屏幕的大小，然后

1409
02:36:04,639 --> 02:36:09,512
稍微减小字体大小，这样就不会那么大了

1410
02:36:09,512 --> 02:36:11,831
所以嗯

1411
02:36:11,831 --> 02:36:15,440
让我们看看到目前为止我们做了什么，你可以看到我们有很多

1412
02:36:15,440 --> 02:36:19,759
例如，这里的功能是删除所有节点

1413
02:36:19,759 --> 02:36:23,440
然后我们得到了所有节点

1414
02:36:23,440 --> 02:36:27,759
我们有更新节点，所以有很多功能

1415
02:36:27,759 --> 02:36:31,679
但是如果您看到所有这些都直接与我们的数据库对话

1416
02:36:31,679 --> 02:36:34,639
sqlite 数据库 这些功能都不是

1417
02:36:34,639 --> 02:36:38,240
实际上告诉或者我们甚至不必谈论

1418
02:36:38,240 --> 02:36:41,600
功能，但如果您查看它本身的节点服务，它不包含

1419
02:36:41,600 --> 02:36:47,512
节点列表，因此它无法缓存这些节点，因此它就像

1420
02:36:47,512 --> 02:36:50,240
只要你给它一个命令节点服务我不知道该怎么做

1421
02:36:50,240 --> 02:36:53,679
只是去数据库，做你说我必须做的事

1422
02:36:53,679 --> 02:36:58,399
但是，这可能不是在我们的应用程序中，而是在一个应用程序中

1423
02:36:58,399 --> 02:37:02,551
有数百万行数据，例如这不可能

1424
02:37:02,551 --> 02:37:06,080
一个好主意，你总是去数据库和

1425
02:37:06,080 --> 02:37:11,512
阅读整个内容，例如删除一行或基本上删除

1426
02:37:11,512 --> 02:37:15,119
这些操作应该有点像之前缓存在您的应用程序中

1427
02:37:15,119 --> 02:37:19,759
你有希望地去访问数据库，我们将尽你所能

1428
02:37:19,759 --> 02:37:22,960
看这里的标题，我们将真正开始缓存笔记列表

1429
02:37:22,960 --> 02:37:26,872
节点服务具有因此目标是笔记服务器能够

1430
02:37:26,872 --> 02:37:32,551
公开一个笔记列表，然后用户界面可以在用户屏幕上呈现这些笔记列表

1431
02:37:32,551 --> 02:37:36,639
所以如果用户去按下加号按钮，那么那个加号按钮就是

1432
02:37:36,639 --> 02:37:40,720
将在此处向我们的便笺服务器发送消息，然后转到此

1433
02:37:40,720 --> 02:37:44,320
函数创建节点，然后在内部创建节点函数

1434
02:37:44,320 --> 02:37:49,279
操纵节点服务内的节点列表说嘿这是一个新节点

1435
02:37:49,279 --> 02:37:53,191
添加它，然后我们的 ui 将听

1436
02:37:53,191 --> 02:37:56,872
笔记服务中可用的这些笔记的列表，如果事情发生变化

1437
02:37:56,872 --> 02:37:59,279
列出然后ui就可以了

1438
02:37:59,279 --> 02:38:02,960
自动更新自身以及 ui 和节点之间的这个接口

1439
02:38:02,960 --> 02:38:06,160
服务器将通过流完成

1440
02:38:06,160 --> 02:38:09,279
我知道这是很多很多信息，但你会得到它你会得到

1441
02:38:09,279 --> 02:38:12,320
只要我们一起读完这一章

1442
02:38:12,320 --> 02:38:15,919
所以我们首先需要做的是让我们走，然后作为底部的标题

1443
02:38:15,919 --> 02:38:20,320
屏幕的 表示我们要在我们的

1444
02:38:20,320 --> 02:38:24,720
注意服务 好的，让我们继续说我们有一个清单

1445
02:38:24,720 --> 02:38:29,679
呃数据库笔记，我们只是称之为笔记和

1446
02:38:29,679 --> 02:38:34,080
我们将从一个空列表开始

1447
02:38:34,080 --> 02:38:36,960
所以这真的很好，现在我们可以说这是我们的缓存，这就是

1448
02:38:36,960 --> 02:38:42,800
我们保留了该节点服务可以正常操作的所有注释

1449
02:38:42,800 --> 02:38:46,800
所以现在让我们去谈谈我们的嗯

1450
02:38:46,800 --> 02:38:51,679
流控制器，因此您可以看到我们需要做的事情

1451
02:38:51,679 --> 02:38:57,039
这里的信息说我们需要的是节点服务

1452
02:38:57,039 --> 02:39:04,000
能够控制节点流，所以当这个节点的列表发生变化时，我们

1453
02:39:04,000 --> 02:39:07,440
需要在笔记服务器中告诉我们的流

1454
02:39:07,440 --> 02:39:11,919
嘿，添加了一些元素 嘿，删除了一些元素，或者删除了一些元素

1455
02:39:11,919 --> 02:39:15,512
更新后，用户界面可以反应性地收听

1456
02:39:15,512 --> 02:39:21,360
对于节点服务中的这些更改，我们通过 um 做到这一点

1457
02:39:21,360 --> 02:39:25,759
我们的流控制器，所以让我们开始吧，因为标题表明我是

1458
02:39:25,759 --> 02:39:29,440
会写它和笔记实际上也许我应该是的，我要写

1459
02:39:29,440 --> 02:39:34,240
它注意到流控制器和创建流控制器的方法是

1460
02:39:34,240 --> 02:39:38,080
你只是说流控制器，然后你指定你的数据类型

1461
02:39:38,080 --> 02:39:42,639
流包含哪个是数据库节点列表

1462
02:39:42,639 --> 02:39:48,080
然后我们就说点广播

1463
02:39:48,080 --> 02:39:52,000
像那样，我相信流控制器还没有

1464
02:39:52,000 --> 02:39:56,960
对不起，我们的笔记服务中没有导入，所以我会得到帮助

1465
02:39:56,960 --> 02:40:01,119
视觉工作室代码，你可以看到它说流控制器很好

1466
02:40:01,119 --> 02:40:08,399
在 dart 异步包中可用，所以嗯，是的，异步意味着异步

1467
02:40:08,399 --> 02:40:11,440
所以为了能够使用流控制器，你必须导入它

1468
02:40:11,440 --> 02:40:14,551
我将从 Visual Studio 代码中获得帮助来做到这一点

1469
02:40:14,551 --> 02:40:17,919
好吧，让我们看看我们在这里做了什么

1470
02:40:17,919 --> 02:40:21,919
这是什么语法看起来真的很可怕但它真的不是全部

1471
02:40:21,919 --> 02:40:25,759
你是说我希望能够控制流

1472
02:40:25,759 --> 02:40:30,000
嗯，基本上是一个数据库笔记列表

1473
02:40:30,000 --> 02:40:33,512
你是说我有一根管子这个管子

1474
02:40:33,512 --> 02:40:37,831
这个管道内的每个事件都是一个数据库节点列表，所以让我们说

1475
02:40:37,831 --> 02:40:41,512
你从一个空列表开始，所以这个列表在这个管道内是空的，然后你

1476
02:40:41,512 --> 02:40:44,639
将项目添加到此管道

1477
02:40:44,639 --> 02:40:49,360
然后它做什么它说哦，在我在空列表上之前我是什么添加新的

1478
02:40:49,360 --> 02:40:54,479
项目所以现在我是一个项目现在我是一个包含一个项目的数组或列表然后它放

1479
02:40:54,479 --> 02:40:58,872
流中的那个数组，所以流的值现在在开头

1480
02:40:58,872 --> 02:41:03,360
是空列表，那么它是一个项目的列表，所以这个流控制器是

1481
02:41:03,360 --> 02:41:09,119
基本上在控制，因为它的名字表明它在控制变化

1482
02:41:09,119 --> 02:41:14,240
到这个笔记嗯列表它还没有被吸引到，但是

1483
02:41:14,240 --> 02:41:18,551
这就是它的目的，这就是它的数据类型完全相同的原因

1484
02:41:18,551 --> 02:41:24,800
流控制器现在在这里和作为广播部分

1485
02:41:24,800 --> 02:41:28,000
你可以看到文档实际上在上面说控制器在哪里

1486
02:41:28,000 --> 02:41:32,000
可以多次收听流并且

1487
02:41:32,000 --> 02:41:35,279
如果你之前做过暗开发或颤动开发

1488
02:41:35,279 --> 02:41:40,399
知道如果你然后嗯，我现在假设我说你的飞镖或

1489
02:41:40,399 --> 02:41:43,512
如果您已经创建了流控制器并且

1490
02:41:43,512 --> 02:41:47,119
然后你去听流控制器对该流的更改

1491
02:41:47,119 --> 02:41:51,440
正在控制，然后您进行热重载，然后您会从您的

1492
02:41:51,440 --> 02:41:54,639
花应用说哦，这个流已经被听过了所以你

1493
02:41:54,639 --> 02:41:58,551
不能再听了，这就是普通流控制器的问题

1494
02:41:58,551 --> 02:42:02,872
可能会导致你一旦听了他们就应该关闭你的

1495
02:42:02,872 --> 02:42:06,872
收听该流的频道，然后您才能再次收听它们

1496
02:42:06,872 --> 02:42:10,551
如果您不是之前的开发人员，那么广播可以解决什么问题

1497
02:42:10,551 --> 02:42:15,440
广播基本上是说你可以创建新的

1498
02:42:15,440 --> 02:42:19,759
侦听此流控制器更改的侦听器，因此这是一个管道

1499
02:42:19,759 --> 02:42:23,600
在这一点上你开始听信息然后就完全没问题了

1500
02:42:23,600 --> 02:42:26,479
如果您想在稍后收听流控制器的更改

1501
02:42:26,479 --> 02:42:30,080
未来也是如此，所以你不会通过这个广播得到任何错误

1502
02:42:30,080 --> 02:42:33,039
好的

1503
02:42:33,039 --> 02:42:36,160
好的 嗯

1504
02:42:36,160 --> 02:42:40,960
现在我们还需要一个方便的功能

1505
02:42:40,960 --> 02:42:44,639
在我们的嗯

1506
02:42:44,639 --> 02:42:50,240
在我们的 application.can

1507
02:42:50,240 --> 02:42:54,551
它可以从我们的数据库中读取所有可用的笔记，然后缓存它们

1508
02:42:54,551 --> 02:42:59,919
在此处的便笺缓存和我们的控制器中都可以

1509
02:42:59,919 --> 02:43:05,119
所以你明白我们在本章中的目标是

1510
02:43:05,119 --> 02:43:09,600
确保这是我们笔记的真实来源

1511
02:43:09,600 --> 02:43:15,759
列表包含所有节点，例如当前用户

1512
02:43:15,759 --> 02:43:20,160
那么流控制器就是我们与外界的接口

1513
02:43:20,160 --> 02:43:24,872
ui 将监听此流中发生的更改

1514
02:43:24,872 --> 02:43:28,479
控制器所以每当你看到这个不是

1515
02:43:28,479 --> 02:43:30,960
将从外部读取的东西

1516
02:43:30,960 --> 02:43:34,800
一切都会通过这个从外部读取，所以请保持

1517
02:43:34,800 --> 02:43:37,360
记住这一点，所以让我们继续作为案例的标题，我们将

1518
02:43:37,360 --> 02:43:41,119
在这里创建一个名为缓存注释的函数，其目的只是为了阅读

1519
02:43:41,119 --> 02:43:45,759
数据库中的所有笔记并将其放置在内部和内部

1520
02:43:45,759 --> 02:43:51,360
我们的节点流控制器，可以从外部读取

1521
02:43:51,360 --> 02:43:54,960
所以让我们去做吧，所以我会说future void，我们会打电话给

1522
02:43:54,960 --> 02:44:00,080
它缓存和笔记是异步的

1523
02:44:00,080 --> 02:44:04,000
那么如果你还记得我们已经有一个名为 get all notes 的异步函数，那么

1524
02:44:04,000 --> 02:44:10,399
我只想说，嗯，最后，嗯，所有的笔记都在等待

1525
02:44:10,399 --> 02:44:14,872
所有的笔记都可以，所以我们所有的笔记

1526
02:44:14,872 --> 02:44:20,720
我们会把它分配到我们的笔记列表中

1527
02:44:20,720 --> 02:44:25,039
所以让我们进去，说你记得得到所有的笔记返回

1528
02:44:25,039 --> 02:44:29,191
可迭代我们所有的笔记，现在我们这里有一点问题

1529
02:44:29,191 --> 02:44:32,551
因为我们说的是所有笔记的清单，在这里我们也说清单

1530
02:44:32,551 --> 02:44:38,800
笔记，所以我们必须将那个可怕的东西转换为所有笔记的列表，好吧

1531
02:44:38,800 --> 02:44:43,440
要么我们可以这样做，要么我们可以让这个只是作为一个眼睛高音坐在那里

1532
02:44:43,440 --> 02:44:47,679
这完全取决于你我没有任何问题，我们可以一起去

1533
02:44:47,679 --> 02:44:50,080
清单，所以让我们进去，然后我们要

1534
02:44:50,080 --> 02:44:55,831
说呃我们的笔记是私人笔记是所有笔记

1535
02:44:55,831 --> 02:44:58,960
列表，我们也将更新我们的

1536
02:44:58,960 --> 02:45:04,080
带有下划线节点值的流控制器可以，所以我们

1537
02:45:04,080 --> 02:45:09,831
如果我能拼写，我会说注释流控制器

1538
02:45:09,831 --> 02:45:14,080
然后我们将向流中添加注释并记住一个

1539
02:45:14,080 --> 02:45:19,119
流只是价值随时间的演变

1540
02:45:19,119 --> 02:45:22,399
这种演变的第一点是

1541
02:45:22,399 --> 02:45:25,919
空列表，然后下一个将是

1542
02:45:25,919 --> 02:45:29,039
所有的笔记都在

1543
02:45:29,039 --> 02:45:33,360
数据库好的，这只是我们告诉任何人在听

1544
02:45:33,360 --> 02:45:38,399
流控制器，嘿，这是一个新值，好吧

1545
02:45:38,399 --> 02:45:42,720
好的，现在我们正在这样做，你可以看到

1546
02:45:42,720 --> 02:45:47,600
我们遇到了一个错误，dart 实际上这个分析非常聪明，因为

1547
02:45:47,600 --> 02:45:52,399
你看它告诉我们缓存笔记功能现在没有被使用

1548
02:45:52,399 --> 02:45:56,000
你可能会问自己这些功能都没有被使用更新

1549
02:45:56,000 --> 02:45:59,039
注意例如没有被使用所以如果我

1550
02:45:59,039 --> 02:46:02,831
搜索更新说明让我们看看更新

1551
02:46:02,831 --> 02:46:07,831
节点无法更新节点所以是的你可以看到更新节点功能

1552
02:46:07,831 --> 02:46:12,320
本身根本没有被使用，所以为什么

1553
02:46:12,320 --> 02:46:15,831
分析器特别抱怨这个功能，原因是

1554
02:46:15,831 --> 02:46:20,479
因为我们在这个函数名后面有一个小前缀

1555
02:46:20,479 --> 02:46:24,080
这个前缀告诉分析器这个函数是

1556
02:46:24,080 --> 02:46:29,039
现在 dart 分析器正在查看这个类的私有和私有

1557
02:46:29,039 --> 02:46:32,479
好吧，这是一门私人课程，但您没有使用它，所以

1558
02:46:32,479 --> 02:46:35,831
其他功能不正常的原因

1559
02:46:35,831 --> 02:46:40,080
标有此警告的是 dart 知道它们没有前缀

1560
02:46:40,080 --> 02:46:44,399
with a with a 带下划线的意思是

1561
02:46:44,399 --> 02:46:48,960
它们将在其他地方公开使用，所以还不会

1562
02:46:48,960 --> 02:46:51,759
给我们任何警告说你没有尽快使用这些功能

1563
02:46:51,759 --> 02:46:55,191
您删除了您看到警告也消失了但我们将保留

1564
02:46:55,191 --> 02:46:58,320
降低分数好吧我只是想向你解释为什么你会看到这个

1565
02:46:58,320 --> 02:47:03,279
小警告 好吧 既然我们已经做了现金票据 什么

1566
02:47:03,279 --> 02:47:06,800
我们要做的只是去我们的标题案例，我们要去

1567
02:47:06,800 --> 02:47:10,080
打开函数让我们看看能不能找到它

1568
02:47:10,080 --> 02:47:12,720
这里开

1569
02:47:12,720 --> 02:47:18,800
打开我们的数据库后，让我看看我的笔记

1570
02:47:18,800 --> 02:47:24,000
打开我们的数据库后，我们将

1571
02:47:24,000 --> 02:47:30,000
缓存所有这些，嗯，让我看看我的

1572
02:47:30,000 --> 02:47:33,279
笔记是的，我们基本上会去呃

1573
02:47:33,279 --> 02:47:36,872
我们在这里的 open 函数 future void open

1574
02:47:36,872 --> 02:47:39,440
我有点惊讶我实际上没有

1575
02:47:39,440 --> 02:47:44,399
写了关于那个的任何笔记是的，我可以看到实际上我有，所以这很好

1576
02:47:44,399 --> 02:47:47,512
所以在执行这个命令之后

1577
02:47:47,512 --> 02:47:51,039
在我们创建了用户表和笔记表之后创建笔记表

1578
02:47:51,039 --> 02:47:54,960
现在我们知道我们可以打开数据库，我们还必须缓存所有

1579
02:47:54,960 --> 02:47:59,831
我们局部变量中的注释，所以让我们去调用

1580
02:47:59,831 --> 02:48:02,872
那个函数，所以我们只说等待缓存

1581
02:48:02,872 --> 02:48:07,679
注释好，所以这意味着当你调用它时

1582
02:48:07,679 --> 02:48:10,551
如果在我们确定所有表格之后打开函数

1583
02:48:10,551 --> 02:48:13,512
一切都在那里，如果他们不存在，那么我们会

1584
02:48:13,512 --> 02:48:17,360
阅读所有笔记并将它们放在这个 notes 变量中，也放在这个

1585
02:48:17,360 --> 02:48:21,440
流控制器好吧，这就是我们做缓存笔记的方式，我希望你

1586
02:48:21,440 --> 02:48:24,872
可以看到代码并且它没有被标题隐藏

1587
02:48:24,872 --> 02:48:30,000
屏幕底部没事，所以这部分现在完成了

1588
02:48:30,000 --> 02:48:34,240
现在我们需要在这里做的是转到代码的下一部分，就像你

1589
02:48:34,240 --> 02:48:38,720
可以看到它在创建节点功能中的创建节点中显示缓存注释添加新的

1590
02:48:38,720 --> 02:48:42,800
节点下划线节点和节点流控制器

1591
02:48:42,800 --> 02:48:46,080
所以我要去我的节点这里创建

1592
02:48:46,080 --> 02:48:50,551
节点并确保当我们创建节点时

1593
02:48:50,551 --> 02:48:55,600
在我们的创建节点中

1594
02:48:55,600 --> 02:48:58,639
就在这里，在创建节点的这个函数中，你现在看到了什么

1595
02:48:58,639 --> 02:49:01,759
我们正在做的是我们只是创建一个节点并返回它

1596
02:49:01,759 --> 02:49:07,191
这很好，但我的意思是这还不够好，因为正如我所说，我们需要 ui

1597
02:49:07,191 --> 02:49:12,160
能够反应性地聆听所有现在在

1598
02:49:12,160 --> 02:49:16,479
该当前用户的数据库好的，所以在我们创建注释后在这里

1599
02:49:16,479 --> 02:49:21,600
我们实际上要将它添加到我们的节点数组中，然后我们也要去

1600
02:49:21,600 --> 02:49:25,600
将它添加到我们的流控制器中，所以我要走了

1601
02:49:25,600 --> 02:49:31,831
进入这里并说节点并在其中添加这个新节点

1602
02:49:31,831 --> 02:49:35,512
记住流控制器的职责只是反映值

1603
02:49:35,512 --> 02:49:38,479
在下划线节点内部到外部世界所以我们所要做的就是

1604
02:49:38,479 --> 02:49:43,831
只是说注释流控制器添加注释就像那样，因为注释是

1605
02:49:43,831 --> 02:49:49,119
我之前提到的真相的来源好吧

1606
02:49:49,119 --> 02:49:52,872
好东西，嗯，现在我们需要照顾其他人

1607
02:49:52,872 --> 02:49:58,240
名为删除笔记的函数让我们搜索它

1608
02:49:58,240 --> 02:50:03,119
嗯删除笔记好吧

1609
02:50:03,119 --> 02:50:06,551
我们需要做的是在这里看看这个呃功能，你可以

1610
02:50:06,551 --> 02:50:11,279
看到它说如果我们不能删除任何东西然后呃扔这个

1611
02:50:11,279 --> 02:50:15,759
例外，但现在我们要在这里添加一个 else 语句

1612
02:50:15,759 --> 02:50:20,000
我们能够删除该便笺，这意味着您可以看到我们的便笺 ID

1613
02:50:20,000 --> 02:50:23,600
have which is this id 所以我们需要做什么作为标题在我们需要的情况下

1614
02:50:23,600 --> 02:50:27,831
实际上也从我们的本地缓存中删除该注释，所以我们要说注释

1615
02:50:27,831 --> 02:50:31,360
删除where，这是便条，然后我要走了

1616
02:50:31,360 --> 02:50:36,160
说注意id应该等于那个id

1617
02:50:36,160 --> 02:50:40,720
之后我们可以说注意流控制器添加

1618
02:50:40,720 --> 02:50:44,551
笔记，你可以尝试你可以在这里变得聪明，你

1619
02:50:44,551 --> 02:50:47,679
实例可以说哦，你看到了

1620
02:50:47,679 --> 02:50:51,600
谁说那张纸条实际上存在于我们的缓存中，我们不能 100 确定

1621
02:50:51,600 --> 02:50:54,800
但是如果你看一下 remove where 函数的签名

1622
02:50:54,800 --> 02:51:00,399
嗯删除所有对象哦，也许我们没有能力真正知道

1623
02:51:00,399 --> 02:51:04,800
如果该节点被删除，但你能做什么，你可以说 count before

1624
02:51:04,800 --> 02:51:09,191
是笔记计数然后你可以在这里或长度

1625
02:51:09,191 --> 02:51:12,960
在这里你可以说如果笔记链接

1626
02:51:12,960 --> 02:51:18,240
在那之前不算数你可以更新你的流我不打算这样做但是

1627
02:51:18,240 --> 02:51:22,479
如果你愿意，你可以尝试这样做，这只是你的保障

1628
02:51:22,479 --> 02:51:28,320
说只有当我真的可以时，我才会更新我的面向外部的流

1629
02:51:28,320 --> 02:51:31,759
如果您认为值得，请从我的缓存中删除此注释我不认为

1630
02:51:31,759 --> 02:51:35,440
这是值得的，但这只是一个意见

1631
02:51:35,440 --> 02:51:39,679
所以我们将像标题一样留下它

1632
02:51:39,679 --> 02:51:43,440
现在你看到我们还有删除所有节点的功能，所以

1633
02:51:43,440 --> 02:51:47,191
让我找到所有节点的功能

1634
02:51:47,191 --> 02:51:54,800
好吧，让我们在这里删除所有节点，找到该函数并

1635
02:51:54,800 --> 02:51:58,399
你现在可以看到它在做什么只是返回数量

1636
02:51:58,399 --> 02:52:01,440
删除节点现在我们要做什么我们要去

1637
02:52:01,440 --> 02:52:05,512
说最后呃我们应该称之为多少

1638
02:52:05,512 --> 02:52:08,720
删除等于这个，我们要返回

1639
02:52:08,720 --> 02:52:12,399
删除的数量可以，因为我的意思是我这样做只是因为我们

1640
02:52:12,399 --> 02:52:17,831
需要在中间做一些工作好吗

1641
02:52:17,831 --> 02:52:21,679
那么我们要做的就是说笔记

1642
02:52:21,679 --> 02:52:27,119
是一个空列表，所以我们正在重置笔记，然后在做之后

1643
02:52:27,119 --> 02:52:30,479
我们还要更新我们的流控制器所以我们要说

1644
02:52:30,479 --> 02:52:34,399
将下划线节点添加到流控制，然后返回数量

1645
02:52:34,399 --> 02:52:38,960
删除，所以让我们确保我们的本地缓存已更新，并且

1646
02:52:38,960 --> 02:52:42,399
我们类的面向用户的界面是

1647
02:52:42,399 --> 02:52:48,720
流控制器也更新了最新信息

1648
02:52:48,720 --> 02:52:51,600
好的，我们需要做的下一件事，正如您在缓存中看到的那样

1649
02:52:51,600 --> 02:52:56,872
更新缓存获取节点删除具有相同ID的旧节点并添加新节点

1650
02:52:56,872 --> 02:53:04,080
更新这个流，让我们去我们的 git 节点

1651
02:53:04,080 --> 02:53:10,000
好吧，嗯

1652
02:53:10,000 --> 02:53:13,679
让我们看看我们的get note in here

1653
02:53:13,679 --> 02:53:17,279
现在你可以在这里看到它在做什么

1654
02:53:17,279 --> 02:53:22,160
哎呀，没有得到注意，嗯，这是得到注意

1655
02:53:22,160 --> 02:53:24,160
就在那儿好吧

1656
02:53:24,160 --> 02:53:28,080
正如你在这里看到的，嗯，我们基本上是我们正在做的就是我们是

1657
02:53:28,080 --> 02:53:32,160
当你试图从

1658
02:53:32,160 --> 02:53:36,551
数据库我们实际上只是对数据库进行查询，然后如果我们

1659
02:53:36,551 --> 02:53:42,080
可以通过创建一个数据库节点来找到我们正在返回的那个项目

1660
02:53:42,080 --> 02:53:48,320
从你可以在这里看到的一排，呃，但我们要做的是，如果

1661
02:53:48,320 --> 02:53:53,440
你试图得到一个便条，我们可能已经知道了

1662
02:53:53,440 --> 02:53:58,320
笔记本地缓存在我们的笔记数组中，但该笔记是

1663
02:53:58,320 --> 02:54:03,679
呃过时的意思是我们在缓存中的副本并不是真的

1664
02:54:03,679 --> 02:54:07,360
使用已应用于数据库的最新更改进行更新，因此它

1665
02:54:07,360 --> 02:54:13,360
在创建数据库节点的新实例时，从这里到现在都很有意义

1666
02:54:13,360 --> 02:54:17,279
实际上也可以更新我们的本地缓存，所以我只想说final

1667
02:54:17,279 --> 02:54:21,119
注意等于那个，我们将返回那个节点

1668
02:54:21,119 --> 02:54:25,440
在这里结算，所以这段代码和以前完全一样，除了我们是

1669
02:54:25,440 --> 02:54:30,872
现在在这里将 from row 的返回值分配给一个新的局部变量

1670
02:54:30,872 --> 02:54:34,320
所以让我们去我们的笔记，说删除哪里

1671
02:54:34,320 --> 02:54:38,160
我要在这里说注意我要说我要说注意

1672
02:54:38,160 --> 02:54:42,960
id 应该等于 id 是

1673
02:54:42,960 --> 02:54:48,080
这个东西在这里没问题所以我们首先从注释中删除那个节点现有节点

1674
02:54:48,080 --> 02:54:52,320
数组然后我们说节点添加

1675
02:54:52,320 --> 02:54:56,160
然后我们在其中添加新节点然后我们要做的就是正确的

1676
02:54:56,160 --> 02:55:01,759
之后更新流控制器，这是我们面向外部的 um 接口

1677
02:55:01,759 --> 02:55:07,279
所以注意流控制器添加笔记好吧，所以你可以看到这个模式所以我们首先

1678
02:55:07,279 --> 02:55:11,759
总是更新我们的本地缓存，然后我们将这些更改反映到外部

1679
02:55:11,759 --> 02:55:17,512
世界很好很好很好的东西所以嗯

1680
02:55:17,512 --> 02:55:20,100
这是笔记流控制器和笔记嗯

1681
02:55:20,100 --> 02:55:23,512
[音乐] 现在还有另一个功能是

1682
02:55:23,512 --> 02:55:28,872
调用更新说明，让我们实际去更新节点之前

1683
02:55:28,872 --> 02:55:33,191
我们看看其他任何东西，当我们更新时你可以在这里看到

1684
02:55:33,191 --> 02:55:36,872
首先，我们确保该节点存在，所以让我们在此处实际添加评论

1685
02:55:36,872 --> 02:55:40,551
确保笔记存在

1686
02:55:40,551 --> 02:55:44,080
然后我们说更新数据库我要扩展这段代码

1687
02:55:44,080 --> 02:55:47,679
所以你看得更清楚，那是更新数据库部分

1688
02:55:47,679 --> 02:55:52,320
如果我们不能更新任何东西，那么我们抛出它不能更新注释和

1689
02:55:52,320 --> 02:55:57,279
你可以在这里看到我们想要的更新节点

1690
02:55:57,279 --> 02:56:00,479
我的意思是到目前为止我们所做的非常聪明，因为这意味着

1691
02:56:00,479 --> 02:56:04,160
我们已经更新了数据库，但是我们为了返回新的

1692
02:56:04,160 --> 02:56:07,831
刷新节点实际上是我们调用getsnow所以

1693
02:56:07,831 --> 02:56:11,440
那很好，但是我们还需要做的就是

1694
02:56:11,440 --> 02:56:15,119
确保我们的本地和缓存也更新

1695
02:56:15,119 --> 02:56:18,160
所以让我们进去说final

1696
02:56:18,160 --> 02:56:21,919
更新的节点以及我们将要做的事情

1697
02:56:21,919 --> 02:56:25,919
屏幕底部的标题表示我们将删除它

1698
02:56:25,919 --> 02:56:31,119
来自我们本地缓存的笔记并在其中添加更新的笔记，然后

1699
02:56:31,119 --> 02:56:35,512
将添加消息也发送到我们的流控制器，所以让我们说

1700
02:56:35,512 --> 02:56:38,639
注释并删除

1701
02:56:38,639 --> 02:56:42,000
所以我们要从缓存中删除旧对象，我只想说

1702
02:56:42,000 --> 02:56:46,160
注释只要注释 id 等于

1703
02:56:46,160 --> 02:56:52,399
更新了注释 ID，以便删除现有的现有节点

1704
02:56:52,399 --> 02:56:56,399
我要说注释添加，我们有

1705
02:56:56,399 --> 02:57:01,119
更改后立即在此处更新节点

1706
02:57:01,119 --> 02:57:06,320
笔记和本地缓存，那么您还需要更新您的流，以便流

1707
02:57:06,320 --> 02:57:08,800
控制器添加注释

1708
02:57:08,800 --> 02:57:13,360
好的，然后我们返回更新的笔记

1709
02:57:13,360 --> 02:57:17,440
所以这里发生的只是我们更新了数据库中的一些内容

1710
02:57:17,440 --> 02:57:23,119
从 uh 数据库中获取了新对象，我们从本地删除了那个 uh 节点

1711
02:57:23,119 --> 02:57:28,639
缓存，然后我们将其添加到那里，好的，将其添加回来，这是更新的节点

1712
02:57:28,639 --> 02:57:32,800
好的好的好的东西要更新

1713
02:57:32,800 --> 02:57:38,000
注释，然后我们需要的是字幕案例是获取或创建用户

1714
02:57:38,000 --> 02:57:41,919
节点服务所以嗯

1715
02:57:41,919 --> 02:57:45,759
这是我们将在下一章实际使用的函数

1716
02:57:45,759 --> 02:57:48,800
嗯

1717
02:57:48,800 --> 02:57:52,399
这个功能有什么用这是我们第一次真正看到

1718
02:57:52,399 --> 02:57:54,960
这个函数的 um 签名作为名称

1719
02:57:54,960 --> 02:57:59,191
如果它说获取或创建您看到的用户

1720
02:57:59,191 --> 02:58:04,320
当您现在进入我们的用户界面时，让我们进入登录视图

1721
02:58:04,320 --> 02:58:06,960
实例登录视图在这里

1722
02:58:06,960 --> 02:58:12,160
我要删除资源管理器，这样你就可以在这里看到完整的代码

1723
02:58:12,160 --> 02:58:16,479
当我们进行 auth service firebase login 时，如果

1724
02:58:16,479 --> 02:58:21,360
电子邮件已验证是我们现在要去节点路由现在让我们去我们的

1725
02:58:21,360 --> 02:58:25,279
您现在可以看到的笔记视图 笔记视图 它唯一能做的就是

1726
02:58:25,279 --> 02:58:29,279
它正在创建一个带有嗯抱歉的应用栏它正在创建一个带有应用栏的脚手架

1727
02:58:29,279 --> 02:58:34,000
我们有我们的注销按钮，让我们开始吧，让我提出来

1728
02:58:34,000 --> 02:58:40,720
scr cpy 所以我要在登录屏幕中使用我的电子邮件地址所以嗯

1729
02:58:40,720 --> 02:58:46,639
我实际上可能需要去把这个设备连接到 wi-fi 所以繁荣

1730
02:58:46,639 --> 02:58:50,639
我要打开 嗯

1731
02:58:50,639 --> 02:58:56,160
用我的用户登录，所以我要摆脱所有这些

1732
02:58:56,160 --> 02:59:00,720
我要在这里登录使用哎呀，我们已经给你发了一封电子邮件验证

1733
02:59:00,720 --> 02:59:03,279
好吧，也许我应该用

1734
02:59:03,279 --> 02:59:08,000
已经通过验证的用户

1735
02:59:08,000 --> 02:59:12,639
因此，让我们使用您在应用程序 um 的主 ui 中看到的这个用户登录

1736
02:59:12,639 --> 02:59:17,039
我们的应用程序我们有这个hello world，因为

1737
02:59:17,039 --> 02:59:22,720
嗯，你现在可以看到我们笔记的正文部分了

1738
02:59:22,720 --> 02:59:27,119
只是说你好世界，所以你几乎可以说笔记视图有

1739
02:59:27,119 --> 02:59:31,039
目前几乎没有与notes服务联系

1740
02:59:31,039 --> 02:59:36,080
但我们很快就会解决这个问题，首先确保笔记服务允许

1741
02:59:36,080 --> 02:59:40,551
用户界面在转到

1742
02:59:40,551 --> 02:59:44,960
屏幕，所以当我们来到屏幕时，我们需要确保有一个用户

1743
02:59:44,960 --> 02:59:48,479
与当前的 firebase 用户相关联

1744
02:59:48,479 --> 02:59:53,512
在我们的数据库里面没问题所以这就是我们需要的这个小呃

1745
02:59:53,512 --> 02:59:59,119
调用 get 或 create user 的好函数，它在我们的数据库中返回一个数据库用户

1746
02:59:59,119 --> 03:00:04,240
笔记服务，所以我们将在下一章中使用它，所以请记住，好的

1747
03:00:04,240 --> 03:00:08,000
但是我们现在需要创建这个函数

1748
03:00:08,000 --> 03:00:13,600
好吧，让我们去创建这个函数，正如名字所暗示的那样，未来

1749
03:00:13,600 --> 03:00:19,600
和数据库用户，我们会说获取或创建用户，它有一个必需的

1750
03:00:19,600 --> 03:00:23,279
参数我可以看到所需的流电子邮件

1751
03:00:23,279 --> 03:00:27,191
它是一个异步函数，所以嗯

1752
03:00:27,191 --> 03:00:33,440
我们基本上需要看看如何创建这个用户

1753
03:00:33,440 --> 03:00:37,191
所以这里的目标是首先我们尝试

1754
03:00:37,191 --> 03:00:41,039
如果该用户不存在，则从数据库中获取该用户，然后我们将

1755
03:00:41,039 --> 03:00:45,919
创建该用户，然后在这两种情况下，我们都将返回

1756
03:00:45,919 --> 03:00:49,600
获取或创建的用户返回到

1757
03:00:49,600 --> 03:00:54,479
来电者所以让我们进去然后说

1758
03:00:54,479 --> 03:00:58,240
最终用户正在等待

1759
03:00:58,240 --> 03:01:02,800
让用户没事，您会看到电子邮件非常适合那里，但是如果您

1760
03:01:02,800 --> 03:01:06,240
记住 get user 的实现让我们进去并扩展它

1761
03:01:06,240 --> 03:01:08,551
如果找不到用户，那么它

1762
03:01:08,551 --> 03:01:13,831
抛出一个错误说找不到用户是 rq 所以如果那个函数

1763
03:01:13,831 --> 03:01:16,872
抛出那个错误然后我们将创建那个用户所以如果那个用户没有

1764
03:01:16,872 --> 03:01:20,320
它存在于需要创建的数据库中，所以让我们在其中添加一个 try 语句

1765
03:01:20,320 --> 03:01:23,831
在这里，然后我们要说找不到用户

1766
03:01:23,831 --> 03:01:28,000
所以这里是用户所以在这种情况下在尝试

1767
03:01:28,000 --> 03:01:32,160
声明这意味着我们可以让用户没事，所以如果我们得到这个回报

1768
03:01:32,160 --> 03:01:35,679
声明它意味着获取用户函数没有抛出任何异常

1769
03:01:35,679 --> 03:01:39,039
例如在我们找不到我们要去的用户的情况下找不到用户

1770
03:01:39,039 --> 03:01:42,960
实际创建一个用户，所以我们只说创建的用户

1771
03:01:42,960 --> 03:01:48,551
是一种使用该电子邮件创建用户的方法，然后我们会说

1772
03:01:48,551 --> 03:01:54,000
返回创建的用户，如果您也查看创建用户功能

1773
03:01:54,000 --> 03:02:00,800
在这里，我也相信它会抛出是的，所以如果它无法创建该用户，如果

1774
03:02:00,800 --> 03:02:04,800
结果是空的，它只是说用户哦不，这就是我们得到的地方

1775
03:02:04,800 --> 03:02:08,872
用户很抱歉，我们需要看看这个插入，所以

1776
03:02:08,872 --> 03:02:11,919
是的，这是它唯一在做的事情，所以它基本上不会扔任何其他东西

1777
03:02:11,919 --> 03:02:14,960
错误好吧，它唯一能做的就是如果你是

1778
03:02:14,960 --> 03:02:18,000
创建一个已经存在的用户我要画一个错误

1779
03:02:18,000 --> 03:02:21,119
所以在这里我们有哪里，我们最终得到了一个

1780
03:02:21,119 --> 03:02:25,119
try 和 catch 块也可能引发异常

1781
03:02:25,119 --> 03:02:30,320
我们还没有处理好所以你能做的就是做一个完整的捕获

1782
03:02:30,320 --> 03:02:34,960
在这里，然后什么都不做，我非常喜欢这种模式

1783
03:02:34,960 --> 03:02:38,551
代码至少是因为如果我不这样做，那么我实际上就没有

1784
03:02:38,551 --> 03:02:42,399
以后可以调试我的应用程序，所以我不能像断点一样放置

1785
03:02:42,399 --> 03:02:47,039
在这里，如果您不这样做，是否会出现任何其他异常，因为那时

1786
03:02:47,039 --> 03:02:50,872
异常将被抛出给调用者，调用者必须

1787
03:02:50,872 --> 03:02:54,080
处理它，但在这种情况下，我们并没有真正处理我们只是

1788
03:02:54,080 --> 03:02:58,479
抓住它，然后我们把它扔回调用方，这只允许

1789
03:02:58,479 --> 03:03:01,679
如果你想调试你的，你基本上在这里放一个断点

1790
03:03:01,679 --> 03:03:06,639
以后申请还好，所以它只是一个它只是一种相当便宜的制作方式

1791
03:03:06,639 --> 03:03:12,240
对于那些对此感兴趣的人来说，您的代码更容易调试

1792
03:03:12,240 --> 03:03:16,000
好吧，太棒了，我们已经介绍了很多

1793
03:03:16,000 --> 03:03:21,919
还有很多事情要做，但我们已经走了很远，所以恭喜你

1794
03:03:21,919 --> 03:03:24,479
让我们看看这里它说让我们为下一章做好准备

1795
03:03:24,479 --> 03:03:28,720
登录我们需要调用我们的 get 或 create user 函数并让用户

1796
03:03:28,720 --> 03:03:31,039
准备好了，这就是我向你提到的

1797
03:03:31,039 --> 03:03:33,512
之前在我们的笔记视图中

1798
03:03:33,512 --> 03:03:36,960
我们没有任何功能可以创建

1799
03:03:36,960 --> 03:03:40,872
新用户或根据他们的电子邮件获取当前用户（如果他们已经）

1800
03:03:40,872 --> 03:03:45,440
存在于数据库中，这将像实际的呃

1801
03:03:45,440 --> 03:03:50,320
我们将在下一章中做的第一个逻辑，它整合了我们的

1802
03:03:50,320 --> 03:03:53,831
使用笔记服务器查看笔记，因此速度

1803
03:03:53,831 --> 03:03:58,551
我们现在的课程将越来越多地转向笔记视图

1804
03:03:58,551 --> 03:04:04,080
直到我们有一个笔记列表并允许用户创建笔记更新笔记

1805
03:04:04,080 --> 03:04:07,919
这是激动人心的时刻，我们已经走了很远，为此我们做了很多工作

1806
03:04:07,919 --> 03:04:11,279
点嗯，还有很多，但是嗯

1807
03:04:11,279 --> 03:04:14,960
希望你能像这样受到攻击

1808
03:04:14,960 --> 03:04:19,191
课程的节奏越来越好和你

1809
03:04:19,191 --> 03:04:22,399
可以看到为什么我们以我们现在的方式做事

1810
03:04:22,399 --> 03:04:25,679
这样做了，再次恭喜

1811
03:04:25,679 --> 03:04:29,039
如果你想的话，你可以喝点茶点

1812
03:04:29,039 --> 03:04:32,872
再来一杯咖啡茶，下一章见

1813
03:04:32,872 --> 03:04:36,720
大家好，欢迎来到上一期 Flutter 课程的第 29 章

1814
03:04:36,720 --> 03:04:40,872
如您所见，我们使用便笺服务器工作并讨论了流

1815
03:04:40,872 --> 03:04:45,679
和流控制器我们已经付出了你知道很多努力

1816
03:04:45,679 --> 03:04:49,360
在我们的便笺服务中，以便与数据库进行对话并从中读取

1817
03:04:49,360 --> 03:04:52,479
数据库并缓存红色信息

1818
03:04:52,479 --> 03:04:56,240
在我们的笔记中 uh 成员变量所以如果你还没有看过上一章

1819
03:04:56,240 --> 03:04:58,800
我强烈建议你这样做，因为

1820
03:04:58,800 --> 03:05:01,360
在没有看过他的章节的情况下继续这门课程

1821
03:05:01,360 --> 03:05:05,512
按时间顺序让你很难继续，所以

1822
03:05:05,512 --> 03:05:08,639
我将建立在上一章的基础上，就像我们对另一章所做的那样

1823
03:05:08,639 --> 03:05:12,872
章节也是如此，在这一章中，我们将基本上开始投入

1824
03:05:12,872 --> 03:05:17,039
放置呃所有必要的结构，以便

1825
03:05:17,039 --> 03:05:20,399
我们能够显示所有用户生成的注释

1826
03:05:20,399 --> 03:05:24,800
在笔记视图中可以，所以你可以看到我们几乎

1827
03:05:24,800 --> 03:05:29,440
一切就绪，还有一些功能要做，我们也在这个

1828
03:05:29,440 --> 03:05:33,119
在本章的视频中，我们将讨论未来的建设者以及

1829
03:05:33,119 --> 03:05:36,399
流生成器，我认为我们没有谈论过

1830
03:05:36,399 --> 03:05:40,240
在我们讨论未来的构建器之前，流构建器，所以这将是一个

1831
03:05:40,240 --> 03:05:45,039
令人兴奋的是本章要讨论的新事物

1832
03:05:45,039 --> 03:05:48,800
好的，所以我刚刚在

1833
03:05:48,800 --> 03:05:52,160
嗯在上一章的结尾

1834
03:05:52,160 --> 03:05:57,119
我们现在在第 29 章需要做的是

1835
03:05:57,119 --> 03:06:01,191
允许用户进入便笺视图，并在进入便笺 c 时

1836
03:06:01,191 --> 03:06:05,440
现在您会看到，所有人总是要确保该用户存在于我们的数据库中

1837
03:06:05,440 --> 03:06:10,240
我们在这里有firebase，然后我们的用户在进入笔记视图时

1838
03:06:10,240 --> 03:06:14,960
该用户必须使用经过验证的电子邮件地址登录，以便该用户

1839
03:06:14,960 --> 03:06:19,360
存在我们知道该用户存在于firebase中并且有一个经过验证的电子邮件

1840
03:06:19,360 --> 03:06:24,479
地址，但该用户可能不存在于我们的数据库中记住我们要存储

1841
03:06:24,479 --> 03:06:29,600
用户在我们的数据库中生成注释并将它们连接到创建的用户

1842
03:06:29,600 --> 03:06:33,512
这些笔记还可以，所以嗯，所以在进入笔记视图时，我们

1843
03:06:33,512 --> 03:06:38,240
始终需要确保该用户存在于数据库中

1844
03:06:38,240 --> 03:06:40,960
以及如何做到这一点，如果你记得让我带上你不知道的代码

1845
03:06:40,960 --> 03:06:47,360
必须试着记住这一点，所以让我们进入我们的笔记服务，你可以看到

1846
03:06:47,360 --> 03:06:51,600
我们有一个名为获取所有笔记的函数，但我们没有任何功能

1847
03:06:51,600 --> 03:06:56,960
目前例如给我们一个特定用户的笔记，所以

1848
03:06:56,960 --> 03:07:01,039
如果我们想这样做，例如，如果您想获取所有笔记

1849
03:07:01,039 --> 03:07:05,119
特定用户然后我们将使用用户的电子邮件地址，因为如果

1850
03:07:05,119 --> 03:07:09,360
你看看我们的应用程序与 um 合作的方式

1851
03:07:09,360 --> 03:07:13,512
您可以看到的当前用户我们一直在与官员合作，所以我们不是

1852
03:07:13,512 --> 03:07:18,800
直接通过 um firebase，我们的身份验证服务也有一个关闭用户，所以

1853
03:07:18,800 --> 03:07:23,600
让我们看看我们的 auth 并看看 auth 用户，你会看到

1854
03:07:23,600 --> 03:07:28,080
我们的 auth 用户只有一个标志，只是说已通过电子邮件验证

1855
03:07:28,080 --> 03:07:33,191
那么我们如何去调用这个被称为get或create user on的函数

1856
03:07:33,191 --> 03:07:37,360
我们的便笺服务实际上没有我们当前的电子邮件地址

1857
03:07:37,360 --> 03:07:40,240
用户，这就是我们需要做的，我们需要做的

1858
03:07:40,240 --> 03:07:44,872
继续为我们的关闭用户添加一个电子邮件字段

1859
03:07:44,872 --> 03:07:49,119
所以正如标题所示，我们需要将此字段添加到我们的关闭用户

1860
03:07:49,119 --> 03:07:53,191
好的，所以我要稍微改变一下屏幕布局，让你看得更清楚

1861
03:07:53,191 --> 03:07:56,800
让我们继续在其中添加一个新字段，我要看看我的

1862
03:07:56,800 --> 03:08:02,639
还请注意 um 或 user so 并在此处添加一个新字段，我们

1863
03:08:02,639 --> 03:08:06,479
就叫它最后的字符串嗯电子邮件

1864
03:08:06,479 --> 03:08:12,240
就这样并从您的编辑那里获得帮助以添加电子邮件字段

1865
03:08:12,240 --> 03:08:17,360
在此处添加最终字段，因此这也将是必需的参数，例如

1866
03:08:17,360 --> 03:08:20,240
这个，我只是让它像这样需要它，它出现在

1867
03:08:20,240 --> 03:08:25,679
结束完成格式化，在这里我们实际创建我们的

1868
03:08:25,679 --> 03:08:30,240
auth 用户的实例我们要做的是说我们返回一个 auth 用户

1869
03:08:30,240 --> 03:08:34,160
并且电子邮件实际上已经在 firebase 用户中，让我们去 firebase

1870
03:08:34,160 --> 03:08:40,240
用户并查找电子邮件，您会看到有一个名为 email 的 getter 好

1871
03:08:40,240 --> 03:08:45,279
问题是这个电子邮件获取器是可选字符串所以我们需要做

1872
03:08:45,279 --> 03:08:50,000
只是让它成为可选的，也许在我们的关闭用户中也可以，所以在这里

1873
03:08:50,000 --> 03:08:53,279
我们在哪里创建关闭用户，我们只是说电子邮件字段等于

1874
03:08:53,279 --> 03:08:57,512
用户电子邮件并在此处末尾添加逗号，并在此处添加逗号以获取

1875
03:08:57,512 --> 03:09:01,512
格式，所以我们在这里所做的一切都会说我们的

1876
03:09:01,512 --> 03:09:06,551
r auth 用户有一个可选字符串作为其电子邮件，并且该电子邮件字符串被读取

1877
03:09:06,551 --> 03:09:10,551
来自firebase用户，这并不复杂

1878
03:09:10,551 --> 03:09:14,080
好的

1879
03:09:14,080 --> 03:09:18,000
好吧，我们需要做的就是如标题所示转到我们的笔记

1880
03:09:18,000 --> 03:09:23,512
在这里查看并抓取我们的笔记视图，然后我们需要阅读

1881
03:09:23,512 --> 03:09:28,080
当前用户的电子邮件地址没问题，所以我们要做的是说我们的

1882
03:09:28,080 --> 03:09:32,320
auth 用户有一个可选的电子邮件，但我们作为应用程序开发人员确信

1883
03:09:32,320 --> 03:09:36,872
因为我们使用的是电子邮件和密码注册，所以我们确信

1884
03:09:36,872 --> 03:09:41,360
任何最终进入笔记视图的用户都有一个电子邮件地址，所以

1885
03:09:41,360 --> 03:09:45,360
这是我们要做的假设，尽管我们离开了

1886
03:09:45,360 --> 03:09:48,479
让我们看看能不能找到它的用户

1887
03:09:48,479 --> 03:09:52,800
关闭用户这里虽然关闭用户说我可以选择有一个电子邮件但是

1888
03:09:52,800 --> 03:09:56,240
我们总是会说不，电子邮件应该存在，因为我们只是在

1889
03:09:56,240 --> 03:10:01,039
使用电子邮件密码登录方法的那一刻好吧

1890
03:10:01,039 --> 03:10:05,679
为了让这个笔记视图能够调用笔记服务和

1891
03:10:05,679 --> 03:10:09,191
抢或抱歉创建或获取当前

1892
03:10:09,191 --> 03:10:13,759
用户它需要一封电子邮件，所以让我们继续在我们的笔记中公开一个功能

1893
03:10:13,759 --> 03:10:17,039
视图作为标题表示抓取

1894
03:10:17,039 --> 03:10:22,000
用户的电子邮件，所以让我们进入这里，我也将进入我的笔记视图

1895
03:10:22,000 --> 03:10:25,279
我的笔记没问题

1896
03:10:25,279 --> 03:10:29,512
我们要做的只是暴露用户的电子邮件，所以让我们

1897
03:10:29,512 --> 03:10:34,720
只是说字符串获取用户电子邮件

1898
03:10:34,720 --> 03:10:38,639
让我们也摆脱这个side explorer

1899
03:10:38,639 --> 03:10:43,191
我要说的是服务火力基地

1900
03:10:43,191 --> 03:10:47,119
好的服务，我不认为它是进口的，所以让我们看看是不是

1901
03:10:47,119 --> 03:10:50,800
进口的

1902
03:10:50,800 --> 03:10:54,080
关闭服务是的，它是进口的，好吧，这很好

1903
03:10:54,080 --> 03:10:57,831
关于火力基地

1904
03:10:57,831 --> 03:11:01,440
这不可能是平等的，所以这就是为什么它会有点疯狂的火力基地

1905
03:11:01,440 --> 03:11:05,679
然后我们会说当前用户，你会看到这个当前用户现在

1906
03:11:05,679 --> 03:11:09,119
可选，但因为我们是应用程序开发人员，我们确信

1907
03:11:09,119 --> 03:11:12,872
如果您最终进入注释视图，那么您应该有一个当前用户

1908
03:11:12,872 --> 03:11:16,000
这就是我们在前面的步骤中已经确定的，所以如果你看

1909
03:11:16,000 --> 03:11:19,191
在登录屏幕上，例如在我们的登录中

1910
03:11:19,191 --> 03:11:24,479
查看所以我在这里打开登录视图我们说当前用户是否存在并且是

1911
03:11:24,479 --> 03:11:27,759
电子邮件验证为真，然后转到注释视图，以便

1912
03:11:27,759 --> 03:11:31,191
那么我们可以确定在notes视图中我们已经有一个用户了

1913
03:11:31,191 --> 03:11:34,479
所以这个当前在firebase的用户目前

1914
03:11:34,479 --> 03:11:39,279
说是可选的，但我们要快速打开它，好吧，然后我们要

1915
03:11:39,279 --> 03:11:44,639
说电子邮件并强制打开它

1916
03:11:44,639 --> 03:11:48,551
好吧，这就是我们所做的，所以现在我们得到了

1917
03:11:48,551 --> 03:11:54,639
如果你记得在我们的 um 里面，现在用户的电子邮件

1918
03:11:54,639 --> 03:11:58,320
在我们的便笺服务中，我们有两个非常重要的功能

1919
03:11:58,320 --> 03:12:04,872
时刻位于此类的底部，称为打开和关闭

1920
03:12:04,872 --> 03:12:08,872
分别，我们需要确保的是

1921
03:12:08,872 --> 03:12:15,512
在去注释视图时，我们的数据库实际上是打开的，所以我们

1922
03:12:15,512 --> 03:12:20,800
如果

1923
03:12:20,800 --> 03:12:24,551
数据库句柄实际上并没有被创建，所以

1924
03:12:24,551 --> 03:12:28,479
然后让我们转到我们的 uh notes 视图和

1925
03:12:28,479 --> 03:12:31,919
如您所见，这就是我们制作此内容的原因，并注意查看a

1926
03:12:31,919 --> 03:12:37,191
有状态的小部件，因为我们现在需要挂钩的两个生命周期事件

1927
03:12:37,191 --> 03:12:42,000
我们注意到您并在创建此节点时打开我们的数据库 2 和

1928
03:12:42,000 --> 03:12:45,512
然后在处理数据库时关闭数据库

1929
03:12:45,512 --> 03:12:49,039
如标题所示，让我们去覆盖 init 状态函数

1930
03:12:49,039 --> 03:12:52,720
好的，我们要在这里做什么，我们要说

1931
03:12:52,720 --> 03:12:57,512
嗯，现在我们基本上想在我们的

1932
03:12:57,512 --> 03:13:03,360
初始化状态，我们还需要确保它是打开的，所以

1933
03:13:03,360 --> 03:13:07,600
所以让我们看看 呃让我也看看我的笔记

1934
03:13:07,600 --> 03:13:10,160
好吧，嗯

1935
03:13:10,160 --> 03:13:14,000
我们需要在那里打开数据库，所以让我们开始吧

1936
03:13:14,000 --> 03:13:17,600
抓住我们的便笺服务，所以我们现在没有便笺服务，但是

1937
03:13:17,600 --> 03:13:23,831
我们将创建它，所以让我们说一下最后的最后笔记

1938
03:13:23,831 --> 03:13:30,000
所以这是我们的 uh notes view uh undefined class notes 服务

1939
03:13:30,000 --> 03:13:34,080
我们没有导入笔记服务，我们还没有，所以让我们在导入时做吧

1940
03:13:34,080 --> 03:13:38,720
现在这是我们的笔记视图，它抓住了一个节点的实例

1941
03:13:38,720 --> 03:13:44,399
服务器，以便它可以使用它，好吧，嗯

1942
03:13:44,399 --> 03:13:48,000
让我们继续这样做，然后我们要说

1943
03:13:48,000 --> 03:13:52,720
笔记服务等于节点的一个实例

1944
03:13:52,720 --> 03:13:57,759
像这样的服务，然后我们要说 nodeservice.open

1945
03:13:57,759 --> 03:14:01,039
现在这个功能是未来的空白

1946
03:14:01,039 --> 03:14:04,720
你可能真的无法做到

1947
03:14:04,720 --> 03:14:08,800
async 在您的 init 中说明，但我们现在只是说

1948
03:14:08,800 --> 03:14:14,800
open all right 所以打开数据库，这就是我们所要做的，然后我们

1949
03:14:14,800 --> 03:14:18,872
必须照顾关闭数据库所以让我们继续说

1950
03:14:18,872 --> 03:14:23,039
在处理这个 uh notes 意见处理后，我们

1951
03:14:23,039 --> 03:14:27,039
还要关闭数据库，因为我们是飞镖实验室的好公民，所以

1952
03:14:27,039 --> 03:14:30,639
我们不只是要让数据库保持打开状态，所以节点服务和我们

1953
03:14:30,639 --> 03:14:35,440
会说关闭好吧，仅此而已

1954
03:14:35,440 --> 03:14:38,639
我们现在必须做

1955
03:14:38,639 --> 03:14:45,440
好吧，好东西，让我们保存这个，嗯，我也可能会带一个 crcpy

1956
03:14:45,440 --> 03:14:49,191
在这里，我要做的就是做一个

1957
03:14:49,191 --> 03:14:52,960
热重启和

1958
03:14:52,960 --> 03:14:57,679
让我们退出，然后我将使用该用户登录

1959
03:14:57,679 --> 03:15:03,119
再说一次，如果我能拼出pick solitude

1960
03:15:03,119 --> 03:15:07,119
嗯 foo barb 我的密码太可怕了

1961
03:15:07,119 --> 03:15:11,679
在身份验证错误之前提到了这一点

1962
03:15:11,679 --> 03:15:16,639
foo barbaz 可能是因为这个呃电话

1963
03:15:16,639 --> 03:15:21,831
现在没有无线网络所以让我们进去打开无线网络然后我会

1964
03:15:21,831 --> 03:15:24,800
回到这里 Android 手机通常是初始的

1965
03:15:24,800 --> 03:15:28,240
非常快地初始化他们的 wi-fi 站点，所以现在我们应该可以说登录

1966
03:15:28,240 --> 03:15:31,119
我们最终进入了应用程序的主界面，所以这个打开的函数有

1967
03:15:31,119 --> 03:15:34,240
进展顺利，我可以看到我们没有任何

1968
03:15:34,240 --> 03:15:38,080
调试控制台中抛出的异常，所以

1969
03:15:38,080 --> 03:15:42,639
那是打开和关闭的

1970
03:15:42,639 --> 03:15:48,000
所以让我们看看这里，嗯，正如你在标题中看到的那样

1971
03:15:48,000 --> 03:15:52,240
现在我们正在做的是我们就像发布不同的功能

1972
03:15:52,240 --> 03:15:55,919
例如我们的函数让我们看看删除用户它的作用是

1973
03:15:55,919 --> 03:16:00,479
它说 get database or throw um 并且目前这个 get database or

1974
03:16:00,479 --> 03:16:05,679
throw 它所做的唯一事情就是确保该数据库在那里可用

1975
03:16:05,679 --> 03:16:08,639
但它并不能确保该数据库是打开的，因此它只是使

1976
03:16:08,639 --> 03:16:13,360
确保节点中有互联网中的数据库实例

1977
03:16:13,360 --> 03:16:17,191
服务所以我们现在需要确保的是

1978
03:16:17,191 --> 03:16:20,872
与我们的数据库一起工作的每个功能首先确保数据库

1979
03:16:20,872 --> 03:16:25,360
不仅有实例，而且数据库也有

1980
03:16:25,360 --> 03:16:28,960
可以正常打开，因为如果您查看

1981
03:16:28,960 --> 03:16:32,960
对不起，我们有开放的数据库，基本上

1982
03:16:32,960 --> 03:16:36,240
可以将实例设置为该数据库

1983
03:16:36,240 --> 03:16:40,639
所以我们需要做的是创建一个小函数，上面写着确保

1984
03:16:40,639 --> 03:16:45,039
数据库，它叫什么，确保数据库是打开的

1985
03:16:45,039 --> 03:16:47,919
呃，我只是要继续前进，并有一个

1986
03:16:47,919 --> 03:16:55,679
看看我的笔记，确保数据库打开，嗯，让我们看看

1987
03:16:55,679 --> 03:17:00,080
把它放在上面打开，好吧，所以

1988
03:17:00,080 --> 03:17:04,080
如果您和我一起关注，您只需转到打开功能的顶部，然后

1989
03:17:04,080 --> 03:17:09,279
我们只是说future void确保数据库是开放的

1990
03:17:09,279 --> 03:17:13,759
这是一个异步函数

1991
03:17:13,759 --> 03:17:17,119
那么我们要做的就是

1992
03:17:17,119 --> 03:17:21,679
说嗯让我们看看

1993
03:17:21,679 --> 03:17:26,639
我们将在这里放一个 try 块，让我们看看我们的 open

1994
03:17:26,639 --> 03:17:30,479
此刻的函数抛出一个异常，说数据库

1995
03:17:30,479 --> 03:17:33,191
已经打开异常所以我们需要确保我们缓存它

1996
03:17:33,191 --> 03:17:39,679
例外，所以当我们的 uh 我们的 uh notes 视图被热重新加载时

1997
03:17:39,679 --> 03:17:43,679
它不应该一遍又一遍地尝试打开数据库，如果确实如此

1998
03:17:43,679 --> 03:17:46,720
这个打开的函数会抛出异常

1999
03:17:46,720 --> 03:17:51,119
嗯，我们确保 dbs 开放功能是

2000
03:17:51,119 --> 03:17:55,039
会抓住它，它会让它一切都好，所以它所做的就是

2001
03:17:55,039 --> 03:17:58,160
我们只是确保我们不会开放

2002
03:17:58,160 --> 03:18:01,512
一遍又一遍的数据库，因为这只是开销

2003
03:18:01,512 --> 03:18:06,000
所以我们接下来要做的是我们会说等待在这里打开

2004
03:18:06,000 --> 03:18:09,600
在这里我们说我们正在捕获数据库

2005
03:18:09,600 --> 03:18:14,000
已经打开了异常，在这种情况下我们就让它过去吧

2006
03:18:14,000 --> 03:18:20,320
我们只是说对不起，所以现在我们有了这个

2007
03:18:20,320 --> 03:18:25,679
介绍数据库功能是开放的呃这是你的数据库是开放的功能

2008
03:18:25,679 --> 03:18:30,720
我们需要开始使用那个嗯所以让我提出正确的标题所以

2009
03:18:30,720 --> 03:18:34,551
我们需要开始在各种功能中使用确保数据库打开功能

2010
03:18:34,551 --> 03:18:38,720
我们的应用程序让我们先去删除用户

2011
03:18:38,720 --> 03:18:42,399
在这里，我们只是说等待

2012
03:18:42,399 --> 03:18:49,360
确保数据库是打开的，这是第一位的，让我们去创建用户

2013
03:18:49,360 --> 03:18:53,039
嗯，我们有一个叫做创建用户的函数

2014
03:18:53,039 --> 03:18:56,240
在这里，我们将等待确保 db 是

2015
03:18:56,240 --> 03:18:59,919
打开好

2016
03:18:59,919 --> 03:19:03,440
那是创建用户现在让我们去getuser

2017
03:19:03,440 --> 03:19:07,119
如果我出于某种原因可以访问此功能，则可以在此处获取用户

2018
03:19:07,119 --> 03:19:13,360
不能去这里，让我们说等待数据库结束了

2019
03:19:13,360 --> 03:19:18,320
呃 那就是那部分让我们去拿所有的笔记

2020
03:19:18,320 --> 03:19:22,160
函数获取所有笔记并做同样的事情等待

2021
03:19:22,160 --> 03:19:27,440
确保数据库是打开的哦，我也可以看到我实际上并没有打电话

2022
03:19:27,440 --> 03:19:31,119
这个功能，所以让我们确保我已经在其他地方完成了它

2023
03:19:31,119 --> 03:19:35,279
只是要复制该代码并确保 bb 是打开的让我们确保我是

2024
03:19:35,279 --> 03:19:40,160
实际上调用函数，就像我不喜欢把它放在那里

2025
03:19:40,160 --> 03:19:44,320
所以它看起来很好，所以你必须这样做

2026
03:19:44,320 --> 03:19:48,399
节点功能也一样，我们将去创建节点和

2027
03:19:48,399 --> 03:19:52,479
做同样的事情，所以让我们继续等待

2028
03:19:52,479 --> 03:19:56,960
实际上将该代码粘贴在那里等待确保数据库是打开的

2029
03:19:56,960 --> 03:20:01,039
我们需要在 um 中完成，所以我们没有在创建节点中完成

2030
03:20:01,039 --> 03:20:05,119
让我们继续删除节点删除节点

2031
03:20:05,119 --> 03:20:08,551
并将函数粘贴在那里以及抱歉粘贴

2032
03:20:08,551 --> 03:20:13,039
调用函数删除所有节点

2033
03:20:13,039 --> 03:20:18,479
以及删除那里的所有节点做同样的事情，我们也这样做

2034
03:20:18,479 --> 03:20:21,279
在这里得到注释

2035
03:20:21,279 --> 03:20:26,872
同样的事情，我们还有什么，我们还有什么

2036
03:20:26,872 --> 03:20:30,399
在那里更新笔记

2037
03:20:30,399 --> 03:20:35,039
我们第一次打电话

2038
03:20:35,039 --> 03:20:38,479
但是然后呃我们还需要在哪里做呢

2039
03:20:38,479 --> 03:20:43,119
让我们看看我们现在已经完成了删除用户是的我想现在我们放置了确保数据库

2040
03:20:43,119 --> 03:20:46,639
打开所有这些电话

2041
03:20:46,639 --> 03:20:53,512
好的，这是很多信息，所以我们现在需要做的是

2042
03:20:53,512 --> 03:20:58,720
基本上确保我们按照我们在

2043
03:20:58,720 --> 03:21:02,080
本章开头现在你看到了

2044
03:21:02,080 --> 03:21:06,960
我们创建确保数据库打开的原因是在任何这些之前

2045
03:21:06,960 --> 03:21:11,831
函数被调用，我们的代码实际上是要打开数据库

2046
03:21:11,831 --> 03:21:16,399
我们这意味着在我们的笔记视图中我们实际上不必再这样做了，因为

2047
03:21:16,399 --> 03:21:21,191
我们知道，通过向我们的节点服务发出任何与数据库相关的命令

2048
03:21:21,191 --> 03:21:25,191
该函数本身将为我们打开数据库它只是一个

2049
03:21:25,191 --> 03:21:29,119
我们节点服务器中的一个不错的小功能，以确保我们不必制作

2050
03:21:29,119 --> 03:21:35,119
在我们之前打开数据库的额外调用

2051
03:21:35,119 --> 03:21:39,191
开始使用我们的节点服务好吧，这样就方便了一点

2052
03:21:39,191 --> 03:21:42,479
现在我可以作为字幕案例发挥作用

2053
03:21:42,479 --> 03:21:47,759
将谈论未来的构建器和异步快照，嗯，我们已经谈过了

2054
03:21:47,759 --> 03:21:52,399
实际上之前有点关于未来的建设者

2055
03:21:52,399 --> 03:21:57,360
但是呃，未来的建设者是什么，也许实际上你应该把它写在这里

2056
03:21:57,360 --> 03:22:00,960
builder，然后转到代码，这样您就可以更好地看到它

2057
03:22:00,960 --> 03:22:07,759
它是一个有状态的小部件，它的作用是订阅未来

2058
03:22:07,759 --> 03:22:11,039
如果你熟悉 javascript 那么它将在未来返回它的值

2059
03:22:11,039 --> 03:22:13,679
你会知道它是承诺

2060
03:22:13,679 --> 03:22:18,960
呃，如果你熟悉 rx swift 或任何与 rx 相关的东西，那么你就会知道

2061
03:22:18,960 --> 03:22:22,551
可能就像一个单一的或可观察的，实际上不是一个

2062
03:22:22,551 --> 03:22:25,440
可观察的，因为这是一个流构建器，未来的构建器有点像

2063
03:22:25,440 --> 03:22:30,000
单个构建器意味着一个值从某个地方开始，然后

2064
03:22:30,000 --> 03:22:34,320
计算一些东西返回它的值，然后它完成了

2065
03:22:34,320 --> 03:22:37,512
所以未来的建设者允许你提交未来

2066
03:22:37,512 --> 03:22:41,759
它将允许您提交一个构建器，这意味着

2067
03:22:41,759 --> 03:22:45,759
它将产生价值的那段代码作为它所说的未来

2068
03:22:45,759 --> 03:22:50,551
好吧，现在它是我的了，我会订阅它作为它的价值

2069
03:22:50,551 --> 03:22:54,320
未来的变化我会给你返回各种小部件的能力

2070
03:22:54,320 --> 03:22:58,320
需要显示在屏幕上，所以它基本上是联系在一起的

2071
03:22:58,320 --> 03:23:01,512
你未来的逻辑和你的 ui 逻辑所以它是

2072
03:23:01,512 --> 03:23:05,919
绝对漂亮，所以我们现在需要做的是

2073
03:23:05,919 --> 03:23:11,191
确保在您看到的正文中转到我们的构建功能时

2074
03:23:11,191 --> 03:23:16,872
在我们的注释视图的正文中，我们需要确保

2075
03:23:16,872 --> 03:23:22,000
我们正在创建用户或获取当前用户

2076
03:23:22,000 --> 03:23:26,800
数据库中的用户，如果它已经存在并且我们正在创建该用户，如果

2077
03:23:26,800 --> 03:23:30,639
该用户不存在，如果您还记得我们有此功能

2078
03:23:30,639 --> 03:23:35,919
它已经被称为获取或创建某物某事获取或创建

2079
03:23:35,919 --> 03:23:41,279
用户，这是一个未来，所以我们将在我们的 uh 笔记中创建一个未来的构建器

2080
03:23:41,279 --> 03:23:45,831
订阅自己返回的值的视图 this 然后它

2081
03:23:45,831 --> 03:23:49,919
将告诉我们各种更新，这些不同的更新将是

2082
03:23:49,919 --> 03:23:54,720
作为所谓的异步快照提供给我们的异步快照是

2083
03:23:54,720 --> 03:23:58,639
基本上，正如它的名字所表明的那样，它是一个包装器，作为围绕

2084
03:23:58,639 --> 03:24:02,639
异步功能，在这种情况下是我们的未来

2085
03:24:02,639 --> 03:24:07,440
获取或创建用户，这就是我们将在我们的

2086
03:24:07,440 --> 03:24:11,679
注释视图，如您在

2087
03:24:11,679 --> 03:24:16,000
标题我们现在要在节点视图中返回一个未来的构建器。

2088
03:24:16,000 --> 03:24:21,279
实际上应该说注释查看注释下划线

2089
03:24:21,279 --> 03:24:24,000
查看所以我也要修复标题

2090
03:24:24,000 --> 03:24:29,512
我不会混淆任何人，包括我自己和笔记视图

2091
03:24:29,512 --> 03:24:32,240
所以现在最好我为此道歉

2092
03:24:32,240 --> 03:24:35,279
所以现在我们有这个你好世界但是

2093
03:24:35,279 --> 03:24:39,360
我们要改变它，让它返回一个笔记视图，所以我要说对不起

2094
03:24:39,360 --> 03:24:43,600
未来的建设者，假设我们现在返回一个未来的建设者

2095
03:24:43,600 --> 03:24:46,551
现在它说好的，我们必须提供两个参数

2096
03:24:46,551 --> 03:24:50,551
是未来另一个实际上是构建器功能所以构建器

2097
03:24:50,551 --> 03:24:52,872
对不起，未来本身就是

2098
03:24:52,872 --> 03:24:56,800
你看到未来是我们的笔记服务

2099
03:24:56,800 --> 03:25:02,000
如果您记得是当前用户的电子邮件，请获取或创建用户和电子邮件

2100
03:25:02,000 --> 03:25:06,639
我们为被调用的用户电子邮件创建了一个 getter 的地址，所以让我们把它

2101
03:25:06,639 --> 03:25:10,639
在那里用户电子邮件，然后你可以看到它仍然在抱怨说

2102
03:25:10,639 --> 03:25:14,320
尚未提供构建器功能

2103
03:25:14,320 --> 03:25:17,279
所以让我们说我们有一个构建器函数

2104
03:25:17,279 --> 03:25:21,512
就在那里，我谈到了异步快照，因为那是参数

2105
03:25:21,512 --> 03:25:27,831
你进入这里的是现在对象的异步快照快照

2106
03:25:27,831 --> 03:25:34,080
但我们会解决这个问题，所以我们就在这里

2107
03:25:34,080 --> 03:25:39,831
然后让我们在这里讨论一下这个功能

2108
03:25:39,831 --> 03:25:43,119
所以在我们获取当前用户或创建后

2109
03:25:43,119 --> 03:25:48,000
一个新用户，如果该用户在我们的数据库中不存在，我们还需要获取所有

2110
03:25:48,000 --> 03:25:51,679
该用户的节点和

2111
03:25:51,679 --> 03:25:56,000
我们现在没有功能

2112
03:25:56,000 --> 03:26:00,000
拥有当前用户的所有节点流，我们将添加它

2113
03:26:00,000 --> 03:26:03,831
很快，但正如您在缓存中看到的那样，我们可以通过我们的流实现这一点

2114
03:26:03,831 --> 03:26:08,080
我们已经在我们的节点中放置的控制器作为基础

2115
03:26:08,080 --> 03:26:11,440
服务所以让我们去创造一点

2116
03:26:11,440 --> 03:26:15,831
我们的笔记服务中的功能 dot dart

2117
03:26:15,831 --> 03:26:20,479
正如你所看到的，它允许你检索所有的笔记，所以

2118
03:26:20,479 --> 03:26:24,080
我们只会说流

2119
03:26:24,080 --> 03:26:29,279
像这样的数据库注释列表

2120
03:26:29,279 --> 03:26:34,720
我们它是一个吸气剂，我们称它为所有的笔记都可以，它的作用是

2121
03:26:34,720 --> 03:26:39,600
本身将订阅这个笔记流控制器并检索所有

2122
03:26:39,600 --> 03:26:42,872
来自该控制器的注释，因为请记住此注释流控制器

2123
03:26:42,872 --> 03:26:46,800
它本身就包含了这个家伙

2124
03:26:46,800 --> 03:26:50,320
所以这就是我们要做的我们要说它返回节点

2125
03:26:50,320 --> 03:26:54,240
流控制器流

2126
03:26:54,240 --> 03:26:58,639
实际上，另一个流得到所有的东西都不是很抱歉这是错误的

2127
03:26:58,639 --> 03:27:01,600
和流

2128
03:27:01,600 --> 03:27:04,720
好的

2129
03:27:04,720 --> 03:27:09,679
所以这是我们获取所有笔记的吸气剂，嗯，现在我们需要做的是

2130
03:27:09,679 --> 03:27:15,600
现在我们已经在 note2.dart 中创建了我们的 uh so back to back

2131
03:27:15,600 --> 03:27:19,279
创建了我们的用户

2132
03:27:19,279 --> 03:27:26,160
我们需要确保的是，如果可以创建用户，那么我们就是

2133
03:27:26,160 --> 03:27:30,320
将使用称为流构建器的东西来检索所有

2134
03:27:30,320 --> 03:27:34,160
节点服务中的节点，然后将它们呈现在屏幕上

2135
03:27:34,160 --> 03:27:37,600
但是我们还不能渲染它们我们没有任何用户生成的内容而且我们

2136
03:27:37,600 --> 03:27:41,119
还不知道如何渲染它们，所以首先让我们处理一下

2137
03:27:41,119 --> 03:27:45,679
这里这个快照在这里我们需要做的是说如果 snapchat

2138
03:27:45,679 --> 03:27:51,600
连接状态是连接状态点完成

2139
03:27:51,600 --> 03:27:53,919
像这样嗯

2140
03:27:53,919 --> 03:27:57,440
如果是这样的话，那么我们将在这里做一些逻辑，所以让我们说

2141
03:27:57,440 --> 03:28:03,360
现在返回一个你好的文本好吧实际上我们可能需要切换它所以

2142
03:28:03,360 --> 03:28:07,679
让我们说开关

2143
03:28:07,679 --> 03:28:12,872
快照点连接状态，我真的很想得到呃视觉工作室代码

2144
03:28:12,872 --> 03:28:16,080
为我完成剩下的，所以我不喜欢写所有的案例，所以我只是

2145
03:28:16,080 --> 03:28:19,831
我会说命令点或在 Mac 上或在 Linux 和 Windows 上控制点我说

2146
03:28:19,831 --> 03:28:24,240
添加缺少的案例条款，在完成的情况下，我只想说返回

2147
03:28:24,240 --> 03:28:28,720
如果创建或检索

2148
03:28:28,720 --> 03:28:32,960
当前用户已完成，然后返回此文本 hello

2149
03:28:32,960 --> 03:28:38,160
在任何其他情况下，例如在默认情况下

2150
03:28:38,160 --> 03:28:43,679
我们只是要返回一个循环进度指示器，就像

2151
03:28:43,679 --> 03:28:48,399
那好吧，那我就完成了

2152
03:28:48,399 --> 03:28:52,399
上面那个就好了

2153
03:28:52,399 --> 03:28:59,039
然后让我们进行热重启，我可以看到我的 um scrcpy 有点崩溃了

2154
03:28:59,039 --> 03:29:03,279
是的，有时会发生这样的事情，没关系，让我继续吧

2155
03:29:03,279 --> 03:29:08,080
回到这个 shell 并说 hcr cpy

2156
03:29:08,080 --> 03:29:11,600
该应用程序运行良好，只是 scr cpy 波峰，所以我只是

2157
03:29:11,600 --> 03:29:15,440
我会说你的笔记现在会出现在这里

2158
03:29:15,440 --> 03:29:19,831
command 实际上我的调试过程已经崩溃了

2159
03:29:19,831 --> 03:29:22,551
好吧，所以我现在要运行该应用程序

2160
03:29:22,551 --> 03:29:25,759
再次

2161
03:29:25,759 --> 03:29:29,360
希望这个 gradle 任务进展得很快，因为我们已经

2162
03:29:29,360 --> 03:29:32,320
已经编译了之前的应用程序

2163
03:29:32,320 --> 03:29:37,191
所以我们需要做什么你看我们现在正在确保用户

2164
03:29:37,191 --> 03:29:40,960
如果它不存在，则在数据库中创建，或者如果存在我们正在获取用户

2165
03:29:40,960 --> 03:29:46,000
用户存在于数据库中，但我们还需要做的是开始收听

2166
03:29:46,000 --> 03:29:50,720
在我们的笔记服务中更改此流，称为所有节点和

2167
03:29:50,720 --> 03:29:55,759
根据该流的状态，然后我们将构建我们的用户

2168
03:29:55,759 --> 03:30:00,960
界面没问题，所以在这里我们实际上不会像这样返回

2169
03:30:00,960 --> 03:30:05,360
嘿，你的笔记会出现在这里，但我们实际上会使用

2170
03:30:05,360 --> 03:30:10,320
流构建器，它与未来的构建器非常相似，但它实际上会监听

2171
03:30:10,320 --> 03:30:14,399
更改为流好

2172
03:30:14,399 --> 03:30:18,399
所以哎呀，我只是杀死了应用程序

2173
03:30:18,399 --> 03:30:21,191
就在这里，所以我们去你的笔记会出现

2174
03:30:21,191 --> 03:30:24,551
在这里，这似乎工作正常，所以让我们

2175
03:30:24,551 --> 03:30:29,831
进去然后说我们想嗯

2176
03:30:29,831 --> 03:30:32,872
返回我们的流生成器​​，我要放这个

2177
03:30:32,872 --> 03:30:37,191
回过头来，在我们这样做之前，我想解释一下我已经

2178
03:30:37,191 --> 03:30:42,080
显示在标题中的等待和黎明标志是什么

2179
03:30:42,080 --> 03:30:45,679
您看到的流构建器和未来的连接状态

2180
03:30:45,679 --> 03:30:49,440
builder 使用称为异步快照的东西，这就是你看到的这个人

2181
03:30:49,440 --> 03:30:53,919
异步快照和这个异步快照可以有各种连接状态，所以如果

2182
03:30:53,919 --> 03:30:58,000
你在那里进入连接状态，你可以看到我们没有等待活动

2183
03:30:58,000 --> 03:31:03,600
做得很好

2184
03:31:03,600 --> 03:31:07,119
当你当你看到在一个活跃的情况下说例如一个

2185
03:31:07,119 --> 03:31:10,872
已返回至少一个值但尚未完成的流

2186
03:31:10,872 --> 03:31:17,440
所以那是为了一个流，呃，但是如果你在等待一个未来或者

2187
03:31:17,440 --> 03:31:21,360
一个流然后你会得到这个等待标志，它会发生

2188
03:31:21,360 --> 03:31:26,639
给你一个未来，一个已经完成任务的未来，就像我说的那样

2189
03:31:26,639 --> 03:31:30,551
一些东西，它完成了，但一个流通常它只是继续生活，所以你

2190
03:31:30,551 --> 03:31:34,399
不喜欢挂钩，或者您不应该挂钩到流的完成事件

2191
03:31:34,399 --> 03:31:39,440
但你实际上应该挂在你的等待中

2192
03:31:39,440 --> 03:31:42,479
连接状态，这就是我们要做的，所以连接保持完成

2193
03:31:42,479 --> 03:31:46,872
嗯的一个未来和一个连接状态是

2194
03:31:46,872 --> 03:31:51,279
等待流所以在这里让我们创建一个

2195
03:31:51,279 --> 03:31:55,919
流生成器和我们的流

2196
03:31:55,919 --> 03:32:03,440
将成为我们的笔记服务所有笔记嗯

2197
03:32:03,440 --> 03:32:08,080
这就是流本身，然后我们需要一个构建器，让我们来看看

2198
03:32:08,080 --> 03:32:13,279
工作室为我们完成，嗯，好吧，在建设者中我们要做什么

2199
03:32:13,279 --> 03:32:19,119
做的是我们要说切换快照连接状态

2200
03:32:19,119 --> 03:32:22,320
像这样获取visual studio代码来为你完成剩下的

2201
03:32:22,320 --> 03:32:26,479
在等待的情况下

2202
03:32:26,479 --> 03:32:30,639
我们只会说返回

2203
03:32:30,639 --> 03:32:36,160
暂停文本等待所有笔记

2204
03:32:36,160 --> 03:32:40,551
好的，我要从这里删除休息

2205
03:32:40,551 --> 03:32:45,191
在任何其他情况下，在默认情况下，我们只会说

2206
03:32:45,191 --> 03:32:50,320
返回循环进度指示器就像

2207
03:32:50,320 --> 03:32:54,320
所以现在你看看我是否命令 s 变热

2208
03:32:54,320 --> 03:32:58,800
重新加载然后它只是说等待所有节点出现在屏幕上所以

2209
03:32:58,800 --> 03:33:04,800
这现在就像我们应用程序的注释视图的骨架，因此它

2210
03:33:04,800 --> 03:33:08,551
处理两件事情，它让当前用户使用他或她的电子邮件

2211
03:33:08,551 --> 03:33:11,679
如果该用户已存在于数据库中或创建它，则地址为

2212
03:33:11,679 --> 03:33:16,320
未来构建器和未来返回的小部件

2213
03:33:16,320 --> 03:33:20,960
builder 本身就是一个流构建器，因此流构建器然后计算

2214
03:33:20,960 --> 03:33:25,512
所有节点并从节点服务返回它们，然后它有一个

2215
03:33:25,512 --> 03:33:28,960
连接状态和等待现在又说等待所有

2216
03:33:28,960 --> 03:33:31,360
节点，我们稍后会改变它

2217
03:33:31,360 --> 03:33:34,872
所以，所以，呃

2218
03:33:34,872 --> 03:33:38,240
它不只是返回一个文本它实际上返回一个笔记列表

2219
03:33:38,240 --> 03:33:42,320
那么现在让我们谈谈别的

2220
03:33:42,320 --> 03:33:46,872
在我们结束这一章之前，你现在看到我们正在做的是

2221
03:33:46,872 --> 03:33:53,039
我们说我们的便笺服务是这里的一项新服务，所以每次

2222
03:33:53,039 --> 03:33:57,679
如果我在这里命令 s 或者您进行了热重载或热，则进入初始化状态

2223
03:33:57,679 --> 03:34:01,119
在这里重启实际上是热重启这个

2224
03:34:01,119 --> 03:34:04,399
我可以看到也许这就是我们使整个应用程序崩溃的原因，因为

2225
03:34:04,399 --> 03:34:07,360
我们正在创建一个新的节点服务，这可能是我可以看到热的原因

2226
03:34:07,360 --> 03:34:11,919
重启现在有点不稳定所以嗯，这就是原因

2227
03:34:11,919 --> 03:34:15,191
如果你不熟悉什么

2228
03:34:15,191 --> 03:34:19,759
单例是单例本质上是软件开发中使用的一种模式

2229
03:34:19,759 --> 03:34:24,872
您在其中创建服务实例或类实例

2230
03:34:24,872 --> 03:34:30,240
该类实例现在只是整个应用程序中的一个

2231
03:34:30,240 --> 03:34:33,759
在我们的应用程序中的任何地方，我们都可以去创建一个新的节点服务实例

2232
03:34:33,759 --> 03:34:38,000
但是如果您考虑一下，节点服务应该只作为一个副本存在

2233
03:34:38,000 --> 03:34:41,360
整个应用程序不应该像制作此笔记的新副本

2234
03:34:41,360 --> 03:34:44,720
一遍又一遍地服务，这就是单例，这就是

2235
03:34:44,720 --> 03:34:50,320
我们将使用我们的便笺服务，所以我知道我有一点问题

2236
03:34:50,320 --> 03:34:53,440
和我的嗯

2237
03:34:53,440 --> 03:34:56,399
字幕，我将带来下一个字幕并修复它

2238
03:34:56,399 --> 03:35:00,720
所以让我们先继续，呃，在我运行应用程序之前，也许我们

2239
03:35:00,720 --> 03:35:04,080
应该用我们的单例解决这个问题，所以让我们转到我们的注释

2240
03:35:04,080 --> 03:35:08,320
服务，我们现在要创建一个

2241
03:35:08,320 --> 03:35:12,800
各种语言的单例模式我的意思是它与语言不同

2242
03:35:12,800 --> 03:35:16,872
在我看来，对你说实话，飞镖并不像应该的那样干净

2243
03:35:16,872 --> 03:35:22,240
例如它在诸如 swift um 之类的语言中，但它就是这样，我们需要

2244
03:35:22,240 --> 03:35:26,551
有点像现在这样工作

2245
03:35:26,551 --> 03:35:30,000
所以我们这样做的方式是我们做我们的

2246
03:35:30,000 --> 03:35:35,512
课堂笔记服务单身人士继续前进

2247
03:35:35,512 --> 03:35:40,080
首先为我们的类创建一个私有构造函数，所以我们要去

2248
03:35:40,080 --> 03:35:45,039
说注意服务下划线只是一个

2249
03:35:45,039 --> 03:35:48,639
共享实例，这只是一个函数名

2250
03:35:48,639 --> 03:35:52,551
只是这个类的私有初始化器

2251
03:35:52,551 --> 03:35:55,440
然后我们要做的是我们要说静态

2252
03:35:55,440 --> 03:35:58,831
最后的笔记

2253
03:35:58,831 --> 03:36:03,600
服务，所以我们正在创建一个共享实例，我们要说注释

2254
03:36:03,600 --> 03:36:06,800
服务获得了共享实例，因此这会创建

2255
03:36:06,800 --> 03:36:10,800
为我们共享实例，但外界没有人能够

2256
03:36:10,800 --> 03:36:15,039
然后给这两个打电话，因为他们很私密，所以现在我们要走了

2257
03:36:15,039 --> 03:36:18,960
要创建一个工厂构造函数，我们将把它称为笔记服务

2258
03:36:18,960 --> 03:36:22,399
就像那样，这将为我们返回一个共享实例，所以它只是一个

2259
03:36:22,399 --> 03:36:26,240
在我看来，老实说，至少这是一种 hacky 方式

2260
03:36:26,240 --> 03:36:31,759
创建一个单例，但至少现在它在飞镖中是这样工作的

2261
03:36:31,759 --> 03:36:35,679
好吧，现在我们已经创建了我们的单例，所以我们可以做的是我

2262
03:36:35,679 --> 03:36:38,720
意味着我们不必对这个人的初始化状态做任何改变，因为

2263
03:36:38,720 --> 03:36:43,039
现在它正在构建节点服务，我们

2264
03:36:43,039 --> 03:36:47,600
已经改变了，所以任何像这样调用节点服务的人实际上都是

2265
03:36:47,600 --> 03:36:51,831
来到工厂构造函数，然后依次返回这个共享

2266
03:36:51,831 --> 03:36:55,831
实例反过来调用这个私有工厂，它会导致私有

2267
03:36:55,831 --> 03:36:59,759
初始化器或构造器，所以它就像一个三层

2268
03:36:59,759 --> 03:37:05,360
为了创建一个单例，我们做得很好

2269
03:37:05,360 --> 03:37:10,479
我的意思是我们也可以在这一切进行时尝试运行应用程序

2270
03:37:10,479 --> 03:37:16,160
我可以再次调出 scr cpy，如果它做得更好，请在这里调出

2271
03:37:16,160 --> 03:37:18,000
可以，然后呢

2272
03:37:18,000 --> 03:37:22,399
我们已经做了很多工作 我们为下一章奠定了基础

2273
03:37:22,399 --> 03:37:27,512
所以现在我们有能力连接到我们数据库中的所有可用笔记

2274
03:37:27,512 --> 03:37:31,279
它由流和流控制器控制，然后我们

2275
03:37:31,279 --> 03:37:37,440
能够然后我们能够使用这个在屏幕上显示这些注释

2276
03:37:37,440 --> 03:37:41,831
我现在正在尝试找到的流生成器​​就在这里，好吧

2277
03:37:41,831 --> 03:37:45,119
我们已经做了很多工作，对你坚持我做得很好

2278
03:37:45,119 --> 03:37:50,551
贯穿本章，就像我们在做的传统一样

2279
03:37:50,551 --> 03:37:54,399
在每一章结束时，我们都会提交我们的工作并标记

2280
03:37:54,399 --> 03:37:57,191
他们所以让我们继续做那我要改变

2281
03:37:57,191 --> 03:38:00,720
屏幕布局一点点摆脱cr cpy 已经一点点了

2282
03:38:00,720 --> 03:38:05,831
今天对我们生气这个 scr cpy 和这里的屏幕布局，我

2283
03:38:05,831 --> 03:38:11,191
会增加它的字体大小和一个新的外壳，所以在

2284
03:38:11,191 --> 03:38:15,759
上一章我们呃承诺并将我们的工作标记为

2285
03:38:15,759 --> 03:38:20,551
第 11 步我相信所以如果你说 git tag 你可以看到我们已经到第 11 步了。让我们

2286
03:38:20,551 --> 03:38:25,360
继续说 git status 首先是的一些文件已被修改

2287
03:38:25,360 --> 03:38:29,512
然后我们添加所有文件然后我们说

2288
03:38:29,512 --> 03:38:34,551
这次是第 12 步，我们推动我们的改变

2289
03:38:34,551 --> 03:38:38,800
然后我们将标记我们的工作以及步骤

2290
03:38:38,800 --> 03:38:44,000
12 然后我们推动我们的攻击

2291
03:38:44,000 --> 03:38:48,720
太棒了，现在又做得很好，嗯，我们在每一个结束时都做了什么

2292
03:38:48,720 --> 03:38:52,160
章节是我们谈了一点我们接下来要谈的内容

2293
03:38:52,160 --> 03:38:55,679
章节和标题表明我们要

2294
03:38:55,679 --> 03:38:58,399
呃，我们已经完成了笔记的基础知识

2295
03:38:58,399 --> 03:39:02,080
但我们没有数据，这就是我们接下来要解决的补救措施

2296
03:39:02,080 --> 03:39:06,639
本章我们将讨论如何允许用户按下按钮

2297
03:39:06,639 --> 03:39:11,119
例如，为了创建一个新的便笺，然后该便笺出现在我们的

2298
03:39:11,119 --> 03:39:15,831
流生成器并显示给用户

2299
03:39:15,831 --> 03:39:19,919
也许你想休息一下，喝点点心，请这样做，然后

2300
03:39:19,919 --> 03:39:24,080
下一章见大家好，欢迎来到第30章

2301
03:39:24,080 --> 03:39:27,919
在前几章的 Flutter 课程中，我们已经做了很多工作

2302
03:39:27,919 --> 03:39:31,679
使用我们的数据库层，我们也一直在使用 ui 以便

2303
03:39:31,679 --> 03:39:36,399
有点确保我们可以有一个笔记清单，嗯，但正如你所知道的

2304
03:39:36,399 --> 03:39:39,919
在前面的章节中看到我们没有注释或

2305
03:39:39,919 --> 03:39:43,600
我们实际上没有能力让用户创建这些

2306
03:39:43,600 --> 03:39:47,831
笔记 所以从本章开始我们将开始创作

2307
03:39:47,831 --> 03:39:51,191
用户可以输入的某种用户界面

2308
03:39:51,191 --> 03:39:55,039
他们的笔记和这些笔记将保存在我们的四服务器上

2309
03:39:55,039 --> 03:39:59,039
我们在前一章中创建了

2310
03:39:59,039 --> 03:40:03,279
在我们继续之前，让我们现在处理一件事，我们的笔记视图

2311
03:40:03,279 --> 03:40:07,360
真的没有合适的标题我要把代码带到这里

2312
03:40:07,360 --> 03:40:12,720
在屏幕上，所以你也可以看到它，我会带上 scrcpy，你可以

2313
03:40:12,720 --> 03:40:18,160
让您的模拟器或模拟器 um 或实际设备出现在屏幕上，这样就可以了

2314
03:40:18,160 --> 03:40:22,320
也很好，让我们在这里重新安排一下，我

2315
03:40:22,320 --> 03:40:27,360
还将在此处重新排列屏幕，以便您现在可以更好地查看代码

2316
03:40:27,360 --> 03:40:32,240
ui 和我们的 main ui 的标题只是说 main ui 所以让我们保重

2317
03:40:32,240 --> 03:40:36,320
那就是里面的笔记查看飞镖

2318
03:40:36,320 --> 03:40:41,440
让我们找到我们正在创建应用栏的位置，这里我们说的是 main ui 所以

2319
03:40:41,440 --> 03:40:44,800
标题表明我们会将其更改为您的笔记

2320
03:40:44,800 --> 03:40:50,479
像这样和命令的热重载然后我们可以看到你的笔记出现在那里

2321
03:40:50,479 --> 03:40:55,759
所以这部分现在已经完成了

2322
03:40:55,759 --> 03:41:00,240
现在让我们看看我们将如何让用户在我们的

2323
03:41:00,240 --> 03:41:03,440
你看到的应用程序

2324
03:41:03,440 --> 03:41:06,320
有不同的方式去做，就像一些

2325
03:41:06,320 --> 03:41:10,320
将显示称为浮动操作的应用程序

2326
03:41:10,320 --> 03:41:14,872
按钮 浮动操作按钮是通常出现在

2327
03:41:14,872 --> 03:41:19,679
如果您的语言是从左到右的，或者如果您的语言是从左到右的

2328
03:41:19,679 --> 03:41:23,600
你有像你写的那样的阿拉伯语波斯语的阿拉伯语语言

2329
03:41:23,600 --> 03:41:27,919
从右到左然后浮动操作按钮应该出现在左下角所以

2330
03:41:27,919 --> 03:41:32,000
它有点像一个浮在屏幕上的按钮

2331
03:41:32,000 --> 03:41:37,279
嗯，通常这就像你的 um 不适合你的主

2332
03:41:37,279 --> 03:41:40,399
ui uh 但是它有时会进入

2333
03:41:40,399 --> 03:41:43,512
中途所以嗯

2334
03:41:43,512 --> 03:41:47,440
例如，如果您有一个笔记列表，并且这些笔记可以喜欢它们的标题

2335
03:41:47,440 --> 03:41:52,160
可以转到几行文本然后你有一个浮动按钮

2336
03:41:52,160 --> 03:41:55,360
就像在屏幕底部一样，它可能会再次阻止

2337
03:41:55,360 --> 03:41:58,720
你的内容，所以有些人不喜欢浮动动作

2338
03:41:58,720 --> 03:42:02,240
按钮和浮动条操作按钮是

2339
03:42:02,240 --> 03:42:04,800
通常它们通常出现在android中

2340
03:42:04,800 --> 03:42:08,720
应用程序是我认为它来自谷歌的材料设计我可以

2341
03:42:08,720 --> 03:42:12,160
这是错误的，但通常你不会在 ios 应用程序中看到它们，并且

2342
03:42:12,160 --> 03:42:16,000
因为我们正在开发我们的应用程序，以便对 ios 和

2343
03:42:16,000 --> 03:42:19,119
android 用户，我们暂时不打算使用浮动操作按钮，但是

2344
03:42:19,119 --> 03:42:22,551
需要明确的是，浮动动作确实没有错

2345
03:42:22,551 --> 03:42:27,360
按钮所以我们可以做的是我们可以

2346
03:42:27,360 --> 03:42:32,399
进入我们已经注销的菜单并在这里创建一个新项目

2347
03:42:32,399 --> 03:42:37,039
说例如加号或添加添加新注释或类似的东西

2348
03:42:37,039 --> 03:42:41,759
对不起，我也将这个添加到呃请勿打扰，所以我们也可以

2349
03:42:41,759 --> 03:42:46,639
在此处添加一个项目，上面写着添加类似的注释，或者我们可以去

2350
03:42:46,639 --> 03:42:49,831
这个栏，我们在这里有我们的应用栏

2351
03:42:49,831 --> 03:42:54,240
并添加一个新项目，就像我们有这三个垂直

2352
03:42:54,240 --> 03:42:58,800
点我们可以在那里添加一个新项目

2353
03:42:58,800 --> 03:43:02,160
所以现在它涉及到一种喜欢的偏好

2354
03:43:02,160 --> 03:43:06,000
以及为什么我们应该添加的某种推理

2355
03:43:06,000 --> 03:43:10,551
加号按钮，我们将添加它的方式以及我背后的推理

2356
03:43:10,551 --> 03:43:15,360
想放加号按钮，但喜欢在这个旁边

2357
03:43:15,360 --> 03:43:20,080
这些垂直的三个点是添加一个新的音符很像

2358
03:43:20,080 --> 03:43:24,551
用户希望在您的应用程序的主要用户中执行的主要任务之一

2359
03:43:24,551 --> 03:43:29,679
界面，所以他们要么进入这里删除他们的笔记更新他们的

2360
03:43:29,679 --> 03:43:33,119
笔记或添加新笔记，所以他们要做三件事

2361
03:43:33,119 --> 03:43:38,551
删除笔记通常并不常见，因此更新笔记并添加新笔记

2362
03:43:38,551 --> 03:43:43,191
注释应该就像您的用户在您的主要操作中执行的主要操作

2363
03:43:43,191 --> 03:43:47,279
应用程序 ui 所以它应该是非常即时的 它应该是非常

2364
03:43:47,279 --> 03:43:51,600
用户很容易做到这一点，所以如果你在这里放一个加号按钮

2365
03:43:51,600 --> 03:43:56,872
除了这三个垂直点，用户只需单击一下即可

2366
03:43:56,872 --> 03:44:01,360
转到新屏幕以创建一个新节点但是如果你像添加

2367
03:44:01,360 --> 03:44:04,720
到这里的注释菜单然后他们必须先做

2368
03:44:04,720 --> 03:44:09,831
一个选项卡转到此处，然后另一个选项卡以创建转到下一个

2369
03:44:09,831 --> 03:44:13,039
屏幕，这就像一个额外的标签

2370
03:44:13,039 --> 03:44:19,512
这就是我们要在这三个垂直点旁边添加一个加号按钮的地方

2371
03:44:19,512 --> 03:44:23,759
所以在我们开始之前让我们继续

2372
03:44:23,759 --> 03:44:27,759
为此做一些准备，所以我们需要一个小部件，这将是我们的

2373
03:44:27,759 --> 03:44:32,080
新的笔记视图，正如你所看到的，我们将在里面为它创建一个新文件

2374
03:44:32,080 --> 03:44:38,872
lib views notes 这是一个我相信我们以前没有的新文件夹

2375
03:44:38,872 --> 03:44:42,800
让我们进去吧，我们有您可以看到的视图，但我们没有文件夹

2376
03:44:42,800 --> 03:44:47,039
称为注释，以便查看我们现在要创建的内容

2377
03:44:47,039 --> 03:44:51,512
这个 dart 文件是新节点视图吗，所以我要右键单击它并说

2378
03:44:51,512 --> 03:44:55,119
在这里，我要说一个我们还没有的名为 notes 的文件夹

2379
03:44:55,119 --> 03:45:00,479
我要说新的笔记视图点dart好的所以那是那个文件了

2380
03:45:00,479 --> 03:45:04,080
我们还不会在那个文件中做任何事情

2381
03:45:04,080 --> 03:45:09,679
现在我们在视图下有了我们的笔记文件夹

2382
03:45:09,679 --> 03:45:13,759
感觉将我们的笔记视图也移动到这里

2383
03:45:13,759 --> 03:45:19,440
在视图下你可以看到这里的面包屑说 lib views notes view it makes

2384
03:45:19,440 --> 03:45:24,639
现在感觉将这个笔记视图移动到这个笔记中，这是我们的笔记列表

2385
03:45:24,639 --> 03:45:29,512
文件夹也是如此，所以我需要您只需拖动该文件并将其放置

2386
03:45:29,512 --> 03:45:34,639
在notes文件夹里面没问题

2387
03:45:34,639 --> 03:45:39,512
好的，对不起，我们现在已经这样做了

2388
03:45:39,512 --> 03:45:43,191
嗯，现在如果我带来你可能会注意到什么

2389
03:45:43,191 --> 03:45:45,679
现在我们已经把列表高了一点

2390
03:45:45,679 --> 03:45:48,320
这样做也让我们确保我们没有

2391
03:45:48,320 --> 03:45:51,191
打破任何呃进口

2392
03:45:51,191 --> 03:45:55,512
笔记视图哦，我知道这真的很棒，因为通过拖动笔记视图

2393
03:45:55,512 --> 03:45:58,720
进入笔记文件夹视觉工作室是

2394
03:45:58,720 --> 03:46:03,679
足够聪明，可以重构我们所指的所有导入

2395
03:46:03,679 --> 03:46:07,831
注释视图，以便您选择编辑器，例如您使用的是 sublime 还是

2396
03:46:07,831 --> 03:46:12,080
例如，使用一些 vim 可能无法自动处理

2397
03:46:12,080 --> 03:46:16,639
因此，您可以根据方式将笔记视图移动到笔记文件夹中

2398
03:46:16,639 --> 03:46:21,279
你这样做你可能还需要修复你的进口，所以

2399
03:46:21,279 --> 03:46:25,759
如果您搜索节点视图。让我们看看

2400
03:46:25,759 --> 03:46:30,720
我可以看到它被导入的唯一地方是 main.dart 文件，所以你会

2401
03:46:30,720 --> 03:46:34,551
你可能需要去那里修复那个导入，所以如果你得到一个

2402
03:46:34,551 --> 03:46:39,440
您的导入错误，那么您就知道为什么了

2403
03:46:39,440 --> 03:46:43,512
如果你注意到如果你回到

2404
03:46:43,512 --> 03:46:47,919
这里的编辑器你可能已经注意到我们有一些红色的文件

2405
03:46:47,919 --> 03:46:51,759
这里是因为我们加了嗯

2406
03:46:51,759 --> 03:46:56,551
我们的电子邮件呃一个电子邮件字段给我们的身份验证用户所以如果

2407
03:46:56,551 --> 03:47:00,720
你进入这里你可以看到我们在我们的身份验证用户中添加了这个电子邮件字段

2408
03:47:00,720 --> 03:47:04,080
前几章的内容，因为我们需要

2409
03:47:04,080 --> 03:47:08,639
能够从我们的

2410
03:47:08,639 --> 03:47:12,872
节点服务还可以，所以在添加之后现在我们已经坏了

2411
03:47:12,872 --> 03:47:17,831
我们的测试，我们还没有真正的时间来修复测试所以

2412
03:47:17,831 --> 03:47:20,800
嗯，让我们看看我们如何修复我们的

2413
03:47:20,800 --> 03:47:26,872
测试我们，如果你博士，呃，在我们的测试文件中向下滚动一点，你会

2414
03:47:26,872 --> 03:47:31,831
注意我们在哪里打破了测试，这就是我们在两个地方

2415
03:47:31,831 --> 03:47:37,119
我们正在这里创建一个关闭用户，以及我们处理这个关闭的方式

2416
03:47:37,119 --> 03:47:41,831
我们测试中的用户并不是我们为以后编写测试的东西

2417
03:47:41,831 --> 03:47:45,360
我们实际上并没有创建一个关闭用户，然后

2418
03:47:45,360 --> 03:47:50,639
对关闭用户的电子邮件进行测试，所以目前它几乎

2419
03:47:50,639 --> 03:47:55,279
只是装饰，我们只需要确保我们的测试编译和

2420
03:47:55,279 --> 03:47:59,759
我们这里没有编译错误所以让我们去看看是否可视化

2421
03:47:59,759 --> 03:48:03,119
工作室代码可以帮助我们，所以我只想在 mac 上执行命令 dot 或

2422
03:48:03,119 --> 03:48:07,679
在 windows 和 linux 上控制点并说添加所需的参数 eval 和电子邮件

2423
03:48:07,679 --> 03:48:12,080
你可以只说 fooatbar.com 这样没关系，在

2424
03:48:12,080 --> 03:48:16,551
最终得到暗格式化程序为我们正确格式化文件

2425
03:48:16,551 --> 03:48:20,160
然后对不起，我会再次从 Visual Studio 代码中获得帮助，然后说添加

2426
03:48:20,160 --> 03:48:24,551
记录争论的电子邮件，然后我们再说一次

2427
03:48:24,551 --> 03:48:29,360
fooatbar.com 和一个指挥好的

2428
03:48:29,360 --> 03:48:32,240
所以正如你在标题中看到的那样，我们只需要确保我们是

2429
03:48:32,240 --> 03:48:35,679
运行我们的测试并确保我们没有破坏任何东西，所以让我们开始吧

2430
03:48:35,679 --> 03:48:40,479
在这里进行我们的测试，看看我是否可以提出这个问题

2431
03:48:40,479 --> 03:48:44,399
改变屏幕布局，这样你也能看到我在做什么

2432
03:48:44,399 --> 03:48:48,800
增加屏幕的大小，我要搜索颤振测试和

2433
03:48:48,800 --> 03:48:52,399
这就是您还必须键入的命令作为标题的行

2434
03:48:52,399 --> 03:48:57,191
屏幕底部也有指示，让我们运行测试看看

2435
03:48:57,191 --> 03:49:00,639
如果我们正确地完成了我们不应该做的所有事情，我们会得到什么结果

2436
03:49:00,639 --> 03:49:04,320
目前我们的测试有任何问题

2437
03:49:04,320 --> 03:49:08,639
但是您可能出于充分的理由而偏离了课程，并写了

2438
03:49:08,639 --> 03:49:13,759
更多测试，然后您可能还必须修复这些测试，我高度

2439
03:49:13,759 --> 03:49:16,960
鼓励所有观看此课程的观众

2440
03:49:16,960 --> 03:49:21,831
用小部件测试集成进行尽可能多的测试

2441
03:49:21,831 --> 03:49:26,399
尽可能多地进行测试和单元测试，以了解其工作原理

2442
03:49:26,399 --> 03:49:30,000
嗯，好吧，就是这样，现在我们走吧

2443
03:49:30,000 --> 03:49:33,759
提前并更改我们现在已经完成测试的屏幕布局，您可以

2444
03:49:33,759 --> 03:49:38,872
看到测试已经通过了，我们也没有

2445
03:49:38,872 --> 03:49:45,679
我们的 auth test.dart 文件中有更多危险信号

2446
03:49:45,679 --> 03:49:48,800
好的，所以我们现在需要做的是你看

2447
03:49:48,800 --> 03:49:54,479
然后我们在主 ui 中添加一个加号按钮以转到

2448
03:49:54,479 --> 03:49:59,360
我们的新观点，嗯，我相信我们在这里创造了新的笔记

2449
03:49:59,360 --> 03:50:02,551
视图我们需要为它定义一个回合

2450
03:50:02,551 --> 03:50:07,440
已经为嗯

2451
03:50:07,440 --> 03:50:12,240
我们所有的其他路线，所以如果我们看看我们的嗯，让我们看看我们是否能找到

2452
03:50:12,240 --> 03:50:15,119
它固定路线

2453
03:50:15,119 --> 03:50:18,800
我们已经验证了电子邮件路由我们有节点路由注册路由和所有

2454
03:50:18,800 --> 03:50:21,512
那些，所以我要看看我的

2455
03:50:21,512 --> 03:50:25,039
注意并确保我们在这里定义我们的新路线

2456
03:50:25,039 --> 03:50:28,000
对不起，让我们去叫这条新路线

2457
03:50:28,000 --> 03:50:32,320
我们将把它称为新的音符路线，我们只想说

2458
03:50:32,320 --> 03:50:35,831
斜线和注释斜线

2459
03:50:35,831 --> 03:50:38,551
新笔记好吧

2460
03:50:38,551 --> 03:50:43,600
请记住，这实际上并没有任何意义，除了

2461
03:50:43,600 --> 03:50:48,320
再次原谅我，除非你像你的路线一样处理

2462
03:50:48,320 --> 03:50:53,039
命名，所以如果你喜欢带有 z 的音符，它会

2463
03:50:53,039 --> 03:50:56,479
只要您在任何地方都使用相同的路线名称，也可以使用

2464
03:50:56,479 --> 03:51:00,960
所以不要认为这就像绑定到任何类型的魔法

2465
03:51:00,960 --> 03:51:04,639
文件在颤动中找到一个机制它与它无关，它只是

2466
03:51:04,639 --> 03:51:09,039
让你定义你的路线名称，这样你就可以在这里说 fu 和

2467
03:51:09,039 --> 03:51:12,399
只要您在任何地方都使用此路线名称，一切都会正常进行

2468
03:51:12,399 --> 03:51:15,512
正如所料

2469
03:51:15,512 --> 03:51:20,000
这是我们在 cons 中创建的新笔记路由

2470
03:51:20,000 --> 03:51:24,160
路线飞镖作为注释表明的标题

2471
03:51:24,160 --> 03:51:28,320
屏幕显示我们必须在此处转到主 dart 文件

2472
03:51:28,320 --> 03:51:32,960
然后我们需要去定义那条路线呃在这里

2473
03:51:32,960 --> 03:51:37,360
好的，所以我们有登录路由注册路由注释路由验证电子邮件路由和

2474
03:51:37,360 --> 03:51:41,759
然后我们必须定义这条新路由，称为新节点路由

2475
03:51:41,759 --> 03:51:46,960
所以我们就说新节点路由在这里需要一个构建上下文

2476
03:51:46,960 --> 03:51:49,759
如果你想我不做，我们可以用下划线忽略它

2477
03:51:49,759 --> 03:51:54,000
然后我们将创建一个 new uh 的新实例

2478
03:51:54,000 --> 03:51:59,440
节点路由对不起一个新的节点视图嗯，但我们没有

2479
03:51:59,440 --> 03:52:05,119
还没有，所以让我们去定义新的节点视图

2480
03:52:05,119 --> 03:52:09,679
但是现在我只想说这样的 const new node view 而这不是

2481
03:52:09,679 --> 03:52:12,960
去工作，因为我们没有设置那个视图

2482
03:52:12,960 --> 03:52:16,399
但是我们刚刚为它创建了文件

2483
03:52:16,399 --> 03:52:21,191
所以我要关闭一些我们不需要的文件，让我们进入我们的新文件

2484
03:52:21,191 --> 03:52:24,320
笔记视图

2485
03:52:24,320 --> 03:52:28,960
正如标题所示，我们将创建一个名为 new 的有状态小部件

2486
03:52:28,960 --> 03:52:35,119
注意视图，所以我将使用颤振抱歉的视觉工作室代码和有状态

2487
03:52:35,119 --> 03:52:40,479
小部件模板在这里 stf 我将把它称为新的笔记视图

2488
03:52:40,479 --> 03:52:43,600
对，我们会遇到一些错误

2489
03:52:43,600 --> 03:52:47,759
你已经知道那是因为我们有一个进口材料圆点飞镖所以我

2490
03:52:47,759 --> 03:52:50,160
将从 Visual Studio 代码命令点获得帮助

2491
03:52:50,160 --> 03:52:53,440
在 mac 上或在 linux 和 windows 上控制点并说导入材料

2492
03:52:53,440 --> 03:52:57,279
所有这些错误都会消失

2493
03:52:57,279 --> 03:53:04,160
所以现在我们有了新的节点视图，对不起

2494
03:53:04,160 --> 03:53:09,360
所以让我们在这个新的笔记视图中创建一个简单的脚手架

2495
03:53:09,360 --> 03:53:14,320
我要说我们有一个脚手架，在我们的脚手架内我们有一个应用程序

2496
03:53:14,320 --> 03:53:19,360
栏，我们要说 avbar 和一个应用栏有一个标题，在这里

2497
03:53:19,360 --> 03:53:23,600
我们只会说 cons text new note

2498
03:53:23,600 --> 03:53:29,119
像这样的东西，对于这个脚手架的主体，我们是

2499
03:53:29,119 --> 03:53:36,320
只是要添加一个 const 的文本，上面写着写你的新的

2500
03:53:36,320 --> 03:53:42,240
请注意这里类似这样的东西，所以这是一个非常简单的有状态小部件

2501
03:53:42,240 --> 03:53:45,679
目前我的意思是它甚至不是有状态的，它在做什么正确

2502
03:53:45,679 --> 03:53:49,191
现在它几乎可以通过无状态小部件来实现，但是在

2503
03:53:49,191 --> 03:53:52,960
在接下来的章节中，我们将为这个视图添加越来越多的逻辑，所以它

2504
03:53:52,960 --> 03:53:57,440
需要成为有状态的小部件才能在将来也能工作

2505
03:53:57,440 --> 03:54:04,080
对于我们已经计划好的，对不起，现在我们有了这个妈妈

2506
03:54:04,080 --> 03:54:09,119
新的笔记视图让我们继续回到我们的主要飞镖并获得帮助

2507
03:54:09,119 --> 03:54:13,600
Visual Studio 代码为我们导入该文件，所以我只想说导入和

2508
03:54:13,600 --> 03:54:18,720
你会在第五行看到对我来说可能是一个新的导入

2509
03:54:18,720 --> 03:54:22,720
另一行给你，所以让我们导入一个新的节点视图和它

2510
03:54:22,720 --> 03:54:27,759
允许我们基本上定义一条路线，我只是说 command s，只是为了

2511
03:54:27,759 --> 03:54:30,960
当然，因为实际上不确定我们是我们

2512
03:54:30,960 --> 03:54:36,080
100 确定我们的主要 um 函数中的变化不会

2513
03:54:36,080 --> 03:54:38,960
不会被带走的

2514
03:54:38,960 --> 03:54:42,800
考虑到当我们进行热重载时，我们必须进行热重启

2515
03:54:42,800 --> 03:54:48,960
这些更改要生效，所以让我们在此处进行热重启

2516
03:54:48,960 --> 03:54:53,679
好的，由于某种原因，我实际上可以看到我的 scr cpy 现在又崩溃了

2517
03:54:53,679 --> 03:54:57,600
这有点片状没关系我不会抱怨的

2518
03:54:57,600 --> 03:54:59,919
呃，这只是

2519
03:54:59,919 --> 03:55:03,512
老实说，一个开源项目，我可以看到我实际上已经输了

2520
03:55:03,512 --> 03:55:07,600
我从颤振到程序的连接也是如此

2521
03:55:07,600 --> 03:55:13,600
让我现在在我的实际 Android 手机上的 scrcpy 中运行该代码

2522
03:55:13,600 --> 03:55:16,639
我还要确保我的 android

2523
03:55:16,639 --> 03:55:22,240
手机实际上也有 wi-fi，所以在我的手机上打开 wi-fi，然后

2524
03:55:22,240 --> 03:55:28,160
我要回到这里回到主界面所以虽然这一切都在编译

2525
03:55:28,160 --> 03:55:31,512
让我们进入下一步我们必须照顾的实际上是

2526
03:55:31,512 --> 03:55:35,600
显示哎呀

2527
03:55:35,600 --> 03:55:43,360
所以这实际上是在显示这个新的笔记视图

2528
03:55:43,360 --> 03:55:47,279
作为标题表明我们需要进入注释视图并按下图标

2529
03:55:47,279 --> 03:55:52,240
按钮显示新的笔记视图，所以我也要去我的笔记去

2530
03:55:52,240 --> 03:55:55,919
在这里做笔记

2531
03:55:55,919 --> 03:56:02,399
我们必须添加一个小按钮

2532
03:56:02,399 --> 03:56:07,600
在我们的 uh notes 视图中，让我们继续

2533
03:56:07,600 --> 03:56:11,831
去那里我们会看看我们的note2是如何构建的

2534
03:56:11,831 --> 03:56:16,479
现在可以看到我们有一系列动作，现在它有一个

2535
03:56:16,479 --> 03:56:21,440
弹出菜单按钮对不起，我们需要添加一个新图标

2536
03:56:21,440 --> 03:56:24,960
按钮在那里，让我们继续说图标按钮

2537
03:56:24,960 --> 03:56:30,160
一个图标按钮必须有一个图标和一个按下所以让我们说未按下所以

2538
03:56:30,160 --> 03:56:34,240
记住这将是我们的加号图标

2539
03:56:34,240 --> 03:56:39,440
所以这是我们的新闻，对于图标，我们只会说 const icon

2540
03:56:39,440 --> 03:56:43,279
然后我们会说添加图标，如您所见，我相信您的

2541
03:56:43,279 --> 03:56:47,360
工作室代码也能够直接显示您的图标，因此您可以看到

2542
03:56:47,360 --> 03:56:51,191
这就是按钮的外观，这是一个加号按钮

2543
03:56:51,191 --> 03:56:54,000
正确和一个逗号在这里让它工作

2544
03:56:54,000 --> 03:56:58,872
如果我现在在这里执行命令，我们应该在热重载后看到一个加号按钮

2545
03:56:58,872 --> 03:57:02,080
是的，但是那个按钮没有做任何事情，因为它没有按下它

2546
03:57:02,080 --> 03:57:06,240
空无所谓 所以我们需要做的就是说 uh

2547
03:57:06,240 --> 03:57:10,639
我们上下文的导航器或构建上下文和

2548
03:57:10,639 --> 03:57:15,831
我们只是要推送一个称为新节点路由的路由

2549
03:57:15,831 --> 03:57:18,240
好的，这就是你需要添加逗号的全部内容

2550
03:57:18,240 --> 03:57:22,160
在这里只是为了让代码格式正常工作

2551
03:57:22,160 --> 03:57:25,831
所以让我们实际测试一下，看看它是否有效，所以我要按下

2552
03:57:25,831 --> 03:57:30,240
这里的加号按钮，您可以看到我们的新节点路由正在显示

2553
03:57:30,240 --> 03:57:33,440
带有我们在此处添加的小文本的屏幕

2554
03:57:33,440 --> 03:57:37,440
说在这里写你的新节点然后按下后退按钮

2555
03:57:37,440 --> 03:57:41,119
将我们发送回应用程序的主用户界面，您可能已经注意到

2556
03:57:41,119 --> 03:57:46,240
在注释视图中，我没有说 push name 和 remove until 那是因为

2557
03:57:46,240 --> 03:57:50,479
当您按下加号按钮以创建您希望用户的新笔记时

2558
03:57:50,479 --> 03:57:53,831
能够在需要时返回应用程序的主用户界面

2559
03:57:53,831 --> 03:57:57,360
这就是便利这个背部的设施

2560
03:57:57,360 --> 03:58:02,399
按钮就在这里 好的 好的 那是很棒的东西

2561
03:58:02,399 --> 03:58:06,080
这几乎是我们为这一章所做的一切

2562
03:58:06,080 --> 03:58:10,399
所以说实话，如果你这么问我，简短的一章会让人耳目一新

2563
03:58:10,399 --> 03:58:16,080
这真的很好，就像传统一样，让我们​​投入我们的工作，所以

2564
03:58:16,080 --> 03:58:20,000
我们可以为下一章做好准备 我要换屏幕

2565
03:58:20,000 --> 03:58:25,512
这里的布局有点糟糕，我们进去改变一下

2566
03:58:25,512 --> 03:58:29,919
屏幕布局，让我打开终端

2567
03:58:29,919 --> 03:58:34,160
增加屏幕尺寸，让我看得更清楚

2568
03:58:34,160 --> 03:58:38,960
所以我们要看看我们的 git 状态，我可以看到有一个全新的

2569
03:58:38,960 --> 03:58:43,119
这里的文件夹名为 lib views notes，我们有两个

2570
03:58:43,119 --> 03:58:47,919
下面的文件是我们的注释视图和新注释视图，所以让我们

2571
03:58:47,919 --> 03:58:51,831
说 git 并在这里查看我们的状态

2572
03:58:51,831 --> 03:58:55,679
现在可以看到那里提到的所有内容我要摆脱

2573
03:58:55,679 --> 03:58:59,039
这让它更大一点，所以你看得更清楚

2574
03:58:59,039 --> 03:59:02,551
所以我们需要做的就是先提交这个，然后我们要说一步

2575
03:59:02,551 --> 03:59:06,399
13. 我相信至少是这样

2576
03:59:06,399 --> 03:59:11,360
看看我们的日志，是的，第 12 步是最后一章，所以我们要说

2577
03:59:11,360 --> 03:59:16,240
嗯，第 13 步，我现在要推动我们的承诺

2578
03:59:16,240 --> 03:59:21,191
github 然后我们要说好标签

2579
03:59:21,191 --> 03:59:26,639
第 13 步以及带有推送标签

2580
03:59:26,639 --> 03:59:30,000
好吧，这也是我们的标签，所以如果

2581
03:59:30,000 --> 03:59:34,080
我说标签现在我们可以看到到目前为止我们创建的所有标签 13 个

2582
03:59:34,080 --> 03:59:38,800
对，这就是我们必须做的

2583
03:59:38,800 --> 03:59:42,551
现在再次成为每个人的传统

2584
03:59:42,551 --> 03:59:45,360
这场洪水的一章当然我通常会谈论我们需要做什么

2585
03:59:45,360 --> 03:59:49,039
下一章，这样我们就可以为那一章做好准备

2586
03:59:49,039 --> 03:59:52,320
下一章现在我们有了新的笔记视图

2587
03:59:52,320 --> 03:59:57,191
我们将努力将逻辑添加到新的笔记视图中，以便我们可以

2588
03:59:57,191 --> 04:00:02,240
实际上将新笔记插入到我们的数据库中，以便我们可以开始

2589
04:00:02,240 --> 04:00:05,679
操纵这些笔记，所以下一章将

2590
04:00:05,679 --> 04:00:10,080
有点沉重的章节代码明智有很多代码所以

2591
04:00:10,080 --> 04:00:14,240
如果你想喝点点心，请做我的客人，请继续这样做

2592
04:00:14,240 --> 04:00:18,720
下一章见大家好，欢迎来到第31章

2593
04:00:18,720 --> 04:00:22,240
上一章的这个flutter课程我们做了一些准备工作

2594
04:00:22,240 --> 04:00:26,800
为了创建我们的新笔记视图，我们已经标记了一切

2595
04:00:26,800 --> 04:00:31,191
准备好了只是我们将新的笔记视图创建为有状态的小部件

2596
04:00:31,191 --> 04:00:35,919
几乎没有逻辑它有一个简单的脚手架，带有一个应用栏和一个简单的

2597
04:00:35,919 --> 04:00:39,919
本章中显示在屏幕上的文本

2598
04:00:39,919 --> 04:00:43,759
我们将确保用户不仅能够

2599
04:00:43,759 --> 04:00:48,320
去新的笔记视图或抱歉新的笔记视图，但他

2600
04:00:48,320 --> 04:00:53,600
或者她能够创建一个实际的注释并修改其文本

2601
04:00:53,600 --> 04:00:58,399
然后能够回到主用户界面

2602
04:00:58,399 --> 04:01:01,440
正如我在前面提到的那样，我们有很多工作要做这些章节

2603
04:01:01,440 --> 04:01:04,872
上一章结尾的章节 这章有点意思

2604
04:01:04,872 --> 04:01:08,960
代码很重，但我会确保带你去

2605
04:01:08,960 --> 04:01:12,240
通过我们将逐步编写的所有代码，这样您就不会错过

2606
04:01:12,240 --> 04:01:16,320
一切都好，在我们开始之前，我们需要解决

2607
04:01:16,320 --> 04:01:21,679
在我们的 um notes 视图中，那是为了确保我们正在听

2608
04:01:21,679 --> 04:01:28,160
我们所有节点流的活动状态加上等待，我的意思是

2609
04:01:28,160 --> 04:01:32,240
无需我们实际上无需我解释

2610
04:01:32,240 --> 04:01:36,000
抽象地说，让我提出代码并看看我们做了什么

2611
04:01:36,000 --> 04:01:40,720
嗯，我们如何才能让它变得更好

2612
04:01:40,720 --> 04:01:45,191
让我更改屏幕布局，以便您更好地查看代码让我们转到

2613
04:01:45,191 --> 04:01:48,551
我们的笔记在这里查看，您可以在

2614
04:01:48,551 --> 04:01:53,512
在我们的笔记的实际正文中，我们有未来的建设者，我们得到或

2615
04:01:53,512 --> 04:01:57,759
创建一个具有电子邮件地址的用户，您很快就会明白为什么

2616
04:01:57,759 --> 04:02:01,831
我们正在这样做，我们也有这个部分，它说开关连接

2617
04:02:01,831 --> 04:02:06,720
状态等待，然后在这里说等待所有笔记我们的计划是

2618
04:02:06,720 --> 04:02:11,360
to in the future 很快 实际上 在不久的将来 显示所有的笔记

2619
04:02:11,360 --> 04:02:15,600
用户在此用户界面中创建的，但是现在我们只是

2620
04:02:15,600 --> 04:02:18,479
监听连接状态等待

2621
04:02:18,479 --> 04:02:21,831
如果您查看文档文档以等待它说

2622
04:02:21,831 --> 04:02:25,512
连接到异步计算我正在等待交互但是如果你

2623
04:02:25,512 --> 04:02:30,160
看看它说的活动连接到一个活动的异步计算

2624
04:02:30,160 --> 04:02:34,240
ha 并且该流已返回至少一个值，因此

2625
04:02:34,240 --> 04:02:38,639
现在我们有如果你看我们的流是所有笔记的流所以这个所有笔记

2626
04:02:38,639 --> 04:02:42,551
开头可以是空的，也可以包含一些注释让我们开始吧

2627
04:02:42,551 --> 04:02:46,800
当流为空时流为空，这意味着

2628
04:02:46,800 --> 04:02:50,080
用户尚未创建任何已填充到便笺中的便笺

2629
04:02:50,080 --> 04:02:54,639
服务然后该流的连接状态将等待，因为飞镖

2630
04:02:54,639 --> 04:03:00,399
现在正在等待该流返回第一个值，这很好

2631
04:03:00,399 --> 04:03:03,600
我们说好的

2632
04:03:03,600 --> 04:03:08,399
流包含一个值或一旦流实际返回一个值

2633
04:03:08,399 --> 04:03:12,399
那么它的连接状态将处于活动状态，我们所做的只是我们

2634
04:03:12,399 --> 04:03:16,320
等待等待状态，但一旦进入活动状态，我们就会显示

2635
04:03:16,320 --> 04:03:21,119
循环进度指示器，这不是不正确的逻辑，所以

2636
04:03:21,119 --> 04:03:26,080
我们需要解决这个问题，所以让我们进入我们的笔记视图，等待之后

2637
04:03:26,080 --> 04:03:28,800
我们还要说

2638
04:03:28,800 --> 04:03:35,279
案例连接状态点活动正常所以这个

2639
04:03:35,279 --> 04:03:40,160
紧接着写两个案例，这是我喜欢的隐含失败

2640
04:03:40,160 --> 04:03:43,512
称它为某种语言称为后续，例如 swift

2641
04:03:43,512 --> 04:03:49,039
意思是一个案例没有逻辑，并且从字面上跌到下一个

2642
04:03:49,039 --> 04:03:53,360
案例，所以你在这里没有任何中断语句，好吧

2643
04:03:53,360 --> 04:03:57,191
所以这是一个后续隐含的失败和

2644
04:03:57,191 --> 04:04:01,039
这意味着在等待和活动状态中，我们将显示此文本和

2645
04:04:01,039 --> 04:04:05,119
如果你命令 s 那么你不会看到运行的任何差异

2646
04:04:05,119 --> 04:04:09,191
您的应用程序只是我们修复了一个损坏的逻辑

2647
04:04:09,191 --> 04:04:11,679
好的

2648
04:04:11,679 --> 04:04:17,191
现在到激动人心的部分，我将带来新的笔记视图

2649
04:04:17,191 --> 04:04:20,479
在这里只是要重新组织它你不必这样做但你现在需要去

2650
04:04:20,479 --> 04:04:24,800
到您的新节点视图 dart 文件，因为这是

2651
04:04:24,800 --> 04:04:29,119
现在我们将在本章的大部分内容中工作

2652
04:04:29,119 --> 04:04:31,512
好的，所以我们将在这个新的

2653
04:04:31,512 --> 04:04:36,872
进入屏幕后的便笺视图，我们实际上将创建一个新便笺

2654
04:04:36,872 --> 04:04:42,080
对你来说好吧，我们将保留那个新笔记并创建一个新的

2655
04:04:42,080 --> 04:04:45,831
节点如果你记得我们的节点服务如果你去我们的

2656
04:04:45,831 --> 04:04:49,919
公用事业我们这里有很多人，我们有节点服务，然后我们有很多

2657
04:04:49,919 --> 04:04:54,000
这里的函数至少让我们看看我们是否可以找到创建节点视图抱歉

2658
04:04:54,000 --> 04:04:59,679
这里的创建节点功能你可以看到它是一个未来所以我们不能

2659
04:04:59,679 --> 04:05:05,440
立即从此创建新节点获得结果，因此我们的新节点的目标

2660
04:05:05,440 --> 04:05:11,831
这里的节点视图是在这个函数体内使用future builder

2661
04:05:11,831 --> 04:05:15,831
所以在这个函数的主体内，我们要说

2662
04:05:15,831 --> 04:05:20,800
新节点视图状态已经创建，那么它还需要创建一个新节点

2663
04:05:20,800 --> 04:05:25,919
然而，在数据库中记住颤振我们有热重载意味着

2664
04:05:25,919 --> 04:05:30,800
当你在那个视图上并且你正在编辑你的文本和等等，你可以

2665
04:05:30,800 --> 04:05:33,831
稍微更改一下代码，然后按 command s

2666
04:05:33,831 --> 04:05:38,720
按下 command s 只会再次调用你的构建函数，所以如果你那时

2667
04:05:38,720 --> 04:05:44,399
在您的构建功能 um 脚手架主体中，您将拥有一个未来的构建器

2668
04:05:44,399 --> 04:05:48,639
反过来创建一个新的注释，该函数将再次被调用

2669
04:05:48,639 --> 04:05:52,639
这意味着每次您在该视图上进行热重载时，都会有一个新的

2670
04:05:52,639 --> 04:05:57,440
注意将被创建，为此我们如标题所示

2671
04:05:57,440 --> 04:06:02,320
我们需要保留一个名为 notes 的变量，这样我们就不会重新创建

2672
04:06:02,320 --> 04:06:07,039
每次调用构建函数时都可以，所以让我们继续做吧

2673
04:06:07,039 --> 04:06:11,119
所以在你的状态里面

2674
04:06:11,119 --> 04:06:16,000
新的笔记视图让我们去定义和说数据库

2675
04:06:16,000 --> 04:06:19,600
笔记，我们只会说笔记

2676
04:06:19,600 --> 04:06:23,831
好吧，我们也只是让它成为可选的，因为它

2677
04:06:23,831 --> 04:06:27,919
没有价值开始

2678
04:06:27,919 --> 04:06:35,119
好的，我们还需要的是保持我们的笔记服务

2679
04:06:35,119 --> 04:06:38,479
正如您在前几章中看到的，我们将节点服务器创建为单例，但是

2680
04:06:38,479 --> 04:06:43,119
如果您不必将其称为工厂功能，那您也将非常出色

2681
04:06:43,119 --> 04:06:46,399
每当我们使用节点服务器时，一遍又一遍地为单例

2682
04:06:46,399 --> 04:06:50,720
所以我们还要保持我们的节点服务作为一个后期的最终变量

2683
04:06:50,720 --> 04:06:53,831
在这里，让我们说迟到的决赛，我们是

2684
04:06:53,831 --> 04:07:00,000
要说这是尾注服务现在首先像这样好吧

2685
04:07:00,000 --> 04:07:03,600
嗯，你可能还没有看到

2686
04:07:03,600 --> 04:07:08,320
应用程序，但在我们处理变量以保持控制时，我们还需要

2687
04:07:08,320 --> 04:07:13,191
现在保持文本编辑控制器的方式是这样的 ui

2688
04:07:13,191 --> 04:07:17,039
view is going to work here is that instead of this text in here we're going

2689
04:07:17,039 --> 04:07:22,551
创建一个文本字段，它将随着用户垂直增加大小

2690
04:07:22,551 --> 04:07:27,039
不断在该字段中输入他们的信息或笔记

2691
04:07:27,039 --> 04:07:30,080
所以我们要做的是跟踪

2692
04:07:30,080 --> 04:07:34,080
用户输入的文本，当用户输入新文本时，我们

2693
04:07:34,080 --> 04:07:39,279
将自动将该信息与我们的数据库同步，并在将来

2694
04:07:39,279 --> 04:07:44,160
我们去firebase我们将与firebase同步该信息

2695
04:07:44,160 --> 04:07:50,720
所以我们需要一个文本编辑控制器来跟踪文本的变化

2696
04:07:50,720 --> 04:07:52,872
所以嗯

2697
04:07:52,872 --> 04:07:57,119
让我把这个标题带到这里，然后我们继续

2698
04:07:57,119 --> 04:08:02,320
并按照标题说的做让我们说迟到的最后和文字

2699
04:08:02,320 --> 04:08:05,679
我认为有时会控制这些文档

2700
04:08:05,679 --> 04:08:13,919
我相信只是过度，我们称之为文本控制器好吧

2701
04:08:13,919 --> 04:08:19,119
好吧，嗯，那太好了，所以我们现在需要做的是

2702
04:08:19,119 --> 04:08:23,039
促进我们的呃我的意思是我们还没有真正初始化任何这些但是

2703
04:08:23,039 --> 04:08:27,440
我们很快就会解决这个问题，所以我们没有忘记这一点

2704
04:08:27,440 --> 04:08:30,479
但是我们现在需要什么，正如我在本章开头提到的，当我们

2705
04:08:30,479 --> 04:08:34,080
来到这个屏幕，我们将创建一个新的笔记，我们需要有一个

2706
04:08:34,080 --> 04:08:37,440
在它被称为 create new 的情况下，它作为标题的函数

2707
04:08:37,440 --> 04:08:41,600
注意，它是一个异步函数，我们很快就会知道为什么

2708
04:08:41,600 --> 04:08:46,399
所以让我们继续说数据库节点的未来

2709
04:08:46,399 --> 04:08:50,240
因为它使用我们的节点服务创建了一个节点

2710
04:08:50,240 --> 04:08:54,800
我们将把它称为创建新节点，它是一个异步函数

2711
04:08:54,800 --> 04:08:57,679
所以在这个函数中我们要做什么

2712
04:08:57,679 --> 04:09:02,080
首先是看看我们之前是否在这个节点内创建了这个注释

2713
04:09:02,080 --> 04:09:05,512
变量，如果我们之前创建过这个节点，那么我们不必创建它

2714
04:09:05,512 --> 04:09:09,440
再次我们只是返回，但如果我们还没有创建它，那么我们去节点

2715
04:09:09,440 --> 04:09:13,919
服务并说创建节点，然后将该节点返回给我们所有人

2716
04:09:13,919 --> 04:09:18,000
好吧，让我们继续做吧，让我们

2717
04:09:18,000 --> 04:09:24,240
说最终存在的节点等于这个注释

2718
04:09:24,240 --> 04:09:29,759
然后我们说嗯然后在这里我们说如果现有的笔记

2719
04:09:29,759 --> 04:09:33,600
不为空，那么我们只返回它

2720
04:09:33,600 --> 04:09:38,160
这东西没问题，所以这就是返回声明

2721
04:09:38,160 --> 04:09:42,639
意味着我们已经有一个笔记，如果我们没有，那么我们将创建一个新的

2722
04:09:42,639 --> 04:09:49,119
请注意，但请记住，当我们创建新便笺时，我们的 um 会在其上创建新便笺功能

2723
04:09:49,119 --> 04:09:55,831
笔记服务如果你看这里创建笔记它需要一个所有者所以现在

2724
04:09:55,831 --> 04:09:58,720
突然间我们必须有一个主人好吗

2725
04:09:58,720 --> 04:10:04,800
再次记住进入应用程序主用户界面时的注释视图

2726
04:10:04,800 --> 04:10:10,000
notes 视图在数据库中创建了一个新用户，这意味着您已经登录

2727
04:10:10,000 --> 04:10:13,679
使用firebase，然后您转到您负责创建的注释视图注释

2728
04:10:13,679 --> 04:10:18,399
该用户我们在这里所要做的就是检索该用户，以便我们实际上可以

2729
04:10:18,399 --> 04:10:24,399
算上数据库中已经存在的那个用户好吧

2730
04:10:24,399 --> 04:10:28,240
所以让我们说最终的当前用户

2731
04:10:28,240 --> 04:10:33,039
等于我们的认证服务

2732
04:10:33,039 --> 04:10:36,872
firebase 然后我们会说当前用户

2733
04:10:36,872 --> 04:10:41,191
我们只是要明确地打开它，意思是

2734
04:10:41,191 --> 04:10:46,720
如果您最终以某种方式出现在此新笔记中，我们希望用户在那里

2735
04:10:46,720 --> 04:10:50,639
看你可能在想，但为什么那不安全呢

2736
04:10:50,639 --> 04:10:54,800
这是不安全的，如果当前用户会导致应用程序崩溃

2737
04:10:54,800 --> 04:11:00,479
不存在，但是您永远不应该以这种方式结束

2738
04:11:00,479 --> 04:11:04,872
如果您没有当前用户，则新节点视图因此最终出现在此屏幕上

2739
04:11:04,872 --> 04:11:08,639
并且没有当前用户是值得崩溃的，因为你想要你的

2740
04:11:08,639 --> 04:11:13,919
如果您的应用程序用户符合您的期望，应用程序就会崩溃

2741
04:11:13,919 --> 04:11:18,551
上一个屏幕没有满足界面和逻辑，所以你现在

2742
04:11:18,551 --> 04:11:22,960
在这一点上创建一个期望并让应用程序崩溃实际上是一个

2743
04:11:22,960 --> 04:11:26,800
在我看来是件好事，因为如果当前用户不存在，你应该

2744
04:11:26,800 --> 04:11:30,160
如果您最终进入此视图并且您没有

2745
04:11:30,160 --> 04:11:33,919
当前用户出现严重问题，所以我会完全安全

2746
04:11:33,919 --> 04:11:38,720
说在这里明确解开当前用户

2747
04:11:38,720 --> 04:11:42,399
我们将从当前用户那里提取电子邮件

2748
04:11:42,399 --> 04:11:46,080
所以我们会说 current user.email 我们也会打开它

2749
04:11:46,080 --> 04:11:50,080
因为记住电子邮件是一个可选字段，但同样因为我们知道

2750
04:11:50,080 --> 04:11:53,919
我们现在的身份验证将处理电子邮件

2751
04:11:53,919 --> 04:11:58,160
因为我们所有的用户都使用电子邮件地址和密码注册然后我们

2752
04:11:58,160 --> 04:12:02,800
可以确定邮箱地址是存在的

2753
04:12:02,800 --> 04:12:06,399
所以让我们继续从数据库中获取那个所有者，所以我们要说

2754
04:12:06,399 --> 04:12:14,000
店主等于我们的off our notes服务

2755
04:12:14,000 --> 04:12:19,360
所以我们会说等待笔记服务，然后我们会得到用户

2756
04:12:19,360 --> 04:12:24,479
用那封电子邮件，然后我们将返回我们的

2757
04:12:24,479 --> 04:12:29,600
注意服务创建节点所以我们要在这里创建一个新节点好的

2758
04:12:29,600 --> 04:12:35,600
因此，假设便笺服务与该所有者创建便笺，并且

2759
04:12:35,600 --> 04:12:39,279
你看这返回 um

2760
04:12:39,279 --> 04:12:42,479
数据库注释的未来，这几乎是我们需要返回的

2761
04:12:42,479 --> 04:12:48,320
在这里，让我们等一下吧

2762
04:12:48,320 --> 04:12:53,119
好的，太棒了，这是为了创建新的笔记，在这里

2763
04:12:53,119 --> 04:12:56,320
你可以看到我们没有设置这个

2764
04:12:56,320 --> 04:13:00,639
我们刚刚为此笔记创建的新笔记

2765
04:13:00,639 --> 04:13:03,440
我们将实际处理的变量

2766
04:13:03,440 --> 04:13:07,600
稍晚一点，所以你不必担心

2767
04:13:07,600 --> 04:13:10,479
那

2768
04:13:10,479 --> 04:13:15,759
好的，这是为了创建我们的笔记

2769
04:13:15,759 --> 04:13:22,080
现在我们需要做的是，当这个视图失去意义时

2770
04:13:22,080 --> 04:13:26,639
例如，用户按下此视图上的后退按钮

2771
04:13:26,639 --> 04:13:33,191
我们需要确保数据库中的当前节点被删除，如果

2772
04:13:33,191 --> 04:13:37,512
没有为该节点输入文本，所以

2773
04:13:37,512 --> 04:13:42,720
原因是假设用户在主界面上

2774
04:13:42,720 --> 04:13:46,479
应用程序就在这里，用户然后按下加号按钮，然后说

2775
04:13:46,479 --> 04:13:50,240
嗯，我实际上不想这样做，所以他们按下后退按钮

2776
04:13:50,240 --> 04:13:55,600
如果我们允许用户这样做并按下加号按钮，我们将创建一个

2777
04:13:55,600 --> 04:14:00,240
新的空节点并返回然后视图可能只是充满了空节点，所以它

2778
04:14:00,240 --> 04:14:04,720
就像用户甚至无法看到的空单元格一样，因为

2779
04:14:04,720 --> 04:14:08,399
稍后我们将在接下来的章节中看到，我们将在这个列表中填充

2780
04:14:08,399 --> 04:14:12,551
您笔记的实际内容，因为我们的笔记没有标题，所以

2781
04:14:12,551 --> 04:14:16,872
我们要显示的实际文本是里面的便笺本身

2782
04:14:16,872 --> 04:14:21,279
各种不同的细胞，所以我们要做的是说

2783
04:14:21,279 --> 04:14:25,191
如果你去创建一个新节点并且你没有输入任何文本意味着

2784
04:14:25,191 --> 04:14:29,119
离开此屏幕后，文本为空

2785
04:14:29,119 --> 04:14:33,119
在新笔记屏幕之外，如果它是空的，我们将删除该笔记

2786
04:14:33,119 --> 04:14:36,320
所以这是有道理的

2787
04:14:36,320 --> 04:14:40,080
所以让我们继续创建并找到该函数

2788
04:14:40,080 --> 04:14:47,600
所以我要带那个

2789
04:14:47,600 --> 04:14:54,551
在这里，如果文本为空，我们就说 void delete note 好吧

2790
04:14:54,551 --> 04:14:58,479
然后我们进去现在我们必须看看

2791
04:14:58,479 --> 04:15:01,512
在我们的笔记中

2792
04:15:01,512 --> 04:15:08,000
并且我们只是说我们得到了我们得到的笔记所以我们在这里说最后的笔记

2793
04:15:08,000 --> 04:15:14,960
注意应该填充在我们的状态中，然后我们说如果

2794
04:15:14,960 --> 04:15:19,831
文本控制器的文本为空

2795
04:15:19,831 --> 04:15:26,720
它是空的并且节点不为空然后我们在这里转到我们的节点服务

2796
04:15:26,720 --> 04:15:32,960
然后我们要求它删除那里的节点好吧，然后我们说使用

2797
04:15:32,960 --> 04:15:36,720
像这样的笔记

2798
04:15:36,720 --> 04:15:40,639
好吧，是的，那应该很好

2799
04:15:40,639 --> 04:15:45,679
如果我们里面的文本，那就是从数据库中删除笔记

2800
04:15:45,679 --> 04:15:50,639
文本编辑控制器为空

2801
04:15:50,639 --> 04:15:55,679
好吧，如果它是空的，那是为了删除它实际上怎么样

2802
04:15:55,679 --> 04:16:00,551
如果其中确实有文本，则保存笔记

2803
04:16:00,551 --> 04:16:05,512
以及我们将在我们的视图中执行的操作，您很快就会在用户视图中

2804
04:16:05,512 --> 04:16:09,759
可以编辑他们的笔记或将新文本添加到我们不会有的笔记中

2805
04:16:09,759 --> 04:16:13,679
如果您不是软件，则现代移动应用程序中的保存按钮类型

2806
04:16:13,679 --> 04:16:16,639
您可能不会注意到之前的开发，但如果您是设计师，您

2807
04:16:16,639 --> 04:16:21,119
可能已经注意到，在移动设备上的大多数笔记应用程序中

2808
04:16:21,119 --> 04:16:25,919
设备至少没有保存按钮，您的所有内容都会自动保存

2809
04:16:25,919 --> 04:16:29,831
保存，所以这实际上是一个很好的设计决策，通常在大多数地方你

2810
04:16:29,831 --> 04:16:33,679
通常在移动应用程序中不需要保存按钮，尤其是在

2811
04:16:33,679 --> 04:16:37,600
移动应用程序，所以我们不会有保存按钮

2812
04:16:37,600 --> 04:16:41,191
所以我们为了方便没有保存按钮，我们必须有一个

2813
04:16:41,191 --> 04:16:44,240
自动保存当前的功能

2814
04:16:44,240 --> 04:16:48,479
当前节点，例如，如果用户然后离开这个视图，那么它

2815
04:16:48,479 --> 04:16:52,399
会自动保存好的，所以让我们继续创建一个函数

2816
04:16:52,399 --> 04:16:57,512
在这里，顾名思义，如果没有文本，则称为保存节点

2817
04:16:57,512 --> 04:17:01,119
空的，我要带上 uh 功能

2818
04:17:01,119 --> 04:17:05,440
来自我的节点的签名，所以我不必手动输入，所以你需要

2819
04:17:05,440 --> 04:17:08,720
不幸的是手动输入这个不幸的是我不知道

2820
04:17:08,720 --> 04:17:13,191
但如果文本不为空，您将需要手动输入保存笔记

2821
04:17:13,191 --> 04:17:18,240
我们在这里要做的与我们的代码非常相似

2822
04:17:18,240 --> 04:17:24,000
如果文本为空，则为删除节点写，所以首先我们要获取节点

2823
04:17:24,000 --> 04:17:30,000
是节点，然后我们在文本控制器文本中获取文本

2824
04:17:30,000 --> 04:17:32,639
然后在这里嗯

2825
04:17:32,639 --> 04:17:37,600
我们会说 um if note 不是 null if note 是

2826
04:17:37,600 --> 04:17:40,000
不正常和

2827
04:17:40,000 --> 04:17:44,960
嗯，我们的文本不是空的，那么我们将等待

2828
04:17:44,960 --> 04:17:48,720
我们的笔记服务

2829
04:17:48,720 --> 04:17:52,720
在这里更新笔记功能

2830
04:17:52,720 --> 04:17:56,800
这正是我们在这里所做的，所以这很简单，我们只是在说

2831
04:17:56,800 --> 04:18:03,360
如果有文本不是空的并且我们有一个注释那么就

2832
04:18:03,360 --> 04:18:08,720
在数据库中更新该注释非常非常简单

2833
04:18:08,720 --> 04:18:12,800
好的两个非常重要的函数现在我们必须把这些函数放入

2834
04:18:12,800 --> 04:18:16,399
如您所见，我们从分析仪那里收到警告说

2835
04:18:16,399 --> 04:18:20,000
这是两个未引用的私有函数，用于

2836
04:18:20,000 --> 04:18:23,831
一个很好的理由，因为我们将在处置中引用它们

2837
04:18:23,831 --> 04:18:28,639
当这个新的笔记视图基本上是时，我们的新节点视图状态

2838
04:18:28,639 --> 04:18:32,720
被系统杀死，例如当用户按下后退按钮时

2839
04:18:32,720 --> 04:18:36,720
好的，让我们进入 dispose 函数

2840
04:18:36,720 --> 04:18:42,320
我们必须在这里照顾呃三件事

2841
04:18:42,320 --> 04:18:45,360
所以我们走吧

2842
04:18:45,360 --> 04:18:50,160
假设我们在这里有一个 dispose 函数，那就是

2843
04:18:50,160 --> 04:18:53,039
默认情况下会被覆盖对不起，我会在这里提出来，我会写的

2844
04:18:53,039 --> 04:18:58,551
从一开始，你就可以看到这个姿势没问题，它确实覆盖了我们和

2845
04:18:58,551 --> 04:19:02,872
我们要做的是首先说如果文本为空则删除笔记

2846
04:19:02,872 --> 04:19:06,000
那么我们要做的是我们要说否则保存笔记如果

2847
04:19:06,000 --> 04:19:09,191
text 不为空，然后我们将摆脱

2848
04:19:09,191 --> 04:19:14,320
文本控制器并对其进行处置，以便成为飞镖界的好公民

2849
04:19:14,320 --> 04:19:17,512
当您创建一个新的文本编辑控制器时，我们很快就会这样做

2850
04:19:17,512 --> 04:19:23,919
我们还需要确保我们在这个姿势上处理它

2851
04:19:23,919 --> 04:19:27,831
所以嗯，那是很多代码，我要

2852
04:19:27,831 --> 04:19:31,679
也看看这里我可以看到我实际上没有提供

2853
04:19:31,679 --> 04:19:36,080
我们照顾初始化的任何字幕

2854
04:19:36,080 --> 04:19:42,800
所以嗯，让我们照顾

2855
04:19:42,800 --> 04:19:45,919
所以我基本上现在正在做的事情，因为我只是注意到我没有

2856
04:19:45,919 --> 04:19:51,119
很好地为初始化函数提供了一个标题，我们现在就去做，嗯

2857
04:19:51,119 --> 04:19:56,551
因为这是一个非常重要的功能，我们需要

2858
04:19:56,551 --> 04:20:01,191
程序所以我也为此道歉

2859
04:20:01,191 --> 04:20:06,639
会把它带到这里，然后给你看标题，让你看看我在做什么

2860
04:20:06,639 --> 04:20:11,191
所以我们有这个姿势，但我们还没有初始化状态，我要初始化

2861
04:20:11,191 --> 04:20:15,440
在这里状态，让我们看看还是我们有任何状态

2862
04:20:15,440 --> 04:20:18,000
已经

2863
04:20:18,000 --> 04:20:22,639
我不这么认为

2864
04:20:22,639 --> 04:20:25,919
我可以看到视觉工作室代码并没有真正帮助我

2865
04:20:25,919 --> 04:20:29,440
所以我只想说覆盖无效初始化状态

2866
04:20:29,440 --> 04:20:32,000
像那样

2867
04:20:32,000 --> 04:20:36,551
然后我们必须在其状态下调用 super 好，所以你可能需要输入

2868
04:20:36,551 --> 04:20:40,720
手工以及个人工作室代码对我有点生气

2869
04:20:40,720 --> 04:20:44,000
也许是因为我只是忘了为互联网状态写标题

2870
04:20:44,000 --> 04:20:47,679
然后在这里我们需要做的就是确保我们同时创建

2871
04:20:47,679 --> 04:20:52,080
一个节点服务的实例，也是我们的文本编辑控制器好的，所以我只是

2872
04:20:52,080 --> 04:20:58,240
要说节点服务，这等于节点服务和

2873
04:20:58,240 --> 04:21:02,000
这只是一个单例，所以它不会创建一个真正的新实例，如果

2874
04:21:02,000 --> 04:21:06,240
它从以前就已经存在，我们的文本控制器将成为

2875
04:21:06,240 --> 04:21:12,080
文本编辑编辑控制器的新实例

2876
04:21:12,080 --> 04:21:14,800
好的，所以我要保存这个，然后我

2877
04:21:14,800 --> 04:21:20,000
打算做一个热重启 嗯，scrcpy 这几天有点生气

2878
04:21:20,000 --> 04:21:23,279
当我做热重启时和我一起，我真的不知道为什么

2879
04:21:23,279 --> 04:21:27,600
但我已经学会了忍受它，所以我只想说 scr cpy

2880
04:21:27,600 --> 04:21:32,479
然后我将在不调试的情况下运行应用程序

2881
04:21:32,479 --> 04:21:36,160
把它带到那里好吧

2882
04:21:36,160 --> 04:21:40,232
当它在做它的工作时，我们需要照顾

2883
04:21:40,232 --> 04:21:44,080
其他一些功能

2884
04:21:44,080 --> 04:21:48,320
当用户在

2885
04:21:48,320 --> 04:21:52,320
应用程序的主用户界面，因此当他或她在

2886
04:21:52,320 --> 04:21:57,279
键盘我们需要确保我们不断更新

2887
04:21:57,279 --> 04:22:00,399
我们在数据库中的笔记所以

2888
04:22:00,399 --> 04:22:05,279
例如，我们不会离开更新

2889
04:22:05,279 --> 04:22:08,960
当用户按下后退按钮时，我们会不断地这样做

2890
04:22:08,960 --> 04:22:14,872
用户在屏幕上输入 um 所以

2891
04:22:14,872 --> 04:22:19,512
为此，我们需要一些听众，以便标题在

2892
04:22:19,512 --> 04:22:22,720
无论如何我们都需要一个文本控制器

2893
04:22:22,720 --> 04:22:24,551
听众和

2894
04:22:24,551 --> 04:22:28,399
这个文本控制器监听器要做的就是它会成为一个主体

2895
04:22:28,399 --> 04:22:32,551
of function 它将是一个获取当前节点（如果存在）的函数

2896
04:22:32,551 --> 04:22:37,039
然后它将采用当前的文本编辑控制器文本并更新它

2897
04:22:37,039 --> 04:22:42,800
数据库中的注释没问题，所以让我们去创建那个函数吧

2898
04:22:42,800 --> 04:22:47,360
void 我们将说文本控制器侦听器

2899
04:22:47,360 --> 04:22:52,320
记住这个函数还没有被调用它是给我们的

2900
04:22:52,320 --> 04:22:56,479
然后作为侦听器连接到文本编辑控制器，所以我们很快

2901
04:22:56,479 --> 04:23:00,399
将编写另一个功能，说嘿文本编辑控制器

2902
04:23:00,399 --> 04:23:04,232
每当您的文本更改时，都可以调用此函数，所以不用担心

2903
04:23:04,232 --> 04:23:09,360
它还没有被调用所以在这里我们基本上会得到

2904
04:23:09,360 --> 04:23:14,399
注意，嗯，我也要摆脱这个，我要说最后

2905
04:23:14,399 --> 04:23:17,440
嗯笔记是这个笔记然后我们要去

2906
04:23:17,440 --> 04:23:20,960
说如果 note 为 null 表示我们没有该便笺

2907
04:23:20,960 --> 04:23:25,759
我们只是返回我们不能使用空节点

2908
04:23:25,759 --> 04:23:31,512
然后我们要说从我们的文本控制器中获取文本

2909
04:23:31,512 --> 04:23:36,551
像那样，然后我们将等待我们的笔记服务更新笔记

2910
04:23:36,551 --> 04:23:42,000
使用该文本，然后在末尾使用逗号以使格式正常工作

2911
04:23:42,000 --> 04:23:45,440
所以这很容易 很简单 不需要那么多

2912
04:23:45,440 --> 04:23:48,831
解释也许这只是一个简单的更新说明

2913
04:23:48,831 --> 04:23:52,232
如此完美

2914
04:23:52,232 --> 04:23:57,039
正如我现在提到的，我们有这个文本控制器监听器，我们还需要

2915
04:23:57,039 --> 04:24:01,512
有一个称为设置文本控制器侦听器的功能，它首先

2916
04:24:01,512 --> 04:24:06,160
如果它已经从我们的文本编辑控制器中删除了这个监听器

2917
04:24:06,160 --> 04:24:10,960
被添加，然后它再次添加它，所以让我们继续，我只是

2918
04:24:10,960 --> 04:24:15,039
将复制该函数名称，因此我不必再次编写它

2919
04:24:15,039 --> 04:24:19,919
嗯，然后在这里我们进入我们称之为文本的文本编辑控制器

2920
04:24:19,919 --> 04:24:25,279
控制器，我们说现在为我们删除侦听器和那个侦听器

2921
04:24:25,279 --> 04:24:28,479
被称为文本控制器侦听器好吧

2922
04:24:28,479 --> 04:24:31,512
然后在删除它之后我们要添加它

2923
04:24:31,512 --> 04:24:36,720
所以在这里我要添加监听器和

2924
04:24:36,720 --> 04:24:41,119
只需添加该侦听器，以防此函数被多次调用

2925
04:24:41,119 --> 04:24:43,759
正确的

2926
04:24:43,759 --> 04:24:49,039
所以现在我们要进入本章有趣的部分

2927
04:24:49,039 --> 04:24:53,831
因为你看到我们已经在这里添加了很多编码但没有人真正

2928
04:24:53,831 --> 04:24:58,479
利用这些，或者实际上我们不能这么说，因为

2929
04:24:58,479 --> 04:25:02,320
白痴对不起处置例如利用保存节点，如果不是

2930
04:25:02,320 --> 04:25:05,919
空的，如果文本为空，它会利用删除注释，但我们是

2931
04:25:05,919 --> 04:25:09,039
没有利用这个创建新节点，我们也没有利用

2932
04:25:09,039 --> 04:25:13,191
设置文本控制器侦听器，这就是我们要做的

2933
04:25:13,191 --> 04:25:17,440
在我们的身体里做我们的

2934
04:25:17,440 --> 04:25:20,960
呃小部件现在它只是说的身体

2935
04:25:20,960 --> 04:25:25,759
context 在这里写下你的新节点，但我们要做的是

2936
04:25:25,759 --> 04:25:31,279
用我们未来的建设者替换它

2937
04:25:31,279 --> 04:25:34,479
当你按下

2938
04:25:34,479 --> 04:25:38,232
应用程序主 ui 上的加号按钮 没有人在创建新的

2939
04:25:38,232 --> 04:25:42,479
请注意您需要在这个新的笔记视图中自己做

2940
04:25:42,479 --> 04:25:47,440
name 表示所以让我们去替换 this 的这个函数的主体

2941
04:25:47,440 --> 04:25:52,551
未来建造者的参数记住未来建造者必须有

2942
04:25:52,551 --> 04:25:56,080
两个变量一个是未来本身和

2943
04:25:56,080 --> 04:25:59,919
另一个将是它的构建器功能，所以

2944
04:25:59,919 --> 04:26:06,000
对于未来，我们需要调用返回未来的创建新节点

2945
04:26:06,000 --> 04:26:11,512
记住它实际上返回了数据库注释，我们已经

2946
04:26:11,512 --> 04:26:16,399
编码这个函数没问题，所以这就是未来

2947
04:26:16,399 --> 04:26:22,232
由未来的构建器调用，然后我们将编写构建器

2948
04:26:22,232 --> 04:26:25,039
我将从 Visual Studio 代码中获得帮助来完成这项工作

2949
04:26:25,039 --> 04:26:28,960
请记住，在您的构建器中，您必须返回一个小部件

2950
04:26:28,960 --> 04:26:31,679
所以我们要做的是因为这是一个

2951
04:26:31,679 --> 04:26:36,551
未来我们需要寻找它的完成状态它不会是我们没有的地方

2952
04:26:36,551 --> 04:26:41,119
必须寻找活动和等待我们只需要寻找完成

2953
04:26:41,119 --> 04:26:46,160
否则我们将显示一个进度指示器好吧，所以让我们说 switch

2954
04:26:46,160 --> 04:26:52,399
快照状态连接状态和来自 Visual Studio 代码的帮助以添加

2955
04:26:52,399 --> 04:26:56,160
这些缺失的案例条款对我来说是这样，嗯

2956
04:26:56,160 --> 04:27:00,800
非等待，所以这些都不重要，除了完成

2957
04:27:00,800 --> 04:27:04,000
对，所以我们就这样离开它

2958
04:27:04,000 --> 04:27:07,919
那么在 uh 默认的情况下，我们只会说

2959
04:27:07,919 --> 04:27:13,119
默认 oops 返回 cons 循环进度指示器

2960
04:27:13,119 --> 04:27:17,679
所以现在我们说当这个创建新节点完成时

2961
04:27:17,679 --> 04:27:20,960
已在我们即将完成的数据库中创建了一个新节点，但我们没有

2962
04:27:20,960 --> 04:27:24,720
返回任何东西，这就是你在这里看到这个小错误的原因，但是

2963
04:27:24,720 --> 04:27:28,551
如果连接状态没有完成，例如如果它正在等待创建

2964
04:27:28,551 --> 04:27:32,160
节点发生然后我们将显示一个小的圆形进度指示器

2965
04:27:32,160 --> 04:27:35,440
用户并记住这将发生得如此之快，以至于您甚至都没有

2966
04:27:35,440 --> 04:27:40,000
会看到这个但是我完全知道循环进展

2967
04:27:40,000 --> 04:27:43,600
指标可能不是以前的解决方案，但我们将在这里做

2968
04:27:43,600 --> 04:27:47,919
我们不会花太多时间来预定义这段代码，因为它是

2969
04:27:47,919 --> 04:27:51,440
可能会在现代硬件上向用户显示

2970
04:27:51,440 --> 04:27:56,479
电话只是几毫秒，所以可能不值得预先定义

2971
04:27:56,479 --> 04:28:00,232
现在代码这么多，至少可以，因为我们在这门课程中进行，但是如果你

2972
04:28:00,232 --> 04:28:04,800
有无限的时间，你和你真的是注意力和你

2973
04:28:04,800 --> 04:28:09,191
对细节有很多关注，那么您可能需要稍微修复一下

2974
04:28:09,191 --> 04:28:14,399
也许把它放在某种中心，或者改变颜色等

2975
04:28:14,399 --> 04:28:18,479
但我们现在不会那样做

2976
04:28:18,479 --> 04:28:21,919
记住我们未来的建设者现在只是

2977
04:28:21,919 --> 04:28:26,000
创建一个未来的构建器，它是并且它被理解为一个数据库

2978
04:28:26,000 --> 04:28:30,551
请注意，如果我们进入 don 连接状态并说

2979
04:28:30,551 --> 04:28:35,759
snapchat 快照数据，虽然它说的是对象

2980
04:28:35,759 --> 04:28:39,679
好吧，我们已经知道这个快照数据是类型

2981
04:28:39,679 --> 04:28:44,000
数据库节点，因为它是未来本身，所以我们只说最终

2982
04:28:44,000 --> 04:28:48,399
实际上不，我们将把它分配给我们的节点变量记住我们有

2983
04:28:48,399 --> 04:28:52,960
这个节点变量在这里，几乎所有这些功能都是

2984
04:28:52,960 --> 04:28:56,639
依靠那个节点变量在那里，这就是我们正在做的事情

2985
04:28:56,639 --> 04:28:59,831
创建一个创建节点的未来构建器，然后我们将其分配给我们的

2986
04:28:59,831 --> 04:29:04,000
节点变量好的，所以我们会说快照

2987
04:29:04,000 --> 04:29:06,720
数据添加

2988
04:29:06,720 --> 04:29:10,000
数据库节点，这就是我们的方式

2989
04:29:10,000 --> 04:29:15,279
从我们的快照中获取我们的节点

2990
04:29:15,279 --> 04:29:18,872
完成此操作后，我们将调用我们的设置

2991
04:29:18,872 --> 04:29:24,000
文本控制器侦听器，因为这就是我们要开始的地方

2992
04:29:24,000 --> 04:29:30,479
在我们的主 UI 上监听用户文本的变化

2993
04:29:30,479 --> 04:29:34,160
好吧，在这一点上我们已经做了什么

2994
04:29:34,160 --> 04:29:38,872
除了实际返回和返回文本外，我们必须做

2995
04:29:38,872 --> 04:29:42,479
用户可以使用的字段

2996
04:29:42,479 --> 04:29:46,960
编辑 ui 上的文本，让我们继续这样做，删除中断

2997
04:29:46,960 --> 04:29:49,831
在这里声明，因为我们不再需要它，我们只想说

2998
04:29:49,831 --> 04:29:54,232
我相信返回添加文本字段

2999
04:29:54,232 --> 04:29:58,639
我们将把我们的文本分配给我们要使用的控制器参数

3000
04:29:58,639 --> 04:30:04,960
在这里分配我们的文本控制器的值，这就是文本字段的方式