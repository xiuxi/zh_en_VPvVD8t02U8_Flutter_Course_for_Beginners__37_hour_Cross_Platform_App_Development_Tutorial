1
21:30:04,960 --> 21:30:09,192
将消息发送到一个称为文本编辑控制器的对象，然后说嘿我的文本

2
21:30:09,192 --> 21:30:13,832
已更改，这是我们在颤振中对文本字段的代理，

3
21:30:13,832 --> 21:30:19,600
好吧，这就是设置，我们还需要做的是

4
21:30:19,600 --> 21:30:23,760
允许用户输入多行 这个文本字段中的文本，因为记住

5
21:30:23,760 --> 21:30:27,600
通常在颤动中的文本字段就像一行，所以例如你正在写一个

6
21:30:27,600 --> 21:30:32,080
电子邮件地址或者你正在写你的密码，所以默认情况下它们不像多行

7
21:30:32,080 --> 21:30:37,360
文本字段，除非你制作它们 多行，这就是我们

8
21:30:37,360 --> 21:30:40,640
现在要做的，所以我们要说我们的键盘类型，

9
21:30:40,640 --> 21:30:45,680
你可以看到它的类型是文本输入类型，然后说文本输入类型

10
21:30:45,680 --> 21:30:50,232
alt-line 好吧，这样你就可以

11
21:30:50,232 --> 21:30:54,400
在键盘的

12
21:30:54,400 --> 21:30:57,360
右下角有一个

13
21:30:57,360 --> 21:31:01,600
小回车键 所以在这里

14
21:31:01,600 --> 21:31:05,760
你会得到那个键盘，你很快就会看到

15
21:31:05,760 --> 21:31:10,080
你会在你的键盘上得到那个键来跳到下一

16
21:31:10,080 --> 21:31:13,600
行，因为当你在做ios开发时它也很快，

17
21:31:13,600 --> 21:31:17,512
有一个奇怪的习惯是

18
21:31:17,512 --> 21:31:23,040
创建带有奇怪参数的多行文本字段和

19
21:31:23,040 --> 21:31:26,232
不幸的是，它也已经泄漏到颤动中，

20
21:31:26,232 --> 21:31:29,360
嗯，你没有像

21
21:31:29,360 --> 21:31:34,960
文本字段中的参数那样显示多行，所以如果你想创建一个多行的文本字段

22
21:31:34,960 --> 21:31:40,320
，它有点像你输入更多 文本输入

23
21:31:40,320 --> 21:31:45,832
然后不幸的是你必须调用并且你必须将 null 分配给 max

24
21:31:45,832 --> 21:31:49,120
行的参数在 github 上有一些

25
21:31:49,120 --> 21:31:53,040
关于为什么会这样的讨论，但它背后有一个很好的理由好吧

26
21:31:53,040 --> 21:31:56,800
嗯，我们接下来要做的是如果 如果

27
21:31:56,800 --> 21:32:02,400
我们这样做，我按 command s，然后我们到这里

28
21:32:02,400 --> 21:32:06,872
，我们在这里按加号按钮，好吧，你会看到这里有一个文本字段，

29
21:32:06,872 --> 21:32:11,920
这很好，但是用户不太明显

30
21:32:11,920 --> 21:32:15,760
我应该做什么 在这里做这行是什么我要点击

31
21:32:15,760 --> 21:32:20,160
这里的某个地方不是这样 很明显，所以我们要做的是在

32
21:32:20,160 --> 21:32:24,552
这个文本字段中添加一个叫做提示的东西，如果你是设计师或开发人员，你

33
21:32:24,552 --> 21:32:28,080
可能已经知道什么是提示，但如果你不知道什么是提示

34
21:32:28,080 --> 21:32:31,920
提示很小，因为这个名称表示一个小文本

35
21:32:31,920 --> 21:32:36,960
，通常会显示给用户，告诉她或他 uh

36
21:32:36,960 --> 21:32:42,400
在这个 uh 字段中应该输入什么，所以

37
21:32:42,400 --> 21:32:46,640
让我们去添加提示，这是通过我们文本上的属性 字段

38
21:32:46,640 --> 21:32:49,600
称为装饰，那是

39
21:32:49,600 --> 21:32:53,760
我们输入装饰中的输入装饰，我们

40
21:32:53,760 --> 21:32:57,920
将添加一个称为提示文本的参数，在这里我们只是说开始

41
21:32:57,920 --> 21:33:01,360
像这样输入你的笔记，

42
21:33:01,360 --> 21:33:03,832
所以命令

43
21:33:03,832 --> 21:33:08,552
和逗号在这里 代码有点，

44
21:33:08,552 --> 21:33:14,080
但现在我们开始了，我们在这里有提示，当我点击这个

45
21:33:14,080 --> 21:33:17,832
文本字段时，你可以看到我可以开始在这里输入，然后按下这个小

46
21:33:17,832 --> 21:33:21,360
按钮，我正在谈论多行 当我开始输入

47
21:33:21,360 --> 21:33:26,080
越来越多的文本时，文本字段会增加 n 大小没问题

48
21:33:26,080 --> 21:33:28,872
，这就是我们在本章中真正要做的我希望我没有

49
21:33:28,872 --> 21:33:33,440
在本章开头说本章将是

50
21:33:33,440 --> 21:33:35,920
一种代码重但我的意思是没有吓到你 是相当多

51
21:33:35,920 --> 21:33:40,080
的代码，但希望你能在整个章节中坚持我并

52
21:33:40,080 --> 21:33:43,440
做到这一点，就像我们工作的所有其他章节中的传统一样，

53
21:33:43,440 --> 21:33:48,480
我们不会

54
21:33:48,480 --> 21:33:51,600
失去我们不想失去的工作 我们正在处理我们的代码，所以我们需要

55
21:33:51,600 --> 21:33:56,232
确保我们提交并且我们标记我们的代码

56
21:33:56,232 --> 21:34:01,120
没问题，所以让我稍微改变一下屏幕布局

57
21:34:01,120 --> 21:34:06,232
，我们已经将前一章标记为第 13 步，所以这里的标题表明

58
21:34:06,232 --> 21:34:11,280
我们将标记并提交此代码作为第 14 步，所以

59
21:34:11,280 --> 21:34:15,512
我要说 git status 两个文件更改，然后我将

60
21:34:15,512 --> 21:34:20,720
它们全部添加到暂存环境，然后我将它们

61
21:34:20,720 --> 21:34:24,640
作为第 14 步提交和 将我的更改推送到 github

62
21:34:24,640 --> 21:34:29,920
，然后我将我们的代码也标记为第 14 步，然后推送我们的标签

63
21:34:29,920 --> 21:34:37,120
t 现在再次标记 um 就像其他章节的传统一样，

64
21:34:37,120 --> 21:34:39,512
以及在每一章的末尾我们将讨论我们将

65
21:34:39,512 --> 21:34:44,720
在下一章讨论的内容，所以我们现在实际上是在创建笔记，它

66
21:34:44,720 --> 21:34:47,600
可能不会立即 对您可见，但如果您

67
21:34:47,600 --> 21:34:54,800
创建了一些笔记，那么这个屏幕应该能够呈现这些笔记，

68
21:34:54,800 --> 21:34:57,920
因为新的笔记视图正在做所有必要的事情，不仅是

69
21:34:57,920 --> 21:35:02,160
创建笔记，让我们看看它在哪里创建新笔记

70
21:35:02,160 --> 21:35:06,552
但它也正在为我们更新该注释，所以在这里您可以看到更新注释，因此这些

71
21:35:06,552 --> 21:35:10,160
注释在数据库中只是应用程序的主 ui 是

72
21:35:10,160 --> 21:35:16,160
这个节点 c 黑暗无法呈现它们它所做的只是

73
21:35:16,160 --> 21:35:19,832
说等待所有节点，所以它不是那么令人兴奋，但只要知道

74
21:35:19,832 --> 21:35:23,440
你已经到达那里，我们正在到达那里，只是还有几个步骤

75
21:35:23,440 --> 21:35:28,400
可以处理这个问题，嗯，这正是我们在下一章要做的，

76
21:35:28,400 --> 21:35:32,160
所以得到 一些茶和咖啡，如果 你想，我会在那里见到你

77
21:35:32,160 --> 21:35:37,920
你好，欢迎来到前几章中 slotzer 课程的第 32 章，

78
21:35:37,920 --> 21:35:42,800
我们一直在谈论我们的节点服务和创建流

79
21:35:42,800 --> 21:35:47,280
控制器以使用节点填充流控制

80
21:35:47,280 --> 21:35:51,280
我们在节点服务中也有一个本地称为下划线节点的缓冲区，

81
21:35:51,280 --> 21:35:55,120
所以我们有点像以一种非常好的和有机的方式处理我们的笔记

82
21:35:55,120 --> 21:35:59,512
，我们还使用新的节点视图暗文件，我们在其中创建了一个有状态的

83
21:35:59,512 --> 21:36:04,232
小部件 它有一个文本编辑控制器，我还允许

84
21:36:04,232 --> 21:36:09,040
用户输入我们管理的一些文本，甚至将该文本作为

85
21:36:09,040 --> 21:36:12,720
新注释保存到数据库中，所以我们已经做了很多，但是没有那么

86
21:36:12,720 --> 21:36:16,720
有趣的是它是 有点反高潮，因为我们能够

87
21:36:16,720 --> 21:36:22,160
创建笔记，但我们无法实际显示它们，所以我们

88
21:36:22,160 --> 21:36:26,080
用新笔记填充数据库，但没有人能够在屏幕上显示它们

89
21:36:26,080 --> 21:36:29,192
，那就是 我们将在本章中处理什么，

90
21:36:29,192 --> 21:36:33,920
所以让我来看看 将我们到目前为止编写的代码响铃到屏幕上

91
21:36:33,920 --> 21:36:38,552
，嗯，我将清除此获取状态，

92
21:36:38,552 --> 21:36:44,080
以确保一切正常，是

93
21:36:44,080 --> 21:36:48,232
的，我将把 scrcpy 带到右侧的 Visual Studio 代码

94
21:36:48,232 --> 21:36:50,872
和 我们现在必须谈谈

95
21:36:50,872 --> 21:36:55,360
我们的节点服务遇到的一个小问题，如果您查看这里的代码

96
21:36:55,360 --> 21:36:59,360
，我将增加大小，以便您看得更清楚，

97
21:36:59,360 --> 21:37:03,680
所以如果您查看我们的注释服务

98
21:37:03,680 --> 21:37:06,480
，我们有 我们在这里创建的这个呃共享实例好吧，所以每当

99
21:37:06,480 --> 21:37:10,480
有人说注意服务括号时，他们实际上并没有创建任何

100
21:37:10,480 --> 21:37:15,280
实例，他们没有创建节点服务的新实例，但他们

101
21:37:15,280 --> 21:37:18,800
正在通过这个工厂初始化程序 调用这个共享

102
21:37:18,800 --> 21:37:22,232
静态 final 反过来又调用这个内部或私有构造函数，这

103
21:37:22,232 --> 21:37:27,120
意味着我们已经创建了一个单例，所以一遍又一遍地创建一个新的节点服务

104
21:37:27,120 --> 21:37:33,760
不会创建一个新实例，

105
21:37:33,760 --> 21:37:37,440
他只会得到相同的共享实例然后 然后谁开始

106
21:37:37,440 --> 21:37:41,440
stalk reading 或者您正确地看到这里的

107
21:37:41,440 --> 21:37:45,120
所有注释所有注释都将其职责委托给节点流

108
21:37:45,120 --> 21:37:48,400
控制器或流但是我们的节点流控制器是广播流

109
21:37:48,400 --> 21:37:52,400
控制器，这意味着流控制器

110
21:37:52,400 --> 21:37:57,360
并没有真正保持 到新监听器的当前值所以假设你

111
21:37:57,360 --> 21:38:02,400
有一个流控制器坐在这里，你开始

112
21:38:02,400 --> 21:38:07,920
从一个地方监听那个流控制器的事件，然后一个事件进入

113
21:38:07,920 --> 21:38:12,080
流控制器，流控制器说哦，我有 一个监听器

114
21:38:12,080 --> 21:38:16,320
在这里我将把这个信息委托给那个监听器

115
21:38:16,320 --> 21:38:20,720
看起来很好但是在这个事件传播到

116
21:38:20,720 --> 21:38:24,872
流控制器之后

117
21:38:24,872 --> 21:38:29,920
当一个新的监听器进来时流控制器不会保持这个值 另一方面，因此

118
21:38:29,920 --> 21:38:34,232
您的广播流控制器的任何新侦听器都不会被

119
21:38:34,232 --> 21:38:37,920
告知该流控制器中填充的当前信息，

120
21:38:37,920 --> 21:38:41,440
因此如果 例如，您熟悉使用 rx 进行反应式编程

121
21:38:41,440 --> 21:38:45,280
，您可能知道这是一个已发表的主题，如果您

122
21:38:45,280 --> 21:38:49,920
使用 rx java 或 rx scotland

123
21:38:49,920 --> 21:38:54,080
rx swift 也是如此，即使您正在做类似的组合编程 使用 swift ui，您

124
21:38:54,080 --> 21:38:58,640
将知道这些就像已发布的主题一样

125
21:38:58,640 --> 21:39:04,232
，因此广播的流控制器不会保留其当前的 uh

126
21:39:04,232 --> 21:39:07,360
值，对于新听众我们需要我们需要解决这个问题，而做到

127
21:39:07,360 --> 21:39:11,832
这一点的方法就是 将节点流

128
21:39:11,832 --> 21:39:16,960
控制器的初始化移到我们的初始化器中，我们很快就会看到，

129
21:39:16,960 --> 21:39:21,280
所以我将在这里做一些屏幕尺寸的洗牌，

130
21:39:21,280 --> 21:39:26,480
因为标题表明

131
21:39:26,480 --> 21:39:29,832
我们需要做什么，我们 需要制作这个注释流控制器

132
21:39:29,832 --> 21:39:34,320
，让我们看看它在哪里，我们需要使它成为一个后期的

133
21:39:34,320 --> 21:39:38,640
最终结果，所以从它所在的位置获取数据类型，然后说后期最终将

134
21:39:38,640 --> 21:39:42,552
数据类型放在这里，然后删除等于 好的，所以现在我们有

135
21:39:42,552 --> 21:39:47,440
责任 确保

136
21:39:47,440 --> 21:39:52,480
在构造我们的节点服务的新实例时，这个节点流控制器实际上是在构造函数上初始化

137
21:39:52,480 --> 21:39:55,920
的

138
21:39:55,920 --> 21:39:59,920
数据库节点的流控制器列表，然后我们做与使用广播之前完全相同的事情，

139
21:39:59,920 --> 21:40:04,552
但是我们在这里要做的是

140
21:40:04,552 --> 21:40:08,720
使用广播流侦听器中的一个属性，在侦听时调用，所以这

141
21:40:08,720 --> 21:40:13,360
除非和呃回调是

142
21:40:13,360 --> 21:40:17,192
每当新的侦听器订阅我们的注释流控制器

143
21:40:17,192 --> 21:40:21,440
注释流控制器流时都会被调用，因此在发生这种情况时，我们需要

144
21:40:21,440 --> 21:40:26,800
确保我们的节点流控制器流填充了

145
21:40:26,800 --> 21:40:30,400
我们当前从数据库中读取的所有值，所以让我们开始吧 前进并这样做，

146
21:40:30,400 --> 21:40:35,600
所以我们将继续说notes

147
21:40:35,600 --> 21:40:41,600
stream controller sync add notes就像这样，

148
21:40:41,600 --> 21:40:46,960
这样可以确保任何开始听

149
21:40:46,960 --> 21:40:52,872
我们的人 属性 all notes 反过来使用 no stream controller 如果它是一个

150
21:40:52,872 --> 21:40:55,680
新订阅者，那么它将调用未列出的 um 回调

151
21:40:55,680 --> 21:41:00,400
，然后我们将

152
21:41:00,400 --> 21:41:04,872
使用我们已经从 数据库

153
21:41:04,872 --> 21:41:08,640
好的，让我们现在进入下一个注释，然后

154
21:41:08,640 --> 21:41:13,600
我们才能真正开始本章的其余部分，正如标题所示，因为

155
21:41:13,600 --> 21:41:17,920
我们不应该在打开数据库后在热重载时关闭数据库，我们不应该

156
21:41:17,920 --> 21:41:22,080
在每次重新加载时关闭它 被关闭，

157
21:41:22,080 --> 21:41:25,120
所以我所指的问题在我们的注释视图中，

158
21:41:25,120 --> 21:41:29,512
它就在我们的处置中，所以在进行热重载时我们正在做的是

159
21:41:29,512 --> 21:41:32,720
我们说节点服务关闭，这反过来又会 实际上关闭

160
21:41:32,720 --> 21:41:36,232
数据库，但请记住节点服务是并且是并且应该是一个

161
21:41:36,232 --> 21:41:41,920
单例，在创建和打开一次时它应该保持

162
21:41:41,920 --> 21:41:46,480
其状态，所以我们不应该

163
21:41:46,480 --> 21:41:50,480
在我们的任何小部件中关闭数据库 因为那个  将

164
21:41:50,480 --> 21:41:56,800
干扰内部结构以及节点服务实际上应该如何工作，所以

165
21:41:56,800 --> 21:42:02,232
我们将要做的，正如你所看到的，因为这里的姿势函数在这里

166
21:42:02,232 --> 21:42:06,080
覆盖了 dispose 函数，它唯一实际

167
21:42:06,080 --> 21:42:10,552
做的事情是 要关闭节点服务数据库，我们现在只是要删除这个

168
21:42:10,552 --> 21:42:16,400
功能，因为我们目前在我们的注释视图中没有其他东西可以处理，

169
21:42:16,400 --> 21:42:19,832
好吧，所以我们需要做的是真正了解

170
21:42:19,832 --> 21:42:23,192
本节的内容 我对本章感到非常兴奋

171
21:42:23,192 --> 21:42:27,120
，那就是开始使用列表视图

172
21:42:27,120 --> 21:42:32,232
，我们需要做的是确保我们有一个列表，

173
21:42:32,232 --> 21:42:36,400
我们可以在这里获取来自我们的流的数据 builder 你可以看到

174
21:42:36,400 --> 21:42:40,960
它读取了所有的注释，现在我们只是说等待所有节点，

175
21:42:40,960 --> 21:42:45,832
所以我们要改变它，相反，我们实际上将开始

176
21:42:45,832 --> 21:42:50,872
使用称为列表视图的东西，现在颤振中的列表视图是 一个很棒的

177
21:42:50,872 --> 21:42:57,680
小部件，我实际上可以展示 你在这里所以如果你只是输入列表视图

178
21:42:57,680 --> 21:43:03,600
然后命令并单击控制点击linux和windows你

179
21:43:03,600 --> 21:43:08,720
可以看到它是一个盒子滚动视图扩展了盒子滚动视图这又是一个

180
21:43:08,720 --> 21:43:12,320
滚动视图又是一个无状态小部件所以

181
21:43:12,320 --> 21:43:18,232
一个列表视图 有一些功能，一些非常棒的功能，它

182
21:43:18,232 --> 21:43:21,680
使用的是构建器，我们可以在这里看到它有一个构建器函数，我相信

183
21:43:21,680 --> 21:43:26,160
它在这里是一个静态函数，或者它实际上是一个构造

184
21:43:26,160 --> 21:43:29,440
器，很好，所以它有一个构建器，在你的构建器中你会是 能够将两个

185
21:43:29,440 --> 21:43:33,280
重要参数传递给这个列表视图，所以我们会说

186
21:43:33,280 --> 21:43:38,080
我们返回一个列表视图，而不是我们现在

187
21:43:38,080 --> 21:43:43,120
所说的等待所有笔记在这里的那个小文本我们会说我们首先有两个

188
21:43:43,120 --> 21:43:47,512
参数 会告诉它必须在屏幕上渲染多少项目，

189
21:43:47,512 --> 21:43:53,280
所以我们会说项目计数

190
21:43:53,280 --> 21:43:57,192
，对于项目计数，我们需要实际侦听此快照数据，

191
21:43:57,192 --> 21:44:01,280
因此请记住流构建器此时正在侦听 所有笔记

192
21:44:01,280 --> 21:44:05,040
所以这意味着来自快照的数据

193
21:44:05,040 --> 21:44:10,640
实际上将是你的

194
21:44:10,640 --> 21:44:14,960
um 将是我们从数据库中读取的所有笔记所以我们

195
21:44:14,960 --> 21:44:20,872
现在需要做的只是确保在这里等待 um 所以

196
21:44:20,872 --> 21:44:25,832
我实际上要删除它，我要说如果

197
21:44:25,832 --> 21:44:29,280
快照有数据，那么这是你的快照上的一个属性，它

198
21:44:29,280 --> 21:44:34,080
显示快照是否实际上有 pro 可以为你提供一些数据，

199
21:44:34,080 --> 21:44:39,040
我将把一个 else 放进去 在这里和其他地方，我们还要说返回

200
21:44:39,040 --> 21:44:44,480
con 循环进度指示器好的，如果

201
21:44:44,480 --> 21:44:49,440
快照有任何数据，那么让我们获取该数据，所以我只想说最后

202
21:44:49,440 --> 21:44:54,720
所有笔记都是快照，它是作为数据库笔记列表的数据

203
21:44:54,720 --> 21:44:58,872
好吧，我们能做什么我们可以说

204
21:44:58,872 --> 21:45:03,600
return const text

205
21:45:03,600 --> 21:45:08,720
得到所有类似的注释，如果你愿意，我们实际上可以将这些注释打印

206
21:45:08,720 --> 21:45:13,832
到屏幕上，我们可以说打印注释

207
21:45:13,832 --> 21:45:21,680
，我将带来调试 控制台，

208
21:45:21,680 --> 21:45:24,800
然后我将清除日志并更改屏幕 布局，

209
21:45:24,800 --> 21:45:28,872
以便您看得更清楚，我只是要执行命令，

210
21:45:28,872 --> 21:45:33,600
好吧，我现在可以看到它只是在说您的笔记，这意味着

211
21:45:33,600 --> 21:45:37,512
我们实际上没有任何笔记，所以如果我进入这里，那么

212
21:45:37,512 --> 21:45:42,232
您可以看到所有 突然间，我们在数据库中填充了一个新便笺，

213
21:45:42,232 --> 21:45:48,232
因为我去了这里，我说我正在打印一些便笺，

214
21:45:48,232 --> 21:45:52,872
所以我要打个招呼，好吧，

215
21:45:52,872 --> 21:45:56,640
看看我正在更改它，我们的快照实际上正在更新为新的

216
21:45:56,640 --> 21:46:01,832
信息，它不断打印，它的注释ID是相同的，你

217
21:46:01,832 --> 21:46:07,040
可以看到他的文字实际上正在改变，如果我出去，那么你可以看到

218
21:46:07,040 --> 21:46:10,480
它只是此刻说得到所有的笔记意味着你有一些笔记

219
21:46:10,480 --> 21:46:13,760
所以如果 你现在看到的是一个循环进度指示器，而不是像一个文本

220
21:46:13,760 --> 21:46:19,832
，我们说所有的笔记，这可能是因为你和我一样

221
21:46:19,832 --> 21:46:24,080
，你在数据库中没有任何笔记，

222
21:46:24,080 --> 21:46:29,680
好吧，现在我们有所有的 笔记 那么我们如何渲染这些所以我们需要

223
21:46:29,680 --> 21:46:33,600
在这里做些什么 我们要说 返回列表视图我要更改屏幕

224
21:46:33,600 --> 21:46:38,080
布局假设列表视图构建器

225
21:46:38,080 --> 21:46:41,512
，你记得我之前提到过我们需要用两个重要参数填充这个列表视图

226
21:46:41,512 --> 21:46:46,000
一个是项目数，目前项目数

227
21:46:46,000 --> 21:46:51,440
是所有笔记计数链接 然后我们让我们的项目构建器

228
21:46:51,440 --> 21:46:55,360
从你的编辑器那里获得一些帮助来完成这个你得到一个

229
21:46:55,360 --> 21:46:59,280
构建上下文作为类型上下文的第一个参数然后你得到一个索引

230
21:46:59,280 --> 21:47:04,000
现在在你的项目构建器中你的工作就是

231
21:47:04,000 --> 21:47:09,920
如果你看

232
21:47:09,920 --> 21:47:15,360
项目构建器的签名它说它是一个函数

233
21:47:15,360 --> 21:47:19,120
，它接受两个参数它构建上下文和一个整数作为索引，

234
21:47:19,120 --> 21:47:23,360
它必须返回一个你在这里看到的小部件，所以你可以在这里返回任何东西你

235
21:47:23,360 --> 21:47:29,512
可以说返回文本项目类似的

236
21:47:29,512 --> 21:47:32,232
东西 它看起来不会那么漂亮

237
21:47:32,232 --> 21:47:35,600
，实际上我可以看到也许我们丢失了我们的项目也许在这里

238
21:47:35,600 --> 21:47:39,680
我们的注释 2 可能有问题，就像

239
21:47:39,680 --> 21:47:44,320
删除注释一样，所以我只是要做 在

240
21:47:44,320 --> 21:47:47,600
这里进行热重载，我的 scr cpy 实际上可能会死掉，但是它可以正常

241
21:47:47,600 --> 21:47:51,600
工作，所以我们有一个项目，所以如果那是您也

242
21:47:51,600 --> 21:47:56,800
看到的，也许您可以进行热重载，因为我们已经更改了节点 服务，

243
21:47:56,800 --> 21:47:59,832
所以问题可能是我们的呃，我们只需要热重载

244
21:47:59,832 --> 21:48:04,160
这个 unlisten 才能真正被调用，所以这就是我们现在看到的，

245
21:48:04,160 --> 21:48:10,720
所以我可以在这里看到项目，我要按下 加号按钮，我

246
21:48:10,720 --> 21:48:13,920
要在这里打招呼，我要出去，突然间

247
21:48:13,920 --> 21:48:18,000
你看到两个项目出现在这里，好吧，但这不是很漂亮，因为

248
21:48:18,000 --> 21:48:23,120
在屏幕上显示文本不是很好 你不会有，

249
21:48:23,120 --> 21:48:27,680
你将无法轻松地为这些项目添加交互，因为

250
21:48:27,680 --> 21:48:31,440
我们希望理想情况下这些项目出现

251
21:48:31,440 --> 21:48:35,360
在列表中，然后它们有自己的尺寸，所以它们有一个很好的高度，

252
21:48:35,360 --> 21:48:39,680
这样 它们彼此分开一点，正如您将在下一章中看到的那样，

253
21:48:39,680 --> 21:48:45,920
我们将使用 嗯，删除这些项目，因此我们希望

254
21:48:45,920 --> 21:48:50,960
用户能够在每个项目旁边看到某种图标，他

255
21:48:50,960 --> 21:48:54,720
或她可以使用该图标单击该图标并删除该项目，因此文本本身

256
21:48:54,720 --> 21:48:59,600
将无法为我们提供 有了我们需要的所有功能，所以

257
21:48:59,600 --> 21:49:03,192
我们需要一个更复杂的小部件，它被称为

258
21:49:03,192 --> 21:49:08,080
列表图块，所以让我们这样做，假设我们至少返回

259
21:49:08,080 --> 21:49:12,480
图块，我们的列表图块将有一个标题，所以这就是

260
21:49:12,480 --> 21:49:17,760
目前我们唯一要提供的东西，你可以看到它是一个小部件

261
21:49:17,760 --> 21:49:23,120
，对于这个列表的小部件和这个列表样式的标题，我们

262
21:49:23,120 --> 21:49:27,192
将使用文本，嗯，好的，我 将在其中放置

263
21:49:27,192 --> 21:49:32,232
一些逗号，因此对于文本，我们要说的

264
21:49:32,232 --> 21:49:38,960
是文本本身是

265
21:49:38,960 --> 21:49:42,400
我们想要获取在该注释中输入的文本，因此您会看到我们拥有所有

266
21:49:42,400 --> 21:49:45,760
注释，但我们没有 拥有当前注释，因此我们实际上正在

267
21:49:45,760 --> 21:49:49,440
阅读其索引的当前注释将使用 thi 提供给我们 s item builders

268
21:49:49,440 --> 21:49:54,160
index 所以让我们说final um notes是该索引处的所有节点，这

269
21:49:54,160 --> 21:49:57,440
就是我们要返回列表图块的当前节点，好吧，

270
21:49:57,440 --> 21:50:03,040
它的文本将是注释文本，你可以在这里看到

271
21:50:03,040 --> 21:50:08,160
呃我可以看到 我在这里写了瓷砖，但它应该是标题

272
21:50:08,160 --> 21:50:11,920
，在这里我们必须有一个分号，所以如果我在这里执行命令，

273
21:50:11,920 --> 21:50:19,600
你可以看到现在我们有非常我的意思是这些文本的更好更漂亮的版本

274
21:50:19,600 --> 21:50:24,552
，你 可以看到他们就在这里它说你好和

275
21:50:24,552 --> 21:50:30,552
你好世界这些是我们输入的文本你可以实际测试一下

276
21:50:30,552 --> 21:50:34,720
并说我的新我的新笔记在这里输入

277
21:50:34,720 --> 21:50:39,192
然后按后退按钮你会看到你的笔记 正常显示在

278
21:50:39,192 --> 21:50:45,360
屏幕上，但我们要在这里做的是，如果

279
21:50:45,360 --> 21:50:48,552
您在笔记中输入大量文本，那么如果我去说这里

280
21:50:48,552 --> 21:50:51,920
是我输入的很长的文本，我不

281
21:50:51,920 --> 21:50:57,920
想要 这一切都将显示在一个图块中，然后显示在节点视图中，因此我们现在有一个

282
21:50:57,920 --> 21:51:01,832
非常大的节点，但它本身正在运行

283
21:51:01,832 --> 21:51:06,800
打破你在笔记列表中看到的布局我们不想

284
21:51:06,800 --> 21:51:14,160
呈现整个笔记我们想以某种方式

285
21:51:14,160 --> 21:51:19,512
将我们显示的信息量限制在合理的大小

286
21:51:19,512 --> 21:51:26,720
，因为我们的笔记不 有标题，我们

287
21:51:26,720 --> 21:51:31,832
可以通过简单地渲染一行文本来推断笔记的内容，

288
21:51:31,832 --> 21:51:36,400
然后用户应该能够说哦，这就是我在笔记中写的内容

289
21:51:36,400 --> 21:51:39,600
，正如你将在最新的后续章节中看到的那样 我们将允许

290
21:51:39,600 --> 21:51:43,760
用户也可以单击或点击这些现有笔记，以便查看

291
21:51:43,760 --> 21:51:47,512
有关它们的更多信息，因此，如果您

292
21:51:47,512 --> 21:51:53,760
不向用户显示整个笔记并且作为 你会看到当用户

293
21:51:53,760 --> 21:51:57,440
开始在他们的笔记中输入越来越多的信息时，实际上并不

294
21:51:57,440 --> 21:52:01,680
希望呈现整个笔记，因为想象一个

295
21:52:01,680 --> 21:52:06,080
笔记有两页长，或者你会有两个非常小的笔记然后

296
21:52:06,080 --> 21:52:09,360
两页 很长的一个音符，这是不可行的，所以实际上是可行的，

297
21:52:09,360 --> 21:52:13,600
但是 这不是一个很好的用户界面，所以我要在这里加一个逗号，

298
21:52:13,600 --> 21:52:17,440
然后我将在我们的文本中使用一个名为 max lines 的属性，

299
21:52:17,440 --> 21:52:21,680
我只想说一个

300
21:52:21,680 --> 21:52:25,680
，所以你会在这里看到 我们要做的是

301
21:52:25,680 --> 21:52:31,600
确保用户理解这里的信息

302
21:52:31,600 --> 21:52:36,960
比我们渲染的更多，所以我们想在没有足够空间的文本末尾放置类似的省略号

303
21:52:36,960 --> 21:52:42,000
完全渲染自己，所以

304
21:52:42,000 --> 21:52:44,832
我们要说软换行，正如你所看到的，信息是

305
21:52:44,832 --> 21:52:49,680
文本是否应该在软换行符处中断，所以确保它是真的

306
21:52:49,680 --> 21:52:54,232
，然后我们要说溢出，我们要 说像这样的文本溢出

307
21:52:54,232 --> 21:52:59,512
省略号

308
21:52:59,512 --> 21:53:03,920
，现在你可以看到它说这是一个很长的文本等等

309
21:53:03,920 --> 21:53:07,760
等等等等，所以这是一个很好的指示，然后所有用户都

310
21:53:07,760 --> 21:53:12,872
知道有更多信息要呈现，但没有足够的

311
21:53:12,872 --> 21:53:17,680
空间 让这些信息现在可以在屏幕上呈现，

312
21:53:17,680 --> 21:53:20,640
所以我想我的意思是我们已经看过了 d 在所有工作原理上，我们实际上

313
21:53:20,640 --> 21:53:23,832
已经对其进行了演示，因此我们不必为此进行单独的演示，我们

314
21:53:23,832 --> 21:53:27,760
一直在研究它，因为我们一直在开发和应用程序，这

315
21:53:27,760 --> 21:53:32,400
是颤振的优点之一，所以

316
21:53:32,400 --> 21:53:37,680
我们现在不需要对这个演示做任何事情

317
21:53:37,680 --> 21:53:42,160
，你可能会感到惊讶，这

318
21:53:42,160 --> 21:53:45,680
就是我们现在要做的所有笔记视图没有更多的

319
21:53:45,680 --> 21:53:49,920
工作我们已经编写了

320
21:53:49,920 --> 21:53:52,552
我们能够在 时刻创建新笔记，我们能够

321
21:53:52,552 --> 21:53:57,120
在此列表视图构建器中一次显示这些笔记和一个，因此您将学习如何

322
21:53:57,120 --> 21:54:00,552
使用列表视图构建器以及我们可以做的传统

323
21:54:00,552 --> 21:54:04,480
我们将要 去提交并标记我们的工作，所以

324
21:54:04,480 --> 21:54:06,960
我要在屏幕上做一些重新洗牌，

325
21:54:06,960 --> 21:54:10,640
这样你就会看到我做得更好一点

326
21:54:10,640 --> 21:54:15,832
，我要在这里转到我的内置终端，我们

327
21:54:15,832 --> 21:54:21,280
会有一个 查看状态可以看到有两个文件已更改，所以

328
21:54:21,280 --> 21:54:25,120
让我们执行 git add all

329
21:54:25,120 --> 21:54:27,680
并将其作为第 15 步提交，在提交之前您可以看到您的

330
21:54:27,680 --> 21:54:30,400
git l 在最后一次提交之前的 ock 是第 14 步，

331
21:54:30,400 --> 21:54:34,800
因此您还可以查看所有标签，我们最多可以看到标签 14。

332
21:54:34,800 --> 21:54:39,680
所以让我们继续说 git commit 并执行第 15 步。

333
21:54:39,680 --> 21:54:42,800
现在我要推送那个提交 到 github 或者如果您使用 bitbucket 或

334
21:54:42,800 --> 21:54:48,232
任何其他提供程序也很好，我将把它标记为第

335
21:54:48,232 --> 21:54:51,600
15 步，然后我们将推送我们的

336
21:54:51,600 --> 21:54:57,440
标签，这部分现在已经完成，所以我们已经完成了 我们承诺在这一

337
21:54:57,440 --> 21:55:02,872
章中要做的下一件事，

338
21:55:02,872 --> 21:55:06,640
作为所有其他章节中的传统，我们必须在每一章的结尾处

339
21:55:06,640 --> 21:55:11,760
讨论我们将在下一章中讨论的内容，你

340
21:55:11,760 --> 21:55:17,512
可以看到我们能够创建笔记 呃我们还不能更新笔记

341
21:55:17,512 --> 21:55:22,872
我们很快就会到达那里但是我们还需要允许用户删除

342
21:55:22,872 --> 21:55:26,552
笔记所以这正是我们

343
21:55:26,552 --> 21:55:30,720
要处理的 在下一章中，下一章也不会

344
21:55:30,720 --> 21:55:34,720
像这一章那样是一个巨大的章节，所以它会非常顺利，但我们

345
21:55:34,720 --> 21:55:40,400
会做一些曲子 对我们的项目进行大量重构，你很快就会看到，所以

346
21:55:40,400 --> 21:55:44,232
如果你愿意，可以拿些点心，

347
21:55:44,232 --> 21:55:48,320
我们下一章再见 如何创建新笔记

348
21:55:48,320 --> 21:55:51,440
以及如何在屏幕上显示这些笔记

349
21:55:51,440 --> 21:55:55,192
嗯，现在我们应用程序的任何用户都可以

350
21:55:55,192 --> 21:56:00,400
删除他们已经创建的笔记，

351
21:56:00,400 --> 21:56:05,040
而我们现在不提供该功能 对用户来说，这

352
21:56:05,040 --> 21:56:08,872
正是我们在本章中要做的

353
21:56:08,872 --> 21:56:13,600
工作，只是提醒一下，我们将在重构方面做很多工作，所以

354
21:56:13,600 --> 21:56:17,280
在代码无法编译的地方，事情会变得有点不舒服，但

355
21:56:17,280 --> 21:56:21,680
我们 '我会在打破它后立即修复它，所以我们也会

356
21:56:21,680 --> 21:56:24,800
对我们的对话进行一些工作，

357
21:56:24,800 --> 21:56:28,480
你会看到我们现在有一些对话出现在屏幕上，

358
21:56:28,480 --> 21:56:32,000
例如我们会显示一个错误 到屏幕

359
21:56:32,000 --> 21:56:35,680
或我们所在的用户 立场说哦，您无法登录，或者您的

360
21:56:35,680 --> 21:56:39,360
密码不正确，或者我们无法注册此用户，因为

361
21:56:39,360 --> 21:56:43,832
输入的密码很弱，所以这就像我们的错误对话，

362
21:56:43,832 --> 21:56:48,160
我们还有一个对话，当他或 她正在尝试

363
21:56:48,160 --> 21:56:52,552
退出应用程序，所以我们现在有两个对话

364
21:56:52,552 --> 21:56:56,552
，在本章中，我们要做的是巩固我们如何

365
21:56:56,552 --> 21:57:00,552
将对话显示给用户，作为删除

366
21:57:00,552 --> 21:57:05,600
功能的一部分，因为你 看看删除部分，我们要做的

367
21:57:05,600 --> 21:57:09,360
就是让我把

368
21:57:09,360 --> 21:57:13,280
scrcpy 带到屏幕上，所以我们要做的是，我们

369
21:57:13,280 --> 21:57:17,600
要放一点删除 列表中每个项目旁边的图标，我们

370
21:57:17,600 --> 21:57:22,080
将允许用户点击这些图标以显示对话

371
21:57:22,080 --> 21:57:27,040
现在这将是第三个对话，嗯，

372
21:57:27,040 --> 21:57:30,800
我的一个同事，我真的和我一起工作 佩服他的工作方式，他提到

373
21:57:30,800 --> 21:57:33,600
当他到达第三个时，他使东西可重复使用 是时候

374
21:57:33,600 --> 21:57:37,440
再次做同样的事情了，所以现在我们已经写了两个对话，我们

375
21:57:37,440 --> 21:57:40,872
现在还需要第三个对话，这就是我们实际上应该

376
21:57:40,872 --> 21:57:45,192
将所有对话显示合并到一个

377
21:57:45,192 --> 21:57:49,280
功能，然后从其他功能我们 我只是要重用它，好吧

378
21:57:49,280 --> 21:57:54,160
，这就是我们在本章中要做的，

379
21:57:54,160 --> 21:57:58,720
所以让我们稍微看一下代码我要嗯，

380
21:57:58,720 --> 21:58:04,480
我要把屏幕调大一点，

381
21:58:04,480 --> 21:58:08,000
所以这里

382
21:58:08,000 --> 21:58:11,832
所以 这是我们的应用程序，我们现在列出的方式

383
21:58:11,832 --> 21:58:16,640
就像那个visual studio代码一样，我们在那里也有一个cr cpy，

384
21:58:16,640 --> 21:58:21,192
所以让我们看看我们的标题，以防万一

385
21:58:21,192 --> 21:58:24,960
看看我们的错误对话框，让我们继续

386
21:58:24,960 --> 21:58:28,640
看看我们有什么持续的服务人群实用程序，我们在这里有一个

387
21:58:28,640 --> 21:58:33,680
称为显示错误对话框的功能，它反过来说显示对话框，

388
21:58:33,680 --> 21:58:37,440
然后它说警报对话好吧，如果你 看看它是如何

389
21:58:37,440 --> 21:58:43,192
构造的 ng 的意思是，嘿，我有，嗯，我有一个

390
21:58:43,192 --> 21:58:46,872
标题，然后我只有一个带有按钮的动作

391
21:58:46,872 --> 21:58:51,680
，而且该动作没有返回任何值，而且

392
21:58:51,680 --> 21:58:54,400
我们还有一些文本可以显示，很好，现在让我们转到我们的 注释视图 如果

393
21:58:54,400 --> 21:58:58,800
您在注释视图末尾查看我们的注释视图，我们有这个

394
21:58:58,800 --> 21:59:03,040
注销对话框 这是做什么的 它有相同的东西

395
21:59:03,040 --> 21:59:08,552
显示对话框它里面有一个警告对话框 它有一个标题和一些文本，

396
21:59:08,552 --> 21:59:14,480
但它有两个 动作和这些动作它们做不同的事情，所以如果一个动作

397
21:59:14,480 --> 21:59:19,280
发送一个 false 的值，另一个动作会发送一个

398
21:59:19,280 --> 21:59:24,320
true 的值，所以每个出现在

399
21:59:24,320 --> 21:59:30,160
屏幕上的对话所以让我们说这个，例如

400
21:59:30,160 --> 21:59:34,400
我们的注销对话框，这是我们的一个 '现在正在查看

401
21:59:34,400 --> 21:59:37,920
取消按钮发送一个错误值，而注销按钮发送一个真实

402
21:59:37,920 --> 21:59:43,192
值，所以对话框都非常相似，它们

403
21:59:43,192 --> 21:59:48,000
有一个标题，它们有一些内容，它们有一些用户

404
21:59:48,000 --> 21:59:51,280
可以对这些对话执行的操作 然后这些行为就有了自己的价值 d

405
21:59:51,280 --> 21:59:54,872
这就是我们现在在我们的应用程序中要做的就是我们

406
21:59:54,872 --> 21:59:57,512
将所有这些整合到一个通用函数中，这

407
21:59:57,512 --> 22:00:00,640
将允许我们根据我们的需要定制它，

408
22:00:00,640 --> 22:00:05,440
所以让我们看看 我们如何实现

409
22:00:05,440 --> 22:00:08,960
这一点，正如标题所示，我们首先要从源头上削减东西

410
22:00:08,960 --> 22:00:14,552
，这就像我在软件开发中经常使用的策略，所以

411
22:00:14,552 --> 22:00:18,400
如果我要破坏事物并且我会喜欢改变 事情的运作方式

412
22:00:18,400 --> 22:00:22,232
我不会害怕，我真的不害怕

413
22:00:22,232 --> 22:00:26,552
让事情崩溃，我认为你可能会想不同，但在我

414
22:00:26,552 --> 22:00:31,760
看来，从源代码中删除东西真的很好，破坏代码然后

415
22:00:31,760 --> 22:00:35,040
开始 一次修复一个问题，而不是试图确保

416
22:00:35,040 --> 22:00:39,120
在重构代码时没有任何问题，所以这就是我们在这里要做的，因为

417
22:00:39,120 --> 22:00:42,872
标题表明我们将进入短空对话让我

418
22:00:42,872 --> 22:00:47,440
们看看你是否可以 发现它我喜欢在 Visual Studio 代码中使用命令 p 我

419
22:00:47,440 --> 22:00:50,960
要说 在这里显示错误对话框

420
22:00:50,960 --> 22:00:56,000
，我们要做的就是删除所有这些代码

421
22:00:56,000 --> 22:00:59,832
从注释视图中注销对话框，因为我们将有一个通用的对话框，因此请

422
22:00:59,832 --> 22:01:03,832
在此处进入您的注释视图并

423
22:01:03,832 --> 22:01:07,192
删除此显示注销对话框好吧，

424
22:01:07,192 --> 22:01:10,400
我们会得到错误，这没关系，你知道我们删除的这段代码

425
22:01:10,400 --> 22:01:14,480
此处显示错误对话框也被大量使用，因此

426
22:01:14,480 --> 22:01:17,280
如果我喜欢搜索显示空气美元，请删除它，您可以看到我们实际上

427
22:01:17,280 --> 22:01:21,280
在七个地方使用，所以所有这些地方现在都会有一个错误

428
22:01:21,280 --> 22:01:25,832
，没关系，我们是 很快就会修复，所以不用担心

429
22:01:25,832 --> 22:01:30,160
，所以我们需要在这里做的是在我们修复所有这些之前，我们将

430
22:01:30,160 --> 22:01:34,640
开始基本上创建我们的笔记列表视图，

431
22:01:34,640 --> 22:01:38,000
所以现在如果你看看我们的 笔记

432
22:01:38,000 --> 22:01:41,832
查看我们所拥有的是这里的这种美丽，它正在做

433
22:01:41,832 --> 22:01:46,160
很多工作，正如您所看到的那样，它很有魅力 真正的构建器在笔记视图的主体中

434
22:01:46,160 --> 22:01:49,760
，它有一个流构建器和很多代码，

435
22:01:49,760 --> 22:01:52,960
如果你能把这段代码分开到它自己的地方，我们可以

436
22:01:52,960 --> 22:01:57,440
像笔记列表视图一样调用这个小部件，那就太好了 正是我们将

437
22:01:57,440 --> 22:02:03,920
在本章中做的所以让我们继续在我们的视图里面的笔记

438
22:02:03,920 --> 22:02:08,960
在这里在你的

439
22:02:08,960 --> 22:02:14,960
视图里面的笔记让我们创建一个新文件我们将称之为笔记

440
22:02:14,960 --> 22:02:18,232
列表视图点

441
22:02:18,232 --> 22:02:23,512
部分 在笔记列表视图中，我们要做的是说笔记

442
22:02:23,512 --> 22:02:27,832
列表视图是一个无状态小部件，因此我们创建一个 stl，它是一个无状态小部件

443
22:02:27,832 --> 22:02:32,080
，我们将其称为笔记列表视图，

444
22:02:32,080 --> 22:02:36,232
因为我们已经看到它 在我们需要导入材料之前，所以我现在要这样做，

445
22:02:36,232 --> 22:02:40,320
所以所有这些错误都会消失，

446
22:02:40,320 --> 22:02:46,480
现在我们需要做的是我们需要将

447
22:02:46,480 --> 22:02:49,832
一个笔记列表实际传递给这个笔记列表

448
22:02:49,832 --> 22:02:55,600
视图，以便它可以 渲染它们，因为您看到检索

449
22:02:55,600 --> 22:02:59,832
笔记的所有逻辑都可以在笔记视图中保持静止，但都没有 tes 列表视图感兴趣的

450
22:02:59,832 --> 22:03:03,600
是要显示

451
22:03:03,600 --> 22:03:08,552
的注释列表，所以让我们在注释列表视图中将其作为参数公开，这样我们将说出

452
22:03:08,552 --> 22:03:11,120
数据库节点的最终列表，您可以看到数据库节点现在没有

453
22:03:11,120 --> 22:03:14,080
导入 但是visual studio代码将足够聪明地

454
22:03:14,080 --> 22:03:17,512
导入它，所以

455
22:03:17,512 --> 22:03:20,480
如果你真的是，

456
22:03:20,480 --> 22:03:25,512
如果你的编辑器喜欢你在linux上使用vim或其他东西，或者

457
22:03:25,512 --> 22:03:30,400
如果你使用的是mac和windows，你可能必须导入 这些东西是手动的，所以

458
22:03:30,400 --> 22:03:35,832
我相信我的意思是，如果你在课程中已经到了这一点，

459
22:03:35,832 --> 22:03:40,552
你应该

460
22:03:40,552 --> 22:03:44,480
足够精明，你应该足够了解所有这些事情，以便

461
22:03:44,480 --> 22:03:49,040
能够自己解决这个问题，所以嗯 所以我不会再重复所有这些

462
22:03:49,040 --> 22:03:53,192
信息，只要确保你的数据库笔记在这一点上是在上下文中，

463
22:03:53,192 --> 22:03:55,832
所以这将是我们的笔记

464
22:03:55,832 --> 22:03:58,800
，也是我在上一章提到的这个笔记视图，但也许它

465
22:03:58,800 --> 22:04:02,640
实际上是值得的 在本章中提到，因为它非常相关

466
22:04:02,640 --> 22:04:06,800
我们要做的是在右侧的每个注释旁边

467
22:04:06,800 --> 22:04:11,192
作为尾随磁贴小部件，我们将显示有点像垃圾桶图标

468
22:04:11,192 --> 22:04:13,512
，用户可以点击它来删除一个 um

469
22:04:13,512 --> 22:04:17,832
注释和我们的内容 '然后要做的是

470
22:04:17,832 --> 22:04:21,680
确保我们基本上可以调用一个小函数来向用户显示一个删除

471
22:04:21,680 --> 22:04:26,400
对话框，所以当你按下删除按钮时，我们将显示

472
22:04:26,400 --> 22:04:30,232
一个对话框，删除对话框将是 非常类似于注销就像

473
22:04:30,232 --> 22:04:34,800
说现在嘿嘿你要删除这个笔记你确定

474
22:04:34,800 --> 22:04:37,512
并且那个对话框将有两个按钮

475
22:04:37,512 --> 22:04:41,760
是或否或类似的东西并且在按下否时我们将

476
22:04:41,760 --> 22:04:47,920
在按下时关闭对话 是的，那么我们将从数据库中删除该便笺

477
22:04:47,920 --> 22:04:52,832
，所以我们需要的是您现在可以看到便笺

478
22:04:52,832 --> 22:04:56,480
列表视图，它不应该与便笺服务有任何联系，

479
22:04:56,480 --> 22:04:59,512
它应该是便笺 具有该连接的视图，因此这

480
22:04:59,512 --> 22:05:06,080
也是您应该喜欢的组件 s在颤抖

481
22:05:06,080 --> 22:05:09,920
，你不应该到处泄露你的服务，所以如果笔记列表视图

482
22:05:09,920 --> 22:05:13,280
可以以某种方式将删除任务委托给笔记视图，那将是理想的，

483
22:05:13,280 --> 22:05:16,800
所以笔记列表视图可以显示对话它可以说

484
22:05:16,800 --> 22:05:20,000
嘿你确定 如果用户然后说是，则注释列表视图可以

485
22:05:20,000 --> 22:05:24,000
将此信息委托给其父级并说嘿用

486
22:05:24,000 --> 22:05:27,192
此信息做某事好吧，

487
22:05:27,192 --> 22:05:32,720
那么让我们去使用 typedef 创建一个小回调定义，

488
22:05:32,720 --> 22:05:38,320
对不起，我们将调用 它删除注释

489
22:05:38,320 --> 22:05:42,480
回调 好的，这是一个 void 函数，它需要一个数据库注释

490
22:05:42,480 --> 22:05:47,192
oops 一个数据库节点

491
22:05:47,192 --> 22:05:52,080
我会这样记，所以我们说我们正在定义一个函数

492
22:05:52,080 --> 22:05:57,760
，然后我们将在我们的节点列表视图中使用 我们称之为我们，

493
22:05:57,760 --> 22:06:02,320
我们将其用作回调，当用户

494
22:06:02,320 --> 22:06:06,552
在这个假设的对话上按下“是”时将被调用，我们

495
22:06:06,552 --> 22:06:11,360
假设会显示该用户没问题，所以让我们进入这里并定义让

496
22:06:11,360 --> 22:06:14,400
我们说删除节点回调和 我们只是 要在删除节点上说，

497
22:06:14,400 --> 22:06:19,920
所以这是我们的回调，你现在从颤动中得到一些错误，

498
22:06:19,920 --> 22:06:24,232
说这些参数没有定义，所以我将使用 Visual

499
22:06:24,232 --> 22:06:30,960
Studio 代码并说为我定义这些参数

500
22:06:30,960 --> 22:06:35,920
我' 我也会让它们需要像这样的参数，这

501
22:06:35,920 --> 22:06:42,080
很好，我们的应用程序中仍然存在一些错误，

502
22:06:42,080 --> 22:06:46,232
但是我们将继续构建，直到我们可以修复所有这些错误，

503
22:06:46,232 --> 22:06:50,400
好吧，这太棒了，所以这是我们拥有的第一部分 继续工作，所以

504
22:06:50,400 --> 22:06:53,832
让我们继续，嗯，把我们的笔记看这里的方式，

505
22:06:53,832 --> 22:06:57,680
你看我们已经有一个列表视图构建器，我要去抓取这个

506
22:06:57,680 --> 22:07:04,232
列表视图，从那里开始

507
22:07:04,232 --> 22:07:08,400
，我' 我实际上要剪切它并将其带到构建函数内的节点列表视图中，

508
22:07:08,400 --> 22:07:11,760
好吧，所以在里面而不是返回一个容器我只是要

509
22:07:11,760 --> 22:07:16,000
返回我刚刚粘贴的代码，我只是剪切好了

510
22:07:16,000 --> 22:07:23,040
它看起来绝对 目前很糟糕，因为我的意思是我们有这么

511
22:07:23,040 --> 22:07:28,320
多呃 rors，但老实说，我真的很喜欢那种

512
22:07:28,320 --> 22:07:34,160
东西，有些开发人员

513
22:07:34,160 --> 22:07:40,080
在他们的代码中有很多错误时会感到紧张，他们只想尽快修补它们，

514
22:07:40,080 --> 22:07:45,360
但我们只需要一步到位 就像我们在瑞典所说的那样，我们说

515
22:07:45,360 --> 22:07:50,000
这意味着一步一步地修复这些错误，

516
22:07:50,000 --> 22:07:52,960
在本章结束时，我向你保证一切都会正常进行，

517
22:07:52,960 --> 22:07:58,000
所以让我们进入这里，你可以看到第一个错误 我们有所有的笔记

518
22:07:58,000 --> 22:08:02,800
，所有的笔记都给我们一个错误，因为它在这个上下文中不存在

519
22:08:02,800 --> 22:08:07,760
，那是因为我们有一个叫做笔记的东西，所以

520
22:08:07,760 --> 22:08:11,600
让我们进去说现在我们正在使用笔记

521
22:08:11,600 --> 22:08:14,640
和 在这里我们也没有所有的笔记，所以我们只说笔记

522
22:08:14,640 --> 22:08:18,160
笔记，并且该

523
22:08:18,160 --> 22:08:21,832
笔记将从该索引处的笔记中提取，

524
22:08:21,832 --> 22:08:27,192
现在令人兴奋的部分是

525
22:08:27,192 --> 22:08:31,120
我们不只是使用我们的标题属性 list tile 我们将

526
22:08:31,120 --> 22:08:35,440
开始使用名为 trailing 的东西，而 trailing is a 作为 li 的属性 st

527
22:08:35,440 --> 22:08:38,960
tile，顾名思义，它将允许您

528
22:08:38,960 --> 22:08:42,720
指定需要在末尾显示的小部件或

529
22:08:42,720 --> 22:08:46,872
每个列表 tile 的尾迹，这就是我们将使用

530
22:08:46,872 --> 22:08:50,400
图标按钮的地方，以便显示我们的小垃圾 可以，所以

531
22:08:50,400 --> 22:08:53,832
让我们说图标按钮

532
22:08:53,832 --> 22:08:56,000
，在这个图标按钮中我们要做的是，我们将定义

533
22:08:56,000 --> 22:08:58,480
看起来像这样的 uncrest，它是图标，然后

534
22:08:58,480 --> 22:09:02,960
它将是图标的图标删除我相信它被称为

535
22:09:02,960 --> 22:09:07,120
让我们 看看 delete 的样子，你会发现它是一个小

536
22:09:07,120 --> 22:09:12,640
垃圾桶，太棒了，让这个缺点让

537
22:09:12,640 --> 22:09:15,600
分析器也很开心，所以我们该怎么办我被按下了，所以我们

538
22:09:15,600 --> 22:09:20,160
需要在按下时做的是 我之前提到过，我们需要处理

539
22:09:20,160 --> 22:09:23,680
一个对话的显示，上面写着让我们调用显示删除对话

540
22:09:23,680 --> 22:09:28,320
好吧，所以这个显示删除对话我们将调用它，我们希望它

541
22:09:28,320 --> 22:09:31,600
返回一个真或假，记住我们没有'  t 实现了显示

542
22:09:31,600 --> 22:09:35,920
删除对话框，没关系，我们可以设置一些限制

543
22:09:35,920 --> 22:09:40,640
这个函数的接口还没有，但它还不存在所以我们只是说

544
22:09:40,640 --> 22:09:45,120
这个函数显示删除对话框需要一个构建上下文，它向我们返回真或

545
22:09:45,120 --> 22:09:48,320
假，所以如果用户说是，我想删除一些项目然后它

546
22:09:48,320 --> 22:09:52,800
如果用户说不，则返回 true，那么这个

547
22:09:52,800 --> 22:09:57,280
对话框应该返回 false 给我们好吧，所以让我们继续说 final 应该，

548
22:09:57,280 --> 22:10:00,552
你应该删除是一个权重

549
22:10:00,552 --> 22:10:05,832
，当你使用一个权重时，你需要使你自己的新闻功能异步

550
22:10:05,832 --> 22:10:10,232
然后我们会说等待显示删除对话框我们没有那个

551
22:10:10,232 --> 22:10:15,280
功能记住但是没关系当我们说

552
22:10:15,280 --> 22:10:20,160
应该删除好如果这是布尔值然后我们说如果

553
22:10:20,160 --> 22:10:25,360
应该删除那么我们要做的是我们说

554
22:10:25,360 --> 22:10:30,320
我们用当前注释调用我们的删除注释，

555
22:10:30,320 --> 22:10:35,192
这只是这个小部件

556
22:10:35,192 --> 22:10:38,640
注释列表视图的实现，

557
22:10:38,640 --> 22:10:44,400
但不要担心这些错误，我们很快就会修复它们

558
22:10:44,400 --> 22:10:48,720
，现在也保存这个文件

559
22:10:48,720 --> 22:10:53,120
我们需要移动到下一个项目，这是我们自己的通用对话 你可以

560
22:10:53,120 --> 22:10:56,720
看到我们将创建一个通用对话飞镖

561
22:10:56,720 --> 22:11:01,600
，这非常重要，因为这几乎显示了通用对话

562
22:11:01,600 --> 22:11:05,280
，我们将在其上创建的变体将修复我们在应用程序中遇到的所有这些错误

563
22:11:05,280 --> 22:11:09,512
现在所以我实际上很高兴开始工作

564
22:11:09,512 --> 22:11:14,960
我们有 lib consonants enums services

565
22:11:14,960 --> 22:11:19,600
实用程序，但在实用程序中我们目前没有

566
22:11:19,600 --> 22:11:22,960
对话文件夹，记住我们

567
22:11:22,960 --> 22:11:27,120
删除了这个显示错误对话框的所有内容，

568
22:11:27,120 --> 22:11:30,800
现在我们不需要删除文件，所以我 '我只是要删除它并将其移至垃圾箱，

569
22:11:30,800 --> 22:11:35,120
所以现在在实用程序中我们什么都没有，所以让我们创建这个新文件，因为

570
22:11:35,120 --> 22:11:39,512
标题表明我们会说它会在一个名为 dialogs 的文件夹中

571
22:11:39,512 --> 22:11:45,440
，我们将调用它 通用 dialog.art

572
22:11:45,440 --> 22:11:49,120
好吧，我要去 ge 去掉侧边栏，我们现在需要开始

573
22:11:49,120 --> 22:11:52,720
实现我们的通用对话

574
22:11:52,720 --> 22:11:56,640
这个节目通用对话会

575
22:11:56,640 --> 22:12:02,320
有点复杂，嗯，我说它有点

576
22:12:02,320 --> 22:12:07,920
复杂只是因为它会使用泛型

577
22:12:07,920 --> 22:12:12,400
和原因 我基本上

578
22:12:12,400 --> 22:12:17,120
决定让它通用是因为通用名称表示这个

579
22:12:17,120 --> 22:12:22,080
通用对话我的意思是文件也说通用方言所以你

580
22:12:22,080 --> 22:12:26,960
需要知道你已经让自己进入

581
22:12:26,960 --> 22:12:31,280
它必须是通用的原因是 它需要能够产生

582
22:12:31,280 --> 22:12:36,000
不同类型的值让我们进入我们的笔记列表视图，你会看到这里

583
22:12:36,000 --> 22:12:42,800
我们会说显示删除对话框我们还没有实现的功能并

584
22:12:42,800 --> 22:12:47,280
突然显示删除对话框它会 返回 true 或 false 好吧

585
22:12:47,280 --> 22:12:52,232
，在登录视图的情况下这是一回事，所以让我们转到登录视图

586
22:12:52,232 --> 22:12:55,440
，这种情况如何显示空气点日志记住显示错误对话框也是

587
22:12:55,440 --> 22:12:59,920
一个我们很快将开发的功能，我们之前有 我们杀了它我们

588
22:12:59,920 --> 22:13:02,720
必须开发一个名为 show air dialog 的新函数，该函数将

589
22:13:02,720 --> 22:13:07,192
使用我们的通用对话框，但在这种情况下它不会返回 true 或 false，因此

590
22:13:07,192 --> 22:13:13,120
我们需要确保我们的通用对话正如其名称所示是一个

591
22:13:13,120 --> 22:13:17,192
通用函数，可以基于 关于您提供给它的内容能够将

592
22:13:17,192 --> 22:13:20,552
这些值返回给您，我的意思是您提供给

593
22:13:20,552 --> 22:13:25,040
它的每个项目每个选项或

594
22:13:25,040 --> 22:13:29,360
显示在我们的通用对话框中的每个按钮都将具有一个值，

595
22:13:29,360 --> 22:13:33,440
我们将假设所有 您在任何给定对话框中显示的按钮

596
22:13:33,440 --> 22:13:37,440
将具有完全相同类型的值，因此

597
22:13:37,440 --> 22:13:42,320
显示“是”或“否”按钮的对话框将有

598
22:13:42,320 --> 22:13:46,720
两个按钮，每个按钮都包含一个布尔值，一个为真，另一个为

599
22:13:46,720 --> 22:13:51,120
假或可能 您想显示 10 个按钮，其中两个的

600
22:13:51,120 --> 22:13:54,160
值为 true，另一个的值为其他 8 个为 false，但我的

601
22:13:54,160 --> 22:13:59,192
意思是您的通用对话框中的按钮将具有

602
22:13:59,192 --> 22:14:03,360
相同的数据类型 所以我们要去c 所有的数据类型

603
22:14:03,360 --> 22:14:09,280
都可以，所以让我们继续定义这个 um 显示

604
22:14:09,280 --> 22:14:13,760
通用对话，所以我们要说这个对话实际上返回

605
22:14:13,760 --> 22:14:18,480
了 t 的未来

606
22:14:18,480 --> 22:14:22,480
以及我们要说的我们要说的 显示通用

607
22:14:22,480 --> 22:14:27,600
对话，

608
22:14:27,600 --> 22:14:31,680
它是一个函数签名，它看起来像这样没问题，

609
22:14:31,680 --> 22:14:35,680
所以它实际上意味着什么 t 可选，这是因为记住

610
22:14:35,680 --> 22:14:40,160
在 android 上，例如，当您向用户显示对话框时，用户

611
22:14:40,160 --> 22:14:44,480
实际上可以按下硬件向下按钮 为了在不

612
22:14:44,480 --> 22:14:49,040
实际响应的情况下关闭对话框，而 ios 实际上

613
22:14:49,040 --> 22:14:52,160
并不像那样，当您显示对话框时，它是

614
22:14:52,160 --> 22:14:57,192
用户必须回复的模式，除非您创建自己的对话或者您正在

615
22:14:57,192 --> 22:15:01,512
做 一边说，哦，如果用户

616
22:15:01,512 --> 22:15:05,280
在对话之外点击，那么它应该消失，否则 ios 中的对话是模态的并且

617
22:15:05,280 --> 22:15:09,360
必须响应但是在 android 中，用户可能会在

618
22:15:09,360 --> 22:15:13,280
没有实际响应的情况下关闭对话 到它，在这种情况下，

619
22:15:13,280 --> 22:15:18,232
show generic 对话实际上应该返回 nil 或 null 取决于

620
22:15:18,232 --> 22:15:21,280
你在谈论什么语言

621
22:15:21,280 --> 22:15:26,160
返回某种

622
22:15:26,160 --> 22:15:29,280
可选值的对话框，我们需要的第一个参数

623
22:15:29,280 --> 22:15:33,192
是构建上下文，所以我们只说构建上下文

624
22:15:33,192 --> 22:15:35,760
，我们需要一个标题和内容，所以

625
22:15:35,760 --> 22:15:40,080
在我们这样做之前我们还要说必需的让我们也 看看这个说构建

626
22:15:40,080 --> 22:15:45,192
上下文没有定义的东西，那是因为我们有一个重要的材料，所以让

627
22:15:45,192 --> 22:15:49,040
我们处理一下，我们必须在这些地方有大括号，

628
22:15:49,040 --> 22:15:52,720
因为 required 实际上需要这样，

629
22:15:52,720 --> 22:15:56,080
所以我们的下一个参数 必须

630
22:15:56,080 --> 22:15:59,120
实现的是标题，然后是内容，所以两者都将是文本或

631
22:15:59,120 --> 22:16:02,640
字符串，所以这就是标题，现在我要

632
22:16:02,640 --> 22:16:05,920
复制粘贴，我要在这里说

633
22:16:05,920 --> 22:16:08,872
内容现在内容现在是令人兴奋的部分 我们需要的是

634
22:16:08,872 --> 22:16:13,280
某种ab 能力和某种方式让用户

635
22:16:13,280 --> 22:16:17,832
能够指定像一个列表这样

636
22:16:17,832 --> 22:16:23,440
的按钮列表来显示给用户现在每个按钮如果我们说

637
22:16:23,440 --> 22:16:28,400
默认情况下每个按钮都应该有例如

638
22:16:28,400 --> 22:16:32,000
我们应该 将每个按钮表示为一个文本按钮，每个文本

639
22:16:32,000 --> 22:16:34,960
按钮都需要一个字符串才能正常显示，然后它将有一个未按下的按钮，

640
22:16:34,960 --> 22:16:38,320
所以我们要说的是，我们应该能够渲染

641
22:16:38,320 --> 22:16:43,512
多个按钮和每个按钮 应该有一个文本

642
22:16:43,512 --> 22:16:45,832
，而且我们从每个按钮之前设置也应该有某种

643
22:16:45,832 --> 22:16:50,080
值，这不是可选的，所以我们需要一种方法让用户指定一个按钮列表，

644
22:16:50,080 --> 22:16:52,552
每个按钮都有一个字符串类型的标题和 这些

645
22:16:52,552 --> 22:16:56,232
按钮中的每一个都应该有一个可选的值，所以最好用一个

646
22:16:56,232 --> 22:17:00,640
字符串映射作为标题和一个像这样的 t 值来描述，

647
22:17:00,640 --> 22:17:04,552
所以我们要输入 def，我们

648
22:17:04,552 --> 22:17:09,360
会说我们有一个定义 的 a ，我们基本上有一个类型要完成

649
22:17:09,360 --> 22:17:14,960
，我们要去 c 所有对话框选项生成器

650
22:17:14,960 --> 22:17:18,160
，我们会说它是通用的

651
22:17:18,160 --> 22:17:22,400
，我们会说它等于一个

652
22:17:22,400 --> 22:17:27,280
返回该值的函数，所以

653
22:17:27,280 --> 22:17:32,000
让我们也看看 map all right key 期望找到所有正确的和

654
22:17:32,000 --> 22:17:35,832
这可能是因为我拼错了，所以现在我们有一个

655
22:17:35,832 --> 22:17:40,232
选项生成器，所以我们将在我们的函数中使用该选项生成器，所以

656
22:17:40,232 --> 22:17:45,920
你很快就会看到我们将如何使用它

657
22:17:45,920 --> 22:17:50,000
所以我 '我会说我们有一个对话框选项生成器，我们

658
22:17:50,000 --> 22:17:55,440
就叫它选项生成器

659
22:17:55,440 --> 22:17:59,360
好了，所以我们已经有了所有这些点点滴滴，现在我们需要做的

660
22:17:59,360 --> 22:18:02,552
是在这个函数内部实际使用构建上下文来显示一个对话

661
22:18:02,552 --> 22:18:07,920
用户所以在我们这样做之前，让我们获取调用者

662
22:18:07,920 --> 22:18:12,960
希望我们显示的所有选项，因此我们将其称为选项

663
22:18:12,960 --> 22:18:15,832
是选项生成器，我们调用该函数，现在您将看到

664
22:18:15,832 --> 22:18:20,640
选项

665
22:18:20,640 --> 22:18:24,800
是否足够聪明，可以理解是的 这是一个字符串动态的映射好吧它

666
22:18:24,800 --> 22:18:30,640
还不明白它是什么所以让我们走吧 提前说，在

667
22:18:30,640 --> 22:18:35,192
这个函数中，我们返回一个显示对话框 t

668
22:18:35,192 --> 22:18:39,280
好吧，在这里我们有两个参数，

669
22:18:39,280 --> 22:18:42,720
我们必须传递一个是上下文，另一个是实际的构建器

670
22:18:42,720 --> 22:18:46,320
函数，好吧，你最喜欢的编辑器的一些帮助

671
22:18:46,320 --> 22:18:50,000
完成构建器功能，这非常简单，

672
22:18:50,000 --> 22:18:54,080
只需构建上下文就可以

673
22:18:54,080 --> 22:18:59,192
了 没有什么革命性的，

674
22:18:59,192 --> 22:19:04,800
所以对于我们要说的标题，我们有一个等于它的文本，

675
22:19:04,800 --> 22:19:07,512
它包含我们要说的内容的标题字符串，还有

676
22:19:07,512 --> 22:19:12,080
一个包含内容的文本

677
22:19:12,080 --> 22:19:15,280
，然后我们要去 进入我们的行动

678
22:19:15,280 --> 22:19:18,720
，这对我来说是令人兴奋的部分，因为对于我们

679
22:19:18,720 --> 22:19:23,832
需要做的行动，您会看到我们的行动在这里定义，此

680
22:19:23,832 --> 22:19:28,552
选项中的每个键都是标题

681
22:19:28,552 --> 22:19:32,480
，由我们对话的行动字符串定义，

682
22:19:32,480 --> 22:19:37,920
所以 我们 需要开始映射它们，所以我们要说

683
22:19:37,920 --> 22:19:42,480
选项键

684
22:19:42,480 --> 22:19:45,040
键，然后我们将它们映射好，这让我们

685
22:19:45,040 --> 22:19:52,720
称之为选项标题

686
22:19:52,720 --> 22:19:56,320
，我们不会在这里使用速记签名，我们只是去

687
22:19:56,320 --> 22:20:00,400
这样做，所以现在在选项标题中，我们

688
22:20:00,400 --> 22:20:05,760
实际上要返回一个文本按钮，所以

689
22:20:05,760 --> 22:20:12,480
让我们首先获取这个键的值，所以我只想说

690
22:20:12,480 --> 22:20:16,720
最终 t 值等于选项

691
22:20:16,720 --> 22:20:21,600
在这样的选项标题上

692
22:20:21,600 --> 22:20:26,000
，现在它说是的，你没有使用它，这很好，

693
22:20:26,000 --> 22:20:31,280
我们会很快修复

694
22:20:31,280 --> 22:20:34,232
这个问题，我们在这里看到的这个巨大错误是因为你看到了它

695
22:20:34,232 --> 22:20:38,000
需要的操作 可迭代我相信不，它实际上是一个小部件列表，但是

696
22:20:38,000 --> 22:20:41,920
当你在你的键上做一个映射时，它会返回一个可迭代的，所以为了解决

697
22:20:41,920 --> 22:20:45,600
这个问题，我们将在最后说这是列出

698
22:20:45,600 --> 22:20:49,512
所有好的 所以现在让我们解决我理解的其余问题我的意思是这是

699
22:20:49,512 --> 22:20:54,000
相当多的错误，你可能有点 对此感到不知所措，

700
22:20:54,000 --> 22:20:57,192
但没关系，我们将一次修复一个，所以最后是一个半列，以便

701
22:20:57,192 --> 22:21:02,160
在最后摆脱那个巨大的 er，然后我们将在这里做些什么来

702
22:21:02,160 --> 22:21:06,160
获得价值 我们将创建一个文本按钮，所以我们只说

703
22:21:06,160 --> 22:21:10,960
每个选项都返回一个文本按钮

704
22:21:10,960 --> 22:21:15,920
，正如我们之前看到的，文本按钮需要的

705
22:21:15,920 --> 22:21:20,640
是两个未按下的参数，它还需要我相信它是

706
22:21:20,640 --> 22:21:23,280
平铺的，我们将 说孩子

707
22:21:23,280 --> 22:21:27,760
等于我们

708
22:21:27,760 --> 22:21:31,280
选项标题的文本，

709
22:21:31,280 --> 22:21:35,440
所以我的意思是你可能对这一切有点困惑

710
22:21:35,440 --> 22:21:39,920
，没关系，我们正在做的事情非常简单，我们有一个

711
22:21:39,920 --> 22:21:45,040
标题列表要为每个按钮显示，所以每个 按钮有一个标题，该

712
22:21:45,040 --> 22:21:49,192
标题在这个字符串映射中，它在字符串映射

713
22:21:49,192 --> 22:21:52,160
和可选 t 中的原因仅仅是因为我们不想拥有

714
22:21:52,160 --> 22:21:56,000
我们不想管理两个单独的列表标题列表 和一个

715
22:21:56,000 --> 22:22:02,160
值列表，然后我们将标题与值匹配，并且 map

716
22:22:02,160 --> 22:22:05,512
已经为我们这样做了 此外，带有 at 的字符串映射的作用是

717
22:22:05,512 --> 22:22:08,832
确保在这种字符串类型的情况下每个字符串或每个键都是唯一的，因此

718
22:22:08,832 --> 22:22:12,720
您不能有两个具有相同标题和不同值的按钮，因此

719
22:22:12,720 --> 22:22:20,480
该映射非常适合这种情况 以及我们在这里为

720
22:22:20,480 --> 22:22:23,680
警报对话框的操作所做的我们说好的

721
22:22:23,680 --> 22:22:28,000
我们地图中的每个键都是一个选项标题是一个按钮的标题好吧

722
22:22:28,000 --> 22:22:31,360
所以我们正在映射我们将它映射到什么 每一个

723
22:22:31,360 --> 22:22:34,720
字符串类型的标题都将被映射到一个文本按钮，

724
22:22:34,720 --> 22:22:39,192
其子按钮是实际标题的文本，在这个键内

725
22:22:39,192 --> 22:22:43,360
我明白这可能会令人困惑，但请暂停视频

726
22:22:43,360 --> 22:22:47,832
看看 代码，我相信在我们自己真正考虑过之后，您会更好地理解它

727
22:22:47,832 --> 22:22:51,040
，然后将

728
22:22:51,040 --> 22:22:54,400
提取这种类型的值，我们要做的是我们

729
22:22:54,400 --> 22:22:57,760
要说让我们看看最终值

730
22:22:57,760 --> 22:23:01,832
和 在这里，如果您查看价值，它将是动态的，我们需要

731
22:23:01,832 --> 22:23:06,552
做的是 只是为了确保说如果 value 不为 null

732
22:23:06,552 --> 22:23:10,640
并且我们要说

733
22:23:10,640 --> 22:23:14,720
我们的上下文的导航器已经写了然后我

734
22:23:14,720 --> 22:23:18,320
要说 pop 它用那个 value 否则我们

735
22:23:18,320 --> 22:23:24,160
只会弹出 pop all 对，这就是现在

736
22:23:24,160 --> 22:23:28,640
你明白我们为什么将值定义为可选的原因，因为你会看到一些

737
22:23:28,640 --> 22:23:31,680
值，如果我们回到这里，我们对话框上的某些按钮

738
22:23:31,680 --> 22:23:37,760
实际上可能没有任何值，就像我们在

739
22:23:37,760 --> 22:23:41,760
登录视图中的值一样 此登录视图将有一个错误

740
22:23:41,760 --> 22:23:44,800
对话框，此错误对话框将使用我们的通用对话框，但此空气

741
22:23:44,800 --> 22:23:47,760
对话框将有一个 ok 按钮它没有任何值 OK 只是

742
22:23:47,760 --> 22:23:52,232
一个 ok 只是关闭对话框，这正是 这是怎么做的，因为

743
22:23:52,232 --> 22:23:56,232
你很快就会看到我们实现新的显示错误对话框的方式将

744
22:23:56,232 --> 22:24:00,160
使用我们的通用对话框，但是它会在那里放置一个小的 um 选项

745
22:24:00,160 --> 22:24:05,192
，上面写着 ok 并且 ok 有一个 null 值 好吧

746
22:24:05,192 --> 22:24:08,160
完美的说了很多逻辑 但没关系我们有时 n 需要这样做好吧

747
22:24:08,160 --> 22:24:11,512
哇，我们现在已经编写了我们的通用对话

748
22:24:11,512 --> 22:24:17,280
我们需要做的是我们需要开始使用它，这在

749
22:24:17,280 --> 22:24:22,080
我们现在要实现的错误对话中，所以

750
22:24:22,080 --> 22:24:27,832
让我们继续创建一个错误 对话框，

751
22:24:27,832 --> 22:24:31,440
所以我要调出我的笔记，

752
22:24:31,440 --> 22:24:36,160
让我们作为标题指示在对话框中

753
22:24:36,160 --> 22:24:40,000
让我们看看它在对话框中的位置我们将在此处创建一个名为错误对话框的新文件

754
22:24:40,000 --> 22:24:44,552
，

755
22:24:44,552 --> 22:24:48,000
现在在错误对话框中我们需要做的是我们 需要使用我们的通用对话框，

756
22:24:48,000 --> 22:24:53,040
因此我们需要在此处进行导入，

757
22:24:53,040 --> 22:24:57,192
我们将获得 Visual Studio 代码来帮助我们，因此

758
22:24:57,192 --> 22:25:01,832
请记住错误对话框将仅显示一个确定按钮它没有任何价值，因此

759
22:25:01,832 --> 22:25:07,360
它是简短的错误 对话框将具有与以前完全相同的签名

760
22:25:07,360 --> 22:25:11,440
，这是一个未来的空白，所以让我们继续这样做

761
22:25:11,440 --> 22:25:14,000
，我们将称之为显示错误对话框

762
22:25:14,000 --> 22:25:18,480
，我唯一的意思是淋浴对话框需要的两件事是 一个构建

763
22:25:18,480 --> 22:25:22,800
上下文和一个文本，所以我们说构建上下文

764
22:25:22,800 --> 22:25:25,280
，我们也要去 说一串文本

765
22:25:25,280 --> 22:25:30,000
好，让我们导入材料以消除该

766
22:25:30,000 --> 22:25:33,280
错误，就是这样，然后在这里我们实际上将返回

767
22:25:33,280 --> 22:25:37,040
我们的 show err show generic dialog 的实例

768
22:25:37,040 --> 22:25:40,000
，我认为现在应该导入它是吗 没有自动导入这里

769
22:25:40,000 --> 22:25:44,960
它还没有但不知何故它找到了它我可以看到我们

770
22:25:44,960 --> 22:25:49,040
在这里实际上有一个显示通用对话所以这不是

771
22:25:49,040 --> 22:25:52,232
我们实际要使用的那个所以我们要使用带有 uh 的那个

772
22:25:52,232 --> 22:25:55,680
像这样，然后我们要说我们的空中

773
22:25:55,680 --> 22:26:01,192
对话避免所以让我们导入我们自己的 uh

774
22:26:01,192 --> 22:26:05,680
show Gener um show generic dialog

775
22:26:05,680 --> 22:26:10,320
所以它是一个表演一般对话我真的很好奇一般对话很

776
22:26:10,320 --> 22:26:13,920
有趣所以有一个叫做显示一般对话的功能

777
22:26:13,920 --> 22:26:18,232
但是 这不是我们创建的，我们称之为显示通用方言，所以要

778
22:26:18,232 --> 22:26:22,400
小心一点，因为我现在真的绊倒了所以

779
22:26:22,400 --> 22:26:26,080
让我们回到我们的错误对话框并说显示

780
22:26:26,080 --> 22:26:31,192
通用对话框，它也将

781
22:26:31,192 --> 22:26:36,552
导入 你知道吗 w 所以这是正确的，

782
22:26:36,552 --> 22:26:40,160
所以在最后加一个逗号，让格式也正常工作

783
22:26:40,160 --> 22:26:46,320
，现在在这里添加一个逗号，以便在那里找到格式，

784
22:26:46,320 --> 22:26:51,280
现在我们要硬编码的标题

785
22:26:51,280 --> 22:26:55,680
会说发生了这样的错误

786
22:26:55,680 --> 22:27:00,160
，内容只是

787
22:27:00,160 --> 22:27:04,720
文本，我们的选项生成器现在将是我记得

788
22:27:04,720 --> 22:27:08,320
如果你回到这里，我们的通用对话框的选项生成器是一个

789
22:27:08,320 --> 22:27:14,160
函数，它返回那个 所以让我们在这里定义一个内联函数，我们

790
22:27:14,160 --> 22:27:18,960
说哎呀要删除它，我们说它是一个

791
22:27:18,960 --> 22:27:22,400
返回映射的函数，这里的键

792
22:27:22,400 --> 22:27:25,920
对 null 的值是没问题的，看看怎么看怎么看 现在是通用的，

793
22:27:25,920 --> 22:27:29,832
所以我们实际上定义说这是一个显示空气拨号它

794
22:27:29,832 --> 22:27:32,640
只是不返回任何东西它只是一个空，好吧

795
22:27:32,640 --> 22:27:35,512
，为了让它更干净，你实际上可以在这里指定这是一个

796
22:27:35,512 --> 22:27:39,360
空，好吧 那部分，所以现在我们已经

797
22:27:39,360 --> 22:27:44,552
处理了我们的错误对话，嗯，现在 w 我们需要做的事情是为了让我们的

798
22:27:44,552 --> 22:27:49,760
代码不那么可怕，因为现在有这么多错误，

799
22:27:49,760 --> 22:27:52,320
让我们去清理其中的一些错误，让我们继续在

800
22:27:52,320 --> 22:27:55,192
任何地方使用这个显示错误对话框好吧，让我们开始吧 查看我们的视图并

801
22:27:55,192 --> 22:27:58,320
查看登录视图，您现在可以看到我们有 show air

802
22:27:58,320 --> 22:28:02,960
dialog 现在我们有自己的 uh show air dialog 实现，所以

803
22:28:02,960 --> 22:28:08,480
让我们从 Visual Studio 代码中获取帮助来导入我们的错误对话框

804
22:28:08,480 --> 22:28:13,192
和所有 突然你在登录视图中看到所有错误并消失了

805
22:28:13,192 --> 22:28:17,192
你可以看到我们在登录视图中。 所以让我们保存我们的登录视图

806
22:28:17,192 --> 22:28:22,080
，我们之前的导入有一个错误，它是 show air

807
22:28:22,080 --> 22:28:26,552
dialog dart，所以让我们也删除它，这样

808
22:28:26,552 --> 22:28:29,760
你的登录视图现在应该看起来很干净，我要关闭它，然后让

809
22:28:29,760 --> 22:28:33,040
我' 我要保存我们在这里拥有的所有这些东西，因为我们

810
22:28:33,040 --> 22:28:36,480
有太多的窗口，太多的选项卡打开，这有点吓人，所以让我们

811
22:28:36,480 --> 22:28:40,400
进入注册视图并清理这个导入，所以让我们

812
22:28:40,400 --> 22:28:45,512
从实用程序显示中删除旧的导入 错误对话框

813
22:28:45,512 --> 22:28:48,872
，让我们开始处理这些错误，我们在

814
22:28:48,872 --> 22:28:52,000
这里显示空中拨号并获取 Visual Studio 代码或您最喜欢的编辑器或

815
22:28:52,000 --> 22:28:56,720
ID，以自动导入我们的新功能，称为短错误对话框，它

816
22:28:56,720 --> 22:29:01,680
位于此实用程序对话框中，错误对话框

817
22:29:01,680 --> 22:29:07,192
现在好了 你现在还记得我们在这里打破

818
22:29:07,192 --> 22:29:11,512
了我们的笔记

819
22:29:11,512 --> 22:29:16,400
视图，现在让我们

820
22:29:16,400 --> 22:29:21,360
看看是的，我们打破了笔记视图只是因为我们没有在这里返回任何东西，

821
22:29:21,360 --> 22:29:25,600
因为我们将所有代码迁移或移动到了

822
22:29:25,600 --> 22:29:30,800
笔记列表视图所以什么 w 我现在需要做的是去

823
22:29:30,800 --> 22:29:35,512
基本上处理我们的

824
22:29:35,512 --> 22:29:39,680
显示删除对话好吧，所以这不是我们需要的，我们需要

825
22:29:39,680 --> 22:29:44,960
处理注释视图注销功能，这里是显示

826
22:29:44,960 --> 22:29:49,680
你看到的注销对话所以我们需要 还要创建一个新的注销

827
22:29:49,680 --> 22:29:52,872
对话框，这个注销对话框将与

828
22:29:52,872 --> 22:29:56,232
我们创建 um 错误对话框的方式非常相似，所以它会非常相似，

829
22:29:56,232 --> 22:30:00,400
好吧，所以我真的要我不

830
22:30:00,400 --> 22:30:05,360
知道它是否值得复制 这段代码我通常不喜欢复制，即使它是

831
22:30:05,360 --> 22:30:10,160
我自己的代码，有时我也会这样做，但在这种情况下，我认为

832
22:30:10,160 --> 22:30:12,480
我们手工编写它实际上更好，所以让我们继续，因为标题

833
22:30:12,480 --> 22:30:16,320
指示在对话文件夹内创建一个名为 注销对话框，

834
22:30:16,320 --> 22:30:18,800
所以在这里我要说新文件注销对话框下拉菜单

835
22:30:18,800 --> 22:30:23,360
和注销对话框，所以我也要去我的笔记，然后注销

836
22:30:23,360 --> 22:30:27,440
那个，好吧，让我们去说和 然后我们需要一个名为 show

837
22:30:27,440 --> 22:30:31,360
logout dialog 的函数，因为我们在这里有它，所以我要开始了 g 只是复制该

838
22:30:31,360 --> 22:30:37,280
名称，因此我们将说这是布尔值的未来

839
22:30:37,280 --> 22:30:41,192
并调用 show logout dialog 并且它唯一需要的是构建

840
22:30:41,192 --> 22:30:44,720
上下文 好吧，

841
22:30:44,720 --> 22:30:48,320
我们将因为我们没有构建内容而收到错误 没有它

842
22:30:48,320 --> 22:30:53,512
在我们的文件中，你现在看到我们得到的唯一错误

843
22:30:53,512 --> 22:30:57,680
是说主体可能正常完成

844
22:30:57,680 --> 22:31:02,400
，这意味着是的，它目前没有返回任何值，我们将

845
22:31:02,400 --> 22:31:06,232
修复我们所以我们 需要在这里我们实际上

846
22:31:06,232 --> 22:31:10,000
要返回我们的显示通用对话框并

847
22:31:10,000 --> 22:31:13,360
在末尾自动导入一个逗号和一个分号只是为了获得正确的格式

848
22:31:13,360 --> 22:31:17,512
上下文在那里我们在这种情况下我们实际上要说

849
22:31:17,512 --> 22:31:21,760
显示通用对话将返回一个布尔值，

850
22:31:21,760 --> 22:31:28,480
所以上下文在那里我们需要指定的标题类型我们只是

851
22:31:28,480 --> 22:31:33,760
要说注销并且对于我们要说的内容你确定你想要

852
22:31:33,760 --> 22:31:38,960
注销可选记住它是一个函数，

853
22:31:38,960 --> 22:31:43,512
我们将在这里创建一个匿名函数 并返回一个地图

854
22:31:43,512 --> 22:31:47,920
，对于取消的选项，我们会说假，对于注销的选项，

855
22:31:47,920 --> 22:31:52,480
我们会说真，好吧，我们在这里遇到了一个巨大的错误，

856
22:31:52,480 --> 22:31:54,960
说有一个布尔值的未来 '正在返回一个布尔

857
22:31:54,960 --> 22:31:57,920
可选的函数，该函数应该再次返回公牛的未来记住

858
22:31:57,920 --> 22:32:02,800
在某些平台上，您可以在不实际

859
22:32:02,800 --> 22:32:05,832
响应您实际需要的那些平台中对话中出现的任何选项的情况下关闭对话

860
22:32:05,832 --> 22:32:08,960
通过返回一个默认值来保护自己免受这种情况的影响，

861
22:32:08,960 --> 22:32:12,960
所以让我们在这里说

862
22:32:12,960 --> 22:32:18,232
，如果我们得到这个值，你可以看到它是一个可选的布尔值，那么我们说

863
22:32:18,232 --> 22:32:22,160
要么返回那个值，要么只返回 false，就是这样，我们可以放一个 最后的逗号

864
22:32:22,160 --> 22:32:25,832
也是为了让格式正确 好的

865
22:32:25,832 --> 22:32:29,512
完美 嗯，现在我们需要做的是现在我们已经编写了显示注销

866
22:32:29,512 --> 22:32:34,000
对话框，我们必须使用它，所以让我们进入我们的注释视图

867
22:32:34,000 --> 22:32:38,640
并获得帮助 您最喜欢的编辑器来

868
22:32:38,640 --> 22:32:42,320
导入您的新注销 对话框在这里，这样错误就消失了，

869
22:32:42,320 --> 22:32:46,400
好吧，所以我们实际上已经解决了这个问题，所以我

870
22:32:46,400 --> 22:32:50,232
想做的是，呃，

871
22:32:50,232 --> 22:32:54,400
稍微编辑一下我的标题，我很抱歉，我很抱歉，

872
22:32:54,400 --> 22:32:59,192
因为这个标题不是 完全正确，所以

873
22:32:59,192 --> 22:33:04,000
我需要解决这个问题

874
22:33:04,000 --> 22:33:07,832
，现在我们已经处理了笔记列表视图，让

875
22:33:07,832 --> 22:33:12,640
我们将笔记列表视图带到笔记视图中，这样你就可以看到我们

876
22:33:12,640 --> 22:33:16,800
有我们的笔记视图，但我们也

877
22:33:16,800 --> 22:33:20,800
有我们必须在

878
22:33:20,800 --> 22:33:24,552
此处导入的笔记列表视图 我们的笔记列表

879
22:33:24,552 --> 22:33:29,512
视图的实例，这将自动为我导入它，

880
22:33:29,512 --> 22:33:34,400
就像这样，对于我要说的笔记，这里是所有笔记，

881
22:33:34,400 --> 22:33:38,720
当用户想要删除笔记时，

882
22:33:38,720 --> 22:33:42,480
我将获得视觉效果 工作室代码为我完成，你可以在这里看到

883
22:33:42,480 --> 22:33:45,360
，我们得到用户想要删除的注释，

884
22:33:45,360 --> 22:33:52,400
然后在这里 w 我要让这个函数异步，只是在

885
22:33:52,400 --> 22:33:56,080
我们的节点服务上等待删除这个

886
22:33:56,080 --> 22:33:58,400
带有这个 ID 的节点

887
22:33:58,400 --> 22:34:01,192
好吧我现在要保存如果你在这里查看你的

888
22:34:01,192 --> 22:34:05,440
代码，你可以看到我们在我们的这里有一个错误 笔记列表视图，

889
22:34:05,440 --> 22:34:13,440
让我们继续修复它，我们可以说它说显示删除对话框

890
22:34:13,440 --> 22:34:17,920
，我们还没有真正编写删除对话框，所以

891
22:34:17,920 --> 22:34:23,280
我们需要做的是需要去修复它，以便它创建一个删除

892
22:34:23,280 --> 22:34:27,832
对话框 同样

893
22:34:27,832 --> 22:34:32,480
，让我们进入我们在此

894
22:34:32,480 --> 22:34:37,600
处的实用程序对话框中的对话框，让我们开始并右键单击它并创建

895
22:34:37,600 --> 22:34:42,160
一个名为删除对话框的新文件，删

896
22:34:42,160 --> 22:34:44,872
除对话框将与注销对话框非常相似，所以让我

897
22:34:44,872 --> 22:34:51,040
们只是 继续吧，也许我们可以使用注销对话框，所以

898
22:34:51,040 --> 22:34:54,480
从注销对话框中复制代码并将其放入名为删除对话框的新文件中，然后将其

899
22:34:54,480 --> 22:34:59,120
粘贴到那里，我们将调用此函数

900
22:34:59,120 --> 22:35:04,400
显示删除对话框

901
22:35:04,400 --> 22:35:08,720
好和 它会

902
22:35:08,720 --> 22:35:12,872
在这里和她身上创造一个通用的对话 e 我们会说 delete

903
22:35:12,872 --> 22:35:16,800
并且我们只会说你确定要删除

904
22:35:16,800 --> 22:35:20,552
这个项目 选项生成器将被取消

905
22:35:20,552 --> 22:35:25,832
false 然后我们将有一个选项只是

906
22:35:25,832 --> 22:35:31,920
说 yes true all 现在你知道现在

907
22:35:31,920 --> 22:35:37,120
我们有一个通用对话框是多么容易，只是我们在任何地方都可以重用它

908
22:35:37,120 --> 22:35:41,512
，那么让我们回到我们的笔记列表视图并修复这个函数修复这个函数的

909
22:35:41,512 --> 22:35:44,480
调用并从 Visual Studio 获得帮助 导入我们的

910
22:35:44,480 --> 22:35:51,040
删除对话的代码并且该错误也消失了，

911
22:35:51,040 --> 22:35:56,160
所以现在我保存了我的项目，突然之间，您看到

912
22:35:56,160 --> 22:36:00,872
我们的每个图块上都出现了删除图标，

913
22:36:00,872 --> 22:36:05,512
我们现在应该准备好将其实际投入测试，所以我 在

914
22:36:05,512 --> 22:36:09,512
这里点击 hello world 项目，现在你看到它说你确定要

915
22:36:09,512 --> 22:36:13,680
删除删除这个项目按取消不会做任何事情，但如果我按下它

916
22:36:13,680 --> 22:36:17,040
并说是，那么你好世界注释被删除并且我们的 notes 视图正在

917
22:36:17,040 --> 22:36:20,720
从其流构建器中收到有关该信息的通知，因为请记住 r

918
22:36:20,720 --> 22:36:23,280
notes 服务，因为我们在这里拥有它，让我们在这里转到我们的

919
22:36:23,280 --> 22:36:27,360
服务，呃

920
22:36:27,360 --> 22:36:30,960
，删除节点时的 crud 和节点服务让我们

921
22:36:30,960 --> 22:36:34,552
看看这里的泄漏节点功能，你会看到它的作用是，如果它可以删除

922
22:36:34,552 --> 22:36:37,280
一个节点，它实际上会删除它 从它的节点数组中，它通知

923
22:36:37,280 --> 22:36:41,760
流控制器实际上不是，那是删除节点

924
22:36:41,760 --> 22:36:46,232
哦，是的，基本上它删除了节点，然后将整个节点数组

925
22:36:46,232 --> 22:36:50,872
放在节点流控制器中，这就是注释视图如何

926
22:36:50,872 --> 22:36:53,760
收到删除通知的方式 如果您愿意，我们可以删除另一个项目

927
22:36:53,760 --> 22:36:56,800
，

928
22:36:56,800 --> 22:37:02,400
在这一章中坚持我，这可能是最具

929
22:37:02,400 --> 22:37:06,480
挑战性的章节之一，因为我们从一开始就有很多错误

930
22:37:06,480 --> 22:37:10,160
，我们有 修复它们，但我本课程的目标之一

931
22:37:10,160 --> 22:37:14,400
不仅仅是让你学习如何编写颤振应用程序，而是真正进入

932
22:37:14,400 --> 22:37:18,800
软件开发人员的心态，所以每个软件开发人员都有

933
22:37:18,800 --> 22:37:24,232
自己的偏好 包括在内，当我进行重构时，我的一个偏好

934
22:37:24,232 --> 22:37:29,512
是就像我在本章开头提到的那样从源代码中删除东西

935
22:37:29,512 --> 22:37:32,720
，这就是为什么我们一开始就有这么多错误，

936
22:37:32,720 --> 22:37:35,760
但你坚持我，我们修复了所有这些 错误，现在我们从本章中走出来

937
22:37:35,760 --> 22:37:39,512
实际上是非常胜利的，所以现在我们有了删除功能

938
22:37:39,512 --> 22:37:44,080
，我们现在需要做的就是去，因为我们已经做了很多工作，所以

939
22:37:44,080 --> 22:37:49,192
我们现在需要确保的是提交 并标记我们的工作，这样我们就不会

940
22:37:49,192 --> 22:37:53,920
丢失这项工作，所以嗯，我要

941
22:37:53,920 --> 22:37:58,640
在这里对窗户进行一些 um 重组，这样你就可以更好地看到一些东西，

942
22:37:58,640 --> 22:38:03,760
我会增加尺寸，现在让我们

943
22:38:03,760 --> 22:38:07,600
看看我们是否 看看之前的标签，我们从上一章来到标签 15

944
22:38:07,600 --> 22:38:12,720
，现在我们需要做一个标签 16

945
22:38:12,720 --> 22:38:16,160
之前的显示错误

946
22:38:16,160 --> 22:38:20,800
对话框我们也对不起，我们还在 l 下添加了一个全新的

947
22:38:20,800 --> 22:38:25,832
文件夹 ib 实用程序对话，

948
22:38:25,832 --> 22:38:29,280
所以让我们开始吧，让我们看看

949
22:38:29,280 --> 22:38:34,160
状态很多事情都改变了，我们要做的是我们

950
22:38:34,160 --> 22:38:37,760
将提交这些，让我们说第

951
22:38:37,760 --> 22:38:40,480
16 步好了，然后将您的更改推送到您的

952
22:38:40,480 --> 22:38:44,000
托管 git repo 我们也将标记为第 16 步，

953
22:38:44,000 --> 22:38:47,360
所以如果您现在查看您的标签，我们将推送我们的标签，您

954
22:38:47,360 --> 22:38:53,440
有 1 二三四五六七等等等等，所以我们有所有的

955
22:38:53,440 --> 22:38:58,000
标签 包括第 16 步。好吧，这是为了提交和

956
22:38:58,000 --> 22:39:02,320
标记我们的工作，因为它是传统 我们

957
22:39:02,320 --> 22:39:06,160
将讨论我们需要在下一章讨论的内容

958
22:39:06,160 --> 22:39:11,440
你可以看到我们有能力创建新的笔记，我们 也有

959
22:39:11,440 --> 22:39:16,552
删除笔记的能力，还有我们没有测试的

960
22:39:16,552 --> 22:39:20,552
东西，当我们创建一个新笔记时，如果我们退出它，你会看到那个

961
22:39:20,552 --> 22:39:25,600
笔记实际上是从数据库中删除的，所以这也是有效的，所以我们

962
22:39:25,600 --> 22:39:29,512
有删除笔记的能力和创建笔记的能力，但我们

963
22:39:29,512 --> 22:39:34,080
没有能力 更新笔记，这正是我们将

964
22:39:34,080 --> 22:39:38,320
在下一章讨论的内容，所以我会在那里见到你们，

965
22:39:38,320 --> 22:39:42,640
大家好，欢迎来到前几章中屠宰课程的第 34

966
22:39:42,640 --> 22:39:45,760
章，我们一直在谈论如何 我们可以创建

967
22:39:45,760 --> 22:39:48,720
和注释以及如何删除它们，因此我们一直在使用一些

968
22:39:48,720 --> 22:39:53,760
通用对话进行大量工作，我们还开发了这些通用对话，以便能够处理

969
22:39:53,760 --> 22:40:00,160
错误对话以及例如注销对话以及

970
22:40:00,160 --> 22:40:05,280
删除对话，所以这方面已经做了很多工作

971
22:40:05,280 --> 22:40:09,680
，但我们还没有真正讨论过用户如何点击或

972
22:40:09,680 --> 22:40:14,800
点击他们现有的笔记，以便能够

973
22:40:14,800 --> 22:40:17,760
更新它，例如更新它 特定的节点，这就是

974
22:40:17,760 --> 22:40:22,160
我们在本章中要处理的内容，

975
22:40:22,160 --> 22:40:25,680
所以如果我们现在开始查看

976
22:40:25,680 --> 22:40:28,872
我们为您编写的代码，您会看到我们已经

977
22:40:28,872 --> 22:40:33,440
将实际创建注释的视图称为新节点

978
22:40:33,440 --> 22:40:37,280
但是我们不会去创建一个

979
22:40:37,280 --> 22:40:40,160
全新的 vi  ew 看起来与这个新的笔记视图完全相同，这样我们就可以

980
22:40:40,160 --> 22:40:43,920
更新现有的笔记，所以本章的目标是重用这个视图，

981
22:40:43,920 --> 22:40:47,512
这样我们就可以使用完全相同的视图，但是

982
22:40:47,512 --> 22:40:51,832
当用户点击笔记时 在笔记列表中，我们将把

983
22:40:51,832 --> 22:40:55,600
点击的笔记传递给现有的视图

984
22:40:55,600 --> 22:40:59,192
更好的是，我会

985
22:40:59,192 --> 22:41:03,120
像往常一样在这里调出 Visual Studio 代码，

986
22:41:03,120 --> 22:41:06,960
我有 scrcpy 负责处理这个 android 屏幕

987
22:41:06,960 --> 22:41:10,400
，然后我们可以看看我们必须做的第一个任务，正如你

988
22:41:10,400 --> 22:41:15,512
在缓存中看到的那样，它说我们 必须将新节点重命名为您的 dart 以创建

989
22:41:15,512 --> 22:41:18,960
更新节点视图，好吧，所以让我们处理一下，我将关闭

990
22:41:18,960 --> 22:41:23,192
此处的所有选项卡，让我们说命令 p visual

991
22:41:23,192 --> 22:41:27,440
studio code 或者 android studio 是另一个命令 您必须

992
22:41:27,440 --> 22:41:30,480
按顺序执行才能显示我不知道的文件列表

993
22:41:30,480 --> 22:41:34,160
android studio 中的命令，但如果您对其中任何一个不满意，

994
22:41:34,160 --> 22:41:39,192
您可以直接在此处转到这个新的笔记视图，我们将重命名它，

995
22:41:39,192 --> 22:41:42,000
所以我们现在就这样做，所以我

996
22:41:42,000 --> 22:41:47,512
只是作为缓存调用 在这种情况下创建更新注释视图好的

997
22:41:47,512 --> 22:41:51,920
创建更新注释视图如果更新我的意思是如果你的编辑

998
22:41:51,920 --> 22:41:55,832
器足够智能并且它内置了一些类似的重构功能

999
22:41:55,832 --> 22:41:59,440
那么你不必为此命令做任何特殊

1000
22:41:59,440 --> 22:42:03,512
的事情 工作但是你可以

1001
22:42:03,512 --> 22:42:07,360
在这里看到例如现在我们已经更改了这个文件名来创建更新

1002
22:42:07,360 --> 22:42:10,720
节点视图但是我们并没有真正改变例如类名所以如果我去

1003
22:42:10,720 --> 22:42:14,000
这里这个东西仍然被称为新节点查看全部 好吧

1004
22:42:14,000 --> 22:42:20,000
，让我们进去，也许也改变一下，让我去我的笔记，

1005
22:42:20,000 --> 22:42:23,760
嗯，让我们看看创建更新笔记视图，我们实际上要

1006
22:42:23,760 --> 22:42:29,040
重命名这个新的笔记视图，所以让我们继续做一些

1007
22:42:29,040 --> 22:42:33,760
重构 在这里，我只想说重构，让我们看看我们有没有

1008
22:42:33,760 --> 22:42:37,120
这里有任何重构功能，我们有重命名符号，所以也许让我们使用

1009
22:42:37,120 --> 22:42:42,080
它，我将调用它创建更新节点视图，

1010
22:42:42,080 --> 22:42:45,920
让我们看看它

1011
22:42:45,920 --> 22:42:49,512
是否能够成功地为我重命名它，所以我可以看到它重命名了类 我和

1012
22:42:49,512 --> 22:42:54,552
它还重命名了状态类，这正是我所需要的，所以如果我现在保存

1013
22:42:54,552 --> 22:42:57,600
它，我们应该会遇到一些问题，请原谅，

1014
22:42:57,600 --> 22:43:02,000
但我可以看到 Visual Studio 代码实际上足够智能，可以

1015
22:43:02,000 --> 22:43:09,192
将主要 dart 引用重命名为这条路线以及

1016
22:43:09,192 --> 22:43:14,320
记住 当我们创建这个创建

1017
22:43:14,320 --> 22:43:16,960
或者在它被调用之前我们实际上称之为

1018
22:43:16,960 --> 22:43:21,040
um new note view 时

1019
22:43:21,040 --> 22:43:25,280
，note view 是一个新的 note view 实际上是在我们的路由中使用的，在我们的

1020
22:43:25,280 --> 22:43:30,232
main.dart 中我们的应用程序的 main 函数中，现在

1021
22:43:30,232 --> 22:43:34,640
我们 '已将其重命名以创建更新注释查看类名、有状态

1022
22:43:34,640 --> 22:43:39,920
小部件及其状态，然后应在 main.dart 中使用该新名称，

1023
22:43:39,920 --> 22:43:45,512
因此如果您使用 vim 或任何其他

1024
22:43:45,512 --> 22:43:50,000
代码编辑器，例如使用 sublime 供应 可能没有这个参考

1025
22:43:50,000 --> 22:43:54,080
可以实际去重命名您使用该符号的位置的演员功能，

1026
22:43:54,080 --> 22:44:00,552
因此您可能需要手动执行此操作，因此您实际上可能会在 main.dart 文件中遇到一些错误，

1027
22:44:00,552 --> 22:44:06,800
但如果您遇到这些错误，请不要

1028
22:44:06,800 --> 22:44:09,832
担心 至少你知道问题是什么，所以你可以自己去解决它，

1029
22:44:09,832 --> 22:44:13,600
所以我们已经完成了，现在我们需要做的是我实际上

1030
22:44:13,600 --> 22:44:18,480
要在这里按 command s，在这里按 command s 只是为了 确保所有内容

1031
22:44:18,480 --> 22:44:22,552
都已保存，并且如标题所示，请记住我们在常量中也有我们的路由，

1032
22:44:22,552 --> 22:44:26,080
因此您可以看到我们的路由仍然称为

1033
22:44:26,080 --> 22:44:30,000
新节点路由，好吧，所以我现在要重命名它，我

1034
22:44:30,000 --> 22:44:33,600
建议您也做同样的事情让我们说 重命名，让我们将

1035
22:44:33,600 --> 22:44:36,552
其重命名为缓存指示创建或更新节点路由可以，所以创建或

1036
22:44:36,552 --> 22:44:38,800
更新雪就像那样，你可以再次看到，Visual Studio

1037
22:44:38,800 --> 22:44:43,680
代码帮助了我们很多，现在它也更新了，

1038
22:44:43,680 --> 22:44:48,080
你看对了

1039
22:44:48,080 --> 22:44:52,800
笔记视图中也发生了一些事情 我可以看到，那是

1040
22:44:52,800 --> 22:44:57,512
因为你看到了我们

1041
22:44:57,512 --> 22:45:01,360
在这里实际按下加号按钮的位置，以创建一个新节点，该节点也使用 uh

1042
22:45:01,360 --> 22:45:04,872
以前 uh 命名的

1043
22:45:04,872 --> 22:45:10,160
新节点路由，但现在它已更新以创建或更新节点路由，所以我只是

1044
22:45:10,160 --> 22:45:13,120
试图在这里说您需要重命名该路由，以便它成为创建或

1045
22:45:13,120 --> 22:45:16,960
更新新节点路由，并且根据您的编辑器，它可能足够聪明，可以

1046
22:45:16,960 --> 22:45:19,832
拥有一些重构功能，如果它像 Visual Studio 代码那么您

1047
22:45:19,832 --> 22:45:23,040
就可以了 重命名它，但如果不是，您可能必须手动执行此操作，所以请

1048
22:45:23,040 --> 22:45:27,192
继续并重命名您在代码中重构的地方，您正在使用

1049
22:45:27,192 --> 22:45:30,160
该路线使用新名称，好吧，

1050
22:45:30,160 --> 22:45:35,360
现在让我们看看这个困境

1051
22:45:35,360 --> 22:45:39,600
你在我们的

1052
22:45:39,600 --> 22:45:44,080
笔记视图中看到当我们创建一个新笔记时我们只是说

1053
22:45:44,080 --> 22:45:48,160
上下文推送名称的导航器现在这里的目标是当我们创建这个

1054
22:45:48,160 --> 22:45:54,080
节点列表视图时我们将允许你在我们拥有的那一刻看到的用户

1055
22:45:54,080 --> 22:45:59,600
删除节点，但我们还将有一个名为 unta 的参数 p 我们

1056
22:45:59,600 --> 22:46:03,760
很快就会开发它，但这里的困境是，当

1057
22:46:03,760 --> 22:46:05,832
你说点击时我们还需要进入这个视图，进入

1058
22:46:05,832 --> 22:46:09,512
这个我们已经创建或更新节点路由的路由，但我们必须

1059
22:46:09,512 --> 22:46:12,800
向那个路由传递一个参数 参数就像函数

1060
22:46:12,800 --> 22:46:19,040
的参数或函数的参数一样，就像您传递给该

1061
22:46:19,040 --> 22:46:21,680
路由的数据一样，您说嘿，我正在初始化此路由，但我正在将一些数据传递给

1062
22:46:21,680 --> 22:46:26,640
它，然后该路由 然后可以反过来反应性地抱歉，拉尔夫可以对此

1063
22:46:26,640 --> 22:46:31,120
做出反应并去阅读那个论点并说哦，我是否通过了一个

1064
22:46:31,120 --> 22:46:35,360
论点是的然后我会这样做如果我没有通过一个论点那么我

1065
22:46:35,360 --> 22:46:38,160
会做某事 否则在这种情况下，如果您将便笺传递给我们的创建或

1066
22:46:38,160 --> 22:46:42,232
更新便笺路线，那么它会说哦，我有一个现有节点，我

1067
22:46:42,232 --> 22:46:46,720
将使用该便笺填充自己和我的内容，并且我不会

1068
22:46:46,720 --> 22:46:50,640
创建 新节点记住我们的创建更新注释

1069
22:46:50,640 --> 22:46:54,160
视图我们在这里设置了这个功能

1070
22:46:54,160 --> 22:46:57,120
，说创建一个新节点 w node 我们很快就会解决这个问题，但请记住，

1071
22:46:57,120 --> 22:47:01,360
当您默认进入该视图时，它正在创建一个新节点，

1072
22:47:01,360 --> 22:47:09,040
我们将对其进行更改，以便我们说我们将重命名它并且

1073
22:47:09,040 --> 22:47:13,512
说像创建或获取注释或类似的东西很快你会看到嗯

1074
22:47:13,512 --> 22:47:17,920
但是在那个函数中我们会说我们在

1075
22:47:17,920 --> 22:47:22,080
哪里传递了一个参数，如果是，我们

1076
22:47:22,080 --> 22:47:26,080
不需要创建一个新节点 如果没有，我们必须创建一个好的，

1077
22:47:26,080 --> 22:47:31,280
所以参数的工作方式是，如果您查看我们的注释视图，

1078
22:47:31,280 --> 22:47:35,832
我们正在使用推送名称，这里有一个称为参数的参数，

1079
22:47:35,832 --> 22:47:40,480
正如您目前所看到的那样 一个可选对象，这意味着它

1080
22:47:40,480 --> 22:47:45,192
可以是 no 或 no 我们不是我们目前没有利用它，

1081
22:47:45,192 --> 22:47:51,192
但我们很快就会在调用端创建一个

1082
22:47:51,192 --> 22:47:55,040
你正在创建路由的地方和 将其推送到

1083
22:47:55,040 --> 22:47:58,872
导航堆栈，您可以使用该 arguments 参数传递您的参数，

1084
22:47:58,872 --> 22:48:03,680
并在 thi 的接收方 s case

1085
22:48:03,680 --> 22:48:07,600
are let's see create or update node view here

1086
22:48:07,600 --> 22:48:11,760
in here 你可以阅读然后你的论点

1087
22:48:11,760 --> 22:48:16,080
让我们看看让我们去一些有意义的地方让我们说在这里

1088
22:48:16,080 --> 22:48:18,960
好吧你可以阅读那个参数调用现在你不必输入 我正在打字，

1089
22:48:18,960 --> 22:48:24,232
我只是在向你展示一些东西，好吧，我们可以使用模型 uh 路线

1090
22:48:24,232 --> 22:48:28,640
，我们说的是上下文，然后你可以说设置

1091
22:48:28,640 --> 22:48:31,920
点参数，那么这就是你基本上可以

1092
22:48:31,920 --> 22:48:37,040
通过你的模态路线访问你的参数的地方所以现在 你知道如何传递参数，你也

1093
22:48:37,040 --> 22:48:39,600
知道如何接收它们，所以

1094
22:48:39,600 --> 22:48:44,080
让我们进入下一点，嗯，你知道

1095
22:48:44,080 --> 22:48:48,232
我们将来可能需要在某个地方在我们的

1096
22:48:48,232 --> 22:48:53,440
任何小部件中接收一个参数，这个参数可以是任何

1097
22:48:53,440 --> 22:48:58,552
您指定的类型，例如，您可以将整数从一个屏幕传递到另一个屏幕，或者

1098
22:48:58,552 --> 22:49:02,800
您可以传递一个字符串，或者您可以传递一个数组，或者在我们的例子中，您可以传递一个

1099
22:49:02,800 --> 22:49:06,720
数据库节点，这样您就可以在这段代码中看到让我们开始

1100
22:49:06,720 --> 22:49:12,080
吧 在这里嗯

1101
22:49:12,080 --> 22:49:15,120
这是什么可选的设置 d 然后

1102
22:49:15,120 --> 22:49:19,832
你现在看到的参数这个家伙是一个对象，所以它并不真正知道它

1103
22:49:19,832 --> 22:49:23,120
是什么，但如果你能

1104
22:49:23,120 --> 22:49:27,680
以某种方式创建一个函数，让我们只说

1105
22:49:27,680 --> 22:49:32,232
例如上下文获取类型的对象，那就太好了 类似这样的东西，所以我们

1106
22:49:32,232 --> 22:49:36,232
可以说给定一个构建上下文

1107
22:49:36,232 --> 22:49:40,552
，如果该参数存在，我们想从中提取任何类型的参数

1108
22:49:40,552 --> 22:49:46,400
，然后我们将在我们的代码中使用它

1109
22:49:46,400 --> 22:49:51,760
，然后我们得到我们的构建 上下文，然后从中取出我们的笔记，

1110
22:49:51,760 --> 22:49:58,552
所以我们要做的就是创建一种从构建上下文中提取参数的通用方法

1111
22:49:58,552 --> 22:50:03,920
，这正是我们现在要做的，

1112
22:50:03,920 --> 22:50:08,080
所以我们要做 将在构建上下文中创建一个扩展，该

1113
22:50:08,080 --> 22:50:12,320
扩展将被称为访客参数，正如我在 um 中指出的那样，

1114
22:50:12,320 --> 22:50:19,120
正如我在屏幕底部的标题中指出的那样，您

1115
22:50:19,120 --> 22:50:23,440
可以看到我们将

1116
22:50:23,440 --> 22:50:27,440
在 lib 实用程序泛型下创建一个新文件，并且文件调用获取参数，因此您可以看到我们

1117
22:50:27,440 --> 22:50:31,280
此刻这里有实用程序，而实用程序跟随我只是

1118
22:50:31,280 --> 22:50:35,360
把所有东西都折叠在这里，所以看起来并不可怕，你可以看到实用程序

1119
22:50:35,360 --> 22:50:39,120
现在有一个名为 dialogs 的文件夹，但

1120
22:50:39,120 --> 22:50:44,000
我们要创建的是一个名为 generics 的文件夹和 然后是一个

1121
22:50:44,000 --> 22:50:48,160
名为 get arguments 的文件，好吧，所以

1122
22:50:48,160 --> 22:50:51,120
我们现在就开始吧，所以我要去 uh

1123
22:50:51,120 --> 22:50:55,280
utility where to go 实用程序对话好了，所以我要

1124
22:50:55,280 --> 22:51:01,920
右键单击实用程序并说新文件 我要说泛型

1125
22:51:01,920 --> 22:51:04,960
歌词并获取参数 dot

1126
22:51:04,960 --> 22:51:10,872
dart 现在在这里我们需要的是嗯

1127
22:51:10,872 --> 22:51:13,680
，开始编写我们的扩展，所以我只想说扩展

1128
22:51:13,680 --> 22:51:18,800
并获取关于构建上下文的参数，

1129
22:51:18,800 --> 22:51:23,440
如果我输入 build context visual 现在可以了

1130
22:51:23,440 --> 22:51:27,440
如果您使用 sublime 或任何其他文本编辑器，工作室代码足够聪明，可以导入材料，

1131
22:51:27,440 --> 22:51:30,480
它可能不够聪明，无法做到这一点，因为您可能不

1132
22:51:30,480 --> 22:51:34,080
喜欢使用 dart 和颤振等的扩展

1133
22:51:34,080 --> 22:51:39,040
，所以您可能不得不 自己进口材料 不记得我们也

1134
22:51:39,040 --> 22:51:43,192
只需要 um build context and modal route from

1135
22:51:43,192 --> 22:51:46,160
the entire material uh packaging here，所以

1136
22:51:46,160 --> 22:51:52,552
如果你只是说显示构建上下文

1137
22:51:52,552 --> 22:51:57,120
和模态

1138
22:51:57,120 --> 22:52:01,120
路径会更有意义，所以我们不会使用更多来自 材料包

1139
22:52:01,120 --> 22:52:04,720
比这

1140
22:52:04,720 --> 22:52:08,160
两个好，所以让我们继续创建这个函数，所以我们

1141
22:52:08,160 --> 22:52:11,920
说我们将有选择地返回一个类型为 t 的值，这意味着

1142
22:52:11,920 --> 22:52:17,680
您要求我们使用的任何类型，我们将调用它 函数获取

1143
22:52:17,680 --> 22:52:21,760
参数没问题，并且获取参数本身可以，

1144
22:52:21,760 --> 22:52:25,920
所以在这里我们要说的是模态路由

1145
22:52:25,920 --> 22:52:30,800
是我们构建上下文的模型路由，

1146
22:52:30,800 --> 22:52:36,320
或者因为你看到我们正在创建一个构建上下文的扩展

1147
22:52:36,320 --> 22:52:41,440
并且 这里的这个标识符是指

1148
22:52:41,440 --> 22:52:45,920
实际调用 get 参数函数的当前构建上下文，所以如果你不

1149
22:52:45,920 --> 22:52:50,080
熟悉我之前讨论过的扩展

1150
22:52:50,080 --> 22:52:54,000
，所以我认为它也是 dart 介绍的一部分 开始

1151
22:52:54,000 --> 22:52:57,192
绝对开始 这门课程，所以你可能想回到那个，以

1152
22:52:57,192 --> 22:53:00,720
了解扩展是如何工作的

1153
22:53:00,720 --> 22:53:05,512
反对这一点，所以我们只说如果模态

1154
22:53:05,512 --> 22:53:10,080
路由不为空

1155
22:53:10,080 --> 22:53:15,360
，否则我们将返回 null 我们说如果我们无法

1156
22:53:15,360 --> 22:53:19,360
获得模型路由，那么我们就无法从中提取任何参数，所以让我们得到

1157
22:53:19,360 --> 22:53:23,440
现在让我们从我们的模型路由中获取所有参数，

1158
22:53:23,440 --> 22:53:29,600
所以我们要说 args 是模型路由设置

1159
22:53:29,600 --> 22:53:32,640
点参数，然后记住 args 现在也是一个对象，因为它

1160
22:53:32,640 --> 22:53:36,552
在调用站点上调用站点可能会跳过传递参数 对我们来说，在

1161
22:53:36,552 --> 22:53:42,320
这种情况下，我们不会得到任何参数，这意味着

1162
22:53:42,320 --> 22:53:46,800
args 在这里将是 null

1163
22:53:46,800 --> 22:53:51,920
我们将返回 rx 好吧 呃 oops

1164
22:53:51,920 --> 22:53:56,640
rx as t 所以我们在这里说的是如果

1165
22:53:56,640 --> 22:54:01,360
我们可以从我们的模态路由设置参数中获取任何参数，如果

1166
22:54:01,360 --> 22:54:05,760
该参数是您要求此函数提取的类型，那么

1167
22:54:05,760 --> 22:54:11,192
我们将把它还给它，否则我们将进入行

1168
22:54:11,192 --> 22:54:15,192
号 12 在这里，只是返回和 null 好了，

1169
22:54:15,192 --> 22:54:18,800
现在我要保存这个文件，好吧

1170
22:54:18,800 --> 22:54:23,600
，这就是那部分现在我们需要的是让我调出

1171
22:54:23,600 --> 22:54:26,872
标题，这样你就可以看到我们必须做什么，

1172
22:54:26,872 --> 22:54:32,160
现在让我们进入我们的视图 我们称之为创建实际上

1173
22:54:32,160 --> 22:54:36,000
现在很容易，因为我们的项目中有很多文件，

1174
22:54:36,000 --> 22:54:40,800
如果我们只是在 Visual Studio 代码中执行命令 p 例如跳转

1175
22:54:40,800 --> 22:54:44,000
到特定文件，那么导航实际上更容易，因此在该文件中它现在称为

1176
22:54:44,000 --> 22:54:47,600
创建 更新节点视图所以让我们去那里

1177
22:54:47,600 --> 22:54:52,800
，因为标题表明我们在这里创建注释让

1178
22:54:52,800 --> 22:54:55,192
我们看看我们是否可以找到该功能创建新节点在这里你看到

1179
22:54:55,192 --> 22:54:59,680
所以我们需要做的是我们只需要重命名那个 um

1180
22:54:59,680 --> 22:55:06,320
create 要求他们创建或获取现有字幕的新注释

1181
22:55:06,320 --> 22:55:11,760
笔记，所以我会这样做，我会说创建

1182
22:55:11,760 --> 22:55:14,960
或获取现有笔记，然后我们再次将代码

1183
22:55:14,960 --> 22:55:19,360
做得足够聪明，以重命名我实际使用该功能的位置，你可以

1184
22:55:19,360 --> 22:55:23,832
在这里看到，好吧，否则你可能会如果 您没有使用

1185
22:55:23,832 --> 22:55:29,832
可视代码，或者如果您没有使用您最喜欢的编辑器的重构功能，

1186
22:55:29,832 --> 22:55:35,120
您可能还必须重命名该调用站点，

1187
22:55:35,120 --> 22:55:40,320
所以我认为我不必再次提及这个我想我现在已经 提到它

1188
22:55:40,320 --> 22:55:45,280
三遍，所以如果你要重命名某些东西，请

1189
22:55:45,280 --> 22:55:48,640
确保所有调用站点也都更新

1190
22:55:48,640 --> 22:55:52,872
好了，所以现在我们已经完成了，如果它已经存在，我们实际上需要获取现有节点

1191
22:55:52,872 --> 22:55:56,872
好的，所以让我们这样做，你可以看到它在

1192
22:55:56,872 --> 22:56:01,832
创建或获取现有的没有得到注释参数，如果有的

1193
22:56:01,832 --> 22:56:06,080
话，那么让我们在这里说如果我们的小部件（如实际调用我们的小部件）

1194
22:56:06,080 --> 22:56:11,760
创建了我们，是否已经向我们传递了一个参数 类型为

1195
22:56:11,760 --> 22:56:15,040
数据库注释，那么我们就可以了，所以我们就称它为小部件

1196
22:56:15,040 --> 22:56:18,872
注释是 嗯，

1197
22:56:18,872 --> 22:56:23,512
我们现在需要一个构建上下文，因为记住我们的扩展是在构建上下文中创建的，

1198
22:56:23,512 --> 22:56:27,192
但是这个函数目前没有构建上下文，所以让我们

1199
22:56:27,192 --> 22:56:32,480
继续在这里传递一个构建上下文，

1200
22:56:32,480 --> 22:56:36,480
好吧，然后让我们进入调用站点并

1201
22:56:36,480 --> 22:56:40,960
传递构建 这里的上下文调用上下文，它在构建函数中传递给我们，

1202
22:56:40,960 --> 22:56:44,872
所以相信你已经完成了，

1203
22:56:44,872 --> 22:56:48,640
我们现在要去说上下文获取

1204
22:56:48,640 --> 22:56:53,832
，你现在看到我们需要我们的 get 参数函数，但是因为我 在这里没有输入任何内容

1205
22:56:53,832 --> 22:56:57,920
，那是因为我们没有导入，所以

1206
22:56:57,920 --> 22:57:02,552
我可以看看我是否只是输入 get the argument 并询问 Visual Studio 代码

1207
22:57:02,552 --> 22:57:05,920
是否可以为我解决这个问题它说哦，又是

1208
22:57:05,920 --> 22:57:10,640
arguments.dart 有一个函数的文件你想让我导入它，所以

1209
22:57:10,640 --> 22:57:14,400
我只想说是，否则如果你不这样做，你

1210
22:57:14,400 --> 22:57:17,512
可能必须手动导入你的 get arguments.dart 文件，所以

1211
22:57:17,512 --> 22:57:23,440
现在我 只是说获取参数并记住获取参数

1212
22:57:23,440 --> 22:57:29,600
本身的功能哈 s没有参数所以你怎么调用这个函数好你怎么告诉

1213
22:57:29,600 --> 22:57:32,960
它提取类似的数据库节点这很

1214
22:57:32,960 --> 22:57:37,832
容易你只需把这个小于号和等级它放在

1215
22:57:37,832 --> 22:57:42,872
里面然后你输入对象的类型 你想提取所以如果我们

1216
22:57:42,872 --> 22:57:48,720
只是说数据库注释好了

1217
22:57:48,720 --> 22:57:52,720
，现在我们这样做了，记住 get 参数返回该类型的可选对象

1218
22:57:52,720 --> 22:57:56,080
，在这种情况下，我们的数据库节点是一个可选的数据库节点，

1219
22:57:56,080 --> 22:57:58,872
这意味着你要么有 一个节点，

1220
22:57:58,872 --> 22:58:02,552
以便用户点击现有节点并来到这里，或者你并不

1221
22:58:02,552 --> 22:58:06,720
意味着用户点击了加号按钮并来到这里没问题，

1222
22:58:06,720 --> 22:58:10,160
所以我们说如果小部件节点不为空，这意味着我们正在

1223
22:58:10,160 --> 22:58:13,760
更新 现有节点，以便用户点击现有节点并最终出现

1224
22:58:13,760 --> 22:58:17,832
在屏幕上然后我们将要做的我们

1225
22:58:17,832 --> 22:58:23,120
将把它保存在我们的节点私有变量中，

1226
22:58:23,120 --> 22:58:26,480
我想我们在这里的某个地方设置它你看

1227
22:58:26,480 --> 22:58:31,832
所以我们要说我们的节点是 widge  t 节点

1228
22:58:31,832 --> 22:58:35,192
好的，在这种情况下，我们还需要做的

1229
22:58:35,192 --> 22:58:38,640
是确保我们屏幕上的文本字段

1230
22:58:38,640 --> 22:58:43,480
，我可以在这里显示给你，所以如果你去这里

1231
22:58:43,480 --> 22:58:47,440
这个文本字段应该预先填充现有的 注释

1232
22:58:47,440 --> 22:58:50,960
文本和我们可以做到的方式我的意思是我们没有直接访问我们的文本

1233
22:58:50,960 --> 22:58:55,600
字段但我们拥有的是我们在这里设置的文本控制器文本

1234
22:58:55,600 --> 22:58:59,192
控制器好的所以让我们去设置文本控制器的文本所以 我只想

1235
22:58:59,192 --> 22:59:05,040
说文本控制器文本等于小部件注释

1236
22:59:05,040 --> 22:59:09,440
点文本，然后我们将返回

1237
22:59:09,440 --> 22:59:13,680
小部件注释，以便我们

1238
22:59:13,680 --> 22:59:18,000
可以提取的注释没问题，否则

1239
22:59:18,000 --> 22:59:21,680
我们在这里所做的就是说 现有的注释注释，所以

1240
22:59:21,680 --> 22:59:27,192
逻辑将保持不变，所以如果我们可以从

1241
22:59:27,192 --> 22:59:31,680
传递的小部件或颜色小部件中提取节点，那么我们将其设置为我们的节点设置文本，

1242
22:59:31,680 --> 22:59:35,040
然后只返回小部件注释，否则我们将继续 就像我们

1243
22:59:35,040 --> 22:59:38,960
之前做的那样，让我们在这里看看我们也在做什

1244
22:59:38,960 --> 22:59:43,360
么 请注意，我们只是返回，但我也可以看到，

1245
22:59:43,360 --> 22:59:48,640
在这里创建笔记时，我们没有设置该笔记，所以我们需要在这里做的，

1246
22:59:48,640 --> 22:59:52,232
让我们说最后的新笔记好吧

1247
22:59:52,232 --> 22:59:54,640
，然后我们存储该笔记我们 说笔记是

1248
22:59:54,640 --> 22:59:59,280
新笔记然后我们只是说返回你知道所以

1249
22:59:59,280 --> 23:00:02,872
在这里我们也保存我们的笔记很好所以这真的很好所以我们

1250
23:00:02,872 --> 23:00:05,760
实际上可以使用现有的笔记

1251
23:00:05,760 --> 23:00:09,120
好吧所以我实际上不确定这是如何

1252
23:00:09,120 --> 23:00:15,120
工作的 在这之前可能是之前 um 部分中的一个错误，因为我们

1253
23:00:15,120 --> 23:00:17,920
实际上并没有将节点存储在这个节点私有变量中，

1254
23:00:17,920 --> 23:00:22,080
所以也许我们之前就有这个错误，我

1255
23:00:22,080 --> 23:00:26,720
不能完全确定，所以我只是 回到这里，但如果

1256
23:00:26,720 --> 23:00:31,680
你也有这个错误，如果你想返回节点

1257
23:00:31,680 --> 23:00:36,320
服务创建节点的重量并且你没有保存我不确定这些

1258
23:00:36,320 --> 23:00:42,000
嗯这些功能实际上是如何工作的，

1259
23:00:42,000 --> 23:00:46,480
因为我个人哦 我可以看到我们将它设置在

1260
23:00:46,480 --> 23:00:51,680
这里，所以我们可能不必再这样做了，所以让我们 然后继续，我的

1261
23:00:51,680 --> 23:00:55,192
意思是这很聪明，但是小部件的构建

1262
23:00:55,192 --> 23:00:59,600
功能像这个小部件的核心部分一样发生变化并不是一个好主意，所以让我们

1263
23:00:59,600 --> 23:01:03,512
现在删除它，好吧它是如何工作的，这就是它工作的原因

1264
23:01:03,512 --> 23:01:08,232
但是 它不应该那样工作

1265
23:01:08,232 --> 23:01:12,160
好吧好吧让我们现在进入下一部分嗯

1266
23:01:12,160 --> 23:01:16,552
你看看我们是否回到这里如果我按下删除

1267
23:01:16,552 --> 23:01:21,680
按钮你还记得

1268
23:01:21,680 --> 23:01:26,720
我们在前几章中开发的这个吗 当然我们确保我们有一个

1269
23:01:26,720 --> 23:01:31,040
回调并且定义了回调让我们进入我们的

1270
23:01:31,040 --> 23:01:35,440
笔记列表视图我实际上会像这个笔记列表视图

1271
23:01:35,440 --> 23:01:39,760
那样做你记得这个回调它被称为删除笔记回调

1272
23:01:39,760 --> 23:01:45,120
它只是一个函数 什么都没返回并接受了注释，

1273
23:01:45,120 --> 23:01:49,832
这样我们可以告诉注释视图，

1274
23:01:49,832 --> 23:01:53,192
嘿，用户想要删除一个注释，现在删除它，

1275
23:01:53,192 --> 23:01:57,600
并且在用户按下是按钮时被调用

1276
23:01:57,600 --> 23:02:01,440
记住它实际上是这个视图显示 删除

1277
23:02:01,440 --> 23:02:04,552
对话框 好吧，但是如果你看一下，

1278
23:02:04,552 --> 23:02:09,040
但是如果你看一下这个删除节点回调

1279
23:02:09,040 --> 23:02:12,800
它实际上是什么调用备份是一个注释的回调好吧所以它

1280
23:02:12,800 --> 23:02:17,192
与删除没有任何关系它只是被称为删除节点回调

1281
23:02:17,192 --> 23:02:20,160
好吧可以 我们还利用它来

1282
23:02:20,160 --> 23:02:24,160
以某种方式告诉何时点击了这些笔记中的任何一个

1283
23:02:24,160 --> 23:02:29,120
我们可以使用完全相同的功能来告诉笔记列表视图

1284
23:02:29,120 --> 23:02:34,720
抱歉告诉笔记视图嘿你用户点击了笔记

1285
23:02:34,720 --> 23:02:39,760
当然我们可以这样做 因为它没有返回值，它只

1286
23:02:39,760 --> 23:02:44,640
接受一个注释，所以我们现在对它的命名有一点问题，

1287
23:02:44,640 --> 23:02:49,832
它只是称为删除注释回调，但它不应该没问题，所以

1288
23:02:49,832 --> 23:02:53,920
我们将两者都用于 删除并且还用于

1289
23:02:53,920 --> 23:02:59,120
点击现有节点所以让我调出标题让我们

1290
23:02:59,120 --> 23:03:02,320
将删除节点回调重命名为节点回调所以我要右键单击

1291
23:03:02,320 --> 23:03:06,552
它我只想说重命名重命名符号，让我们打电话 它

1292
23:03:06,552 --> 23:03:10,552
节点回调好的，现在你可以看到它的行为 也为我在这里重命名了它

1293
23:03:10,552 --> 23:03:15,512
，一切都应该按照以前的方式工作，

1294
23:03:15,512 --> 23:03:19,120
所以我们不必做任何特别的事情，它现在只是称为节点

1295
23:03:19,120 --> 23:03:23,920
回调，

1296
23:03:23,920 --> 23:03:27,360
好吧，让我们现在进入下一个

1297
23:03:27,360 --> 23:03:31,680
非常相关的部分，所以 我们现在需要做的是你现在看到

1298
23:03:31,680 --> 23:03:35,040
节点列表视图它根本没有处理用户点击这些列表

1299
23:03:35,040 --> 23:03:38,320
图块中的任何一个，我们将解决这个问题，所以我只是去我的笔记

1300
23:03:38,320 --> 23:03:42,080
和 确保我在这里拥有所有信息，

1301
23:03:42,080 --> 23:03:45,360
所以我们现在需要的只是确保用户可以点击 um

1302
23:03:45,360 --> 23:03:49,832
on those uh on the on tap 好吧，很抱歉，用户可以点击这些

1303
23:03:49,832 --> 23:03:53,920
列表图块，然后我们' 然后像节点回调一样调用一个函数，

1304
23:03:53,920 --> 23:03:58,320
并告诉我们的所有者小部件，嘿，用户点击

1305
23:03:58,320 --> 23:04:02,320
其中一个只是做任何你想做的事情，所以让我们继续在这里添加一个字段并

1306
23:04:02,320 --> 23:04:07,512
在点击时说抱歉回调，我们' 我只是调用它

1307
23:04:07,512 --> 23:04:13,120
ontap 构造函数现在不高兴说是的，你有一个 final 字段

1308
23:04:13,120 --> 23:04:16,480
您还没有初始化，所以让我们在取消删除后立即添加它，

1309
23:04:16,480 --> 23:04:20,552
我将在末尾添加这个必需的参数和逗号，以

1310
23:04:20,552 --> 23:04:23,680
确保您获得正确的格式以及

1311
23:04:23,680 --> 23:04:27,120
我们没有在点击时使用 现在，如果您注意到我们在这里也破坏了

1312
23:04:27,120 --> 23:04:31,192
笔记，那没关系，我们会到达那里，我们会尽快修复我们

1313
23:04:31,192 --> 23:04:35,360
破坏 note2 的原因是因为我们没有通过 tap，因为它是必需的

1314
23:04:35,360 --> 23:04:40,480
参数 好的，我们将幸运地解决这个问题，以便处理列表图块上的选项卡，

1315
23:04:40,480 --> 23:04:44,720
我们不必使用手势识别或类似的东西

1316
23:04:44,720 --> 23:04:48,552
，但我们可以做的就是说未点击你看到它已经在那里，所以

1317
23:04:48,552 --> 23:04:51,920
有一个 没有参数的函数

1318
23:04:51,920 --> 23:04:56,320
，我们需要在这里做的只是在这里调用我们自己的 ontap，你可以

1319
23:04:56,320 --> 23:04:59,832
看到我们必须传递一个数据库节点，幸运的是我们已经有了我相信这里有一个注释

1320
23:04:59,832 --> 23:05:04,640
好的，所以我们只是要 说 untap 并

1321
23:05:04,640 --> 23:05:11,760
注意

1322
23:05:11,760 --> 23:05:15,680
没关系，所以我们现在正在这样做，现在我们需要做的是回到

1323
23:05:15,680 --> 23:05:21,192
我们的 笔记查看并处理你看到的情况，

1324
23:05:21,192 --> 23:05:26,320
所以我要回到我们的笔记2并滚动到我们

1325
23:05:26,320 --> 23:05:31,600
遇到错误的部分，我们有删除嗯，

1326
23:05:31,600 --> 23:05:37,120
但我们没有点击所以我 '我现在也要去我的笔记，

1327
23:05:37,120 --> 23:05:41,760
在删除笔记之后，

1328
23:05:41,760 --> 23:05:45,600
让我们在这里添加这个未开发的功能

1329
23:05:45,600 --> 23:05:51,040
，你可以看到帮助我的视觉效果，并说哦，这个功能实际上接受

1330
23:05:51,040 --> 23:05:54,480
一个节点，所以如果我移动我的 将鼠标悬停在它上面它已经告诉我它是一个数据库节点

1331
23:05:54,480 --> 23:05:58,480
，记住这正是节点列表视图给我们的一切

1332
23:05:58,480 --> 23:06:03,120
，然后在这里让这个函数成为一个异步函数，原因

1333
23:06:03,120 --> 23:06:06,400
是因为我们要真正抓住我们的

1334
23:06:06,400 --> 23:06:10,720
um 让我实际看看我们是否必须

1335
23:06:10,720 --> 23:06:14,080
让它异步我认为它不需要首先异步让我们不要让它

1336
23:06:14,080 --> 23:06:17,600
异步我在我的笔记中将它作为异步我认为我们必须这样

1337
23:06:17,600 --> 23:06:23,040
做但也许有一个 背后的原因

1338
23:06:23,040 --> 23:06:26,872
我还不知道，但是呃，让我们继续，不要添加 asynchr

1339
23:06:26,872 --> 23:06:31,832
目前很麻烦所以在这种情况下我们需要做的

1340
23:06:31,832 --> 23:06:36,080
也是做一些与我们在这里所做的非常相似的

1341
23:06:36,080 --> 23:06:40,320
事情 复制该代码实际上可能是有意义的，让我们

1342
23:06:40,320 --> 23:06:45,440
进入选项卡并粘贴我将在

1343
23:06:45,440 --> 23:06:48,552
此处放置一个逗号以便它为我分解它

1344
23:06:48,552 --> 23:06:52,960
，在这里我们要做的只是说出论点 我们要在

1345
23:06:52,960 --> 23:06:59,192
那里传递注释，

1346
23:06:59,192 --> 23:07:03,192
所以我们只是说这是一个注释，然后

1347
23:07:03,192 --> 23:07:06,960
转到该屏幕并将该参数传递给它，然后当我们

1348
23:07:06,960 --> 23:07:11,600
转到 um 创建更新注释视图时，

1349
23:07:11,600 --> 23:07:16,400
此函数被称为 create 或 get 现有节点

1350
23:07:16,400 --> 23:07:20,400
反过来尝试

1351
23:07:20,400 --> 23:07:24,000
使用我们的 get 参数泛型函数从我们的上下文中获取类型数据库节点的参数

1352
23:07:24,000 --> 23:07:27,280
，然后转到该上下文的模态路径，然后

1353
23:07:27,280 --> 23:07:33,192
获取该参数，因此它就像三层提取，但这

1354
23:07:33,192 --> 23:07:37,120
很好 现在至少你有一个通用的函数可以抓取 你的论点

1355
23:07:37,120 --> 23:07:41,832
没问题，所以我要按命令，做一个热重载可能会很好

1356
23:07:41,832 --> 23:07:45,360
抱歉热重启只是因为我们已经做了很多

1357
23:07:45,360 --> 23:07:47,920
改变，所以我要像这样删除这两个节点，然后我

1358
23:07:47,920 --> 23:07:50,640
我要按加号按钮让我们在这里

1359
23:07:50,640 --> 23:07:54,080
第一个和第二个

1360
23:07:54,080 --> 23:07:56,400
，然后我现在要测试一下，看看我们实际上可以去编辑一个

1361
23:07:56,400 --> 23:07:59,920
现有的便笺，所以我要去我的第一个便笺并点击它，

1362
23:07:59,920 --> 23:08:03,440
现在我可以看到我实际上 去了我们的笔记，它说它仍然写着新

1363
23:08:03,440 --> 23:08:07,440
笔记，也许没关系，我们可以

1364
23:08:07,440 --> 23:08:12,720
保持这样，我们可以稍后更新文本，这很好，

1365
23:08:12,720 --> 23:08:18,080
但至少我可以看到文本，所以我现在实际上要改变 这是我的新

1366
23:08:18,080 --> 23:08:21,832
笔记，对不起，我的笔记 1 到我的笔记 3，然后回去，我现在可以看到我有笔记 2

1367
23:08:21,832 --> 23:08:25,192
和 3。所以这是一个非常好的迹象，因为这意味着上升 约会

1368
23:08:25,192 --> 23:08:28,800
现有笔记实际上是有效的，我们不会创建新笔记，因为

1369
23:08:28,800 --> 23:08:31,512
否则该笔记将出现在此列表中，所以我将转到此

1370
23:08:31,512 --> 23:08:34,552
新笔记 3，然后将其更改为一个，所以现在你看到了 它得到了

1371
23:08:34,552 --> 23:08:38,640
更新，很好，完美，我们得到了更新工作，

1372
23:08:38,640 --> 23:08:42,552
如果你问我做得很好，对你说实话是一件轻而易举的事，

1373
23:08:42,552 --> 23:08:46,232
嗯，我们现在需要的是确保我们

1374
23:08:46,232 --> 23:08:49,512
不会丢失我们的代码，所以让我们像往常一样去吧 在每一章的最后做

1375
23:08:49,512 --> 23:08:53,512
，我们要提交并标记我们的代码 好的，我要改变屏幕

1376
23:08:53,512 --> 23:08:57,192
布局，然后我要增加屏幕的大小，这样你就可以

1377
23:08:57,192 --> 23:09:01,360
看到我在做什么了 更好一点，让我们去我们的终端，如果你

1378
23:09:01,360 --> 23:09:04,872
看看 oops，如果你看看

1379
23:09:04,872 --> 23:09:10,000
um，我认为它是命令 k 是的，让我们看看我们的 git log，你会

1380
23:09:10,000 --> 23:09:14,160
看到我们所做的最后一个 uh 提交是第 16 步，还有你的标签 最后一个标签

1381
23:09:14,160 --> 23:09:18,720
也是第 16 步，好吧，让我们现在

1382
23:09:18,720 --> 23:09:24,872
像之前一样提交，让我们看看

1383
23:09:24,872 --> 23:09:28,552
状态，有点改变了修改 m  odified

1384
23:09:28,552 --> 23:09:31,600
deleted 它认为这个文件已被删除，

1385
23:09:31,600 --> 23:09:35,600
虽然它真的不是，它只是被重命名了，

1386
23:09:35,600 --> 23:09:39,832
所以不幸的是它把它标记为

1387
23:09:39,832 --> 23:09:43,512
已删除，虽然没关系，但有点不幸的是，有一些方法可以

1388
23:09:43,512 --> 23:09:48,960
做到这一点，以便 git 真正理解 您重命名文件，但

1389
23:09:48,960 --> 23:09:52,480
我可以看到 Visual Studio 代码实际上无法将其标记为重命名，并且

1390
23:09:52,480 --> 23:09:56,400
它也只是将其标记为基本上被标记为已删除，

1391
23:09:56,400 --> 23:09:59,512
但没关系我们可以忍受，所以让我们说 git add all

1392
23:09:59,512 --> 23:10:04,872
然后我们就说 git commit step 17

1393
23:10:04,872 --> 23:10:09,192
好吧 然后我们就说 git push 所以我们推送我们

1394
23:10:09,192 --> 23:10:13,440
所有的更改，让我们做一个 git status 以确保我们没有留下任何

1395
23:10:13,440 --> 23:10:16,552
文件，我们在这里没有留下任何文件 '然后会说获取

1396
23:10:16,552 --> 23:10:21,040
标签第 17 步，然后推送我们的标签，

1397
23:10:21,040 --> 23:10:26,720
这样这部分就完成了，我们已经

1398
23:10:26,720 --> 23:10:29,920
完成了对

1399
23:10:29,920 --> 23:10:33,832
现有笔记的更新，这太棒了，就像本课程每一章的传统一样，

1400
23:10:33,832 --> 23:10:38,400
我们总是谈论什么 当我们需要在下一章继续工作时

1401
23:10:38,400 --> 23:10:43,680
所以

1402
23:10:43,680 --> 23:10:49,760
目前我们的源代码中存在一些问题，这

1403
23:10:49,760 --> 23:10:54,720
在我们的节点服务中，所以我将在这里摆脱这个底部栏并

1404
23:10:54,720 --> 23:10:58,800
转到节点服务，你可以在我们的节点服务中看到

1405
23:10:58,800 --> 23:11:04,872
我们 '在这里公开一个名为获取所有节点的功能实际上我不

1406
23:11:04,872 --> 23:11:10,160
认为我们正在使用它获取所有笔记我们只是使用

1407
23:11:10,160 --> 23:11:13,832
所有笔记流，嗯

1408
23:11:13,832 --> 23:11:16,480
让我们看看这里所有笔记流在哪里，那只是阅读

1409
23:11:16,480 --> 23:11:19,760
笔记 流控制器流

1410
23:11:19,760 --> 23:11:23,680
和来自这里的，你可以

1411
23:11:23,680 --> 23:11:28,640
从我们的笔记中看到，并且

1412
23:11:28,640 --> 23:11:31,832
里面填充了笔记让我们看看删除我们这里的所有节点，

1413
23:11:31,832 --> 23:11:36,720
所以你看到我们现在正在阅读所有笔记，我们只是暴露 他们

1414
23:11:36,720 --> 23:11:40,720
到外面的世界，但等一下，我们的应用程序有用户的概念，

1415
23:11:40,720 --> 23:11:44,480
所以如果我们现在退出

1416
23:11:44,480 --> 23:11:48,400
应用程序并用另一个用户重新登录，

1417
23:11:48,400 --> 23:11:52,160
那么新用户将看到我的笔记，因为里面没有地方 这个

1418
23:11:52,160 --> 23:11:56,800
节点服务，我们有一个像我们这样的用户的概念 实际上并没有过滤

1419
23:11:56,800 --> 23:11:59,832
掉这些东西，只向用户公开相关数据，好吧，所以

1420
23:11:59,832 --> 23:12:03,192
我们需要修复它非常严重，呃，这不是一个错误，它实际上是

1421
23:12:03,192 --> 23:12:07,120
我故意留下的东西，直到这一点，因为是的，我们不必这样做

1422
23:12:07,120 --> 23:12:12,872
处理应用程序的用户界面更有趣，但我们

1423
23:12:12,872 --> 23:12:16,000
必须非常注意这些我们尚未实现的小东西，

1424
23:12:16,000 --> 23:12:19,280
而这正是我们将在下一章中要做的和修复的，

1425
23:12:19,280 --> 23:12:24,480
所以我'

1426
23:12:24,480 --> 23:12:29,280
大家好，欢迎来到上一章 swati 课程的第 35

1427
23:12:29,280 --> 23:12:31,920
章，正如你所看到的，我们开始讨论如何更新

1428
23:12:31,920 --> 23:12:35,040
节点列表中的现有节点，并且我们重构了新的节点视图，因为它

1429
23:12:35,040 --> 23:12:39,360
之前被称为 成为我相信创建更新节点视图，这个节点视图

1430
23:12:39,360 --> 23:12:42,960
现在能够做两件事，要么创建一个新节点，

1431
23:12:42,960 --> 23:12:47,600
要么更新一个现有节点，所以我们没有创建一个全新的视图，只是为了

1432
23:12:47,600 --> 23:12:51,040
能够更新现有节点，这样就可以了 真的很好

1433
23:12:51,040 --> 23:12:54,640
，但是作为我男人

1434
23:12:54,640 --> 23:12:58,000
在上一章末尾提到我们的

1435
23:12:58,000 --> 23:13:01,280
节点服务有一点问题，因为现在节点服务并没有真正

1436
23:13:01,280 --> 23:13:04,720
考虑哪些用户登录了应用程序，因此它无法

1437
23:13:04,720 --> 23:13:09,280
返回该特定用户的相关节点 所以节点

1438
23:13:09,280 --> 23:13:17,920
服务目前正在做的只是从数据库中获取所有节点并将其

1439
23:13:17,920 --> 23:13:23,360
返回给当前用户，这将导致一个问题，当我们

1440
23:13:23,360 --> 23:13:28,960
使用一个用户登录时，我们将看到所有 系统中的节点，当我们

1441
23:13:28,960 --> 23:13:33,360
以用户注销并以全新用户登录时，我们将再次

1442
23:13:33,360 --> 23:13:37,600
看到存储在笔记服务器中的所有笔记，因此我们必须在本章开始之前修复它

1443
23:13:37,600 --> 23:13:43,440
我们的更新有点问题

1444
23:13:43,440 --> 23:13:48,480
，这是一个在应用程序内部存在一段时间的错误，因为我们

1445
23:13:48,480 --> 23:13:52,800
基本上创建了我们的云服务，我们必须修复它，所以让我们

1446
23:13:52,800 --> 23:13:56,720
看看这个错误实际上是什么 在我能

1447
23:13:56,720 --> 23:13:59,920
之前 o on 所以我要把 scrcpy 放在这里

1448
23:13:59,920 --> 23:14:03,760
，我也要把 Visual Studio 代码放在这里

1449
23:14:03,760 --> 23:14:06,552
，所以我希望你能看到屏幕，所以现在我们有，嗯，

1450
23:14:06,552 --> 23:14:10,400
也许我不必 希望我可以把屏幕

1451
23:14:10,400 --> 23:14:12,872
稍微大一点，所以如果你现在看 scr cpy，我们有两个我的笔记，

1452
23:14:12,872 --> 23:14:16,872
第二个，这正是盒子，所以让我们进去第一个，我'

1453
23:14:16,872 --> 23:14:20,720
我只想说我的第一条笔记，哎呀

1454
23:14:20,720 --> 23:14:26,640
，然后出去，现在一切看起来都很好，这只是因为我们也在

1455
23:14:26,640 --> 23:14:31,680
更新我们的本地缓存，所以事情看起来不错，但是如果

1456
23:14:31,680 --> 23:14:35,192
你热重启应用程序并且我的 scr cpy 刚刚死了 所以没关系，

1457
23:14:35,192 --> 23:14:40,320
我可以忍受它是一个免费软件，就像你的 cpy 一样，我

1458
23:14:40,320 --> 23:14:44,000
现在可以看到我实际上也丢失了 scrcpy 的调试命令，

1459
23:14:44,000 --> 23:14:47,040
所以我要重新启动应用程序，但现在会发生什么 正如

1460
23:14:47,040 --> 23:14:50,960
您很快就会看到的，我们的更新注释功能有一点问题，

1461
23:14:50,960 --> 23:14:56,552
所以您现在可以看到我现在我重新 突然启动了应用程序

1462
23:14:56,552 --> 23:15:02,320
，两个笔记都更改为我的第一条笔记，这

1463
23:15:02,320 --> 23:15:06,320
并不是不正确，因为应用程序内部存在错误，

1464
23:15:06,320 --> 23:15:09,360
因此它的表现形式是，当您在本地更新笔记时

1465
23:15:09,360 --> 23:15:13,680
，它看起来很好，但是如果您 做一个热重启，对不起，它会

1466
23:15:13,680 --> 23:15:17,600
像现在一样跳闸，错误就在这里我不知道

1467
23:15:17,600 --> 23:15:21,512
你是否能注意到，对不起，

1468
23:15:21,512 --> 23:15:24,960
我不知道你是否能注意到，但我们有这个电话

1469
23:15:24,960 --> 23:15:29,600
到更新功能，但是我们实际上并没有告诉，

1470
23:15:29,600 --> 23:15:33,360
这也是在更新节点功能内的节点服务飞镖内部的方式

1471
23:15:33,360 --> 23:15:36,400
在这里您可以看到我们正在向 sqlite 发出查询，我们说的是

1472
23:15:36,400 --> 23:15:40,480
更新节点表 并将文本设置为该文本，这正是

1473
23:15:40,480 --> 23:15:43,920
sqlite 正在做的事情，它遍历 note 表中的所有行并

1474
23:15:43,920 --> 23:15:47,192
使用给定文本更新它们的文本列，

1475
23:15:47,192 --> 23:15:51,120
所以我们错过了一个 where 参数，所以我们不是 告诉 sqlite

1476
23:15:51,120 --> 23:15:55,040
钻机 ht 现在要更新哪一行，所以它正在更新

1477
23:15:55,040 --> 23:15:58,160
所有行，所以我们需要紧急解决这个问题，

1478
23:15:58,160 --> 23:16:03,440
所以让我们进入这里，说我们现在

1479
23:16:03,440 --> 23:16:08,160
看到这是我们的更新

1480
23:16:08,160 --> 23:16:11,512
，在创建这本

1481
23:16:11,512 --> 23:16:15,920
字典之后，我们 重新说一个是，我们要说

1482
23:16:15,920 --> 23:16:20,552
我们要更新的那一列的 id 字段，或者对不起，我们要更新的行的 id 字段，或者

1483
23:16:20,552 --> 23:16:27,120
注意我们要更新的内容将等于某事，并且 args

1484
23:16:27,120 --> 23:16:31,760
在哪里 将等于我们的节点 id，所以我需要你也

1485
23:16:31,760 --> 23:16:37,192
按照我在这里写的方式编写这段代码，所以现在如果你说我的第一个注释，我进入

1486
23:16:37,192 --> 23:16:42,640
这里，我说第二个次要，那么它会做 正确的

1487
23:16:42,640 --> 23:16:47,120
做法是，如果您进行热重启，那么您可以看到注释实际上已

1488
23:16:47,120 --> 23:16:51,440
正确填充，好吧，我不会进行热重启，

1489
23:16:51,440 --> 23:16:56,160
因为我知道 scr cpy 可能会再次崩溃，我必须重新启动整个过程

1490
23:16:56,160 --> 23:16:59,832
所以 我不想浪费你的时间，

1491
23:16:59,832 --> 23:17:04,720
这就是为什么我不会做一个热

1492
23:17:04,720 --> 23:17:09,440
重启，但这应该可以正常工作抱歉 再次

1493
23:17:09,440 --> 23:17:13,760
好吧，嗯，现在回到我们正在做的

1494
23:17:13,760 --> 23:17:17,360
事情，或者回到本章的主要目标，所以

1495
23:17:17,360 --> 23:17:20,160
让我们看看如果你去这里无法解决我们的用户服务器与我们的

1496
23:17:20,160 --> 23:17:25,760
节点服务的问题 返回相关节点，

1497
23:17:25,760 --> 23:17:30,640
除了它返回所有节点，所以我相信它就在节点服务内部

1498
23:17:30,640 --> 23:17:34,480
哦，我们已经在那里对此感到抱歉，所以我们有我们的节点服务

1499
23:17:34,480 --> 23:17:39,680
，当我们说这里时你可以看到，

1500
23:17:39,680 --> 23:17:44,232
注意这发生在呃内部 缓存所有缓存注释，您可以

1501
23:17:44,232 --> 23:17:46,960
看到它正在从数据库中读取所有注释，使用获取所有注释将其

1502
23:17:46,960 --> 23:17:51,600
放入其中，抱歉您看不到缓存注释正在读取所有

1503
23:17:51,600 --> 23:17:55,760
注释，然后将它们放入本地局部变量中 还可以

1504
23:17:55,760 --> 23:18:00,000
填充流控制器，但是我们需要做的是

1505
23:18:00,000 --> 23:18:03,832
我们需要确保当前用户保存在此便笺

1506
23:18:03,832 --> 23:18:07,512
服务中的某个位置，以便便笺服务知道可以，这是当前用户

1507
23:18:07,512 --> 23:18:12,320
使用此处的所有节点功能将我的所有笔记转到呼叫站点

1508
23:18:12,320 --> 23:18:17,440
我需要实际过滤掉

1509
23:18:17,440 --> 23:18:21,280
该列表中的笔记，以确保只有当前用户创建的相关笔记才能

1510
23:18:21,280 --> 23:18:26,160
从该流中返回，

1511
23:18:26,160 --> 23:18:31,440
所以我们需要什么 是

1512
23:18:31,440 --> 23:18:35,680
在这个 uh 节点服务中的我们的服务中保留某种当前用户，所以让我们继续这样做，

1513
23:18:35,680 --> 23:18:39,760
让我们在这里实际定义我们的 um 数据库用户

1514
23:18:39,760 --> 23:18:42,960
，我们说这是可选的，它是平等的 但是对于用户，

1515
23:18:42,960 --> 23:18:46,400
我们总是希望确保在您实际获取笔记列表之前设置该用户

1516
23:18:46,400 --> 23:18:50,480
，所以这是

1517
23:18:50,480 --> 23:18:52,720
该笔记服务器的期望，因此笔记服务器说，如果您希望

1518
23:18:52,720 --> 23:18:55,360
能够阅读所有笔记 你这样做的方式和你做的一样干净

1519
23:18:55,360 --> 23:19:02,400
你还要确保你已经把这个当前用户设置好了，

1520
23:19:02,400 --> 23:19:06,960
所以如果这个期望没有得到满足，我们将抛出一个异常

1521
23:19:06,960 --> 23:19:10,872
，我们将 调用该异常用户应该在读取所有节点之前设置

1522
23:19:10,872 --> 23:19:15,280
正如标题所示，我们将转到我们之前的人群异常

1523
23:19:15,280 --> 23:19:20,000
，所以让我们发现给定文件夹中的人群异常

1524
23:19:20,000 --> 23:19:24,232
是抱歉，在我在屏幕底部提到的给定路径中是的 lib s

1525
23:19:24,232 --> 23:19:28,800
rvices cross 人群异常

1526
23:19:28,800 --> 23:19:32,800
，我们将定义一个名为 user 的新异常，应该

1527
23:19:32,800 --> 23:19:39,120
在阅读所有此类注释之前设置

1528
23:19:39,120 --> 23:19:42,640
好，所以请继续并将其定义为您的应用程序中的异常之一

1529
23:19:42,640 --> 23:19:46,960
以及人群异常下的异常，

1530
23:19:46,960 --> 23:19:51,512
所以

1531
23:19:51,512 --> 23:19:57,280
我们 现在需要是我们能够

1532
23:19:57,280 --> 23:20:03,512
根据当前用户过滤所有给定节点的一种方式，

1533
23:20:03,512 --> 23:20:07,120
所以让我们看看我们现在的所有节点

1534
23:20:07,120 --> 23:20:12,320
在这里你看到我们需要的是确保所有

1535
23:20:12,320 --> 23:20:16,640
节点都可以实际过滤呃 此流中的给定节点

1536
23:20:16,640 --> 23:20:21,360
并使用某种过滤器功能

1537
23:20:21,360 --> 23:20:27,600
所以我们所拥有的你可以在这里看到一个流

1538
23:20:27,600 --> 23:20:31,120
让我们说流一个流有一个名为 where 的函数

1539
23:20:31,120 --> 23:20:35,512
所以它的作用是你可以看到它

1540
23:20:35,512 --> 23:20:40,872
有嗯它允许你 抓住当前的续集 ent 的那个

1541
23:20:40,872 --> 23:20:46,160
流，然后你可以通过一个测试，这样你就可以说这个对象是否

1542
23:20:46,160 --> 23:20:49,512
等于这个然后做那个并返回这个值，否则返回其他的

1543
23:20:49,512 --> 23:20:54,960
东西，所以它有点像一个流值上的字符串的过滤机制

1544
23:20:54,960 --> 23:20:58,080
但是我们的流包含一个列表记住让我们回到

1545
23:20:58,080 --> 23:21:01,600
这里原谅我在这里你可以看到

1546
23:21:01,600 --> 23:21:05,512
我们返回一个数据库节点列表的流

1547
23:21:05,512 --> 23:21:10,552
所以我们想要的是一个两层深的 where 子句

1548
23:21:10,552 --> 23:21:15,280
我们希望能够过滤掉并且

1549
23:21:15,280 --> 23:21:19,760
根据当前用户更改此流的内容，然后我们需要

1550
23:21:19,760 --> 23:21:24,480
根据当前用户的 id 过滤列表，并仅返回与该用户相关的数据库注释，

1551
23:21:24,480 --> 23:21:29,120
因此这是一种特殊情况，

1552
23:21:29,120 --> 23:21:32,720
因此我们 需要在我们的流上创建我们自己的函数

1553
23:21:32,720 --> 23:21:35,832
，这是一个类似于过滤器函数的手动函数，

1554
23:21:35,832 --> 23:21:39,192
所以让我们继续这样做，所以我们需要在这里做

1555
23:21:39,192 --> 23:21:42,552
的是创建一个新文件，如您在 lib 扩展列表过滤器下看到的那样

1556
23:21:42,552 --> 23:21:46,960
所以我要继续这样做 看看我们是否已经有一些扩展，

1557
23:21:46,960 --> 23:21:50,800
所以我现在可以在 lib 下看到我们有常量枚举服务实用程序视图，

1558
23:21:50,800 --> 23:21:53,680
但我们没有任何扩展，所以最好的方法是创建

1559
23:21:53,680 --> 23:21:58,080
过滤器 dart 文件是正确的 单击实时并说新文件

1560
23:21:58,080 --> 23:22:01,600
，然后我要说扩展列表

1561
23:22:01,600 --> 23:22:05,360
过滤器。 好的

1562
23:22:05,360 --> 23:22:10,872
，那么我们在这里要做的是在我们的流上创建一个扩展，

1563
23:22:10,872 --> 23:22:18,000
所以让我们继续说扩展

1564
23:22:18,000 --> 23:22:21,440
过滤器在 t 的流上，

1565
23:22:21,440 --> 23:22:24,720
所以我这样做的原因是

1566
23:22:24,720 --> 23:22:30,400
这样我们可以 在我们的扩展中抓住那个流的内容

1567
23:22:30,400 --> 23:22:32,720
好吧，就像如果你做了这样

1568
23:22:32,720 --> 23:22:38,960
的事情仍然可以工作，但在这里我们要说的是我们正在扩展

1569
23:22:38,960 --> 23:22:44,080
任何具有 t 值并在我们的过滤器中的流 函数，然后我们可以

1570
23:22:44,080 --> 23:22:48,160
访问那个 t，你很快就会看到好的，所以我们会说

1571
23:22:48,160 --> 23:22:51,832
那个对象列表的流

1572
23:22:51,832 --> 23:22:58,640
，我们将调用我们的函数过滤器

1573
23:22:58,640 --> 23:23:02,800
，在我们的过滤器函数中，我们想要获取另一个函数 这

1574
23:23:02,800 --> 23:23:07,440
对项目进行了测试，所以让我们说 bool

1575
23:23:07,440 --> 23:23:11,280
um 函数，它抓取该类型的项目，

1576
23:23:11,280 --> 23:23:16,400
所以你现在可以看到我们基本上已经分解了过滤的要求，

1577
23:23:16,400 --> 23:23:21,360
应该是两层

1578
23:23:21,360 --> 23:23:25,360
深现在是一层 跳跃是因为我们的过滤器函数

1579
23:23:25,360 --> 23:23:29,512
将我们的数据库节点 t 传递给了这个 where 函数 好的，

1580
23:23:29,512 --> 23:23:32,960
所以目前不存在，但我们正在创建它，好的，

1581
23:23:32,960 --> 23:23:39,920
所以在这里我们要说的是

1582
23:23:39,920 --> 23:23:46,000
我们要做的是我们需要映射我们的 um

1583
23:23:46,000 --> 23:23:50,640
流，你可以看到它 给

1584
23:23:50,640 --> 23:23:56,232
我们值所以在这里我们得到项目然后在这里我们说

1585
23:23:56,232 --> 23:24:00,960
我们在这里传递那个词子句的项目我们说像这样列出

1586
23:24:00,960 --> 23:24:06,400
所以我可以在这里看到实际上我们有一个

1587
23:24:06,400 --> 23:24:10,640
过滤器 t 但我们的流 需要有一个 t 的列表，这样就可以

1588
23:24:10,640 --> 23:24:15,080
解决我们的问题，所以在这种情况下，我们实际上是

1589
23:24:15,080 --> 23:24:18,000
在列表的深处向下钻取两层，好吧，这是我们刚刚创建的函数，

1590
23:24:18,000 --> 23:24:23,040
因此它允许我们过滤流 一些东西的列表，然后

1591
23:24:23,040 --> 23:24:29,920
我们的 where 子句将得到那个东西，如果那个东西

1592
23:24:29,920 --> 23:24:34,160
通过测试，那么它将被包含在最终列表中，所以

1593
23:24:34,160 --> 23:24:37,680
看起来我知道这是复杂的东西，但请暂停视频，

1594
23:24:37,680 --> 23:24:43,832
稍微思考一下 我们有一个包含事物列表的

1595
23:24:43,832 --> 23:24:48,400
流，现在我们想要流相同的细列表 g 只要

1596
23:24:48,400 --> 23:24:53,920
这些东西通过了

1597
23:24:53,920 --> 23:24:59,440
使用此工作损失指定的特定测试，好吧，

1598
23:24:59,440 --> 23:25:03,760
这很难，我知道这可能是一些对于某些用户来说可能太难了

1599
23:25:03,760 --> 23:25:08,872
，你会觉得我不明白 任何这些我都不明白，但

1600
23:25:08,872 --> 23:25:11,680
你只需要练习你只需要抓住这段代码就可以

1601
23:25:11,680 --> 23:25:16,320
继续并在其他一些功能上实现它，比如清单，

1602
23:25:16,320 --> 23:25:20,872
如果我有一个清单，看看没关系 我如何过滤掉

1603
23:25:20,872 --> 23:25:27,192
里面的那个东西，它最终会点击好的

1604
23:25:27,192 --> 23:25:32,400
看到现在我们

1605
23:25:32,400 --> 23:25:35,280
在节点服务中有获取或创建用户功能，

1606
23:25:35,280 --> 23:25:40,800
所以让我们回到我们的节点服务并找到该函数获取或创建用户

1607
23:25:40,800 --> 23:25:45,512
，目前它只需要一封电子邮件，因为标题表明我们需要

1608
23:25:45,512 --> 23:25:48,720
在这个函数中添加一个参数 这也说设置为当前用户，所以当你得到

1609
23:25:48,720 --> 23:25:51,440
或 cr 吃掉我们目前正在做的用户我

1610
23:25:51,440 --> 23:25:56,080
相信我们的笔记视图所以让我们进入这里的

1611
23:25:56,080 --> 23:25:59,440
笔记笔记视图在这里你看到获取或创建用户所以

1612
23:25:59,440 --> 23:26:06,720
这就像裸露的骨头这是实际非常重要的部分 在我们的应用程序

1613
23:26:06,720 --> 23:26:13,600
中，用户要么按照他或她原来的方式或创建方式从数据库中检索出来，

1614
23:26:13,600 --> 23:26:17,600
此时让该用户成为当前用户才有意义，

1615
23:26:17,600 --> 23:26:22,320
所以让我们进入我们的节点服务

1616
23:26:22,320 --> 23:26:25,440
并更改该功能，所以我 '我也要调出我的笔记

1617
23:26:25,440 --> 23:26:29,040
，让我们在这里添加一个名为 set as current user 的参数，在那里放一个

1618
23:26:29,040 --> 23:26:34,000
逗号，让我们说这个

1619
23:26:34,000 --> 23:26:38,232
参数是一个布尔集作为当前用户，我们要设置

1620
23:26:38,232 --> 23:26:42,800
默认情况下它为真，所以我需要做同样的事情，

1621
23:26:42,800 --> 23:26:46,400
所以在这样做之后，当我们检索用户时，我们将查看这个

1622
23:26:46,400 --> 23:26:51,120
参数，我们会说如果设置

1623
23:26:51,120 --> 23:26:57,680
为当前用户，然后设置为当前用户 我们将把我们自己的用户设置为我们刚刚

1624
23:26:57,680 --> 23:27:01,040
从 数据库，也不要忘记创建

1625
23:27:01,040 --> 23:27:04,552
此用户时，

1626
23:27:04,552 --> 23:27:09,192
如果该布尔标志为真，您还必须设置当前用户，所以我们

1627
23:27:09,192 --> 23:27:12,640
在这里也设置为当前用户，然后我们会说用户是创建用户

1628
23:27:12,640 --> 23:27:17,512
所以 我们在这里所做的是我们只是说如果我们可以从数据库中检索该用户

1629
23:27:17,512 --> 23:27:22,000
并且这个布尔参数为真，那么我们将我们自己的用户设置为该

1630
23:27:22,000 --> 23:27:26,400
用户，否则如果我们必须创建该用户

1631
23:27:26,400 --> 23:27:30,800
并且该参数为真，那么我们执行 同样，我们将此当前用户

1632
23:27:30,800 --> 23:27:36,160
设置为创建的用户，如果您在这里遇到一些错误，说

1633
23:27:36,160 --> 23:27:40,400
找不到该下划线用户，这可能是因为您错过了将

1634
23:27:40,400 --> 23:27:44,552
这个数据库用户添加到您的节点服务中

1635
23:27:44,552 --> 23:27:47,832
，这是我之前提到的

1636
23:27:47,832 --> 23:27:53,360
在我们创建这个异常之前，我们继续创建过滤器函数好吧或抱歉，

1637
23:27:53,360 --> 23:27:57,920
这部分现在也完成了，嗯，

1638
23:27:57,920 --> 23:28:03,360
现在我们需要做的是进行实际的

1639
23:28:03,360 --> 23:28:06,800
过滤，这就是我们需要做的事情 你可以看到一个

1640
23:28:06,800 --> 23:28:11,512
缓存 e索引更改所有节点流以过滤当前用户

1641
23:28:11,512 --> 23:28:17,832
，这是我们需要在所有节点函数中执行的操作，

1642
23:28:17,832 --> 23:28:22,640
或者对不起getter，所以在这里

1643
23:28:22,640 --> 23:28:26,320
我们要说的是我实际上我想我会 改变它们，

1644
23:28:26,320 --> 23:28:31,040
是的，让我们保持这样，所以我只想说没有流

1645
23:28:31,040 --> 23:28:35,920
控制器和点

1646
23:28:35,920 --> 23:28:43,040
流，在这里我们可以使用我们的过滤器功能，你现在看到的 Visual

1647
23:28:43,040 --> 23:28:48,232
Studio 代码就像混淆一样哦，没有过滤器功能 流，

1648
23:28:48,232 --> 23:28:52,000
但请记住，我们实际上是自己添加的，所以我要从

1649
23:28:52,000 --> 23:28:57,192
Visual Studio 代码中获得帮助，并在 Mac 上说命令点或在 Linux 和

1650
23:28:57,192 --> 23:29:02,960
Windows 和 Visual Studio 代码上说控制点，然后它就会明白哦

1651
23:29:02,960 --> 23:29:06,400
，你有一个过滤器功能 '已经在流中定义了你想让我导入那个，

1652
23:29:06,400 --> 23:29:10,640
我会说是的，所以现在我们有了

1653
23:29:10,640 --> 23:29:15,360
过滤器记住过滤器然后得到一个正确的注释，如果我现在将鼠标移到它上面

1654
23:29:15,360 --> 23:29:19,920
你可以看到它说哦你有 一个数据库注释，但是我们的流

1655
23:29:19,920 --> 23:29:23,920
实际上包含一个 dat 列表 一个基本节点，突然我们的过滤器一次只

1656
23:29:23,920 --> 23:29:27,512
得到一个注释，所以这是创建自己的扩展的美妙之处，

1657
23:29:27,512 --> 23:29:33,760
这样您就可以深入现有对象并在应用程序中获取您需要的

1658
23:29:33,760 --> 23:29:39,280
内容，所以在这里我们需要什么 是创建一个

1659
23:29:39,280 --> 23:29:44,000
函数然后你记得这个函数必须返回一个布尔值我们还

1660
23:29:44,000 --> 23:29:47,920
没有从这里返回任何东西这就是为什么我们得到一个错误

1661
23:29:47,920 --> 23:29:52,000
所以在这个函数结束时我们需要返回一个卷所以让我们说

1662
23:29:52,000 --> 23:29:55,040
final 当前用户是这个用户，如果这个当前

1663
23:29:55,040 --> 23:29:58,232
用户不为空，这就像我们实际期望的条件，那么我们

1664
23:29:58,232 --> 23:30:01,040
将做一些代码，否则我们需要抛出我们的异常

1665
23:30:01,040 --> 23:30:03,920
用户应该在之前说好，所以这是

1666
23:30:03,920 --> 23:30:09,360
我们的期望 调用者如果您正在阅读此

1667
23:30:09,360 --> 23:30:13,360
界面中的所有注释，则需要确保在调用此函数时设置了当前用户，

1668
23:30:13,360 --> 23:30:16,960
因此这必须是正确的，抱歉，您可能没有

1669
23:30:16,960 --> 23:30:22,080
看到代码，但您也可以争辩 哦，等等

1670
23:30:22,080 --> 23:30:27,120
分钟如果这就像这个界面的期望，

1671
23:30:27,120 --> 23:30:30,960
在你阅读所有笔记之前应该总是说当前用户，

1672
23:30:30,960 --> 23:30:35,040
那么你为什么不把它

1673
23:30:35,040 --> 23:30:41,600
设为默认为什么不这样做并删除这个功能并始终设置用户

1674
23:30:41,600 --> 23:30:44,720
默认情况下，其背后的原因

1675
23:30:44,720 --> 23:30:47,760
是只有在您使用所有节点时才必须发送当前用户现在

1676
23:30:47,760 --> 23:30:51,600
这个节点服务应该能够像更新现有节点或删除

1677
23:30:51,600 --> 23:30:55,040
现有节点一样工作它在这些功能中应该

1678
23:30:55,040 --> 23:30:58,160
仍然有效 如果当前用户未正确设置，因为这些功能是

1679
23:30:58,160 --> 23:31:01,832
纯交叉函数，即更新具有此 ID 的节点获取具有此 ID 的用户

1680
23:31:01,832 --> 23:31:05,832
删除具有此 ID 的节点等它们不依赖于当前用户

1681
23:31:05,832 --> 23:31:09,760
但是所有节点都依赖 在当前用户上，

1682
23:31:09,760 --> 23:31:12,832
在这里设置这个功能

1683
23:31:12,832 --> 23:31:18,872
是有意义的

1684
23:31:18,872 --> 23:31:23,280
这是我将其作为

1685
23:31:23,280 --> 23:31:27,360
参数而不是使其成为此类的默认 um

1686
23:31:27,360 --> 23:31:31,512
行为的原因，所以如果当前用户不为

1687
23:31:31,512 --> 23:31:37,440
空，那就像快乐的路径，那么我们说我们返回此注释

1688
23:31:37,440 --> 23:31:42,872
它不只要它的 um 用户 id

1689
23:31:42,872 --> 23:31:46,400
与当前用户 id 相同，所以我们说

1690
23:31:46,400 --> 23:31:49,360
注意用户 id 应该等于当前用户

1691
23:31:49,360 --> 23:31:53,360
点 id

1692
23:31:53,360 --> 23:31:59,512
必须返回

1693
23:31:59,512 --> 23:32:04,000
一个布尔值，所以我们在这里不返回任何节点，我们只是检查

1694
23:32:04,000 --> 23:32:07,760
该节点的使用是否与该节点相同，然后执行此操作，

1695
23:32:07,760 --> 23:32:12,080
这样现在应该很好，所以我们

1696
23:32:12,080 --> 23:32:16,552
可以做什么我知道这可能 实际上，现在就破坏事情，因为我在

1697
23:32:16,552 --> 23:32:21,440
scr cpy 方面遇到了一些问题，但是您必须原谅我，这

1698
23:32:21,440 --> 23:32:27,120
不是我可以控制的，但是由于我们已经更改了很多代码，所以我现在要

1699
23:32:27,120 --> 23:32:30,552
关闭所有这些屏幕 在这些选项卡上，我将进行热重载，

1700
23:32:30,552 --> 23:32:34,872
但这很可能会发生 崩溃 scr cpy

1701
23:32:34,872 --> 23:32:37,832
哦，这不是很好，感谢上帝，所以我们现在有了笔记，我们如何将

1702
23:32:37,832 --> 23:32:41,600
其用于测试我们需要做的是注销并登录

1703
23:32:41,600 --> 23:32:45,920
，所以我要去控制台 firebase

1704
23:32:45,920 --> 23:32:49,120
让我们转到我们的应用程序，这是我的笔记颤动项目

1705
23:32:49,120 --> 23:32:53,920
我们现在有两个经过身份验证的用户这两封电子邮件所以

1706
23:32:53,920 --> 23:32:58,872
现在我用其中一个登录我真的不知道哪一个所以我

1707
23:32:58,872 --> 23:33:03,040
要登录 在这里，然后我将使用

1708
23:33:03,040 --> 23:33:07,832
pixeltab gmail.com foobarbas 登录

1709
23:33:07,832 --> 23:33:12,552
，我可以看到那些电子邮件在像素选项卡下，所以我

1710
23:33:12,552 --> 23:33:18,960
将再次注销，我将登录 其他用户

1711
23:33:18,960 --> 23:33:24,160
喜欢这个工具栏坏了，然后我要

1712
23:33:24,160 --> 23:33:27,192
按下登录按钮，我还没有验证我的电子邮件，所以我必须这样做

1713
23:33:27,192 --> 23:33:32,552
，所以让我看看我现在是否可以处理这个问题

1714
23:33:32,552 --> 23:33:36,320
然后我会带上我的电子邮件

1715
23:33:36,320 --> 23:33:39,832
去看看我能不能找到这封验证邮件，但我找不到，所以我

1716
23:33:39,832 --> 23:33:44,960
只是要发送发送电子邮件验证，它会发送一个新的电子邮件 邮件

1717
23:33:44,960 --> 23:33:50,720
验证给我，我收到了电子邮件验证

1718
23:33:50,720 --> 23:33:57,440
，它看起来像这样，所以我要点击它，我

1719
23:33:57,440 --> 23:34:01,680
现在可以看到它说你的电子邮件已经过验证，

1720
23:34:01,680 --> 23:34:05,280
所以让我重新开始，现在

1721
23:34:05,280 --> 23:34:09,760
我' 已经验证了我的电子邮件我将尝试使用用户登录，

1722
23:34:09,760 --> 23:34:14,080
因为哎呀这是注册我想

1723
23:34:14,080 --> 23:34:17,680
登录所以

1724
23:34:17,680 --> 23:34:22,640
这里 foo barbats

1725
23:34:22,640 --> 23:34:25,832
然后登录现在我可以看到我的用户我没有

1726
23:34:25,832 --> 23:34:31,832
看到任何注释 但只是为了确保我只是要创建一个新用户并

1727
23:34:31,832 --> 23:34:35,832
说不抱歉创建一个新节点我要说这个节点是

1728
23:34:35,832 --> 23:34:40,640
为 van dot 创建的或者只是把我的电子邮件放在这里

1729
23:34:40,640 --> 23:34:45,280
好吧我是 回去，我可以看到

1730
23:34:45,280 --> 23:34:49,192
这里显示了注释然后我要做的就是

1731
23:34:49,192 --> 23:34:54,000
注销这个用户并与另一个用户一起登录

1732
23:34:54,000 --> 23:34:58,000
只是为了确保那个是由另一个创建的哦 用户

1733
23:34:58,000 --> 23:35:01,440
没有显示给这个用户，好吧

1734
23:35:01,440 --> 23:35:06,000
，现在我们可以登录，我只能看到这个用户的笔记，所以

1735
23:35:06,000 --> 23:35:11,832
恭喜我们做了很多工作，t 就像我们所做的那样，嗯，

1736
23:35:11,832 --> 23:35:15,120
应用程序似乎按照我们设计的方式工作，

1737
23:35:15,120 --> 23:35:19,120
所以我们现在需要做的就是

1738
23:35:19,120 --> 23:35:24,552
确保我们不会像传统那样丢失我们的代码，所以我们需要承诺 我们的

1739
23:35:24,552 --> 23:35:29,920
代码，还可以标记我们的代码，所以我要

1740
23:35:29,920 --> 23:35:34,640
在屏幕上做一些 uh shuffle，我要增加 Visual Studio 代码的大小，

1741
23:35:34,640 --> 23:35:37,680
这样你可以更好地看到它让我们做 git status 看看我们的

1742
23:35:37,680 --> 23:35:42,552
状态是什么 '已经修改了两个文件，我们还添加了一个全新的文件夹，所以

1743
23:35:42,552 --> 23:35:47,600
我只想说 git add all 如果您查看我们的日志，上

1744
23:35:47,600 --> 23:35:53,440
一步是第 17 步，现在我们必须提交我们的工作并将其

1745
23:35:53,440 --> 23:35:58,872
标记为步骤 18，如果您也查看我们的标签，那么您应该在

1746
23:35:58,872 --> 23:36:02,400
这里执行第 17 步，让我们说 git commit，我将

1747
23:36:02,400 --> 23:36:08,160
说第 18 步。在这里，我将这些更改推送到

1748
23:36:08,160 --> 23:36:12,160
遥控器，在我的情况下是 github，您可能 在这里也使用 bitbucket 或其他一些

1749
23:36:12,160 --> 23:36:16,080
远程和小于标记作为步骤 18

1750
23:36:16,080 --> 23:36:20,000
并把你的标签放好，

1751
23:36:20,000 --> 23:36:26,480
这样部分就完成了，现在我们已经标记和合作 提交或代码，所以如果你

1752
23:36:26,480 --> 23:36:29,920
说 git status 你应该没有任何处理在这里可以提交

1753
23:36:29,920 --> 23:36:32,800
哇太棒了 所以再次作为传统，我们总是

1754
23:36:32,800 --> 23:36:35,192
谈论我们需要在下一章中提到

1755
23:36:35,192 --> 23:36:39,280
的内容 下一章在每一章的末尾，所以

1756
23:36:39,280 --> 23:36:42,960
到目前为止，我们一直在使用我们的 notes crot 服务，效果

1757
23:36:42,960 --> 23:36:47,192
非常好，一切都保存在设备上，

1758
23:36:47,192 --> 23:36:52,160
但是如果你真的考虑一下，

1759
23:36:52,160 --> 23:36:54,720
你现在已经学会了如何 与人群一起工作，这就是

1760
23:36:54,720 --> 23:37:00,640
我在本课程开始

1761
23:37:00,640 --> 23:37:05,512
时的意图之一

1762
23:37:05,512 --> 23:37:09,680
开发人员必须知道，所以我希望您已经了解到，

1763
23:37:09,680 --> 23:37:13,512
但是现在我们在这里遇到了一个大问题，那就是我们所有的笔记都保存在本地

1764
23:37:13,512 --> 23:37:19,920
的类似 sql 的数据库中，如果出现任何问题，例如

1765
23:37:19,920 --> 23:37:24,480
如果用户发生了什么事 这 用户的电话所有数据

1766
23:37:24,480 --> 23:37:28,320
都会消失，所以用户的笔记可能会消失，

1767
23:37:28,320 --> 23:37:32,320
如果你像我一样，你可能会想，这有什么问题？

1768
23:37:32,320 --> 23:37:38,232
很多所以我

1769
23:37:38,232 --> 23:37:42,872
有时会在我的笔记中存储非常非常重要的信息，你会惊讶

1770
23:37:42,872 --> 23:37:46,552
于这门课程的大纲我实际上管理了这一切我

1771
23:37:46,552 --> 23:37:51,440
在我的 Macintosh 上的笔记应用程序中管理了所有这些所以我写了整个大纲

1772
23:37:51,440 --> 23:37:55,832
花了很多很多 几个小时，

1773
23:37:55,832 --> 23:38:00,000
如果这些笔记由于某种原因消失了，或者如果我的孩子抓住了我的

1774
23:38:00,000 --> 23:38:04,232
电话并且只是移除了笔记并且没有任何理由，那么

1775
23:38:04,232 --> 23:38:08,232
我将无法再次抓住这些笔记，那么我会被摧毁，那又

1776
23:38:08,232 --> 23:38:11,440
怎样 我们现在需要做的只是确保我们可以将这些节点存储在

1777
23:38:11,440 --> 23:38:16,552
某种后端中，以便它位于

1778
23:38:16,552 --> 23:38:20,640
云中，这样我们就不必在本地管理它们，这就是我们将

1779
23:38:20,640 --> 23:38:25,120
使用 firebase 的目的 我们要开始了

1780
23:38:25,120 --> 23:38:29,600
从下一章开始就越来越多地谈论 Firebase 存储，所以我希望

1781
23:38:29,600 --> 23:38:34,160
你喜欢这一章，喝点茶点咖啡或茶或任何

1782
23:38:34,160 --> 23:38:40,400
你想要的巧克力，我会在下一章见到你

1783
23:38:40,400 --> 23:38:44,552
你好，欢迎来到第 36 章 在前面章节中的这个颤振课程中，

1784
23:38:44,552 --> 23:38:47,512
我们一直在使用我们的 quad 服务，并且我们一直在

1785
23:38:47,512 --> 23:38:50,400
使用 firebase 身份验证到目前为止，我们已经将用户生成的

1786
23:38:50,400 --> 23:38:54,000
注释存储在我们用 sqlite 支持的 crtch 存储中 数据库，

1787
23:38:54,000 --> 23:38:57,120
我们还让云服务

1788
23:38:57,120 --> 23:39:01,040
知道当前登录的用户，所以

1789
23:39:01,040 --> 23:39:04,480
当用户登录时，他或她只能看到他们自己的笔记，当该用户注销

1790
23:39:04,480 --> 23:39:07,680
时，另一个用户登录，然后是之前创建的

1791
23:39:07,680 --> 23:39:12,400
数据库中的笔记不会暴露给新用户，所以我们已经处理了所有这些，但

1792
23:39:12,400 --> 23:39:15,040
我们的笔记仍然只存储在本地存储中

1793
23:39:15,040 --> 23:39:19,280
，从本章开始，我们将真正

1794
23:39:19,280 --> 23:39:23,920
远离 存储我们 将数据存储在本地数据库中

1795
23:39:23,920 --> 23:39:28,800
，而不是将其存储在 firebase 中

1796
23:39:28,800 --> 23:39:33,120
事情是crud create read update and delete and um 虽然 firebase

1797
23:39:33,120 --> 23:39:36,720
是一个很好的方法，但是 firebase 删除了很多

1798
23:39:36,720 --> 23:39:40,320
你需要理解的逻辑才能成为更好的开发人员，所以

1799
23:39:40,320 --> 23:39:44,960
firebase 已经抽象出人群的概念 很多，你

1800
23:39:44,960 --> 23:39:50,000
在云中处理数据，你真的不知道这些数据是如何填充的以及在

1801
23:39:50,000 --> 23:39:54,872
哪里填充，所以当我开始设计课程时，我

1802
23:39:54,872 --> 23:39:59,120
想也许可以，我们可以先看看在本地存储数据

1803
23:39:59,120 --> 23:40:02,872
很好地掌握crud，然后我们现在

1804
23:40:02,872 --> 23:40:06,400
了解crop是如何工作的，以及这些操作是如何在数据库级别的低级别执行的，

1805
23:40:06,400 --> 23:40:10,872
然后我们可以离开它并转到am  ore abstract layer

1806
23:40:10,872 --> 23:40:13,832
所以这是我在设计这门课程的早期遇到的一个选择，这

1807
23:40:13,832 --> 23:40:17,280
绝对不是浪费时间你现在知道如何在你的应用程序中使用 sql light

1808
23:40:17,280 --> 23:40:21,832
，你可能会越来越多地使用 sqlite

1809
23:40:21,832 --> 23:40:24,872
在你的 Flutter 开发生涯中，

1810
23:40:24,872 --> 23:40:28,800
我希望你明白，

1811
23:40:28,800 --> 23:40:32,320
我们仍然很好地使用了 uh sqlite，我们已经理解了这一点，但是现在

1812
23:40:32,320 --> 23:40:36,720
是时候离开我们的本地存储并转向使用 um firebase 相反，

1813
23:40:36,720 --> 23:40:40,872
所以我想为本章的下一部分提供标题，

1814
23:40:40,872 --> 23:40:44,720
这就是我们要讨论 Cloud Firestore 所以如果我拿出我的

1815
23:40:44,720 --> 23:40:49,040
笔记并转到我为你提供的那个 URL

1816
23:40:49,040 --> 23:40:52,400
并且 把它带到这里，你可以在这里看到它说

1817
23:40:52,400 --> 23:40:57,192
firestore是一个灵活的可扩展的nosql云数据库，以

1818
23:40:57,192 --> 23:41:03,040
它的工作方式存储和同步数据我的意思是你

1819
23:41:03,040 --> 23:41:06,872
可以实际访问我提供的这个链接 你在这里，它告诉

1820
23:41:06,872 --> 23:41:10,160
你如何实际 y 将 cloud firestore 添加到您的应用程序，但我

1821
23:41:10,160 --> 23:41:14,720
相信我们已经这样做了，所以如果我将我们的 um

1822
23:41:14,720 --> 23:41:19,040
应用程序也带到屏幕上，请增加大小，然后我们进入我们的 pop

1823
23:41:19,040 --> 23:41:25,440
special，我们将查看我们所处的依赖项

1824
23:41:25,440 --> 23:41:29,192
在这里使用 firebase core firebase auth 和 um 的那一刻也告诉

1825
23:41:29,192 --> 23:41:33,040
你必须使用 cloud firestore 所以让我们进入这里，我们可以看到我们

1826
23:41:33,040 --> 23:41:36,400
已经从本课程中绝对最早的章节之一中拖入了 cloud firestore

1827
23:41:36,400 --> 23:41:41,040
已经

1828
23:41:41,040 --> 23:41:43,832
将此依赖项添加到我们的应用程序中，因此您不必这样做，但如果您

1829
23:41:43,832 --> 23:41:48,000
没有将 Cloud Firestore 添加到您的应用程序中，您现在可能需要

1830
23:41:48,000 --> 23:41:51,680
按照此链接中的说明进行操作，如果您有 没有

1831
23:41:51,680 --> 23:41:57,280
它可能是因为你错过了这个 um 课程的早期章节之一，

1832
23:41:57,280 --> 23:42:02,800
所以

1833
23:42:02,800 --> 23:42:07,360
我们将使用 cloud firestore 来存储用户

1834
23:42:07,360 --> 23:42:11,920
生成的数据，在这种情况下，我们的节点

1835
23:42:11,920 --> 23:42:14,872
现在你可能很熟悉 使用 sql 和 nosql

1836
23:42:14,872 --> 23:42:18,400
但我的意思是

1837
23:42:18,400 --> 23:42:22,960
我可以解释 clo  ud fire stories是你将有

1838
23:42:22,960 --> 23:42:27,280
两个你需要理解的概念，它们被称为um collections

1839
23:42:27,280 --> 23:42:30,800
，另一个是文档，所以在传统的sql存储中，你

1840
23:42:30,800 --> 23:42:35,280
将有硬依赖和每个uh表，例如当我们设计我们的

1841
23:42:35,280 --> 23:42:39,832
sqlite时 数据库我们实际上必须在表内设计具有特定

1842
23:42:39,832 --> 23:42:44,160
布局的表，所以我们有不同的字段，我们有

1843
23:42:44,160 --> 23:42:49,040
外键等，这就像一个典型的 sql 关系关系数据库，

1844
23:42:49,040 --> 23:42:53,680
但是当你去 node sql 例如 firestore 时，事情更多是

1845
23:42:53,680 --> 23:42:56,872
基于文档的所以 对于那些正在做后端开发的人来说，你已经知道

1846
23:42:56,872 --> 23:43:01,600
了，例如，

1847
23:43:01,600 --> 23:43:08,320
如果你使用的是 sequel light，那么事情不会像你想的那样基于文档，

1848
23:43:08,320 --> 23:43:11,600
但是当我们去 firestore 时，你

1849
23:43:11,600 --> 23:43:16,640
会拥有很多 基本上为您的表格和文档定义更宽松的数据，

1850
23:43:16,640 --> 23:43:21,040
因此同一集合中的一个文档可以包含

1851
23:43:21,040 --> 23:43:25,512
两个字段，下一个文档可以包含三个字段，

1852
23:43:25,512 --> 23:43:31,040
因此 使用firestar创建它的方式更加开放，

1853
23:43:31,040 --> 23:43:34,552
因此从这一点开始，在整个课程中，我们将

1854
23:43:34,552 --> 23:43:38,232
依赖firestore来使用它来存储用户生成的内容，

1855
23:43:38,232 --> 23:43:41,832
这些内容在我们的例子中是笔记，所以让我们 现在谈谈

1856
23:43:41,832 --> 23:43:45,040
生产模式与测试模式 um firebase 使用 firestore，因为您很快就会看到它

1857
23:43:45,040 --> 23:43:49,360
有不同的

1858
23:43:49,360 --> 23:43:52,552
方式允许您作为开发人员与您的数据库进行交互，

1859
23:43:52,552 --> 23:43:57,280
所以有一种叫做测试模式和另一个调用者的东西 生产模式

1860
23:43:57,280 --> 23:44:01,120
和测试模式，这意味着当您正在开发您的应用程序时

1861
23:44:01,120 --> 23:44:04,872
，例如我们目前正在开发的应用程序，您可能需要例如

1862
23:44:04,872 --> 23:44:08,400
打开您的数据库，以便您可以

1863
23:44:08,400 --> 23:44:12,080
与您的 from 进行实际交互 例如，您的应用程序甚至无需对用户进行身份验证，

1864
23:44:12,080 --> 23:44:17,440
因此即使用户未经过身份验证，您实际上也可以

1865
23:44:17,440 --> 23:44:21,192
向 firestore 发出一些命令以读取数据、删除数据

1866
23:44:21,192 --> 23:44:25,680
并更改数据，这就是您正在开发的

1867
23:44:25,680 --> 23:44:29,832
r 应用程序，而您仍在使用身份验证，但

1868
23:44:29,832 --> 23:44:34,000
请记住，我们已经确定了身份验证，因此如果您忘记了无法结束，您实际上无法

1869
23:44:34,000 --> 23:44:36,800
最终进入便笺视图或嵌入在便笺视图中的便笺列表视图

1870
23:44:36,800 --> 23:44:41,600
如果您尚未进行身份验证并且您尚未

1871
23:44:41,600 --> 23:44:44,720
验证您的电子邮件地址，那么我们知道，在我们的案例中，我们实际上

1872
23:44:44,720 --> 23:44:50,160
并不需要使用我们的数据库的测试模式和 Firestore，我们

1873
23:44:50,160 --> 23:44:55,832
会立即 切换到生产模式以及生产模式是什么，

1874
23:44:55,832 --> 23:45:01,512
例如，当您开发 Firestore 数据库时，您将在本章中很快看到

1875
23:45:01,512 --> 23:45:06,640
您将能够向数据库添加更多规则，

1876
23:45:06,640 --> 23:45:10,960
以便未经身份验证访问

1877
23:45:10,960 --> 23:45:14,720
数据库 将被拒绝，这是我们

1878
23:45:14,720 --> 23:45:20,000
将在本课程的其余部分中使用的类似模型，并且几乎在本课程结束时，

1879
23:45:20,000 --> 23:45:24,800
我们还将向

1880
23:45:24,800 --> 23:45:27,600
我们的 firebase 添加更多规则 抱歉，firestore 数据库 ase 以便我们

1881
23:45:27,600 --> 23:45:30,720
更明确地说明谁可以访问

1882
23:45:30,720 --> 23:45:35,120
只知道有测试模式和生产模式的内容 测试模式

1883
23:45:35,120 --> 23:45:38,080
在安全性方面有点松散，但生产模式

1884
23:45:38,080 --> 23:45:44,232
在这方面更严格一些 如果它只是试图

1885
23:45:44,232 --> 23:45:48,800
确保在经过身份验证的访问

1886
23:45:48,800 --> 23:45:52,552
uh 时，例如一个文档，因此用户无权访问将被

1887
23:45:52,552 --> 23:45:57,192
拒绝，

1888
23:45:57,192 --> 23:46:00,872
好吧，我们已经注意到我刚刚

1889
23:46:00,872 --> 23:46:06,080
提到了一些事情 关于规则，您可能想知道这些

1890
23:46:06,080 --> 23:46:11,192
规则实际上是什么以及它们的实际含义，

1891
23:46:11,192 --> 23:46:16,872
所以我在这里准备了链接，所以我要看看我是否真的可以在

1892
23:46:16,872 --> 23:46:19,920
我的电脑上打开它，这样我就可以把它带到 屏幕

1893
23:46:19,920 --> 23:46:26,160
在这里没关系，所以这些是我正在谈论的规则，

1894
23:46:26,160 --> 23:46:30,080
所以你看看你是否

1895
23:46:30,080 --> 23:46:34,080
像我一样是后端开发人员，你也会非常熟悉部署你的

1896
23:46:34,080 --> 23:46:38,960
应用程序，所以如果你是 django 开发人员或 node.js 与 express

1897
23:46:38,960 --> 23:46:43,040
或任何东西或烧瓶开发人员然后你是公关 习惯于

1898
23:46:43,040 --> 23:46:46,960
将您的应用程序部署到某种云

1899
23:46:46,960 --> 23:46:50,232
服务，然后您还将

1900
23:46:50,232 --> 23:46:55,280
负责指定用户如何与您的后端交互以及

1901
23:46:55,280 --> 23:46:59,680
在什么情况下应用什么规则，因为它不像

1902
23:46:59,680 --> 23:47:02,720
您拥有的传统后端 部署自己，因为它是

1903
23:47:02,720 --> 23:47:06,720
已经存在并且已部署的产品，它需要您的帮助才能

1904
23:47:06,720 --> 23:47:10,872
了解其安全规则，因此您可以看到这是后端的典型 Firebase

1905
23:47:10,872 --> 23:47:13,680
Firestore 配置，您可以在此处看到它说 该

1906
23:47:13,680 --> 23:47:18,320
服务是 firestore 服务，并在这些路径上匹配这些文档，

1907
23:47:18,320 --> 23:47:22,720
并且仅在用户经过身份验证时才允许读取和写入，

1908
23:47:22,720 --> 23:47:27,832
因此，如果您是 django 开发人员，您已经知道类似

1909
23:47:27,832 --> 23:47:32,872
请求，您也会知道您在 django 中所以 请求用户将

1910
23:47:32,872 --> 23:47:37,192
包含当前登录的经过身份验证的用户，因此这与该用户非常相似

1911
23:47:37,192 --> 23:47:39,192
，如果我

1912
23:47:39,192 --> 23:47:43,120
谈论后端开发只是因为我正在尝试，我很抱歉 如果您不是

1913
23:47:43,120 --> 23:47:46,400
后端开发人员，那么喜欢为那些后端开发人员并尝试了解 Firebase Firestore 的人建立这种联系，

1914
23:47:46,400 --> 23:47:50,800
只要

1915
23:47:50,800 --> 23:47:55,120
知道这些安全规则可以帮助

1916
23:47:55,120 --> 23:47:58,640
您，

1917
23:47:58,640 --> 23:48:02,480
他们就可以提供帮助 您保护了您的数据库，因为您看到

1918
23:48:02,480 --> 23:48:07,512
了我们实际生成应用程序的方式让我们转到源代码

1919
23:48:07,512 --> 23:48:10,872
并看一下它，当我们使用 firebase cli 和 firestore cli 设置我们的 uh firebase 时，

1920
23:48:10,872 --> 23:48:14,800
有一些文件 它们是自动为我们生成的

1921
23:48:14,800 --> 23:48:18,720
，它们在这个 firebase 选项中，所以

1922
23:48:18,720 --> 23:48:21,832
我要在这里为我们打开它，你可以在这里看到一些信息，

1923
23:48:21,832 --> 23:48:25,440
正如你可以看到的 android 应用程序有一个 api key app id 消息

1924
23:48:25,440 --> 23:48:29,120
发送者 id 项目 id 和存储桶，如果有人掌握了此信息，

1925
23:48:29,120 --> 23:48:32,720
因为您现在将通过观看本课程来掌握此信息，

1926
23:48:32,720 --> 23:48:37,120
您实际上将能够复制此 firebase 选项。 在您自己的

1927
23:48:37,120 --> 23:48:40,080
应用程序中使用我的 api 密钥应用程序 ID 和发件人 ID 并与

1928
23:48:40,080 --> 23:48:44,480
我控制的数据库进行交互，即使您个人无权访问该

1929
23:48:44,480 --> 23:48:47,440
数据库，因为该数据库存储在我

1930
23:48:47,440 --> 23:48:51,832
在

1931
23:48:51,832 --> 23:48:55,192
firebase 控制台中的配置文件下，因此使用 这个 api 密钥和应用程序 ID，您可以

1932
23:48:55,192 --> 23:48:59,920
与数据库交互，它只是安全信息，它只是

1933
23:48:59,920 --> 23:49:03,680
我在我的 firebase 配置中指定的 um 身份验证信息或身份验证规则，

1934
23:49:03,680 --> 23:49:08,960
然后将决定谁可以访问什么，

1935
23:49:08,960 --> 23:49:12,872
所以不用担心 关于这一点，我

1936
23:49:12,872 --> 23:49:17,280
实际上将在本课程发布时删除这个 firebase 项目，所以我对这些

1937
23:49:17,280 --> 23:49:23,600
信息公开并显示给你感到非常满意

1938
23:49:23,600 --> 23:49:29,280
我们可以在我们的 firebase firestore 项目中定义我们可以指定谁可以访问

1939
23:49:29,280 --> 23:49:33,440
什么以及基于什么规则，例如，如果用户经过身份验证，

1940
23:49:33,440 --> 23:49:37,760
或者该用户 id 是否实际存在于该文档的 id 字段中 例如，这样的

1941
23:49:37,760 --> 23:49:42,552
事情

1942
23:49:42,552 --> 23:49:46,232
好吧，嗯，现在我们要做的实际上是

1943
23:49:46,232 --> 23:49:51,600
开始为我们的项目创建一个 um firestore 数据库，所以

1944
23:49:51,600 --> 23:49:56,000
呃我在这里要做的是我要调出 safari，我要

1945
23:49:56,000 --> 23:49:59,192
去控制台firebase.com，所以我建议你做同样的事情，

1946
23:49:59,192 --> 23:50:04,872
在这里稍微改变一下屏幕布局，

1947
23:50:04,872 --> 23:50:08,960
这样你就能更好地看到我的屏幕，对不起

1948
23:50:08,960 --> 23:50:11,760
，然后我要去我们的减号花项目，所以我建议你

1949
23:50:11,760 --> 23:50:14,320
做 你的应用程序也是一样的，

1950
23:50:14,320 --> 23:50:17,440
所以当我们在这里结束时，在左侧你会看到一个叫做

1951
23:50:17,440 --> 23:50:21,040
firestore 数据库的东西，我希望你点击那里并确保你

1952
23:50:21,040 --> 23:50:25,360
在这里也选择了正确的应用程序 可能有很多

1953
23:50:25,360 --> 23:50:28,800
就像我一样，然后我们需要在这里

1954
23:50:28,800 --> 23:50:33,832
做的，只是说创建数据库没问题，正如你所看到的，现在的

1955
23:50:33,832 --> 23:50:37,192
屏幕可能看起来有点吓人，但它完全没问题

1956
23:50:37,192 --> 23:50:41,760
，你 可以看到这里指定了两种不同的模式，因为我们谈到了

1957
23:50:41,760 --> 23:50:46,400
生产模式 a 然后另一个

1958
23:50:46,400 --> 23:50:50,480
是生产模式下的测试模式，对不起，默认规则非常

1959
23:50:50,480 --> 23:50:54,552
糟糕，正如您在此处看到的那样，它说数据库中的任何文档都

1960
23:50:54,552 --> 23:50:58,872
无法访问，因此或无法访问，无法访问

1961
23:50:58,872 --> 23:51:05,192
它说不允许读取 或者写因为条件只是假

1962
23:51:05,192 --> 23:51:09,360
所以你可以看到它说所有第三方读取和权利都将被拒绝

1963
23:51:09,360 --> 23:51:13,512
但这真的不是嗯

1964
23:51:13,512 --> 23:51:20,080
这不是我们将如何设置我们的

1965
23:51:20,080 --> 23:51:24,160
firestore数据库我们就像我之前提到的我们 将来会加强

1966
23:51:24,160 --> 23:51:28,160
很多，但不仅仅是现在，所以我需要你

1967
23:51:28,160 --> 23:51:30,320
进入测试模式开始，你会收到这个绝对漂亮的

1968
23:51:30,320 --> 23:51:34,480
消息，说测试模式的默认安全规则允许

1969
23:51:34,480 --> 23:51:39,192
任何人 使用您的数据库参考来查看和记住数据库参考

1970
23:51:39,192 --> 23:51:42,640
它说

1971
23:51:42,640 --> 23:51:46,400
在接下来的 30 天内从数据库中的所有数据中编辑和删除所有数据库，所以没关系

1972
23:51:46,400 --> 23:51:50,640
，你可以看到这里设置的规则说如果

1973
23:51:50,640 --> 23:51:55,192
请求时间小于等等等等，则允许读写所以 它基本上会打开您的数据库

1974
23:51:55,192 --> 23:51:59,280
30 天 它实际上非常智能 非常好 所以我

1975
23:51:59,280 --> 23:52:04,552
需要你这样做 记住我们很快就会收紧它

1976
23:52:04,552 --> 23:52:07,280
然后你可以在这里看到它说允许基本上设置一个位置

1977
23:52:07,280 --> 23:52:13,120
您的数据现在将存储在哪里可能存在某种

1978
23:52:13,120 --> 23:52:17,760
利益冲突，例如您的业务的法律部分

1979
23:52:17,760 --> 23:52:23,512
以及您想要存储数据的位置以及您实际

1980
23:52:23,512 --> 23:52:27,120
感觉舒适的位置，但是 gdpr 肯定会让

1981
23:52:27,120 --> 23:52:31,040
如果你住在欧洲，这会更加复杂，所以

1982
23:52:31,040 --> 23:52:36,960
我的意思是，即使你住在国外，gdpr 也会让事情变得复杂

1983
23:52:36,960 --> 23:52:41,360
，一些托管在美国的网站仍然无法被欧盟的用户访问

1984
23:52:41,360 --> 23:52:45,920
，这让事情变得有点复杂 我现在基本上

1985
23:52:45,920 --> 23:52:49,120
在瑞典，所以我更喜欢使用

1986
23:52:49,120 --> 23:52:52,720
可能与欧洲有关的位置，嗯，我可以看到欧洲西部，而瑞典

1987
23:52:52,720 --> 23:52:57,512
有点像在中间，所以我只是 现在要使用欧洲西部，但

1988
23:52:57,512 --> 23:53:00,552
现在这又不是那么重要，它可能

1989
23:53:00,552 --> 23:53:04,080
会对应用程序的速度产生一些影响，具体取决于服务器的实际

1990
23:53:04,080 --> 23:53:07,440
位置，所以 Firebase 让你可以选择你的位置真的很好

1991
23:53:07,440 --> 23:53:11,192
firestore 数据库，因此您可能想阅读更多有关此内容的信息

1992
23:53:11,192 --> 23:53:14,800
，您可以按了解更多信息以阅读有关此内容的更多信息，但我

1993
23:53:14,800 --> 23:53:20,872
只会选择欧洲西部，因为我相信它对我来说更有意义，

1994
23:53:20,872 --> 23:53:26,000
因为我位于 在瑞典所以

1995
23:53:26,000 --> 23:53:30,080
选择一个对你有意义的位置，然后按下启用按钮

1996
23:53:30,080 --> 23:53:33,832
哇，这是一个绝对可怕的加载屏幕

1997
23:53:33,832 --> 23:53:40,720
我的意思是它甚至没有居中所以没关系 firebase

1998
23:53:40,720 --> 23:53:46,080
记住我们使用 firebase 作为免费服务 所以我只想 确保

1999
23:53:46,080 --> 23:53:49,832
每个人都明白我非常感谢拥有 firebase，因为

2000
23:53:49,832 --> 23:53:55,680
它让我的生活变得更轻松，即使我可以创建自己的后端，

2001
23:53:55,680 --> 23:53:59,920
但我有时仍然更喜欢使用 firebase，

2002
23:53:59,920 --> 23:54:03,600
所以嗯，只是因为它很容易使用 所以，非常感谢

2003
23:54:03,600 --> 23:54:06,552
任何在firebase上工作并为我们提供免费

2004
23:54:06,552 --> 23:54:10,800
服务的人，

2005
23:54:10,800 --> 23:54:16,640
所以让我们在这里看看我们的规则，让我

2006
23:54:16,640 --> 23:54:21,120
像这样增加屏幕的大小，也许也

2007
23:54:21,120 --> 23:54:25,600
像这样增加它 所以你看得更清楚，让我看看我是否可以

2008
23:54:25,600 --> 23:54:29,832
稍微关闭左边的部分

2009
23:54:29,832 --> 23:54:34,552
，我实际上可能已经这样做了，

2010
23:54:34,552 --> 23:54:38,552
所以我要回到这里并按下这个按钮来关闭那个部分，

2011
23:54:38,552 --> 23:54:41,920
所以 我们现在需要做的是，正如标题所示，

2012
23:54:41,920 --> 23:54:45,120
我们将更改数据库中的安全规则

2013
23:54:45,120 --> 23:54:50,400
，我对其进行更改，以便

2014
23:54:50,400 --> 23:54:54,000
在用户通过身份验证的情况下允许读取和写入，

2015
23:54:54,000 --> 23:54:58,480
所以我们尽可能确保您可以 看到它说 request off 不是 null 所以让我们

2016
23:54:58,480 --> 23:55:02,800
继续并更改它，因此我将在这样的请求点之后删除所有内容

2017
23:55:02,800 --> 23:55:07,440
，您可以看到它使您可以访问路径资源时间

2018
23:55:07,440 --> 23:55:11,760
方法，所以我只想说 off 不是 null

2019
23:55:11,760 --> 23:55:17,360
好的，所以您实际上可以带来它

2020
23:55:17,360 --> 23:55:21,680
如果您愿意，也可以在同一行完成后，

2021
23:55:21,680 --> 23:55:25,760
如果请求身份验证不是全部，您可以说允许读写，这实际上只是意味着

2022
23:55:25,760 --> 23:55:30,552
通过我们的应用程序进行身份验证的人并且他们拥有

2023
23:55:30,552 --> 23:55:34,080
并且他们拥有有效的 当他们与数据库交互时，firebase 用户被

2024
23:55:34,080 --> 23:55:38,640
允许读取和写入从数据库读取和写入数据库，

2025
23:55:38,640 --> 23:55:43,040
但是请记住，这是数据库范围的，目前它

2026
23:55:43,040 --> 23:55:47,440
说任何文档，我们仍然没有太多谈论文档，但我会

2027
23:55:47,440 --> 23:55:50,320
告诉 你很快就会知道，但是任何人都可以想象，如果用户登录，你的数据库中的任何内容都可以被

2028
23:55:50,320 --> 23:55:53,832
读取和写入，这并不那么安全，

2029
23:55:53,832 --> 23:55:59,600
因为这实际上意味着我作为用户 1

2030
23:55:59,600 --> 23:56:04,000
而你作为用户 2 可以访问彼此的文档 好吧，即使

2031
23:56:04,000 --> 23:56:08,400
应用程序本身就像隔离这两个文件，说哦，

2032
23:56:08,400 --> 23:56:12,160
你是一个用户，我只会给你用户的文件，但在内部作为

2033
23:56:12,160 --> 23:56:16,000
firebase 用户，考虑到我们当前的安全 um

2034
23:56:16,000 --> 23:56:21,192
规则，即使应用程序受到限制，你也可以访问我的文件

2035
23:56:21,192 --> 23:56:25,680
您的访问权限请记住，好的，

2036
23:56:25,680 --> 23:56:30,232
所以在您完成之后，我需要您

2037
23:56:30,232 --> 23:56:34,080
按下发布按钮，这样您就可以看到它说发布

2038
23:56:34,080 --> 23:56:38,960
更改可能需要一分钟才能生效，这没关系，因为

2039
23:56:38,960 --> 23:56:45,360
我们要 在我们开始在我们的应用程序中使用这些新规则之前实际上需要一分钟多的时间，

2040
23:56:45,360 --> 23:56:49,512

2041
23:56:49,512 --> 23:56:53,680
null
2042
23:56:53,680 --> 23:56:56,872
null
2043
23:56:56,872 --> 23:57:00,872
null
2044
23:57:00,872 --> 23:57:04,320
null
2045
23:57:04,320 --> 23:57:10,320
null
2046
23:57:10,320 --> 23:57:15,280
null
2047
23:57:15,280 --> 23:57:19,600
null
2048
23:57:19,600 --> 23:57:25,120
null
2049
23:57:25,120 --> 23:57:28,960
null
2050
23:57:28,960 --> 23:57:33,440
null
2051
23:57:33,440 --> 23:57:37,120
null
2052
23:57:37,120 --> 23:57:39,920
null
2053
23:57:39,920 --> 23:57:43,832
null
2054
23:57:43,832 --> 23:57:48,320
null
2055
23:57:48,320 --> 23:57:53,512
null
2056
23:57:53,512 --> 23:57:57,440
null
2057
23:57:57,440 --> 23:58:03,680
null
2058
23:58:03,680 --> 23:58:09,040
null
2059
23:58:09,040 --> 23:58:14,400
null
2060
23:58:14,400 --> 23:58:19,440
null
2061
23:58:19,440 --> 23:58:22,872
null
2062
23:58:22,872 --> 23:58:26,800
null
2063
23:58:26,800 --> 23:58:30,400
null
2064
23:58:30,400 --> 23:58:35,680
null
2065
23:58:35,680 --> 23:58:40,320
null
2066
23:58:40,320 --> 23:58:45,280
null
2067
23:58:45,280 --> 23:58:49,040
null
2068
23:58:49,040 --> 23:58:53,832
null
2069
23:58:53,832 --> 23:58:57,760
null
2070
23:58:57,760 --> 23:59:02,400
null
2071
23:59:02,400 --> 23:59:07,192
null
2072
23:59:07,192 --> 23:59:10,640
null
2073
23:59:10,640 --> 23:59:15,192
null
2074
23:59:15,192 --> 23:59:19,440
null
2075
23:59:19,440 --> 23:59:24,552
null
2076
23:59:24,552 --> 23:59:29,600
null
2077
23:59:29,600 --> 23:59:32,872
null
2078
23:59:32,872 --> 23:59:36,872
null
2079
23:59:36,872 --> 23:59:40,080
null
2080
23:59:40,080 --> 23:59:44,960
null
2081
23:59:44,960 --> 23:59:48,000
null
2082
23:59:48,000 --> 23:59:53,120
null
2083
23:59:53,120 --> 23:59:58,232
null
