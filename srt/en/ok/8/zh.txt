1
00:30:04,960 --> 00:30:09,192
将消息发送到一个称为文本编辑控制器的对象，然后说嘿我的文本

2
00:30:09,192 --> 00:30:13,832
已更改，这是我们在颤振中对文本字段的代理，

3
00:30:13,832 --> 00:30:19,600
好吧，这就是设置，我们还需要做的是

4
00:30:19,600 --> 00:30:23,760
允许用户输入多行 这个文本字段中的文本，因为记住

5
00:30:23,760 --> 00:30:27,600
通常在颤动中的文本字段就像一行，所以例如你正在写一个

6
00:30:27,600 --> 00:30:32,080
电子邮件地址或者你正在写你的密码，所以默认情况下它们不像多行

7
00:30:32,080 --> 00:30:37,360
文本字段，除非你制作它们 多行，这就是我们

8
00:30:37,360 --> 00:30:40,640
现在要做的，所以我们要说我们的键盘类型，

9
00:30:40,640 --> 00:30:45,680
你可以看到它的类型是文本输入类型，然后说文本输入类型

10
00:30:45,680 --> 00:30:50,232
alt-line 好吧，这样你就可以

11
00:30:50,232 --> 00:30:54,400
在键盘的

12
00:30:54,400 --> 00:30:57,360
右下角有一个

13
00:30:57,360 --> 00:31:01,600
小回车键 所以在这里

14
00:31:01,600 --> 00:31:05,760
你会得到那个键盘，你很快就会看到

15
00:31:05,760 --> 00:31:10,080
你会在你的键盘上得到那个键来跳到下一

16
00:31:10,080 --> 00:31:13,600
行，因为当你在做ios开发时它也很快，

17
00:31:13,600 --> 00:31:17,512
有一个奇怪的习惯是

18
00:31:17,512 --> 00:31:23,040
创建带有奇怪参数的多行文本字段和

19
00:31:23,040 --> 00:31:26,232
不幸的是，它也已经泄漏到颤动中，

20
00:31:26,232 --> 00:31:29,360
嗯，你没有像

21
00:31:29,360 --> 00:31:34,960
文本字段中的参数那样显示多行，所以如果你想创建一个多行的文本字段

22
00:31:34,960 --> 00:31:40,320
，它有点像你输入更多 文本输入

23
00:31:40,320 --> 00:31:45,832
然后不幸的是你必须调用并且你必须将 null 分配给 max

24
00:31:45,832 --> 00:31:49,120
行的参数在 github 上有一些

25
00:31:49,120 --> 00:31:53,040
关于为什么会这样的讨论，但它背后有一个很好的理由好吧

26
00:31:53,040 --> 00:31:56,800
嗯，我们接下来要做的是如果 如果

27
00:31:56,800 --> 00:32:02,400
我们这样做，我按 command s，然后我们到这里

28
00:32:02,400 --> 00:32:06,872
，我们在这里按加号按钮，好吧，你会看到这里有一个文本字段，

29
00:32:06,872 --> 00:32:11,920
这很好，但是用户不太明显

30
00:32:11,920 --> 00:32:15,760
我应该做什么 在这里做这行是什么我要点击

31
00:32:15,760 --> 00:32:20,160
这里的某个地方不是这样 很明显，所以我们要做的是在

32
00:32:20,160 --> 00:32:24,552
这个文本字段中添加一个叫做提示的东西，如果你是设计师或开发人员，你

33
00:32:24,552 --> 00:32:28,080
可能已经知道什么是提示，但如果你不知道什么是提示

34
00:32:28,080 --> 00:32:31,920
提示很小，因为这个名称表示一个小文本

35
00:32:31,920 --> 00:32:36,960
，通常会显示给用户，告诉她或他 uh

36
00:32:36,960 --> 00:32:42,400
在这个 uh 字段中应该输入什么，所以

37
00:32:42,400 --> 00:32:46,640
让我们去添加提示，这是通过我们文本上的属性 字段

38
00:32:46,640 --> 00:32:49,600
称为装饰，那是

39
00:32:49,600 --> 00:32:53,760
我们输入装饰中的输入装饰，我们

40
00:32:53,760 --> 00:32:57,920
将添加一个称为提示文本的参数，在这里我们只是说开始

41
00:32:57,920 --> 00:33:01,360
像这样输入你的笔记，

42
00:33:01,360 --> 00:33:03,832
所以命令

43
00:33:03,832 --> 00:33:08,552
和逗号在这里 代码有点，

44
00:33:08,552 --> 00:33:14,080
但现在我们开始了，我们在这里有提示，当我点击这个

45
00:33:14,080 --> 00:33:17,832
文本字段时，你可以看到我可以开始在这里输入，然后按下这个小

46
00:33:17,832 --> 00:33:21,360
按钮，我正在谈论多行 当我开始输入

47
00:33:21,360 --> 00:33:26,080
越来越多的文本时，文本字段会增加 n 大小没问题

48
00:33:28,872 --> 00:33:33,440
，这就是我们在本章中真正要做的我希望我没有

49
00:33:33,440 --> 00:33:35,920
在本章开头说本章将是

50
00:33:35,920 --> 00:33:40,080
一种代码重但我的意思是没有吓到你 是相当多

51
00:33:40,080 --> 00:33:43,440
的代码，但希望你能在整个章节中坚持我并

52
00:33:43,440 --> 00:33:48,480
做到这一点，就像我们工作的所有其他章节中的传统一样，

53
00:33:48,480 --> 00:33:51,600
我们不会

54
00:33:51,600 --> 00:33:56,232
失去我们不想失去的工作 我们正在处理我们的代码，所以我们需要

55
00:33:56,232 --> 00:34:01,120
确保我们提交并且我们标记我们的代码

56
00:34:01,120 --> 00:34:06,232
没问题，所以让我稍微改变一下屏幕布局

57
00:34:06,232 --> 00:34:11,280
，我们已经将前一章标记为第 13 步，所以这里的标题表明

58
00:34:11,280 --> 00:34:15,512
我们将标记并提交此代码作为第 14 步，所以

59
00:34:15,512 --> 00:34:20,720
我要说 git status 两个文件更改，然后我将

60
00:34:20,720 --> 00:34:24,640
它们全部添加到暂存环境，然后我将它们

61
00:34:24,640 --> 00:34:29,920
作为第 14 步提交和 将我的更改推送到 github

62
00:34:29,920 --> 00:34:37,120
，然后我将我们的代码也标记为第 14 步，然后推送我们的标签

63
00:34:39,512 --> 00:34:44,720
t 现在再次标记 um 就像其他章节的传统一样，

64
00:34:44,720 --> 00:34:47,600
以及在每一章的末尾我们将讨论我们将

65
00:34:47,600 --> 00:34:54,800
在下一章讨论的内容，所以我们现在实际上是在创建笔记，它

66
00:34:54,800 --> 00:34:57,920
可能不会立即 对您可见，但如果您

67
00:34:57,920 --> 00:35:02,160
创建了一些笔记，那么这个屏幕应该能够呈现这些笔记，

68
00:35:02,160 --> 00:35:06,552
因为新的笔记视图正在做所有必要的事情，不仅是

69
00:35:06,552 --> 00:35:10,160
创建笔记，让我们看看它在哪里创建新笔记

70
00:35:10,160 --> 00:35:16,160
但它也正在为我们更新该注释，所以在这里您可以看到更新注释，因此这些

71
00:35:16,160 --> 00:35:19,832
注释在数据库中只是应用程序的主 ui 是

72
00:35:19,832 --> 00:35:23,440
这个节点 c 黑暗无法呈现它们它所做的只是

73
00:35:23,440 --> 00:35:28,400
说等待所有节点，所以它不是那么令人兴奋，但只要知道

74
00:35:28,400 --> 00:35:32,160
你已经到达那里，我们正在到达那里，只是还有几个步骤

75
00:35:32,160 --> 00:35:37,920
可以处理这个问题，嗯，这正是我们在下一章要做的，

76
00:35:37,920 --> 00:35:42,800
所以得到 一些茶和咖啡，如果 你想，我会在那里见到你

77
00:35:42,800 --> 00:35:47,280
你好，欢迎来到前几章中 slotzer 课程的第 32 章，

78
00:35:47,280 --> 00:35:51,280
我们一直在谈论我们的节点服务和创建流

79
00:35:51,280 --> 00:35:55,120
控制器以使用节点填充流控制

80
00:35:55,120 --> 00:35:59,512
我们在节点服务中也有一个本地称为下划线节点的缓冲区，

81
00:35:59,512 --> 00:36:04,232
所以我们有点像以一种非常好的和有机的方式处理我们的笔记

82
00:36:04,232 --> 00:36:09,040
，我们还使用新的节点视图暗文件，我们在其中创建了一个有状态的

83
00:36:09,040 --> 00:36:12,720
小部件 它有一个文本编辑控制器，我还允许

84
00:36:12,720 --> 00:36:16,720
用户输入我们管理的一些文本，甚至将该文本作为

85
00:36:16,720 --> 00:36:22,160
新注释保存到数据库中，所以我们已经做了很多，但是没有那么

86
00:36:22,160 --> 00:36:26,080
有趣的是它是 有点反高潮，因为我们能够

87
00:36:26,080 --> 00:36:29,192
创建笔记，但我们无法实际显示它们，所以我们

88
00:36:29,192 --> 00:36:33,920
用新笔记填充数据库，但没有人能够在屏幕上显示它们

89
00:36:33,920 --> 00:36:38,552
，那就是 我们将在本章中处理什么，

90
00:36:38,552 --> 00:36:44,080
所以让我来看看 将我们到目前为止编写的代码响铃到屏幕上

91
00:36:44,080 --> 00:36:48,232
，嗯，我将清除此获取状态，

92
00:36:48,232 --> 00:36:50,872
以确保一切正常，是

93
00:36:50,872 --> 00:36:55,360
的，我将把 scrcpy 带到右侧的 Visual Studio 代码

94
00:36:55,360 --> 00:36:59,360
和 我们现在必须谈谈

95
00:36:59,360 --> 00:37:03,680
我们的节点服务遇到的一个小问题，如果您查看这里的代码

96
00:37:03,680 --> 00:37:06,480
，我将增加大小，以便您看得更清楚，

97
00:37:06,480 --> 00:37:10,480
所以如果您查看我们的注释服务

98
00:37:10,480 --> 00:37:15,280
，我们有 我们在这里创建的这个呃共享实例好吧，所以每当

99
00:37:15,280 --> 00:37:18,800
有人说注意服务括号时，他们实际上并没有创建任何

100
00:37:18,800 --> 00:37:22,232
实例，他们没有创建节点服务的新实例，但他们

101
00:37:22,232 --> 00:37:27,120
正在通过这个工厂初始化程序 调用这个共享

102
00:37:27,120 --> 00:37:33,760
静态 final 反过来又调用这个内部或私有构造函数，这

103
00:37:33,760 --> 00:37:37,440
意味着我们已经创建了一个单例，所以一遍又一遍地创建一个新的节点服务

104
00:37:37,440 --> 00:37:41,440
不会创建一个新实例，

105
00:37:41,440 --> 00:37:45,120
他只会得到相同的共享实例然后 然后谁开始

106
00:37:45,120 --> 00:37:48,400
stalk reading 或者您正确地看到这里的

107
00:37:48,400 --> 00:37:52,400
所有注释所有注释都将其职责委托给节点流

108
00:37:52,400 --> 00:37:57,360
控制器或流但是我们的节点流控制器是广播流

109
00:37:57,360 --> 00:38:02,400
控制器，这意味着流控制器

110
00:38:02,400 --> 00:38:07,920
并没有真正保持 到新监听器的当前值所以假设你

111
00:38:07,920 --> 00:38:12,080
有一个流控制器坐在这里，你开始

112
00:38:12,080 --> 00:38:16,320
从一个地方监听那个流控制器的事件，然后一个事件进入

113
00:38:16,320 --> 00:38:20,720
流控制器，流控制器说哦，我有 一个监听器

114
00:38:20,720 --> 00:38:24,872
在这里我将把这个信息委托给那个监听器

115
00:38:24,872 --> 00:38:29,920
看起来很好但是在这个事件传播到

116
00:38:29,920 --> 00:38:34,232
流控制器之后

117
00:38:34,232 --> 00:38:37,920
当一个新的监听器进来时流控制器不会保持这个值 另一方面，因此

118
00:38:37,920 --> 00:38:41,440
您的广播流控制器的任何新侦听器都不会被

119
00:38:41,440 --> 00:38:45,280
告知该流控制器中填充的当前信息，

120
00:38:45,280 --> 00:38:49,920
因此如果 例如，您熟悉使用 rx 进行反应式编程

121
00:38:49,920 --> 00:38:54,080
，您可能知道这是一个已发表的主题，如果您

122
00:38:54,080 --> 00:38:58,640
使用 rx java 或 rx scotland

123
00:38:58,640 --> 00:39:04,232
rx swift 也是如此，即使您正在做类似的组合编程 使用 swift ui，您

124
00:39:04,232 --> 00:39:07,360
将知道这些就像已发布的主题一样

125
00:39:07,360 --> 00:39:11,832
，因此广播的流控制器不会保留其当前的 uh

126
00:39:11,832 --> 00:39:16,960
值，对于新听众我们需要我们需要解决这个问题，而做到

127
00:39:16,960 --> 00:39:21,280
这一点的方法就是 将节点流

128
00:39:21,280 --> 00:39:26,480
控制器的初始化移到我们的初始化器中，我们很快就会看到，

129
00:39:26,480 --> 00:39:29,832
所以我将在这里做一些屏幕尺寸的洗牌，

130
00:39:29,832 --> 00:39:34,320
因为标题表明

131
00:39:34,320 --> 00:39:38,640
我们需要做什么，我们 需要制作这个注释流控制器

132
00:39:38,640 --> 00:39:42,552
，让我们看看它在哪里，我们需要使它成为一个后期的

133
00:39:42,552 --> 00:39:47,440
最终结果，所以从它所在的位置获取数据类型，然后说后期最终将

134
00:39:47,440 --> 00:39:52,480
数据类型放在这里，然后删除等于 好的，所以现在我们有

135
00:39:52,480 --> 00:39:55,920
责任 确保

136
00:39:55,920 --> 00:39:59,920
在构造我们的节点服务的新实例时，这个节点流控制器实际上是在构造函数上初始化

137
00:40:08,720 --> 00:40:13,360
的

138
00:40:13,360 --> 00:40:17,192
数据库节点的流控制器列表，然后我们做与使用广播之前完全相同的事情，

139
00:40:17,192 --> 00:40:21,440
但是我们在这里要做的是

140
00:40:21,440 --> 00:40:26,800
使用广播流侦听器中的一个属性，在侦听时调用，所以这

141
00:40:26,800 --> 00:40:30,400
除非和呃回调是

142
00:40:30,400 --> 00:40:35,600
每当新的侦听器订阅我们的注释流控制器

143
00:40:35,600 --> 00:40:41,600
注释流控制器流时都会被调用，因此在发生这种情况时，我们需要

144
00:40:41,600 --> 00:40:46,960
确保我们的节点流控制器流填充了

145
00:40:46,960 --> 00:40:52,872
我们当前从数据库中读取的所有值，所以让我们开始吧 前进并这样做，

146
00:40:52,872 --> 00:40:55,680
所以我们将继续说notes

147
00:40:55,680 --> 00:41:00,400
stream controller sync add notes就像这样，

148
00:41:00,400 --> 00:41:04,872
这样可以确保任何开始听

149
00:41:04,872 --> 00:41:08,640
我们的人 属性 all notes 反过来使用 no stream controller 如果它是一个

150
00:41:08,640 --> 00:41:13,600
新订阅者，那么它将调用未列出的 um 回调

151
00:41:13,600 --> 00:41:17,920
，然后我们将

152
00:41:17,920 --> 00:41:22,080
使用我们已经从 数据库

153
00:41:22,080 --> 00:41:25,120
好的，让我们现在进入下一个注释，然后

154
00:41:25,120 --> 00:41:29,512
我们才能真正开始本章的其余部分，正如标题所示，因为

155
00:41:29,512 --> 00:41:32,720
我们不应该在打开数据库后在热重载时关闭数据库，我们不应该

156
00:41:32,720 --> 00:41:36,232
在每次重新加载时关闭它 被关闭，

157
00:41:36,232 --> 00:41:41,920
所以我所指的问题在我们的注释视图中，

158
00:41:41,920 --> 00:41:46,480
它就在我们的处置中，所以在进行热重载时我们正在做的是

159
00:41:46,480 --> 00:41:50,480
我们说节点服务关闭，这反过来又会 实际上关闭

160
00:41:50,480 --> 00:41:56,800
数据库，但请记住节点服务是并且是并且应该是一个

161
00:41:56,800 --> 00:42:02,232
单例，在创建和打开一次时它应该保持

162
00:42:02,232 --> 00:42:06,080
其状态，所以我们不应该

163
00:42:06,080 --> 00:42:10,552
在我们的任何小部件中关闭数据库 因为那个  将

164
00:42:10,552 --> 00:42:16,400
干扰内部结构以及节点服务实际上应该如何工作，所以

165
00:42:16,400 --> 00:42:19,832
我们将要做的，正如你所看到的，因为这里的姿势函数在这里

166
00:42:19,832 --> 00:42:23,192
覆盖了 dispose 函数，它唯一实际

167
00:42:23,192 --> 00:42:27,120
做的事情是 要关闭节点服务数据库，我们现在只是要删除这个

168
00:42:27,120 --> 00:42:32,232
功能，因为我们目前在我们的注释视图中没有其他东西可以处理，

169
00:42:36,400 --> 00:42:40,960
好吧，所以我们需要做的是真正了解

170
00:42:40,960 --> 00:42:45,832
本节的内容 我对本章感到非常兴奋

171
00:42:45,832 --> 00:42:50,872
，那就是开始使用列表视图

172
00:42:50,872 --> 00:42:57,680
，我们需要做的是确保我们有一个列表，

173
00:42:57,680 --> 00:43:03,600
我们可以在这里获取来自我们的流的数据 builder 你可以看到

174
00:43:03,600 --> 00:43:08,720
它读取了所有的注释，现在我们只是说等待所有节点，

175
00:43:08,720 --> 00:43:12,320
所以我们要改变它，相反，我们实际上将开始

176
00:43:12,320 --> 00:43:18,232
使用称为列表视图的东西，现在颤振中的列表视图是 一个很棒的

177
00:43:18,232 --> 00:43:21,680
小部件，我实际上可以展示 你在这里所以如果你只是输入列表视图

178
00:43:21,680 --> 00:43:26,160
然后命令并单击控制点击linux和windows你

179
00:43:26,160 --> 00:43:29,440
可以看到它是一个盒子滚动视图扩展了盒子滚动视图这又是一个

180
00:43:29,440 --> 00:43:33,280
滚动视图又是一个无状态小部件所以

181
00:43:33,280 --> 00:43:38,080
一个列表视图 有一些功能，一些非常棒的功能，它

182
00:43:38,080 --> 00:43:43,120
使用的是构建器，我们可以在这里看到它有一个构建器函数，我相信

183
00:43:43,120 --> 00:43:47,512
它在这里是一个静态函数，或者它实际上是一个构造

184
00:43:47,512 --> 00:43:53,280
器，很好，所以它有一个构建器，在你的构建器中你会是 能够将两个

185
00:43:53,280 --> 00:43:57,192
重要参数传递给这个列表视图，所以我们会说

186
00:43:57,192 --> 00:44:01,280
我们返回一个列表视图，而不是我们现在

187
00:44:01,280 --> 00:44:05,040
所说的等待所有笔记在这里的那个小文本我们会说我们首先有两个

188
00:44:05,040 --> 00:44:10,640
参数 会告诉它必须在屏幕上渲染多少项目，

189
00:44:10,640 --> 00:44:14,960
所以我们会说项目计数

190
00:44:14,960 --> 00:44:20,872
，对于项目计数，我们需要实际侦听此快照数据，

191
00:44:20,872 --> 00:44:25,832
因此请记住流构建器此时正在侦听 所有笔记

192
00:44:25,832 --> 00:44:29,280
所以这意味着来自快照的数据

193
00:44:29,280 --> 00:44:34,080
实际上将是你的

194
00:44:34,080 --> 00:44:39,040
um 将是我们从数据库中读取的所有笔记所以我们

195
00:44:39,040 --> 00:44:44,480
现在需要做的只是确保在这里等待 um 所以

196
00:44:44,480 --> 00:44:49,440
我实际上要删除它，我要说如果

197
00:44:49,440 --> 00:44:54,720
快照有数据，那么这是你的快照上的一个属性，它

198
00:44:54,720 --> 00:44:58,872
显示快照是否实际上有 pro 可以为你提供一些数据，

199
00:44:58,872 --> 00:45:03,600
我将把一个 else 放进去 在这里和其他地方，我们还要说返回

200
00:45:03,600 --> 00:45:08,720
con 循环进度指示器好的，如果

201
00:45:08,720 --> 00:45:13,832
快照有任何数据，那么让我们获取该数据，所以我只想说最后

202
00:45:13,832 --> 00:45:21,680
所有笔记都是快照，它是作为数据库笔记列表的数据

203
00:45:21,680 --> 00:45:24,800
好吧，我们能做什么我们可以说

204
00:45:24,800 --> 00:45:28,872
return const text

205
00:45:28,872 --> 00:45:33,600
得到所有类似的注释，如果你愿意，我们实际上可以将这些注释打印

206
00:45:33,600 --> 00:45:37,512
到屏幕上，我们可以说打印注释

207
00:45:37,512 --> 00:45:42,232
，我将带来调试 控制台，

208
00:45:42,232 --> 00:45:48,232
然后我将清除日志并更改屏幕 布局，

209
00:45:48,232 --> 00:45:52,872
以便您看得更清楚，我只是要执行命令，

210
00:45:52,872 --> 00:45:56,640
好吧，我现在可以看到它只是在说您的笔记，这意味着

211
00:45:56,640 --> 00:46:01,832
我们实际上没有任何笔记，所以如果我进入这里，那么

212
00:46:01,832 --> 00:46:07,040
您可以看到所有 突然间，我们在数据库中填充了一个新便笺，

213
00:46:07,040 --> 00:46:10,480
因为我去了这里，我说我正在打印一些便笺，

214
00:46:10,480 --> 00:46:13,760
所以我要打个招呼，好吧，

215
00:46:13,760 --> 00:46:19,832
看看我正在更改它，我们的快照实际上正在更新为新的

216
00:46:19,832 --> 00:46:24,080
信息，它不断打印，它的注释ID是相同的，你

217
00:46:24,080 --> 00:46:29,680
可以看到他的文字实际上正在改变，如果我出去，那么你可以看到

218
00:46:29,680 --> 00:46:33,600
它只是此刻说得到所有的笔记意味着你有一些笔记

219
00:46:33,600 --> 00:46:38,080
所以如果 你现在看到的是一个循环进度指示器，而不是像一个文本

220
00:46:38,080 --> 00:46:41,512
，我们说所有的笔记，这可能是因为你和我一样

221
00:46:41,512 --> 00:46:46,000
，你在数据库中没有任何笔记，

222
00:46:46,000 --> 00:46:51,440
好吧，现在我们有所有的 笔记 那么我们如何渲染这些所以我们需要

223
00:46:51,440 --> 00:46:55,360
在这里做些什么 我们要说 返回列表视图我要更改屏幕

224
00:46:55,360 --> 00:46:59,280
布局假设列表视图构建器

225
00:46:59,280 --> 00:47:04,000
，你记得我之前提到过我们需要用两个重要参数填充这个列表视图

226
00:47:04,000 --> 00:47:09,920
一个是项目数，目前项目数

227
00:47:09,920 --> 00:47:15,360
是所有笔记计数链接 然后我们让我们的项目构建器

228
00:47:15,360 --> 00:47:19,120
从你的编辑器那里获得一些帮助来完成这个你得到一个

229
00:47:19,120 --> 00:47:23,360
构建上下文作为类型上下文的第一个参数然后你得到一个索引

230
00:47:23,360 --> 00:47:29,512
现在在你的项目构建器中你的工作就是

231
00:47:29,512 --> 00:47:32,232
如果你看

232
00:47:32,232 --> 00:47:35,600
项目构建器的签名它说它是一个函数

233
00:47:35,600 --> 00:47:39,680
，它接受两个参数它构建上下文和一个整数作为索引，

234
00:47:39,680 --> 00:47:44,320
它必须返回一个你在这里看到的小部件，所以你可以在这里返回任何东西你

235
00:47:44,320 --> 00:47:47,600
可以说返回文本项目类似的

236
00:47:47,600 --> 00:47:51,600
东西 它看起来不会那么漂亮

237
00:47:51,600 --> 00:47:56,800
，实际上我可以看到也许我们丢失了我们的项目也许在这里

238
00:47:56,800 --> 00:47:59,832
我们的注释 2 可能有问题，就像

239
00:47:59,832 --> 00:48:04,160
删除注释一样，所以我只是要做 在

240
00:48:04,160 --> 00:48:10,720
这里进行热重载，我的 scr cpy 实际上可能会死掉，但是它可以正常

241
00:48:10,720 --> 00:48:13,920
工作，所以我们有一个项目，所以如果那是您也

242
00:48:13,920 --> 00:48:18,000
看到的，也许您可以进行热重载，因为我们已经更改了节点 服务，

243
00:48:18,000 --> 00:48:23,120
所以问题可能是我们的呃，我们只需要热重载

244
00:48:23,120 --> 00:48:27,680
这个 unlisten 才能真正被调用，所以这就是我们现在看到的，

245
00:48:27,680 --> 00:48:31,440
所以我可以在这里看到项目，我要按下 加号按钮，我

246
00:48:31,440 --> 00:48:35,360
要在这里打招呼，我要出去，突然间

247
00:48:35,360 --> 00:48:39,680
你看到两个项目出现在这里，好吧，但这不是很漂亮，因为

248
00:48:39,680 --> 00:48:45,920
在屏幕上显示文本不是很好 你不会有，

249
00:48:45,920 --> 00:48:50,960
你将无法轻松地为这些项目添加交互，因为

250
00:48:50,960 --> 00:48:54,720
我们希望理想情况下这些项目出现

251
00:48:54,720 --> 00:48:59,600
在列表中，然后它们有自己的尺寸，所以它们有一个很好的高度，

252
00:48:59,600 --> 00:49:03,192
这样 它们彼此分开一点，正如您将在下一章中看到的那样，

253
00:49:03,192 --> 00:49:08,080
我们将使用 嗯，删除这些项目，因此我们希望

254
00:49:08,080 --> 00:49:12,480
用户能够在每个项目旁边看到某种图标，他

255
00:49:12,480 --> 00:49:17,760
或她可以使用该图标单击该图标并删除该项目，因此文本本身

256
00:49:17,760 --> 00:49:23,120
将无法为我们提供 有了我们需要的所有功能，所以

257
00:49:23,120 --> 00:49:27,192
我们需要一个更复杂的小部件，它被称为

258
00:49:27,192 --> 00:49:32,232
列表图块，所以让我们这样做，假设我们至少返回

259
00:49:32,232 --> 00:49:38,960
图块，我们的列表图块将有一个标题，所以这就是

260
00:49:38,960 --> 00:49:42,400
目前我们唯一要提供的东西，你可以看到它是一个小部件

261
00:49:42,400 --> 00:49:45,760
，对于这个列表的小部件和这个列表样式的标题，我们

262
00:49:45,760 --> 00:49:49,440
将使用文本，嗯，好的，我 将在其中放置

263
00:49:49,440 --> 00:49:54,160
一些逗号，因此对于文本，我们要说的

264
00:49:54,160 --> 00:49:57,440
是文本本身是

265
00:49:57,440 --> 00:50:03,040
我们想要获取在该注释中输入的文本，因此您会看到我们拥有所有

266
00:50:03,040 --> 00:50:08,160
注释，但我们没有 拥有当前注释，因此我们实际上正在

267
00:50:08,160 --> 00:50:11,920
阅读其索引的当前注释将使用 thi 提供给我们 s item builders

268
00:50:11,920 --> 00:50:19,600
index 所以让我们说final um notes是该索引处的所有节点，这

269
00:50:19,600 --> 00:50:24,552
就是我们要返回列表图块的当前节点，好吧，

270
00:50:24,552 --> 00:50:30,552
它的文本将是注释文本，你可以在这里看到

271
00:50:30,552 --> 00:50:34,720
呃我可以看到 我在这里写了瓷砖，但它应该是标题

272
00:50:34,720 --> 00:50:39,192
，在这里我们必须有一个分号，所以如果我在这里执行命令，

273
00:50:39,192 --> 00:50:45,360
你可以看到现在我们有非常我的意思是这些文本的更好更漂亮的版本

274
00:50:45,360 --> 00:50:48,552
，你 可以看到他们就在这里它说你好和

275
00:50:48,552 --> 00:50:51,920
你好世界这些是我们输入的文本你可以实际测试一下

276
00:50:51,920 --> 00:50:57,920
并说我的新我的新笔记在这里输入

277
00:50:57,920 --> 00:51:01,832
然后按后退按钮你会看到你的笔记 正常显示在

278
00:51:01,832 --> 00:51:06,800
屏幕上，但我们要在这里做的是，如果

279
00:51:06,800 --> 00:51:14,160
您在笔记中输入大量文本，那么如果我去说这里

280
00:51:14,160 --> 00:51:19,512
是我输入的很长的文本，我不

281
00:51:19,512 --> 00:51:26,720
想要 这一切都将显示在一个图块中，然后显示在节点视图中，因此我们现在有一个

282
00:51:26,720 --> 00:51:31,832
非常大的节点，但它本身正在运行

283
00:51:31,832 --> 00:51:36,400
打破你在笔记列表中看到的布局我们不想

284
00:51:36,400 --> 00:51:39,600
呈现整个笔记我们想以某种方式

285
00:51:39,600 --> 00:51:43,760
将我们显示的信息量限制在合理的大小

286
00:51:43,760 --> 00:51:47,512
，因为我们的笔记不 有标题，我们

287
00:51:47,512 --> 00:51:53,760
可以通过简单地渲染一行文本来推断笔记的内容，

288
00:51:53,760 --> 00:51:57,440
然后用户应该能够说哦，这就是我在笔记中写的内容

289
00:51:57,440 --> 00:52:01,680
，正如你将在最新的后续章节中看到的那样 我们将允许

290
00:52:01,680 --> 00:52:06,080
用户也可以单击或点击这些现有笔记，以便查看

291
00:52:06,080 --> 00:52:09,360
有关它们的更多信息，因此，如果您

292
00:52:09,360 --> 00:52:13,600
不向用户显示整个笔记并且作为 你会看到当用户

293
00:52:13,600 --> 00:52:17,440
开始在他们的笔记中输入越来越多的信息时，实际上并不

294
00:52:17,440 --> 00:52:21,680
希望呈现整个笔记，因为想象一个

295
00:52:21,680 --> 00:52:25,680
笔记有两页长，或者你会有两个非常小的笔记然后

296
00:52:25,680 --> 00:52:31,600
两页 很长的一个音符，这是不可行的，所以实际上是可行的，

297
00:52:31,600 --> 00:52:36,960
但是 这不是一个很好的用户界面，所以我要在这里加一个逗号，

298
00:52:36,960 --> 00:52:42,000
然后我将在我们的文本中使用一个名为 max lines 的属性，

299
00:52:42,000 --> 00:52:44,832
我只想说一个

300
00:52:44,832 --> 00:52:49,680
，所以你会在这里看到 我们要做的是

301
00:52:49,680 --> 00:52:54,232
确保用户理解这里的信息

302
00:52:54,232 --> 00:52:59,512
比我们渲染的更多，所以我们想在没有足够空间的文本末尾放置类似的省略号

303
00:52:59,512 --> 00:53:03,920
完全渲染自己，所以

304
00:53:03,920 --> 00:53:07,760
我们要说软换行，正如你所看到的，信息是

305
00:53:07,760 --> 00:53:12,872
文本是否应该在软换行符处中断，所以确保它是真的

306
00:53:12,872 --> 00:53:17,680
，然后我们要说溢出，我们要 说像这样的文本溢出

307
00:53:17,680 --> 00:53:20,640
省略号

308
00:53:20,640 --> 00:53:23,832
，现在你可以看到它说这是一个很长的文本等等

309
00:53:23,832 --> 00:53:27,760
等等等等，所以这是一个很好的指示，然后所有用户都

310
00:53:27,760 --> 00:53:32,400
知道有更多信息要呈现，但没有足够的

311
00:53:32,400 --> 00:53:37,680
空间 让这些信息现在可以在屏幕上呈现，

312
00:53:37,680 --> 00:53:42,160
所以我想我的意思是我们已经看过了 d 在所有工作原理上，我们实际上

313
00:53:42,160 --> 00:53:45,680
已经对其进行了演示，因此我们不必为此进行单独的演示，我们

314
00:53:45,680 --> 00:53:49,920
一直在研究它，因为我们一直在开发和应用程序，这

315
00:53:49,920 --> 00:53:52,552
是颤振的优点之一，所以

316
00:53:52,552 --> 00:53:57,120
我们现在不需要对这个演示做任何事情

317
00:53:57,120 --> 00:54:00,552
，你可能会感到惊讶，这

318
00:54:00,552 --> 00:54:04,480
就是我们现在要做的所有笔记视图没有更多的

319
00:54:04,480 --> 00:54:06,960
工作我们已经编写了

320
00:54:06,960 --> 00:54:10,640
我们能够在 时刻创建新笔记，我们能够

321
00:54:10,640 --> 00:54:15,832
在此列表视图构建器中一次显示这些笔记和一个，因此您将学习如何

322
00:54:15,832 --> 00:54:21,280
使用列表视图构建器以及我们可以做的传统

323
00:54:21,280 --> 00:54:25,120
我们将要 去提交并标记我们的工作，所以

324
00:54:25,120 --> 00:54:27,680
我要在屏幕上做一些重新洗牌，

325
00:54:27,680 --> 00:54:30,400
这样你就会看到我做得更好一点

326
00:54:30,400 --> 00:54:34,800
，我要在这里转到我的内置终端，我们

327
00:54:34,800 --> 00:54:39,680
会有一个 查看状态可以看到有两个文件已更改，所以

328
00:54:39,680 --> 00:54:42,800
让我们执行 git add all

329
00:54:42,800 --> 00:54:48,232
并将其作为第 15 步提交，在提交之前您可以看到您的

330
00:54:48,232 --> 00:54:51,600
git l 在最后一次提交之前的 ock 是第 14 步，

331
00:54:51,600 --> 00:54:57,440
因此您还可以查看所有标签，我们最多可以看到标签 14。

332
00:54:57,440 --> 00:55:02,872
所以让我们继续说 git commit 并执行第 15 步。

333
00:55:02,872 --> 00:55:06,640
现在我要推送那个提交 到 github 或者如果您使用 bitbucket 或

334
00:55:06,640 --> 00:55:11,760
任何其他提供程序也很好，我将把它标记为第

335
00:55:11,760 --> 00:55:17,512
15 步，然后我们将推送我们的

336
00:55:17,512 --> 00:55:22,872
标签，这部分现在已经完成，所以我们已经完成了 我们承诺在这一

337
00:55:22,872 --> 00:55:26,552
章中要做的下一件事，

338
00:55:26,552 --> 00:55:30,720
作为所有其他章节中的传统，我们必须在每一章的结尾处

339
00:55:30,720 --> 00:55:34,720
讨论我们将在下一章中讨论的内容，你

340
00:55:34,720 --> 00:55:40,400
可以看到我们能够创建笔记 呃我们还不能更新笔记

341
00:55:40,400 --> 00:55:44,232
我们很快就会到达那里但是我们还需要允许用户删除

342
00:55:44,232 --> 00:55:48,320
笔记所以这正是我们

343
00:55:48,320 --> 00:55:51,440
要处理的 在下一章中，下一章也不会

344
00:55:51,440 --> 00:55:55,192
像这一章那样是一个巨大的章节，所以它会非常顺利，但我们

345
00:55:55,192 --> 00:56:00,400
会做一些曲子 对我们的项目进行大量重构，你很快就会看到，所以

346
00:56:00,400 --> 00:56:05,040
如果你愿意，可以拿些点心，

347
00:56:08,872 --> 00:56:13,600
我们下一章再见 如何创建新笔记

348
00:56:13,600 --> 00:56:17,280
以及如何在屏幕上显示这些笔记

349
00:56:17,280 --> 00:56:21,680
嗯，现在我们应用程序的任何用户都可以

350
00:56:21,680 --> 00:56:24,800
删除他们已经创建的笔记，

351
00:56:24,800 --> 00:56:28,480
而我们现在不提供该功能 对用户来说，这

352
00:56:28,480 --> 00:56:32,000
正是我们在本章中要做的

353
00:56:32,000 --> 00:56:35,680
工作，只是提醒一下，我们将在重构方面做很多工作，所以

354
00:56:35,680 --> 00:56:39,360
在代码无法编译的地方，事情会变得有点不舒服，但

355
00:56:39,360 --> 00:56:43,832
我们 '我会在打破它后立即修复它，所以我们也会

356
00:56:43,832 --> 00:56:48,160
对我们的对话进行一些工作，

357
00:56:48,160 --> 00:56:52,552
你会看到我们现在有一些对话出现在屏幕上，

358
00:56:52,552 --> 00:56:56,552
例如我们会显示一个错误 到屏幕

359
00:56:56,552 --> 00:57:00,552
或我们所在的用户 立场说哦，您无法登录，或者您的

360
00:57:00,552 --> 00:57:05,600
密码不正确，或者我们无法注册此用户，因为

361
00:57:05,600 --> 00:57:09,360
输入的密码很弱，所以这就像我们的错误对话，

362
00:57:09,360 --> 00:57:13,280
我们还有一个对话，当他或 她正在尝试

363
00:57:13,280 --> 00:57:17,600
退出应用程序，所以我们现在有两个对话

364
00:57:17,600 --> 00:57:22,080
，在本章中，我们要做的是巩固我们如何

365
00:57:22,080 --> 00:57:27,040
将对话显示给用户，作为删除

366
00:57:27,040 --> 00:57:30,800
功能的一部分，因为你 看看删除部分，我们要做的

367
00:57:30,800 --> 00:57:33,600
就是让我把

368
00:57:33,600 --> 00:57:37,440
scrcpy 带到屏幕上，所以我们要做的是，我们

369
00:57:37,440 --> 00:57:40,872
要放一点删除 列表中每个项目旁边的图标，我们

370
00:57:40,872 --> 00:57:45,192
将允许用户点击这些图标以显示对话

371
00:57:45,192 --> 00:57:49,280
现在这将是第三个对话，嗯，

372
00:57:49,280 --> 00:57:54,160
我的一个同事，我真的和我一起工作 佩服他的工作方式，他提到

373
00:57:54,160 --> 00:57:58,720
当他到达第三个时，他使东西可重复使用 是时候

374
00:57:58,720 --> 00:58:04,480
再次做同样的事情了，所以现在我们已经写了两个对话，我们

375
00:58:04,480 --> 00:58:08,000
现在还需要第三个对话，这就是我们实际上应该

376
00:58:08,000 --> 00:58:11,832
将所有对话显示合并到一个

377
00:58:11,832 --> 00:58:16,640
功能，然后从其他功能我们 我只是要重用它，好吧

378
00:58:16,640 --> 00:58:21,192
，这就是我们在本章中要做的，

379
00:58:21,192 --> 00:58:24,960
所以让我们稍微看一下代码我要嗯，

380
00:58:24,960 --> 00:58:28,640
我要把屏幕调大一点，

381
00:58:28,640 --> 00:58:33,680
所以这里

382
00:58:33,680 --> 00:58:37,440
所以 这是我们的应用程序，我们现在列出的方式

383
00:58:37,440 --> 00:58:43,192
就像那个visual studio代码一样，我们在那里也有一个cr cpy，

384
00:58:43,192 --> 00:58:46,872
所以让我们看看我们的标题，以防万一

385
00:58:46,872 --> 00:58:51,680
看看我们的错误对话框，让我们继续

386
00:58:54,400 --> 00:58:58,800
看看我们有什么持续的服务人群实用程序，我们在这里有一个

387
00:58:58,800 --> 00:59:03,040
称为显示错误对话框的功能，它反过来说显示对话框，

388
00:59:03,040 --> 00:59:08,552
然后它说警报对话好吧，如果你 看看它是如何

389
00:59:08,552 --> 00:59:14,480
构造的 ng 的意思是，嘿，我有，嗯，我有一个

390
00:59:14,480 --> 00:59:19,280
标题，然后我只有一个带有按钮的动作

391
00:59:19,280 --> 00:59:24,320
，而且该动作没有返回任何值，而且

392
00:59:24,320 --> 00:59:30,160
我们还有一些文本可以显示，很好，现在让我们转到我们的 注释视图 如果

393
00:59:30,160 --> 00:59:34,400
您在注释视图末尾查看我们的注释视图，我们有这个

394
00:59:34,400 --> 00:59:37,920
注销对话框 这是做什么的 它有相同的东西

395
00:59:37,920 --> 00:59:43,192
显示对话框它里面有一个警告对话框 它有一个标题和一些文本，

396
00:59:43,192 --> 00:59:48,000
但它有两个 动作和这些动作它们做不同的事情，所以如果一个动作

397
00:59:48,000 --> 00:59:51,280
发送一个 false 的值，另一个动作会发送一个

398
00:59:51,280 --> 00:59:54,872
true 的值，所以每个出现在

399
00:59:54,872 --> 00:59:57,512
屏幕上的对话所以让我们说这个，例如

400
00:59:57,512 --> 01:00:00,640
我们的注销对话框，这是我们的一个 '现在正在查看

401
01:00:00,640 --> 01:00:05,440
取消按钮发送一个错误值，而注销按钮发送一个真实

402
01:00:05,440 --> 01:00:08,960
值，所以对话框都非常相似，它们

403
01:00:08,960 --> 01:00:14,552
有一个标题，它们有一些内容，它们有一些用户

404
01:00:14,552 --> 01:00:18,400
可以对这些对话执行的操作 然后这些行为就有了自己的价值 d

405
01:00:18,400 --> 01:00:22,232
这就是我们现在在我们的应用程序中要做的就是我们

406
01:00:22,232 --> 01:00:26,552
将所有这些整合到一个通用函数中，这

407
01:00:26,552 --> 01:00:31,760
将允许我们根据我们的需要定制它，

408
01:00:31,760 --> 01:00:35,040
所以让我们看看 我们如何实现

409
01:00:35,040 --> 01:00:39,120
这一点，正如标题所示，我们首先要从源头上削减东西

410
01:00:39,120 --> 01:00:42,872
，这就像我在软件开发中经常使用的策略，所以

411
01:00:42,872 --> 01:00:47,440
如果我要破坏事物并且我会喜欢改变 事情的运作方式

412
01:00:47,440 --> 01:00:50,960
我不会害怕，我真的不害怕

413
01:00:50,960 --> 01:00:56,000
让事情崩溃，我认为你可能会想不同，但在我

414
01:00:56,000 --> 01:00:59,832
看来，从源代码中删除东西真的很好，破坏代码然后

415
01:00:59,832 --> 01:01:03,832
开始 一次修复一个问题，而不是试图确保

416
01:01:03,832 --> 01:01:07,192
在重构代码时没有任何问题，所以这就是我们在这里要做的，因为

417
01:01:07,192 --> 01:01:10,400
标题表明我们将进入短空对话让我

418
01:01:10,400 --> 01:01:14,480
们看看你是否可以 发现它我喜欢在 Visual Studio 代码中使用命令 p 我

419
01:01:14,480 --> 01:01:17,280
要说 在这里显示错误对话框

420
01:01:17,280 --> 01:01:21,280
，我们要做的就是删除所有这些代码

421
01:01:30,160 --> 01:01:34,640
从注释视图中注销对话框，因为我们将有一个通用的对话框，因此请

422
01:01:34,640 --> 01:01:38,000
在此处进入您的注释视图并

423
01:01:38,000 --> 01:01:41,832
删除此显示注销对话框好吧，

424
01:01:41,832 --> 01:01:46,160
我们会得到错误，这没关系，你知道我们删除的这段代码

425
01:01:46,160 --> 01:01:49,760
此处显示错误对话框也被大量使用，因此

426
01:01:49,760 --> 01:01:52,960
如果我喜欢搜索显示空气美元，请删除它，您可以看到我们实际上

427
01:01:52,960 --> 01:01:57,440
在七个地方使用，所以所有这些地方现在都会有一个错误

428
01:01:57,440 --> 01:02:03,920
，没关系，我们是 很快就会修复，所以不用担心

429
01:02:03,920 --> 01:02:08,960
，所以我们需要在这里做的是在我们修复所有这些之前，我们将

430
01:02:08,960 --> 01:02:14,960
开始基本上创建我们的笔记列表视图，

431
01:02:14,960 --> 01:02:18,232
所以现在如果你看看我们的 笔记

432
01:02:18,232 --> 01:02:23,512
查看我们所拥有的是这里的这种美丽，它正在做

433
01:02:23,512 --> 01:02:27,832
很多工作，正如您所看到的那样，它很有魅力 真正的构建器在笔记视图的主体中

434
01:02:27,832 --> 01:02:32,080
，它有一个流构建器和很多代码，

435
01:02:32,080 --> 01:02:36,232
如果你能把这段代码分开到它自己的地方，我们可以

436
01:02:36,232 --> 01:02:40,320
像笔记列表视图一样调用这个小部件，那就太好了 正是我们将

437
01:02:40,320 --> 01:02:46,480
在本章中做的所以让我们继续在我们的视图里面的笔记

438
01:02:46,480 --> 01:02:49,832
在这里在你的

439
01:02:49,832 --> 01:02:55,600
视图里面的笔记让我们创建一个新文件我们将称之为笔记

440
01:02:55,600 --> 01:02:59,832
列表视图点

441
01:02:59,832 --> 01:03:03,600
部分 在笔记列表视图中，我们要做的是说笔记

442
01:03:03,600 --> 01:03:08,552
列表视图是一个无状态小部件，因此我们创建一个 stl，它是一个无状态小部件

443
01:03:08,552 --> 01:03:11,120
，我们将其称为笔记列表视图，

444
01:03:11,120 --> 01:03:14,080
因为我们已经看到它 在我们需要导入材料之前，所以我现在要这样做，

445
01:03:14,080 --> 01:03:17,512
所以所有这些错误都会消失，

446
01:03:17,512 --> 01:03:20,480
现在我们需要做的是我们需要将

447
01:03:20,480 --> 01:03:25,512
一个笔记列表实际传递给这个笔记列表

448
01:03:25,512 --> 01:03:30,400
视图，以便它可以 渲染它们，因为您看到检索

449
01:03:30,400 --> 01:03:35,832
笔记的所有逻辑都可以在笔记视图中保持静止，但都没有 tes 列表视图感兴趣的

450
01:03:35,832 --> 01:03:40,552
是要显示

451
01:03:40,552 --> 01:03:44,480
的注释列表，所以让我们在注释列表视图中将其作为参数公开，这样我们将说出

452
01:03:44,480 --> 01:03:49,040
数据库节点的最终列表，您可以看到数据库节点现在没有

453
01:03:49,040 --> 01:03:53,192
导入 但是visual studio代码将足够聪明地

454
01:03:53,192 --> 01:03:55,832
导入它，所以

455
01:03:55,832 --> 01:03:58,800
如果你真的是，

456
01:03:58,800 --> 01:04:02,640
如果你的编辑器喜欢你在linux上使用vim或其他东西，或者

457
01:04:02,640 --> 01:04:06,800
如果你使用的是mac和windows，你可能必须导入 这些东西是手动的，所以

458
01:04:06,800 --> 01:04:11,192
我相信我的意思是，如果你在课程中已经到了这一点，

459
01:04:11,192 --> 01:04:13,512
你应该

460
01:04:13,512 --> 01:04:17,832
足够精明，你应该足够了解所有这些事情，以便

461
01:04:17,832 --> 01:04:21,680
能够自己解决这个问题，所以嗯 所以我不会再重复所有这些

462
01:04:21,680 --> 01:04:26,400
信息，只要确保你的数据库笔记在这一点上是在上下文中，

463
01:04:26,400 --> 01:04:30,232
所以这将是我们的笔记

464
01:04:30,232 --> 01:04:34,800
，也是我在上一章提到的这个笔记视图，但也许它

465
01:04:34,800 --> 01:04:37,512
实际上是值得的 在本章中提到，因为它非常相关

466
01:04:37,512 --> 01:04:41,760
我们要做的是在右侧的每个注释旁边

467
01:04:41,760 --> 01:04:47,920
作为尾随磁贴小部件，我们将显示有点像垃圾桶图标

468
01:04:47,920 --> 01:04:52,832
，用户可以点击它来删除一个 um

469
01:04:52,832 --> 01:04:56,480
注释和我们的内容 '然后要做的是

470
01:04:59,512 --> 01:05:06,080
确保我们基本上可以调用一个小函数来向用户显示一个删除

471
01:05:06,080 --> 01:05:09,920
对话框，所以当你按下删除按钮时，我们将显示

472
01:05:09,920 --> 01:05:13,280
一个对话框，删除对话框将是 非常类似于注销就像

473
01:05:13,280 --> 01:05:16,800
说现在嘿嘿你要删除这个笔记你确定

474
01:05:16,800 --> 01:05:20,000
并且那个对话框将有两个按钮

475
01:05:20,000 --> 01:05:24,000
是或否或类似的东西并且在按下否时我们将

476
01:05:24,000 --> 01:05:27,192
在按下时关闭对话 是的，那么我们将从数据库中删除该便笺

477
01:05:27,192 --> 01:05:32,720
，所以我们需要的是您现在可以看到便笺

478
01:05:32,720 --> 01:05:38,320
列表视图，它不应该与便笺服务有任何联系，

479
01:05:38,320 --> 01:05:42,480
它应该是便笺 具有该连接的视图，因此这

480
01:05:42,480 --> 01:05:47,192
也是您应该喜欢的组件 s在颤抖

481
01:05:47,192 --> 01:05:52,080
，你不应该到处泄露你的服务，所以如果笔记列表视图

482
01:05:52,080 --> 01:05:57,760
可以以某种方式将删除任务委托给笔记视图，那将是理想的，

483
01:05:57,760 --> 01:06:02,320
所以笔记列表视图可以显示对话它可以说

484
01:06:02,320 --> 01:06:06,552
嘿你确定 如果用户然后说是，则注释列表视图可以

485
01:06:06,552 --> 01:06:11,360
将此信息委托给其父级并说嘿用

486
01:06:11,360 --> 01:06:14,400
此信息做某事好吧，

487
01:06:14,400 --> 01:06:19,920
那么让我们去使用 typedef 创建一个小回调定义，

488
01:06:19,920 --> 01:06:24,232
对不起，我们将调用 它删除注释

489
01:06:24,232 --> 01:06:30,960
回调 好的，这是一个 void 函数，它需要一个数据库注释

490
01:06:30,960 --> 01:06:35,920
oops 一个数据库节点

491
01:06:35,920 --> 01:06:42,080
我会这样记，所以我们说我们正在定义一个函数

492
01:06:42,080 --> 01:06:46,232
，然后我们将在我们的节点列表视图中使用 我们称之为我们，

493
01:06:46,232 --> 01:06:50,400
我们将其用作回调，当用户

494
01:06:50,400 --> 01:06:53,832
在这个假设的对话上按下“是”时将被调用，我们

495
01:06:53,832 --> 01:06:57,680
假设会显示该用户没问题，所以让我们进入这里并定义让

496
01:06:57,680 --> 01:07:04,232
我们说删除节点回调和 我们只是 要在删除节点上说，

497
01:07:04,232 --> 01:07:08,400
所以这是我们的回调，你现在从颤动中得到一些错误，

498
01:07:08,400 --> 01:07:11,760
说这些参数没有定义，所以我将使用 Visual

499
01:07:11,760 --> 01:07:16,000
Studio 代码并说为我定义这些参数

500
01:07:16,000 --> 01:07:23,040
我' 我也会让它们需要像这样的参数，这

501
01:07:23,040 --> 01:07:28,320
很好，我们的应用程序中仍然存在一些错误，

502
01:07:28,320 --> 01:07:34,160
但是我们将继续构建，直到我们可以修复所有这些错误，

503
01:07:34,160 --> 01:07:40,080
好吧，这太棒了，所以这是我们拥有的第一部分 继续工作，所以

504
01:07:40,080 --> 01:07:45,360
让我们继续，嗯，把我们的笔记看这里的方式，

505
01:07:45,360 --> 01:07:50,000
你看我们已经有一个列表视图构建器，我要去抓取这个

506
01:07:50,000 --> 01:07:52,960
列表视图，从那里开始

507
01:07:52,960 --> 01:07:58,000
，我' 我实际上要剪切它并将其带到构建函数内的节点列表视图中，

508
01:07:58,000 --> 01:08:02,800
好吧，所以在里面而不是返回一个容器我只是要

509
01:08:02,800 --> 01:08:07,760
返回我刚刚粘贴的代码，我只是剪切好了

510
01:08:07,760 --> 01:08:11,600
它看起来绝对 目前很糟糕，因为我的意思是我们有这么

511
01:08:11,600 --> 01:08:14,640
多呃 rors，但老实说，我真的很喜欢那种

512
01:08:14,640 --> 01:08:18,160
东西，有些开发人员

513
01:08:18,160 --> 01:08:21,832
在他们的代码中有很多错误时会感到紧张，他们只想尽快修补它们，

514
01:08:21,832 --> 01:08:27,192
但我们只需要一步到位 就像我们在瑞典所说的那样，我们说

515
01:08:27,192 --> 01:08:31,120
这意味着一步一步地修复这些错误，

516
01:08:31,120 --> 01:08:35,440
在本章结束时，我向你保证一切都会正常进行，

517
01:08:35,440 --> 01:08:38,960
所以让我们进入这里，你可以看到第一个错误 我们有所有的笔记

518
01:08:38,960 --> 01:08:42,720
，所有的笔记都给我们一个错误，因为它在这个上下文中不存在

519
01:08:42,720 --> 01:08:46,872
，那是因为我们有一个叫做笔记的东西，所以

520
01:08:46,872 --> 01:08:50,400
让我们进去说现在我们正在使用笔记

521
01:08:50,400 --> 01:08:53,832
和 在这里我们也没有所有的笔记，所以我们只说笔记

522
01:08:53,832 --> 01:08:56,000
笔记，并且该

523
01:08:56,000 --> 01:08:58,480
笔记将从该索引处的笔记中提取，

524
01:08:58,480 --> 01:09:02,960
现在令人兴奋的部分是

525
01:09:02,960 --> 01:09:07,120
我们不只是使用我们的标题属性 list tile 我们将

526
01:09:07,120 --> 01:09:12,640
开始使用名为 trailing 的东西，而 trailing is a 作为 li 的属性 st

527
01:09:12,640 --> 01:09:15,600
tile，顾名思义，它将允许您

528
01:09:15,600 --> 01:09:20,160
指定需要在末尾显示的小部件或

529
01:09:20,160 --> 01:09:23,680
每个列表 tile 的尾迹，这就是我们将使用

530
01:09:23,680 --> 01:09:28,320
图标按钮的地方，以便显示我们的小垃圾 可以，所以

531
01:09:28,320 --> 01:09:31,600
让我们说图标按钮

532
01:09:31,600 --> 01:09:35,920
，在这个图标按钮中我们要做的是，我们将定义

533
01:09:35,920 --> 01:09:40,640
看起来像这样的 uncrest，它是图标，然后

534
01:09:40,640 --> 01:09:45,120
它将是图标的图标删除我相信它被称为

535
01:09:45,120 --> 01:09:48,320
让我们 看看 delete 的样子，你会发现它是一个小

536
01:09:48,320 --> 01:09:52,800
垃圾桶，太棒了，让这个缺点让

537
01:09:52,800 --> 01:09:57,280
分析器也很开心，所以我们该怎么办我被按下了，所以我们

538
01:09:57,280 --> 01:10:00,552
需要在按下时做的是 我之前提到过，我们需要处理

539
01:10:00,552 --> 01:10:05,832
一个对话的显示，上面写着让我们调用显示删除对话

540
01:10:05,832 --> 01:10:10,232
好吧，所以这个显示删除对话我们将调用它，我们希望它

541
01:10:10,232 --> 01:10:15,280
返回一个真或假，记住我们没有'  t 实现了显示

542
01:10:15,280 --> 01:10:20,160
删除对话框，没关系，我们可以设置一些限制

543
01:10:20,160 --> 01:10:25,360
这个函数的接口还没有，但它还不存在所以我们只是说

544
01:10:25,360 --> 01:10:30,320
这个函数显示删除对话框需要一个构建上下文，它向我们返回真或

545
01:10:30,320 --> 01:10:35,192
假，所以如果用户说是，我想删除一些项目然后它

546
01:10:35,192 --> 01:10:38,640
如果用户说不，则返回 true，那么这个

547
01:10:38,640 --> 01:10:44,400
对话框应该返回 false 给我们好吧，所以让我们继续说 final 应该，

548
01:10:44,400 --> 01:10:48,720
你应该删除是一个权重

549
01:10:48,720 --> 01:10:53,120
，当你使用一个权重时，你需要使你自己的新闻功能异步

550
01:10:53,120 --> 01:10:56,720
然后我们会说等待显示删除对话框我们没有那个

551
01:10:56,720 --> 01:11:01,600
功能记住但是没关系当我们说

552
01:11:01,600 --> 01:11:05,280
应该删除好如果这是布尔值然后我们说如果

553
01:11:05,280 --> 01:11:09,512
应该删除那么我们要做的是我们说

554
01:11:09,512 --> 01:11:14,960
我们用当前注释调用我们的删除注释，

555
01:11:14,960 --> 01:11:19,600
这只是这个小部件

556
01:11:19,600 --> 01:11:22,960
注释列表视图的实现，

557
01:11:22,960 --> 01:11:27,120
但不要担心这些错误，我们很快就会修复它们

558
01:11:27,120 --> 01:11:30,800
，现在也保存这个文件

559
01:11:30,800 --> 01:11:35,120
我们需要移动到下一个项目，这是我们自己的通用对话 你可以

560
01:11:35,120 --> 01:11:39,512
看到我们将创建一个通用对话飞镖

561
01:11:39,512 --> 01:11:45,440
，这非常重要，因为这几乎显示了通用对话

562
01:11:45,440 --> 01:11:49,120
，我们将在其上创建的变体将修复我们在应用程序中遇到的所有这些错误

563
01:11:49,120 --> 01:11:52,720
现在所以我实际上很高兴开始工作

564
01:12:02,320 --> 01:12:07,920
我们有 lib consonants enums services

565
01:12:07,920 --> 01:12:12,400
实用程序，但在实用程序中我们目前没有

566
01:12:12,400 --> 01:12:17,120
对话文件夹，记住我们

567
01:12:17,120 --> 01:12:22,080
删除了这个显示错误对话框的所有内容，

568
01:12:22,080 --> 01:12:26,960
现在我们不需要删除文件，所以我 '我只是要删除它并将其移至垃圾箱，

569
01:12:26,960 --> 01:12:31,280
所以现在在实用程序中我们什么都没有，所以让我们创建这个新文件，因为

570
01:12:31,280 --> 01:12:36,000
标题表明我们会说它会在一个名为 dialogs 的文件夹中

571
01:12:36,000 --> 01:12:42,800
，我们将调用它 通用 dialog.art

572
01:12:42,800 --> 01:12:47,280
好吧，我要去 ge 去掉侧边栏，我们现在需要开始

573
01:12:47,280 --> 01:12:52,232
实现我们的通用对话

574
01:12:52,232 --> 01:12:55,440
这个节目通用对话会

575
01:12:55,440 --> 01:12:59,920
有点复杂，嗯，我说它有点

576
01:12:59,920 --> 01:13:02,720
复杂只是因为它会使用泛型

577
01:13:02,720 --> 01:13:07,192
和原因 我基本上

578
01:13:07,192 --> 01:13:13,120
决定让它通用是因为通用名称表示这个

579
01:13:13,120 --> 01:13:17,192
通用对话我的意思是文件也说通用方言所以你

580
01:13:17,192 --> 01:13:20,552
需要知道你已经让自己进入

581
01:13:20,552 --> 01:13:25,040
它必须是通用的原因是 它需要能够产生

582
01:13:25,040 --> 01:13:29,360
不同类型的值让我们进入我们的笔记列表视图，你会看到这里

583
01:13:29,360 --> 01:13:33,440
我们会说显示删除对话框我们还没有实现的功能并

584
01:13:33,440 --> 01:13:37,440
突然显示删除对话框它会 返回 true 或 false 好吧

585
01:13:37,440 --> 01:13:42,320
，在登录视图的情况下这是一回事，所以让我们转到登录视图

586
01:13:42,320 --> 01:13:46,720
，这种情况如何显示空气点日志记住显示错误对话框也是

587
01:13:46,720 --> 01:13:51,120
一个我们很快将开发的功能，我们之前有 我们杀了它我们

588
01:13:51,120 --> 01:13:54,160
必须开发一个名为 show air dialog 的新函数，该函数将

589
01:13:54,160 --> 01:13:59,192
使用我们的通用对话框，但在这种情况下它不会返回 true 或 false，因此

590
01:13:59,192 --> 01:14:03,360
我们需要确保我们的通用对话正如其名称所示是一个

591
01:14:03,360 --> 01:14:09,280
通用函数，可以基于 关于您提供给它的内容能够将

592
01:14:09,280 --> 01:14:13,760
这些值返回给您，我的意思是您提供给

593
01:14:13,760 --> 01:14:18,480
它的每个项目每个选项或

594
01:14:18,480 --> 01:14:22,480
显示在我们的通用对话框中的每个按钮都将具有一个值，

595
01:14:22,480 --> 01:14:27,600
我们将假设所有 您在任何给定对话框中显示的按钮

596
01:14:27,600 --> 01:14:31,680
将具有完全相同类型的值，因此

597
01:14:31,680 --> 01:14:35,680
显示“是”或“否”按钮的对话框将有

598
01:14:35,680 --> 01:14:40,160
两个按钮，每个按钮都包含一个布尔值，一个为真，另一个为

599
01:14:40,160 --> 01:14:44,480
假或可能 您想显示 10 个按钮，其中两个的

600
01:14:44,480 --> 01:14:49,040
值为 true，另一个的值为其他 8 个为 false，但我的

601
01:14:49,040 --> 01:14:52,160
意思是您的通用对话框中的按钮将具有

602
01:14:52,160 --> 01:14:57,192
相同的数据类型 所以我们要去c 所有的数据类型

603
01:14:57,192 --> 01:15:01,512
都可以，所以让我们继续定义这个 um 显示

604
01:15:01,512 --> 01:15:05,280
通用对话，所以我们要说这个对话实际上返回

605
01:15:05,280 --> 01:15:09,360
了 t 的未来

606
01:15:09,360 --> 01:15:13,280
以及我们要说的我们要说的 显示通用

607
01:15:13,280 --> 01:15:18,232
对话，

608
01:15:18,232 --> 01:15:21,280
它是一个函数签名，它看起来像这样没问题，

609
01:15:21,280 --> 01:15:26,160
所以它实际上意味着什么 t 可选，这是因为记住

610
01:15:26,160 --> 01:15:29,280
在 android 上，例如，当您向用户显示对话框时，用户

611
01:15:29,280 --> 01:15:33,192
实际上可以按下硬件向下按钮 为了在不

612
01:15:33,192 --> 01:15:35,760
实际响应的情况下关闭对话框，而 ios 实际上

613
01:15:35,760 --> 01:15:40,080
并不像那样，当您显示对话框时，它是

614
01:15:40,080 --> 01:15:45,192
用户必须回复的模式，除非您创建自己的对话或者您正在

615
01:15:45,192 --> 01:15:49,040
做 一边说，哦，如果用户

616
01:15:49,040 --> 01:15:52,720
在对话之外点击，那么它应该消失，否则 ios 中的对话是模态的并且

617
01:15:52,720 --> 01:15:56,080
必须响应但是在 android 中，用户可能会在

618
01:15:56,080 --> 01:15:59,120
没有实际响应的情况下关闭对话 到它，在这种情况下，

619
01:15:59,120 --> 01:16:02,640
show generic 对话实际上应该返回 nil 或 null 取决于

620
01:16:02,640 --> 01:16:05,920
你在谈论什么语言

621
01:16:08,872 --> 01:16:13,280
返回某种

622
01:16:13,280 --> 01:16:17,832
可选值的对话框，我们需要的第一个参数

623
01:16:17,832 --> 01:16:23,440
是构建上下文，所以我们只说构建上下文

624
01:16:23,440 --> 01:16:28,400
，我们需要一个标题和内容，所以

625
01:16:28,400 --> 01:16:32,000
在我们这样做之前我们还要说必需的让我们也 看看这个说构建

626
01:16:32,000 --> 01:16:34,960
上下文没有定义的东西，那是因为我们有一个重要的材料，所以让

627
01:16:34,960 --> 01:16:38,320
我们处理一下，我们必须在这些地方有大括号，

628
01:16:38,320 --> 01:16:43,512
因为 required 实际上需要这样，

629
01:16:43,512 --> 01:16:45,832
所以我们的下一个参数 必须

630
01:16:45,832 --> 01:16:50,080
实现的是标题，然后是内容，所以两者都将是文本或

631
01:16:50,080 --> 01:16:52,552
字符串，所以这就是标题，现在我要

632
01:16:52,552 --> 01:16:56,232
复制粘贴，我要在这里说

633
01:16:56,232 --> 01:17:00,640
内容现在内容现在是令人兴奋的部分 我们需要的是

634
01:17:00,640 --> 01:17:04,552
某种ab 能力和某种方式让用户

635
01:17:04,552 --> 01:17:09,360
能够指定像一个列表这样

636
01:17:09,360 --> 01:17:14,960
的按钮列表来显示给用户现在每个按钮如果我们说

637
01:17:14,960 --> 01:17:18,160
默认情况下每个按钮都应该有例如

638
01:17:18,160 --> 01:17:22,400
我们应该 将每个按钮表示为一个文本按钮，每个文本

639
01:17:22,400 --> 01:17:27,280
按钮都需要一个字符串才能正常显示，然后它将有一个未按下的按钮，

640
01:17:27,280 --> 01:17:32,000
所以我们要说的是，我们应该能够渲染

641
01:17:32,000 --> 01:17:35,832
多个按钮和每个按钮 应该有一个文本

642
01:17:35,832 --> 01:17:40,232
，而且我们从每个按钮之前设置也应该有某种

643
01:17:40,232 --> 01:17:45,920
值，这不是可选的，所以我们需要一种方法让用户指定一个按钮列表，

644
01:17:45,920 --> 01:17:50,000
每个按钮都有一个字符串类型的标题和 这些

645
01:17:50,000 --> 01:17:55,440
按钮中的每一个都应该有一个可选的值，所以最好用一个

646
01:17:55,440 --> 01:17:59,360
字符串映射作为标题和一个像这样的 t 值来描述，

647
01:17:59,360 --> 01:18:02,552
所以我们要输入 def，我们

648
01:18:02,552 --> 01:18:07,920
会说我们有一个定义 的 a ，我们基本上有一个类型要完成

649
01:18:07,920 --> 01:18:12,960
，我们要去 c 所有对话框选项生成器

650
01:18:12,960 --> 01:18:15,832
，我们会说它是通用的

651
01:18:15,832 --> 01:18:20,640
，我们会说它等于一个

652
01:18:20,640 --> 01:18:24,800
返回该值的函数，所以

653
01:18:24,800 --> 01:18:30,640
让我们也看看 map all right key 期望找到所有正确的和

654
01:18:30,640 --> 01:18:35,192
这可能是因为我拼错了，所以现在我们有一个

655
01:18:35,192 --> 01:18:39,280
选项生成器，所以我们将在我们的函数中使用该选项生成器，所以

656
01:18:39,280 --> 01:18:42,720
你很快就会看到我们将如何使用它

657
01:18:42,720 --> 01:18:46,320
所以我 '我会说我们有一个对话框选项生成器，我们

658
01:18:46,320 --> 01:18:50,000
就叫它选项生成器

659
01:18:50,000 --> 01:18:54,080
好了，所以我们已经有了所有这些点点滴滴，现在我们需要做的

660
01:18:54,080 --> 01:18:59,192
是在这个函数内部实际使用构建上下文来显示一个对话

661
01:18:59,192 --> 01:19:04,800
用户所以在我们这样做之前，让我们获取调用者

662
01:19:04,800 --> 01:19:07,512
希望我们显示的所有选项，因此我们将其称为选项

663
01:19:07,512 --> 01:19:12,080
是选项生成器，我们调用该函数，现在您将看到

664
01:19:12,080 --> 01:19:15,280
选项

665
01:19:15,280 --> 01:19:18,720
是否足够聪明，可以理解是的 这是一个字符串动态的映射好吧它

666
01:19:18,720 --> 01:19:23,832
还不明白它是什么所以让我们走吧 提前说，在

667
01:19:23,832 --> 01:19:28,552
这个函数中，我们返回一个显示对话框 t

668
01:19:28,552 --> 01:19:32,480
好吧，在这里我们有两个参数，

669
01:19:32,480 --> 01:19:37,920
我们必须传递一个是上下文，另一个是实际的构建器

670
01:19:37,920 --> 01:19:42,480
函数，好吧，你最喜欢的编辑器的一些帮助

671
01:19:42,480 --> 01:19:45,040
完成构建器功能，这非常简单，

672
01:19:45,040 --> 01:19:52,720
只需构建上下文就可以

673
01:19:56,320 --> 01:20:00,400
了 没有什么革命性的，

674
01:20:00,400 --> 01:20:05,760
所以对于我们要说的标题，我们有一个等于它的文本，

675
01:20:05,760 --> 01:20:12,480
它包含我们要说的内容的标题字符串，还有

676
01:20:12,480 --> 01:20:16,720
一个包含内容的文本

677
01:20:16,720 --> 01:20:21,600
，然后我们要去 进入我们的行动

678
01:20:21,600 --> 01:20:26,000
，这对我来说是令人兴奋的部分，因为对于我们

679
01:20:26,000 --> 01:20:31,280
需要做的行动，您会看到我们的行动在这里定义，此

680
01:20:31,280 --> 01:20:34,232
选项中的每个键都是标题

681
01:20:34,232 --> 01:20:38,000
，由我们对话的行动字符串定义，

682
01:20:38,000 --> 01:20:41,920
所以 我们 需要开始映射它们，所以我们要说

683
01:20:41,920 --> 01:20:45,600
选项键

684
01:20:45,600 --> 01:20:49,512
键，然后我们将它们映射好，这让我们

685
01:20:49,512 --> 01:20:54,000
称之为选项标题

686
01:20:54,000 --> 01:20:57,192
，我们不会在这里使用速记签名，我们只是去

687
01:20:57,192 --> 01:21:02,160
这样做，所以现在在选项标题中，我们

688
01:21:02,160 --> 01:21:06,160
实际上要返回一个文本按钮，所以

689
01:21:06,160 --> 01:21:10,960
让我们首先获取这个键的值，所以我只想说

690
01:21:10,960 --> 01:21:15,920
最终 t 值等于选项

691
01:21:15,920 --> 01:21:20,640
在这样的选项标题上

692
01:21:20,640 --> 01:21:23,280
，现在它说是的，你没有使用它，这很好，

693
01:21:23,280 --> 01:21:27,760
我们会很快修复

694
01:21:27,760 --> 01:21:31,280
这个问题，我们在这里看到的这个巨大错误是因为你看到了它

695
01:21:31,280 --> 01:21:35,440
需要的操作 可迭代我相信不，它实际上是一个小部件列表，但是

696
01:21:35,440 --> 01:21:39,920
当你在你的键上做一个映射时，它会返回一个可迭代的，所以为了解决

697
01:21:39,920 --> 01:21:45,040
这个问题，我们将在最后说这是列出

698
01:21:45,040 --> 01:21:49,192
所有好的 所以现在让我们解决我理解的其余问题我的意思是这是

699
01:21:49,192 --> 01:21:52,160
相当多的错误，你可能有点 对此感到不知所措，

700
01:21:52,160 --> 01:21:56,000
但没关系，我们将一次修复一个，所以最后是一个半列，以便

701
01:21:56,000 --> 01:22:02,160
在最后摆脱那个巨大的 er，然后我们将在这里做些什么来

702
01:22:02,160 --> 01:22:05,512
获得价值 我们将创建一个文本按钮，所以我们只说

703
01:22:05,512 --> 01:22:08,832
每个选项都返回一个文本按钮

704
01:22:08,832 --> 01:22:12,720
，正如我们之前看到的，文本按钮需要的

705
01:22:12,720 --> 01:22:20,480
是两个未按下的参数，它还需要我相信它是

706
01:22:20,480 --> 01:22:23,680
平铺的，我们将 说孩子

707
01:22:23,680 --> 01:22:28,000
等于我们

708
01:22:28,000 --> 01:22:31,360
选项标题的文本，

709
01:22:31,360 --> 01:22:34,720
所以我的意思是你可能对这一切有点困惑

710
01:22:34,720 --> 01:22:39,192
，没关系，我们正在做的事情非常简单，我们有一个

711
01:22:39,192 --> 01:22:43,360
标题列表要为每个按钮显示，所以每个 按钮有一个标题，该

712
01:22:43,360 --> 01:22:47,832
标题在这个字符串映射中，它在字符串映射

713
01:22:47,832 --> 01:22:51,040
和可选 t 中的原因仅仅是因为我们不想拥有

714
01:22:51,040 --> 01:22:54,400
我们不想管理两个单独的列表标题列表 和一个

715
01:22:54,400 --> 01:22:57,760
值列表，然后我们将标题与值匹配，并且 map

716
01:22:57,760 --> 01:23:01,832
已经为我们这样做了 此外，带有 at 的字符串映射的作用是

717
01:23:01,832 --> 01:23:06,552
确保在这种字符串类型的情况下每个字符串或每个键都是唯一的，因此

718
01:23:06,552 --> 01:23:10,640
您不能有两个具有相同标题和不同值的按钮，因此

719
01:23:10,640 --> 01:23:14,720
该映射非常适合这种情况 以及我们在这里为

720
01:23:14,720 --> 01:23:18,320
警报对话框的操作所做的我们说好的

721
01:23:18,320 --> 01:23:24,160
我们地图中的每个键都是一个选项标题是一个按钮的标题好吧

722
01:23:24,160 --> 01:23:28,640
所以我们正在映射我们将它映射到什么 每一个

723
01:23:28,640 --> 01:23:31,680
字符串类型的标题都将被映射到一个文本按钮，

724
01:23:31,680 --> 01:23:37,760
其子按钮是实际标题的文本，在这个键内

725
01:23:37,760 --> 01:23:41,760
我明白这可能会令人困惑，但请暂停视频

726
01:23:41,760 --> 01:23:44,800
看看 代码，我相信在我们自己真正考虑过之后，您会更好地理解它

727
01:23:44,800 --> 01:23:47,760
，然后将

728
01:23:47,760 --> 01:23:52,232
提取这种类型的值，我们要做的是我们

729
01:23:52,232 --> 01:23:56,232
要说让我们看看最终值

730
01:23:56,232 --> 01:24:00,160
和 在这里，如果您查看价值，它将是动态的，我们需要

731
01:24:00,160 --> 01:24:05,192
做的是 只是为了确保说如果 value 不为 null

732
01:24:05,192 --> 01:24:08,160
并且我们要说

733
01:24:08,160 --> 01:24:11,512
我们的上下文的导航器已经写了然后我

734
01:24:11,512 --> 01:24:17,280
要说 pop 它用那个 value 否则我们

735
01:24:17,280 --> 01:24:22,080
只会弹出 pop all 对，这就是现在

736
01:24:22,080 --> 01:24:27,832
你明白我们为什么将值定义为可选的原因，因为你会看到一些

737
01:24:27,832 --> 01:24:31,440
值，如果我们回到这里，我们对话框上的某些按钮

738
01:24:31,440 --> 01:24:36,160
实际上可能没有任何值，就像我们在

739
01:24:36,160 --> 01:24:40,000
登录视图中的值一样 此登录视图将有一个错误

740
01:24:40,000 --> 01:24:44,552
对话框，此错误对话框将使用我们的通用对话框，但此空气

741
01:24:44,552 --> 01:24:48,000
对话框将有一个 ok 按钮它没有任何值 OK 只是

742
01:24:48,000 --> 01:24:53,040
一个 ok 只是关闭对话框，这正是 这是怎么做的，因为

743
01:24:53,040 --> 01:24:57,192
你很快就会看到我们实现新的显示错误对话框的方式将

744
01:24:57,192 --> 01:25:01,832
使用我们的通用对话框，但是它会在那里放置一个小的 um 选项

745
01:25:01,832 --> 01:25:07,360
，上面写着 ok 并且 ok 有一个 null 值 好吧

746
01:25:07,360 --> 01:25:11,440
完美的说了很多逻辑 但没关系我们有时 n 需要这样做好吧

747
01:25:14,000 --> 01:25:18,480
哇，我们现在已经编写了我们的通用对话

748
01:25:18,480 --> 01:25:22,800
我们需要做的是我们需要开始使用它，这在

749
01:25:22,800 --> 01:25:25,280
我们现在要实现的错误对话中，所以

750
01:25:25,280 --> 01:25:30,000
让我们继续创建一个错误 对话框，

751
01:25:30,000 --> 01:25:33,280
所以我要调出我的笔记，

752
01:25:33,280 --> 01:25:37,040
让我们作为标题指示在对话框中

753
01:25:37,040 --> 01:25:40,000
让我们看看它在对话框中的位置我们将在此处创建一个名为错误对话框的新文件

754
01:25:40,000 --> 01:25:44,960
，

755
01:25:44,960 --> 01:25:49,040
现在在错误对话框中我们需要做的是我们 需要使用我们的通用对话框，

756
01:25:49,040 --> 01:25:52,232
因此我们需要在此处进行导入，

757
01:25:52,232 --> 01:25:55,680
我们将获得 Visual Studio 代码来帮助我们，因此

758
01:25:55,680 --> 01:26:01,192
请记住错误对话框将仅显示一个确定按钮它没有任何价值，因此

759
01:26:01,192 --> 01:26:05,680
它是简短的错误 对话框将具有与以前完全相同的签名

760
01:26:05,680 --> 01:26:10,320
，这是一个未来的空白，所以让我们继续这样做

761
01:26:10,320 --> 01:26:13,920
，我们将称之为显示错误对话框

762
01:26:13,920 --> 01:26:18,232
，我唯一的意思是淋浴对话框需要的两件事是 一个构建

763
01:26:18,232 --> 01:26:22,400
上下文和一个文本，所以我们说构建上下文

764
01:26:22,400 --> 01:26:26,080
，我们也要去 说一串文本

765
01:26:26,080 --> 01:26:31,192
好，让我们导入材料以消除该

766
01:26:31,192 --> 01:26:36,552
错误，就是这样，然后在这里我们实际上将返回

767
01:26:36,552 --> 01:26:40,160
我们的 show err show generic dialog 的实例

768
01:26:40,160 --> 01:26:46,320
，我认为现在应该导入它是吗 没有自动导入这里

769
01:26:46,320 --> 01:26:51,280
它还没有但不知何故它找到了它我可以看到我们

770
01:26:51,280 --> 01:26:55,680
在这里实际上有一个显示通用对话所以这不是

771
01:26:55,680 --> 01:27:00,160
我们实际要使用的那个所以我们要使用带有 uh 的那个

772
01:27:00,160 --> 01:27:04,720
像这样，然后我们要说我们的空中

773
01:27:04,720 --> 01:27:08,320
对话避免所以让我们导入我们自己的 uh

774
01:27:08,320 --> 01:27:14,160
show Gener um show generic dialog

775
01:27:14,160 --> 01:27:18,960
所以它是一个表演一般对话我真的很好奇一般对话很

776
01:27:18,960 --> 01:27:22,400
有趣所以有一个叫做显示一般对话的功能

777
01:27:22,400 --> 01:27:25,920
但是 这不是我们创建的，我们称之为显示通用方言，所以要

778
01:27:25,920 --> 01:27:29,832
小心一点，因为我现在真的绊倒了所以

779
01:27:29,832 --> 01:27:32,640
让我们回到我们的错误对话框并说显示

780
01:27:32,640 --> 01:27:35,512
通用对话框，它也将

781
01:27:35,512 --> 01:27:39,360
导入 你知道吗 w 所以这是正确的，

782
01:27:39,360 --> 01:27:44,552
所以在最后加一个逗号，让格式也正常工作

783
01:27:44,552 --> 01:27:49,760
，现在在这里添加一个逗号，以便在那里找到格式，

784
01:27:49,760 --> 01:27:52,320
现在我们要硬编码的标题

785
01:27:52,320 --> 01:27:55,192
会说发生了这样的错误

786
01:27:55,192 --> 01:27:58,320
，内容只是

787
01:27:58,320 --> 01:28:02,960
文本，我们的选项生成器现在将是我记得

788
01:28:02,960 --> 01:28:08,480
如果你回到这里，我们的通用对话框的选项生成器是一个

789
01:28:08,480 --> 01:28:13,192
函数，它返回那个 所以让我们在这里定义一个内联函数，我们

790
01:28:13,192 --> 01:28:17,192
说哎呀要删除它，我们说它是一个

791
01:28:17,192 --> 01:28:22,080
返回映射的函数，这里的键

792
01:28:22,080 --> 01:28:26,552
对 null 的值是没问题的，看看怎么看怎么看 现在是通用的，

793
01:28:26,552 --> 01:28:29,760
所以我们实际上定义说这是一个显示空气拨号它

794
01:28:29,760 --> 01:28:33,040
只是不返回任何东西它只是一个空，好吧

795
01:28:33,040 --> 01:28:36,480
，为了让它更干净，你实际上可以在这里指定这是一个

796
01:28:36,480 --> 01:28:40,400
空，好吧 那部分，所以现在我们已经

797
01:28:40,400 --> 01:28:45,512
处理了我们的错误对话，嗯，现在 w 我们需要做的事情是为了让我们的

798
01:28:45,512 --> 01:28:48,872
代码不那么可怕，因为现在有这么多错误，

799
01:28:48,872 --> 01:28:52,000
让我们去清理其中的一些错误，让我们继续在

800
01:28:52,000 --> 01:28:56,720
任何地方使用这个显示错误对话框好吧，让我们开始吧 查看我们的视图并

801
01:28:56,720 --> 01:29:01,680
查看登录视图，您现在可以看到我们有 show air

802
01:29:01,680 --> 01:29:07,192
dialog 现在我们有自己的 uh show air dialog 实现，所以

803
01:29:07,192 --> 01:29:11,512
让我们从 Visual Studio 代码中获取帮助来导入我们的错误对话框

804
01:29:11,512 --> 01:29:16,400
和所有 突然你在登录视图中看到所有错误并消失了

805
01:29:16,400 --> 01:29:21,360
你可以看到我们在登录视图中。 所以让我们保存我们的登录视图

806
01:29:21,360 --> 01:29:25,600
，我们之前的导入有一个错误，它是 show air

807
01:29:25,600 --> 01:29:30,800
dialog dart，所以让我们也删除它，这样

808
01:29:30,800 --> 01:29:35,512
你的登录视图现在应该看起来很干净，我要关闭它，然后让

809
01:29:35,512 --> 01:29:39,680
我' 我要保存我们在这里拥有的所有这些东西，因为我们

810
01:29:39,680 --> 01:29:44,960
有太多的窗口，太多的选项卡打开，这有点吓人，所以让我们

811
01:29:44,960 --> 01:29:49,680
进入注册视图并清理这个导入，所以让我们

812
01:29:49,680 --> 01:29:52,872
从实用程序显示中删除旧的导入 错误对话框

813
01:29:52,872 --> 01:29:56,232
，让我们开始处理这些错误，我们在

814
01:29:56,232 --> 01:30:00,400
这里显示空中拨号并获取 Visual Studio 代码或您最喜欢的编辑器或

815
01:30:00,400 --> 01:30:05,360
ID，以自动导入我们的新功能，称为短错误对话框，它

816
01:30:05,360 --> 01:30:10,160
位于此实用程序对话框中，错误对话框

817
01:30:12,480 --> 01:30:16,320
现在好了 你现在还记得我们在这里打破

818
01:30:16,320 --> 01:30:18,800
了我们的笔记

819
01:30:18,800 --> 01:30:23,360
视图，现在让我们

820
01:30:23,360 --> 01:30:27,440
看看是的，我们打破了笔记视图只是因为我们没有在这里返回任何东西，

821
01:30:27,440 --> 01:30:31,360
因为我们将所有代码迁移或移动到了

822
01:30:31,360 --> 01:30:37,280
笔记列表视图所以什么 w 我现在需要做的是去

823
01:30:37,280 --> 01:30:41,192
基本上处理我们的

824
01:30:41,192 --> 01:30:44,720
显示删除对话好吧，所以这不是我们需要的，我们需要

825
01:30:44,720 --> 01:30:48,320
处理注释视图注销功能，这里是显示

826
01:30:48,320 --> 01:30:53,512
你看到的注销对话所以我们需要 还要创建一个新的注销

827
01:30:53,512 --> 01:30:57,680
对话框，这个注销对话框将与

828
01:30:57,680 --> 01:31:02,400
我们创建 um 错误对话框的方式非常相似，所以它会非常相似，

829
01:31:02,400 --> 01:31:06,232
好吧，所以我真的要我不

830
01:31:06,232 --> 01:31:10,000
知道它是否值得复制 这段代码我通常不喜欢复制，即使它是

831
01:31:10,000 --> 01:31:13,360
我自己的代码，有时我也会这样做，但在这种情况下，我认为

832
01:31:13,360 --> 01:31:17,512
我们手工编写它实际上更好，所以让我们继续，因为标题

833
01:31:17,512 --> 01:31:21,760
指示在对话文件夹内创建一个名为 注销对话框，

834
01:31:21,760 --> 01:31:28,480
所以在这里我要说新文件注销对话框下拉菜单

835
01:31:28,480 --> 01:31:33,760
和注销对话框，所以我也要去我的笔记，然后注销

836
01:31:33,760 --> 01:31:38,960
那个，好吧，让我们去说和 然后我们需要一个名为 show

837
01:31:38,960 --> 01:31:43,512
logout dialog 的函数，因为我们在这里有它，所以我要开始了 g 只是复制该

838
01:31:43,512 --> 01:31:47,920
名称，因此我们将说这是布尔值的未来

839
01:31:47,920 --> 01:31:52,480
并调用 show logout dialog 并且它唯一需要的是构建

840
01:31:52,480 --> 01:31:54,960
上下文 好吧，

841
01:31:54,960 --> 01:31:57,920
我们将因为我们没有构建内容而收到错误 没有它

842
01:31:57,920 --> 01:32:02,800
在我们的文件中，你现在看到我们得到的唯一错误

843
01:32:02,800 --> 01:32:05,832
是说主体可能正常完成

844
01:32:05,832 --> 01:32:08,960
，这意味着是的，它目前没有返回任何值，我们将

845
01:32:08,960 --> 01:32:12,960
修复我们所以我们 需要在这里我们实际上

846
01:32:12,960 --> 01:32:18,232
要返回我们的显示通用对话框并

847
01:32:18,232 --> 01:32:22,160
在末尾自动导入一个逗号和一个分号只是为了获得正确的格式

848
01:32:22,160 --> 01:32:25,832
上下文在那里我们在这种情况下我们实际上要说

849
01:32:25,832 --> 01:32:29,512
显示通用对话将返回一个布尔值，

850
01:32:29,512 --> 01:32:34,000
所以上下文在那里我们需要指定的标题类型我们只是

851
01:32:34,000 --> 01:32:38,640
要说注销并且对于我们要说的内容你确定你想要

852
01:32:38,640 --> 01:32:42,320
注销可选记住它是一个函数，

853
01:32:42,320 --> 01:32:46,400
我们将在这里创建一个匿名函数 并返回一个地图

854
01:32:46,400 --> 01:32:50,232
，对于取消的选项，我们会说假，对于注销的选项，

855
01:32:50,232 --> 01:32:54,400
我们会说真，好吧，我们在这里遇到了一个巨大的错误，

856
01:32:54,400 --> 01:32:59,192
说有一个布尔值的未来 '正在返回一个布尔

857
01:32:59,192 --> 01:33:04,000
可选的函数，该函数应该再次返回公牛的未来记住

858
01:33:04,000 --> 01:33:07,832
在某些平台上，您可以在不实际

859
01:33:07,832 --> 01:33:12,640
响应您实际需要的那些平台中对话中出现的任何选项的情况下关闭对话

860
01:33:12,640 --> 01:33:16,800
通过返回一个默认值来保护自己免受这种情况的影响，

861
01:33:16,800 --> 01:33:20,800
所以让我们在这里说

862
01:33:20,800 --> 01:33:24,552
，如果我们得到这个值，你可以看到它是一个可选的布尔值，那么我们说

863
01:33:24,552 --> 01:33:29,512
要么返回那个值，要么只返回 false，就是这样，我们可以放一个 最后的逗号

864
01:33:29,512 --> 01:33:34,400
也是为了让格式正确 好的

865
01:33:34,400 --> 01:33:38,720
完美 嗯，现在我们需要做的是现在我们已经编写了显示注销

866
01:33:38,720 --> 01:33:42,480
对话框，我们必须使用它，所以让我们进入我们的注释视图

867
01:33:42,480 --> 01:33:45,360
并获得帮助 您最喜欢的编辑器来

868
01:33:45,360 --> 01:33:52,400
导入您的新注销 对话框在这里，这样错误就消失了，

869
01:33:52,400 --> 01:33:56,080
好吧，所以我们实际上已经解决了这个问题，所以我

870
01:33:56,080 --> 01:33:58,400
想做的是，呃，

871
01:33:58,400 --> 01:34:01,192
稍微编辑一下我的标题，我很抱歉，我很抱歉，

872
01:34:01,192 --> 01:34:05,440
因为这个标题不是 完全正确，所以

873
01:34:05,440 --> 01:34:13,440
我需要解决这个问题

874
01:34:13,440 --> 01:34:17,920
，现在我们已经处理了笔记列表视图，让

875
01:34:17,920 --> 01:34:23,280
我们将笔记列表视图带到笔记视图中，这样你就可以看到我们

876
01:34:23,280 --> 01:34:27,832
有我们的笔记视图，但我们也

877
01:34:27,832 --> 01:34:32,480
有我们必须在

878
01:34:37,600 --> 01:34:42,160
此处导入的笔记列表视图 我们的笔记列表

879
01:34:42,160 --> 01:34:44,872
视图的实例，这将自动为我导入它，

880
01:34:44,872 --> 01:34:51,040
就像这样，对于我要说的笔记，这里是所有笔记，

881
01:34:51,040 --> 01:34:54,480
当用户想要删除笔记时，

882
01:34:54,480 --> 01:34:59,120
我将获得视觉效果 工作室代码为我完成，你可以在这里看到

883
01:34:59,120 --> 01:35:04,400
，我们得到用户想要删除的注释，

884
01:35:04,400 --> 01:35:08,720
然后在这里 w 我要让这个函数异步，只是在

885
01:35:08,720 --> 01:35:12,872
我们的节点服务上等待删除这个

886
01:35:12,872 --> 01:35:16,800
带有这个 ID 的节点

887
01:35:16,800 --> 01:35:20,552
好吧我现在要保存如果你在这里查看你的

888
01:35:20,552 --> 01:35:25,832
代码，你可以看到我们在我们的这里有一个错误 笔记列表视图，

889
01:35:25,832 --> 01:35:31,920
让我们继续修复它，我们可以说它说显示删除对话框

890
01:35:31,920 --> 01:35:37,120
，我们还没有真正编写删除对话框，所以

891
01:35:37,120 --> 01:35:41,512
我们需要做的是需要去修复它，以便它创建一个删除

892
01:35:41,512 --> 01:35:44,480
对话框 同样

893
01:35:44,480 --> 01:35:51,040
，让我们进入我们在此

894
01:35:51,040 --> 01:35:56,160
处的实用程序对话框中的对话框，让我们开始并右键单击它并创建

895
01:35:56,160 --> 01:36:00,872
一个名为删除对话框的新文件，删

896
01:36:00,872 --> 01:36:05,512
除对话框将与注销对话框非常相似，所以让我

897
01:36:05,512 --> 01:36:09,512
们只是 继续吧，也许我们可以使用注销对话框，所以

898
01:36:09,512 --> 01:36:13,680
从注销对话框中复制代码并将其放入名为删除对话框的新文件中，然后将其

899
01:36:13,680 --> 01:36:17,040
粘贴到那里，我们将调用此函数

900
01:36:17,040 --> 01:36:20,720
显示删除对话框

901
01:36:20,720 --> 01:36:23,280
好和 它会

902
01:36:23,280 --> 01:36:27,360
在这里和她身上创造一个通用的对话 e 我们会说 delete

903
01:36:27,360 --> 01:36:30,960
并且我们只会说你确定要删除

904
01:36:30,960 --> 01:36:34,552
这个项目 选项生成器将被取消

905
01:36:34,552 --> 01:36:37,280
false 然后我们将有一个选项只是

906
01:36:37,280 --> 01:36:41,760
说 yes true all 现在你知道现在

907
01:36:41,760 --> 01:36:46,232
我们有一个通用对话框是多么容易，只是我们在任何地方都可以重用它

908
01:36:46,232 --> 01:36:50,872
，那么让我们回到我们的笔记列表视图并修复这个函数修复这个函数的

909
01:36:50,872 --> 01:36:53,760
调用并从 Visual Studio 获得帮助 导入我们的

910
01:36:53,760 --> 01:36:56,800
删除对话的代码并且该错误也消失了，

911
01:36:56,800 --> 01:37:02,400
所以现在我保存了我的项目，突然之间，您看到

912
01:37:02,400 --> 01:37:06,480
我们的每个图块上都出现了删除图标，

913
01:37:06,480 --> 01:37:10,160
我们现在应该准备好将其实际投入测试，所以我 在

914
01:37:10,160 --> 01:37:14,400
这里点击 hello world 项目，现在你看到它说你确定要

915
01:37:14,400 --> 01:37:18,800
删除删除这个项目按取消不会做任何事情，但如果我按下它

916
01:37:18,800 --> 01:37:24,232
并说是，那么你好世界注释被删除并且我们的 notes 视图正在

917
01:37:24,232 --> 01:37:29,512
从其流构建器中收到有关该信息的通知，因为请记住 r

918
01:37:29,512 --> 01:37:32,720
notes 服务，因为我们在这里拥有它，让我们在这里转到我们的

919
01:37:32,720 --> 01:37:35,760
服务，呃

920
01:37:35,760 --> 01:37:39,512
，删除节点时的 crud 和节点服务让我们

921
01:37:39,512 --> 01:37:44,080
看看这里的泄漏节点功能，你会看到它的作用是，如果它可以删除

922
01:37:44,080 --> 01:37:49,192
一个节点，它实际上会删除它 从它的节点数组中，它通知

923
01:37:49,192 --> 01:37:53,920
流控制器实际上不是，那是删除节点

924
01:37:53,920 --> 01:37:58,640
哦，是的，基本上它删除了节点，然后将整个节点数组

925
01:37:58,640 --> 01:38:03,760
放在节点流控制器中，这就是注释视图如何

926
01:38:03,760 --> 01:38:07,600
收到删除通知的方式 如果您愿意，我们可以删除另一个项目

927
01:38:07,600 --> 01:38:12,720
，

928
01:38:12,720 --> 01:38:16,160
在这一章中坚持我，这可能是最具

929
01:38:16,160 --> 01:38:20,800
挑战性的章节之一，因为我们从一开始就有很多错误

930
01:38:20,800 --> 01:38:25,832
，我们有 修复它们，但我本课程的目标之一

931
01:38:25,832 --> 01:38:29,280
不仅仅是让你学习如何编写颤振应用程序，而是真正进入

932
01:38:29,280 --> 01:38:34,160
软件开发人员的心态，所以每个软件开发人员都有

933
01:38:34,160 --> 01:38:37,760
自己的偏好 包括在内，当我进行重构时，我的一个偏好

934
01:38:37,760 --> 01:38:40,480
是就像我在本章开头提到的那样从源代码中删除东西

935
01:38:40,480 --> 01:38:44,000
，这就是为什么我们一开始就有这么多错误，

936
01:38:44,000 --> 01:38:47,360
但你坚持我，我们修复了所有这些 错误，现在我们从本章中走出来

937
01:38:47,360 --> 01:38:53,440
实际上是非常胜利的，所以现在我们有了删除功能

938
01:38:53,440 --> 01:38:58,000
，我们现在需要做的就是去，因为我们已经做了很多工作，所以

939
01:38:58,000 --> 01:39:02,320
我们现在需要确保的是提交 并标记我们的工作，这样我们就不会

940
01:39:02,320 --> 01:39:06,160
丢失这项工作，所以嗯，我要

941
01:39:06,160 --> 01:39:11,440
在这里对窗户进行一些 um 重组，这样你就可以更好地看到一些东西，

942
01:39:11,440 --> 01:39:16,552
我会增加尺寸，现在让我们

943
01:39:16,552 --> 01:39:20,552
看看我们是否 看看之前的标签，我们从上一章来到标签 15

944
01:39:20,552 --> 01:39:25,600
，现在我们需要做一个标签 16

945
01:39:25,600 --> 01:39:29,512
之前的显示错误

946
01:39:29,512 --> 01:39:34,080
对话框我们也对不起，我们还在 l 下添加了一个全新的

947
01:39:34,080 --> 01:39:38,320
文件夹 ib 实用程序对话，

948
01:39:38,320 --> 01:39:42,640
所以让我们开始吧，让我们看看

949
01:39:42,640 --> 01:39:45,760
状态很多事情都改变了，我们要做的是我们

950
01:39:45,760 --> 01:39:48,720
将提交这些，让我们说第

951
01:39:48,720 --> 01:39:53,760
16 步好了，然后将您的更改推送到您的

952
01:39:53,760 --> 01:40:00,160
托管 git repo 我们也将标记为第 16 步，

953
01:40:00,160 --> 01:40:05,280
所以如果您现在查看您的标签，我们将推送我们的标签，您

954
01:40:05,280 --> 01:40:09,680
有 1 二三四五六七等等等等，所以我们有所有的

955
01:40:09,680 --> 01:40:14,800
标签 包括第 16 步。好吧，这是为了提交和

956
01:40:14,800 --> 01:40:17,760
标记我们的工作，因为它是传统 我们

957
01:40:17,760 --> 01:40:22,160
将讨论我们需要在下一章讨论的内容

958
01:40:22,160 --> 01:40:25,680
你可以看到我们有能力创建新的笔记，我们 也有

959
01:40:25,680 --> 01:40:28,872
删除笔记的能力，还有我们没有测试的

960
01:40:28,872 --> 01:40:33,440
东西，当我们创建一个新笔记时，如果我们退出它，你会看到那个

961
01:40:33,440 --> 01:40:37,280
笔记实际上是从数据库中删除的，所以这也是有效的，所以我们

962
01:40:37,280 --> 01:40:40,160
有删除笔记的能力和创建笔记的能力，但我们

963
01:40:40,160 --> 01:40:43,920
没有能力 更新笔记，这正是我们将

964
01:40:43,920 --> 01:40:47,512
在下一章讨论的内容，所以我会在那里见到你们，

965
01:40:47,512 --> 01:40:51,832
大家好，欢迎来到前几章中屠宰课程的第 34

966
01:40:51,832 --> 01:40:55,600
章，我们一直在谈论如何 我们可以创建

967
01:40:55,600 --> 01:40:59,192
和注释以及如何删除它们，因此我们一直在使用一些

968
01:40:59,192 --> 01:41:03,120
通用对话进行大量工作，我们还开发了这些通用对话，以便能够处理

969
01:41:03,120 --> 01:41:06,960
错误对话以及例如注销对话以及

970
01:41:06,960 --> 01:41:10,400
删除对话，所以这方面已经做了很多工作

971
01:41:10,400 --> 01:41:15,512
，但我们还没有真正讨论过用户如何点击或

972
01:41:15,512 --> 01:41:18,960
点击他们现有的笔记，以便能够

973
01:41:18,960 --> 01:41:23,192
更新它，例如更新它 特定的节点，这就是

974
01:41:23,192 --> 01:41:27,440
我们在本章中要处理的内容，

975
01:41:27,440 --> 01:41:30,480
所以如果我们现在开始查看

976
01:41:30,480 --> 01:41:34,160
我们为您编写的代码，您会看到我们已经

977
01:41:34,160 --> 01:41:39,192
将实际创建注释的视图称为新节点

978
01:41:39,192 --> 01:41:42,000
但是我们不会去创建一个

979
01:41:42,000 --> 01:41:47,512
全新的 vi  ew 看起来与这个新的笔记视图完全相同，这样我们就可以

980
01:41:47,512 --> 01:41:51,920
更新现有的笔记，所以本章的目标是重用这个视图，

981
01:41:51,920 --> 01:41:55,832
这样我们就可以使用完全相同的视图，但是

982
01:41:55,832 --> 01:41:59,440
当用户点击笔记时 在笔记列表中，我们将把

983
01:41:59,440 --> 01:42:03,512
点击的笔记传递给现有的视图

984
01:42:07,360 --> 01:42:10,720
更好的是，我会

985
01:42:10,720 --> 01:42:14,000
像往常一样在这里调出 Visual Studio 代码，

986
01:42:14,000 --> 01:42:20,000
我有 scrcpy 负责处理这个 android 屏幕

987
01:42:20,000 --> 01:42:23,760
，然后我们可以看看我们必须做的第一个任务，正如你

988
01:42:23,760 --> 01:42:29,040
在缓存中看到的那样，它说我们 必须将新节点重命名为您的 dart 以创建

989
01:42:29,040 --> 01:42:33,760
更新节点视图，好吧，所以让我们处理一下，我将关闭

990
01:42:33,760 --> 01:42:37,120
此处的所有选项卡，让我们说命令 p visual

991
01:42:37,120 --> 01:42:42,080
studio code 或者 android studio 是另一个命令 您必须

992
01:42:42,080 --> 01:42:45,920
按顺序执行才能显示我不知道的文件列表

993
01:42:45,920 --> 01:42:49,512
android studio 中的命令，但如果您对其中任何一个不满意，

994
01:42:49,512 --> 01:42:54,552
您可以直接在此处转到这个新的笔记视图，我们将重命名它，

995
01:42:54,552 --> 01:42:57,600
所以我们现在就这样做，所以我

996
01:42:57,600 --> 01:43:02,000
只是作为缓存调用 在这种情况下创建更新注释视图好的

997
01:43:02,000 --> 01:43:09,192
创建更新注释视图如果更新我的意思是如果你的编辑

998
01:43:09,192 --> 01:43:14,320
器足够智能并且它内置了一些类似的重构功能

999
01:43:14,320 --> 01:43:16,960
那么你不必为此命令做任何特殊

1000
01:43:16,960 --> 01:43:21,040
的事情 工作但是你可以

1001
01:43:21,040 --> 01:43:25,280
在这里看到例如现在我们已经更改了这个文件名来创建更新

1002
01:43:25,280 --> 01:43:30,232
节点视图但是我们并没有真正改变例如类名所以如果我去

1003
01:43:30,232 --> 01:43:34,640
这里这个东西仍然被称为新节点查看全部 好吧

1004
01:43:34,640 --> 01:43:39,920
，让我们进去，也许也改变一下，让我去我的笔记，

1005
01:43:39,920 --> 01:43:45,512
嗯，让我们看看创建更新笔记视图，我们实际上要

1006
01:43:45,512 --> 01:43:50,000
重命名这个新的笔记视图，所以让我们继续做一些

1007
01:43:50,000 --> 01:43:54,080
重构 在这里，我只想说重构，让我们看看我们有没有

1008
01:43:54,080 --> 01:44:00,552
这里有任何重构功能，我们有重命名符号，所以也许让我们使用

1009
01:44:00,552 --> 01:44:06,800
它，我将调用它创建更新节点视图，

1010
01:44:06,800 --> 01:44:09,832
让我们看看它

1011
01:44:09,832 --> 01:44:13,600
是否能够成功地为我重命名它，所以我可以看到它重命名了类 我和

1012
01:44:13,600 --> 01:44:18,480
它还重命名了状态类，这正是我所需要的，所以如果我现在保存

1013
01:44:18,480 --> 01:44:22,552
它，我们应该会遇到一些问题，请原谅，

1014
01:44:22,552 --> 01:44:26,080
但我可以看到 Visual Studio 代码实际上足够智能，可以

1015
01:44:26,080 --> 01:44:30,000
将主要 dart 引用重命名为这条路线以及

1016
01:44:30,000 --> 01:44:33,600
记住 当我们创建这个创建

1017
01:44:33,600 --> 01:44:36,552
或者在它被调用之前我们实际上称之为

1018
01:44:36,552 --> 01:44:38,800
um new note view 时

1019
01:44:38,800 --> 01:44:43,680
，note view 是一个新的 note view 实际上是在我们的路由中使用的，在我们的

1020
01:44:43,680 --> 01:44:48,080
main.dart 中我们的应用程序的 main 函数中，现在

1021
01:44:48,080 --> 01:44:52,800
我们 '已将其重命名以创建更新注释查看类名、有状态

1022
01:44:52,800 --> 01:44:57,512
小部件及其状态，然后应在 main.dart 中使用该新名称，

1023
01:44:57,512 --> 01:45:01,360
因此如果您使用 vim 或任何其他

1024
01:45:01,360 --> 01:45:04,872
代码编辑器，例如使用 sublime 供应 可能没有这个参考

1025
01:45:04,872 --> 01:45:10,160
可以实际去重命名您使用该符号的位置的演员功能，

1026
01:45:10,160 --> 01:45:13,120
因此您可能需要手动执行此操作，因此您实际上可能会在 main.dart 文件中遇到一些错误，

1027
01:45:13,120 --> 01:45:16,960
但如果您遇到这些错误，请不要

1028
01:45:16,960 --> 01:45:19,832
担心 至少你知道问题是什么，所以你可以自己去解决它，

1029
01:45:23,040 --> 01:45:27,192
所以我们已经完成了，现在我们需要做的是我实际上

1030
01:45:27,192 --> 01:45:30,160
要在这里按 command s，在这里按 command s 只是为了 确保所有内容

1031
01:45:30,160 --> 01:45:35,360
都已保存，并且如标题所示，请记住我们在常量中也有我们的路由，

1032
01:45:35,360 --> 01:45:39,600
因此您可以看到我们的路由仍然称为

1033
01:45:39,600 --> 01:45:44,080
新节点路由，好吧，所以我现在要重命名它，我

1034
01:45:44,080 --> 01:45:48,160
建议您也做同样的事情让我们说 重命名，让我们将

1035
01:45:48,160 --> 01:45:54,080
其重命名为缓存指示创建或更新节点路由可以，所以创建或

1036
01:45:54,080 --> 01:45:59,600
更新雪就像那样，你可以再次看到，Visual Studio

1037
01:45:59,600 --> 01:46:03,760
代码帮助了我们很多，现在它也更新了，

1038
01:46:03,760 --> 01:46:05,832
你看对了

1039
01:46:05,832 --> 01:46:09,512
笔记视图中也发生了一些事情 我可以看到，那是

1040
01:46:09,512 --> 01:46:12,800
因为你看到了我们

1041
01:46:12,800 --> 01:46:19,040
在这里实际按下加号按钮的位置，以创建一个新节点，该节点也使用 uh

1042
01:46:19,040 --> 01:46:21,680
以前 uh 命名的

1043
01:46:21,680 --> 01:46:26,640
新节点路由，但现在它已更新以创建或更新节点路由，所以我只是

1044
01:46:26,640 --> 01:46:31,120
试图在这里说您需要重命名该路由，以便它成为创建或

1045
01:46:31,120 --> 01:46:35,360
更新新节点路由，并且根据您的编辑器，它可能足够聪明，可以

1046
01:46:35,360 --> 01:46:38,160
拥有一些重构功能，如果它像 Visual Studio 代码那么您

1047
01:46:38,160 --> 01:46:42,232
就可以了 重命名它，但如果不是，您可能必须手动执行此操作，所以请

1048
01:46:42,232 --> 01:46:46,720
继续并重命名您在代码中重构的地方，您正在使用

1049
01:46:46,720 --> 01:46:50,640
该路线使用新名称，好吧，

1050
01:46:50,640 --> 01:46:54,160
现在让我们看看这个困境

1051
01:46:54,160 --> 01:46:57,120
你在我们的

1052
01:46:57,120 --> 01:47:01,360
笔记视图中看到当我们创建一个新笔记时我们只是说

1053
01:47:01,360 --> 01:47:09,040
上下文推送名称的导航器现在这里的目标是当我们创建这个

1054
01:47:09,040 --> 01:47:13,512
节点列表视图时我们将允许你在我们拥有的那一刻看到的用户

1055
01:47:13,512 --> 01:47:17,920
删除节点，但我们还将有一个名为 unta 的参数 p 我们

1056
01:47:17,920 --> 01:47:22,080
很快就会开发它，但这里的困境是，当

1057
01:47:22,080 --> 01:47:26,080
你说点击时我们还需要进入这个视图，进入

1058
01:47:26,080 --> 01:47:31,280
这个我们已经创建或更新节点路由的路由，但我们必须

1059
01:47:31,280 --> 01:47:35,832
向那个路由传递一个参数 参数就像函数

1060
01:47:35,832 --> 01:47:40,480
的参数或函数的参数一样，就像您传递给该

1061
01:47:40,480 --> 01:47:45,192
路由的数据一样，您说嘿，我正在初始化此路由，但我正在将一些数据传递给

1062
01:47:45,192 --> 01:47:51,192
它，然后该路由 然后可以反过来反应性地抱歉，拉尔夫可以对此

1063
01:47:51,192 --> 01:47:55,040
做出反应并去阅读那个论点并说哦，我是否通过了一个

1064
01:47:55,040 --> 01:47:58,872
论点是的然后我会这样做如果我没有通过一个论点那么我

1065
01:47:58,872 --> 01:48:03,680
会做某事 否则在这种情况下，如果您将便笺传递给我们的创建或

1066
01:48:03,680 --> 01:48:07,600
更新便笺路线，那么它会说哦，我有一个现有节点，我

1067
01:48:07,600 --> 01:48:11,760
将使用该便笺填充自己和我的内容，并且我不会

1068
01:48:11,760 --> 01:48:16,080
创建 新节点记住我们的创建更新注释

1069
01:48:16,080 --> 01:48:18,960
视图我们在这里设置了这个功能

1070
01:48:18,960 --> 01:48:24,232
，说创建一个新节点 w node 我们很快就会解决这个问题，但请记住，

1071
01:48:24,232 --> 01:48:28,640
当您默认进入该视图时，它正在创建一个新节点，

1072
01:48:28,640 --> 01:48:31,920
我们将对其进行更改，以便我们说我们将重命名它并且

1073
01:48:31,920 --> 01:48:37,040
说像创建或获取注释或类似的东西很快你会看到嗯

1074
01:48:37,040 --> 01:48:39,600
但是在那个函数中我们会说我们在

1075
01:48:39,600 --> 01:48:44,080
哪里传递了一个参数，如果是，我们

1076
01:48:44,080 --> 01:48:48,232
不需要创建一个新节点 如果没有，我们必须创建一个好的，

1077
01:48:48,232 --> 01:48:53,440
所以参数的工作方式是，如果您查看我们的注释视图，

1078
01:48:53,440 --> 01:48:58,552
我们正在使用推送名称，这里有一个称为参数的参数，

1079
01:48:58,552 --> 01:49:02,800
正如您目前所看到的那样 一个可选对象，这意味着它

1080
01:49:02,800 --> 01:49:06,720
可以是 no 或 no 我们不是我们目前没有利用它，

1081
01:49:06,720 --> 01:49:12,080
但我们很快就会在调用端创建一个

1082
01:49:12,080 --> 01:49:15,120
你正在创建路由的地方和 将其推送到

1083
01:49:15,120 --> 01:49:19,832
导航堆栈，您可以使用该 arguments 参数传递您的参数，

1084
01:49:19,832 --> 01:49:23,120
并在 thi 的接收方 s case

1085
01:49:23,120 --> 01:49:27,680
are let's see create or update node view here

1086
01:49:27,680 --> 01:49:32,232
in here 你可以阅读然后你的论点

1087
01:49:32,232 --> 01:49:36,232
让我们看看让我们去一些有意义的地方让我们说在这里

1088
01:49:36,232 --> 01:49:40,552
好吧你可以阅读那个参数调用现在你不必输入 我正在打字，

1089
01:49:40,552 --> 01:49:46,400
我只是在向你展示一些东西，好吧，我们可以使用模型 uh 路线

1090
01:49:46,400 --> 01:49:51,760
，我们说的是上下文，然后你可以说设置

1091
01:49:51,760 --> 01:49:58,552
点参数，那么这就是你基本上可以

1092
01:49:58,552 --> 01:50:03,920
通过你的模态路线访问你的参数的地方所以现在 你知道如何传递参数，你也

1093
01:50:03,920 --> 01:50:08,080
知道如何接收它们，所以

1094
01:50:08,080 --> 01:50:12,320
让我们进入下一点，嗯，你知道

1095
01:50:12,320 --> 01:50:19,120
我们将来可能需要在某个地方在我们的

1096
01:50:19,120 --> 01:50:23,440
任何小部件中接收一个参数，这个参数可以是任何

1097
01:50:23,440 --> 01:50:27,440
您指定的类型，例如，您可以将整数从一个屏幕传递到另一个屏幕，或者

1098
01:50:27,440 --> 01:50:31,280
您可以传递一个字符串，或者您可以传递一个数组，或者在我们的例子中，您可以传递一个

1099
01:50:31,280 --> 01:50:35,360
数据库节点，这样您就可以在这段代码中看到让我们开始

1100
01:50:35,360 --> 01:50:39,120
吧 在这里嗯

1101
01:50:39,120 --> 01:50:44,000
这是什么可选的设置 d 然后

1102
01:50:44,000 --> 01:50:48,160
你现在看到的参数这个家伙是一个对象，所以它并不真正知道它

1103
01:50:48,160 --> 01:50:51,120
是什么，但如果你能

1104
01:50:51,120 --> 01:50:55,280
以某种方式创建一个函数，让我们只说

1105
01:50:55,280 --> 01:51:01,920
例如上下文获取类型的对象，那就太好了 类似这样的东西，所以我们

1106
01:51:01,920 --> 01:51:04,960
可以说给定一个构建上下文

1107
01:51:04,960 --> 01:51:10,872
，如果该参数存在，我们想从中提取任何类型的参数

1108
01:51:10,872 --> 01:51:13,680
，然后我们将在我们的代码中使用它

1109
01:51:13,680 --> 01:51:18,800
，然后我们得到我们的构建 上下文，然后从中取出我们的笔记，

1110
01:51:18,800 --> 01:51:23,440
所以我们要做的就是创建一种从构建上下文中提取参数的通用方法

1111
01:51:23,440 --> 01:51:27,440
，这正是我们现在要做的，

1112
01:51:30,480 --> 01:51:34,080
所以我们要做 将在构建上下文中创建一个扩展，该

1113
01:51:34,080 --> 01:51:39,040
扩展将被称为访客参数，正如我在 um 中指出的那样，

1114
01:51:39,040 --> 01:51:43,192
正如我在屏幕底部的标题中指出的那样，您

1115
01:51:43,192 --> 01:51:46,160
可以看到我们将

1116
01:51:46,160 --> 01:51:52,552
在 lib 实用程序泛型下创建一个新文件，并且文件调用获取参数，因此您可以看到我们

1117
01:51:52,552 --> 01:51:57,120
此刻这里有实用程序，而实用程序跟随我只是

1118
01:51:57,120 --> 01:52:01,120
把所有东西都折叠在这里，所以看起来并不可怕，你可以看到实用程序

1119
01:52:01,120 --> 01:52:04,720
现在有一个名为 dialogs 的文件夹，但

1120
01:52:04,720 --> 01:52:08,160
我们要创建的是一个名为 generics 的文件夹和 然后是一个

1121
01:52:08,160 --> 01:52:11,920
名为 get arguments 的文件，好吧，所以

1122
01:52:11,920 --> 01:52:17,680
我们现在就开始吧，所以我要去 uh

1123
01:52:17,680 --> 01:52:21,760
utility where to go 实用程序对话好了，所以我要

1124
01:52:21,760 --> 01:52:25,920
右键单击实用程序并说新文件 我要说泛型

1125
01:52:25,920 --> 01:52:30,800
歌词并获取参数 dot

1126
01:52:30,800 --> 01:52:36,320
dart 现在在这里我们需要的是嗯

1127
01:52:36,320 --> 01:52:41,440
，开始编写我们的扩展，所以我只想说扩展

1128
01:52:41,440 --> 01:52:45,920
并获取关于构建上下文的参数，

1129
01:52:45,920 --> 01:52:50,080
如果我输入 build context visual 现在可以了

1130
01:52:50,080 --> 01:52:54,000
如果您使用 sublime 或任何其他文本编辑器，工作室代码足够聪明，可以导入材料，

1131
01:52:54,000 --> 01:52:57,192
它可能不够聪明，无法做到这一点，因为您可能不

1132
01:52:57,192 --> 01:53:00,720
喜欢使用 dart 和颤振等的扩展

1133
01:53:00,720 --> 01:53:05,512
，所以您可能不得不 自己进口材料 不记得我们也

1134
01:53:05,512 --> 01:53:10,080
只需要 um build context and modal route from

1135
01:53:10,080 --> 01:53:15,360
the entire material uh packaging here，所以

1136
01:53:15,360 --> 01:53:19,360
如果你只是说显示构建上下文

1137
01:53:19,360 --> 01:53:23,440
和模态

1138
01:53:23,440 --> 01:53:29,600
路径会更有意义，所以我们不会使用更多来自 材料包

1139
01:53:29,600 --> 01:53:32,640
比这

1140
01:53:32,640 --> 01:53:36,552
两个好，所以让我们继续创建这个函数，所以我们

1141
01:53:36,552 --> 01:53:42,320
说我们将有选择地返回一个类型为 t 的值，这意味着

1142
01:53:42,320 --> 01:53:46,800
您要求我们使用的任何类型，我们将调用它 函数获取

1143
01:53:46,800 --> 01:53:51,920
参数没问题，并且获取参数本身可以，

1144
01:53:51,920 --> 01:53:56,640
所以在这里我们要说的是模态路由

1145
01:53:56,640 --> 01:54:01,360
是我们构建上下文的模型路由，

1146
01:54:01,360 --> 01:54:05,760
或者因为你看到我们正在创建一个构建上下文的扩展

1147
01:54:05,760 --> 01:54:11,192
并且 这里的这个标识符是指

1148
01:54:11,192 --> 01:54:15,192
实际调用 get 参数函数的当前构建上下文，所以如果你不

1149
01:54:15,192 --> 01:54:18,800
熟悉我之前讨论过的扩展

1150
01:54:18,800 --> 01:54:23,600
，所以我认为它也是 dart 介绍的一部分 开始

1151
01:54:23,600 --> 01:54:26,872
绝对开始 这门课程，所以你可能想回到那个，以

1152
01:54:26,872 --> 01:54:32,160
了解扩展是如何工作的

1153
01:54:36,000 --> 01:54:40,800
反对这一点，所以我们只说如果模态

1154
01:54:40,800 --> 01:54:44,000
路由不为空

1155
01:54:44,000 --> 01:54:47,600
，否则我们将返回 null 我们说如果我们无法

1156
01:54:47,600 --> 01:54:52,800
获得模型路由，那么我们就无法从中提取任何参数，所以让我们得到

1157
01:54:52,800 --> 01:54:55,192
现在让我们从我们的模型路由中获取所有参数，

1158
01:54:55,192 --> 01:54:59,680
所以我们要说 args 是模型路由设置

1159
01:54:59,680 --> 01:55:06,320
点参数，然后记住 args 现在也是一个对象，因为它

1160
01:55:06,320 --> 01:55:11,760
在调用站点上调用站点可能会跳过传递参数 对我们来说，在

1161
01:55:11,760 --> 01:55:14,960
这种情况下，我们不会得到任何参数，这意味着

1162
01:55:14,960 --> 01:55:19,360
args 在这里将是 null

1163
01:55:23,832 --> 01:55:29,832
我们将返回 rx 好吧 呃 oops

1164
01:55:29,832 --> 01:55:35,120
rx as t 所以我们在这里说的是如果

1165
01:55:35,120 --> 01:55:40,320
我们可以从我们的模态路由设置参数中获取任何参数，如果

1166
01:55:40,320 --> 01:55:45,280
该参数是您要求此函数提取的类型，那么

1167
01:55:45,280 --> 01:55:48,640
我们将把它还给它，否则我们将进入行

1168
01:55:48,640 --> 01:55:52,872
号 12 在这里，只是返回和 null 好了，

1169
01:55:52,872 --> 01:55:56,872
现在我要保存这个文件，好吧

1170
01:55:56,872 --> 01:56:01,832
，这就是那部分现在我们需要的是让我调出

1171
01:56:01,832 --> 01:56:06,080
标题，这样你就可以看到我们必须做什么，

1172
01:56:06,080 --> 01:56:11,760
现在让我们进入我们的视图 我们称之为创建实际上

1173
01:56:11,760 --> 01:56:15,040
现在很容易，因为我们的项目中有很多文件，

1174
01:56:15,040 --> 01:56:18,872
如果我们只是在 Visual Studio 代码中执行命令 p 例如跳转

1175
01:56:18,872 --> 01:56:23,512
到特定文件，那么导航实际上更容易，因此在该文件中它现在称为

1176
01:56:23,512 --> 01:56:27,192
创建 更新节点视图所以让我们去那里

1177
01:56:27,192 --> 01:56:32,480
，因为标题表明我们在这里创建注释让

1178
01:56:32,480 --> 01:56:36,480
我们看看我们是否可以找到该功能创建新节点在这里你看到

1179
01:56:36,480 --> 01:56:40,960
所以我们需要做的是我们只需要重命名那个 um

1180
01:56:40,960 --> 01:56:44,872
create 要求他们创建或获取现有字幕的新注释

1181
01:56:44,872 --> 01:56:48,640
笔记，所以我会这样做，我会说创建

1182
01:56:48,640 --> 01:56:53,832
或获取现有笔记，然后我们再次将代码

1183
01:56:53,832 --> 01:56:57,920
做得足够聪明，以重命名我实际使用该功能的位置，你可以

1184
01:56:57,920 --> 01:57:02,552
在这里看到，好吧，否则你可能会如果 您没有使用

1185
01:57:02,552 --> 01:57:05,920
可视代码，或者如果您没有使用您最喜欢的编辑器的重构功能，

1186
01:57:05,920 --> 01:57:10,640
您可能还必须重命名该调用站点，

1187
01:57:10,640 --> 01:57:14,400
所以我认为我不必再次提及这个我想我现在已经 提到它

1188
01:57:14,400 --> 01:57:17,512
三遍，所以如果你要重命名某些东西，请

1189
01:57:17,512 --> 01:57:23,440
确保所有调用站点也都更新

1190
01:57:23,440 --> 01:57:29,600
好了，所以现在我们已经完成了，如果它已经存在，我们实际上需要获取现有节点

1191
01:57:32,960 --> 01:57:37,832
好的，所以让我们这样做，你可以看到它在

1192
01:57:37,832 --> 01:57:42,872
创建或获取现有的没有得到注释参数，如果有的

1193
01:57:42,872 --> 01:57:48,720
话，那么让我们在这里说如果我们的小部件（如实际调用我们的小部件）

1194
01:57:48,720 --> 01:57:52,720
创建了我们，是否已经向我们传递了一个参数 类型为

1195
01:57:52,720 --> 01:57:56,080
数据库注释，那么我们就可以了，所以我们就称它为小部件

1196
01:57:56,080 --> 01:57:58,872
注释是 嗯，

1197
01:57:58,872 --> 01:58:02,552
我们现在需要一个构建上下文，因为记住我们的扩展是在构建上下文中创建的，

1198
01:58:02,552 --> 01:58:06,720
但是这个函数目前没有构建上下文，所以让我们

1199
01:58:06,720 --> 01:58:10,160
继续在这里传递一个构建上下文，

1200
01:58:10,160 --> 01:58:13,760
好吧，然后让我们进入调用站点并

1201
01:58:13,760 --> 01:58:17,832
传递构建 这里的上下文调用上下文，它在构建函数中传递给我们，

1202
01:58:17,832 --> 01:58:23,120
所以相信你已经完成了，

1203
01:58:23,120 --> 01:58:26,480
我们现在要去说上下文获取

1204
01:58:26,480 --> 01:58:31,832
，你现在看到我们需要我们的 get 参数函数，但是因为我 在这里没有输入任何内容

1205
01:58:31,832 --> 01:58:35,192
，那是因为我们没有导入，所以

1206
01:58:35,192 --> 01:58:38,640
我可以看看我是否只是输入 get the argument 并询问 Visual Studio 代码

1207
01:58:38,640 --> 01:58:43,480
是否可以为我解决这个问题它说哦，又是

1208
01:58:43,480 --> 01:58:47,440
arguments.dart 有一个函数的文件你想让我导入它，所以

1209
01:58:47,440 --> 01:58:50,960
我只想说是，否则如果你不这样做，你

1210
01:58:50,960 --> 01:58:55,600
可能必须手动导入你的 get arguments.dart 文件，所以

1211
01:58:55,600 --> 01:58:59,192
现在我 只是说获取参数并记住获取参数

1212
01:58:59,192 --> 01:59:05,040
本身的功能哈 s没有参数所以你怎么调用这个函数好你怎么告诉

1213
01:59:05,040 --> 01:59:09,440
它提取类似的数据库节点这很

1214
01:59:09,440 --> 01:59:13,680
容易你只需把这个小于号和等级它放在

1215
01:59:13,680 --> 01:59:18,000
里面然后你输入对象的类型 你想提取所以如果我们

1216
01:59:18,000 --> 01:59:21,680
只是说数据库注释好了

1217
01:59:21,680 --> 01:59:27,192
，现在我们这样做了，记住 get 参数返回该类型的可选对象

1218
01:59:27,192 --> 01:59:31,680
，在这种情况下，我们的数据库节点是一个可选的数据库节点，

1219
01:59:31,680 --> 01:59:35,040
这意味着你要么有 一个节点，

1220
01:59:35,040 --> 01:59:38,960
以便用户点击现有节点并来到这里，或者你并不

1221
01:59:38,960 --> 01:59:43,360
意味着用户点击了加号按钮并来到这里没问题，

1222
01:59:43,360 --> 01:59:48,640
所以我们说如果小部件节点不为空，这意味着我们正在

1223
01:59:48,640 --> 01:59:52,232
更新 现有节点，以便用户点击现有节点并最终出现

1224
01:59:52,232 --> 01:59:54,640
在屏幕上然后我们将要做的我们

1225
01:59:54,640 --> 01:59:59,280
将把它保存在我们的节点私有变量中，

1226
01:59:59,280 --> 02:00:02,872
我想我们在这里的某个地方设置它你看

1227
02:00:02,872 --> 02:00:05,760
所以我们要说我们的节点是 widge  t 节点

1228
02:00:05,760 --> 02:00:09,120
好的，在这种情况下，我们还需要做的

1229
02:00:09,120 --> 02:00:15,120
是确保我们屏幕上的文本字段

1230
02:00:15,120 --> 02:00:17,920
，我可以在这里显示给你，所以如果你去这里

1231
02:00:17,920 --> 02:00:22,080
这个文本字段应该预先填充现有的 注释

1232
02:00:22,080 --> 02:00:26,720
文本和我们可以做到的方式我的意思是我们没有直接访问我们的文本

1233
02:00:26,720 --> 02:00:31,680
字段但我们拥有的是我们在这里设置的文本控制器文本

1234
02:00:31,680 --> 02:00:36,320
控制器好的所以让我们去设置文本控制器的文本所以 我只想

1235
02:00:36,320 --> 02:00:42,000
说文本控制器文本等于小部件注释

1236
02:00:42,000 --> 02:00:46,480
点文本，然后我们将返回

1237
02:00:46,480 --> 02:00:51,680
小部件注释，以便我们

1238
02:00:51,680 --> 02:00:55,192
可以提取的注释没问题，否则

1239
02:00:55,192 --> 02:00:59,600
我们在这里所做的就是说 现有的注释注释，所以

1240
02:00:59,600 --> 02:01:03,512
逻辑将保持不变，所以如果我们可以从

1241
02:01:03,512 --> 02:01:08,232
传递的小部件或颜色小部件中提取节点，那么我们将其设置为我们的节点设置文本，

1242
02:01:08,232 --> 02:01:12,160
然后只返回小部件注释，否则我们将继续 就像我们

1243
02:01:12,160 --> 02:01:16,552
之前做的那样，让我们在这里看看我们也在做什

1244
02:01:16,552 --> 02:01:21,680
么 请注意，我们只是返回，但我也可以看到，

1245
02:01:21,680 --> 02:01:26,720
在这里创建笔记时，我们没有设置该笔记，所以我们需要在这里做的，

1246
02:01:26,720 --> 02:01:31,040
让我们说最后的新笔记好吧

1247
02:01:31,040 --> 02:01:35,440
，然后我们存储该笔记我们 说笔记是

1248
02:01:35,440 --> 02:01:39,760
新笔记然后我们只是说返回你知道所以

1249
02:01:39,760 --> 02:01:45,120
在这里我们也保存我们的笔记很好所以这真的很好所以我们

1250
02:01:45,120 --> 02:01:49,832
实际上可以使用现有的笔记

1251
02:01:49,832 --> 02:01:53,192
好吧所以我实际上不确定这是如何

1252
02:01:53,192 --> 02:01:57,600
工作的 在这之前可能是之前 um 部分中的一个错误，因为我们

1253
02:01:57,600 --> 02:02:01,440
实际上并没有将节点存储在这个节点私有变量中，

1254
02:02:01,440 --> 02:02:04,552
所以也许我们之前就有这个错误，我

1255
02:02:04,552 --> 02:02:09,040
不能完全确定，所以我只是 回到这里，但如果

1256
02:02:09,040 --> 02:02:12,800
你也有这个错误，如果你想返回节点

1257
02:02:12,800 --> 02:02:17,192
服务创建节点的重量并且你没有保存我不确定这些

1258
02:02:17,192 --> 02:02:20,160
嗯这些功能实际上是如何工作的，

1259
02:02:20,160 --> 02:02:24,160
因为我个人哦 我可以看到我们将它设置在

1260
02:02:24,160 --> 02:02:29,120
这里，所以我们可能不必再这样做了，所以让我们 然后继续，我的

1261
02:02:29,120 --> 02:02:34,720
意思是这很聪明，但是小部件的构建

1262
02:02:34,720 --> 02:02:39,760
功能像这个小部件的核心部分一样发生变化并不是一个好主意，所以让我们

1263
02:02:39,760 --> 02:02:44,640
现在删除它，好吧它是如何工作的，这就是它工作的原因

1264
02:02:44,640 --> 02:02:49,832
但是 它不应该那样工作

1265
02:02:49,832 --> 02:02:53,920
好吧好吧让我们现在进入下一部分嗯

1266
02:02:53,920 --> 02:02:59,120
你看看我们是否回到这里如果我按下删除

1267
02:02:59,120 --> 02:03:02,320
按钮你还记得

1268
02:03:02,320 --> 02:03:06,552
我们在前几章中开发的这个吗 当然我们确保我们有一个

1269
02:03:06,552 --> 02:03:10,552
回调并且定义了回调让我们进入我们的

1270
02:03:10,552 --> 02:03:15,512
笔记列表视图我实际上会像这个笔记列表视图

1271
02:03:15,512 --> 02:03:19,120
那样做你记得这个回调它被称为删除笔记回调

1272
02:03:19,120 --> 02:03:23,920
它只是一个函数 什么都没返回并接受了注释，

1273
02:03:23,920 --> 02:03:27,360
这样我们可以告诉注释视图，

1274
02:03:27,360 --> 02:03:31,680
嘿，用户想要删除一个注释，现在删除它，

1275
02:03:31,680 --> 02:03:35,040
并且在用户按下是按钮时被调用

1276
02:03:35,040 --> 02:03:38,320
记住它实际上是这个视图显示 删除

1277
02:03:38,320 --> 02:03:42,080
对话框 好吧，但是如果你看一下，

1278
02:03:42,080 --> 02:03:45,360
但是如果你看一下这个删除节点回调

1279
02:03:45,360 --> 02:03:49,832
它实际上是什么调用备份是一个注释的回调好吧所以它

1280
02:03:49,832 --> 02:03:53,920
与删除没有任何关系它只是被称为删除节点回调

1281
02:03:53,920 --> 02:03:58,320
好吧可以 我们还利用它来

1282
02:03:58,320 --> 02:04:02,320
以某种方式告诉何时点击了这些笔记中的任何一个

1283
02:04:02,320 --> 02:04:07,512
我们可以使用完全相同的功能来告诉笔记列表视图

1284
02:04:07,512 --> 02:04:13,120
抱歉告诉笔记视图嘿你用户点击了笔记

1285
02:04:13,120 --> 02:04:16,480
当然我们可以这样做 因为它没有返回值，它只

1286
02:04:16,480 --> 02:04:20,552
接受一个注释，所以我们现在对它的命名有一点问题，

1287
02:04:20,552 --> 02:04:23,680
它只是称为删除注释回调，但它不应该没问题，所以

1288
02:04:23,680 --> 02:04:27,120
我们将两者都用于 删除并且还用于

1289
02:04:27,120 --> 02:04:31,192
点击现有节点所以让我调出标题让我们

1290
02:04:31,192 --> 02:04:35,360
将删除节点回调重命名为节点回调所以我要右键单击

1291
02:04:35,360 --> 02:04:40,480
它我只想说重命名重命名符号，让我们打电话 它

1292
02:04:40,480 --> 02:04:44,720
节点回调好的，现在你可以看到它的行为 也为我在这里重命名了它

1293
02:04:44,720 --> 02:04:48,552
，一切都应该按照以前的方式工作，

1294
02:04:48,552 --> 02:04:51,920
所以我们不必做任何特别的事情，它现在只是称为节点

1295
02:04:51,920 --> 02:04:56,320
回调，

1296
02:04:56,320 --> 02:04:59,832
好吧，让我们现在进入下一个

1297
02:04:59,832 --> 02:05:04,640
非常相关的部分，所以 我们现在需要做的是你现在看到

1298
02:05:04,640 --> 02:05:11,760
节点列表视图它根本没有处理用户点击这些列表

1299
02:05:11,760 --> 02:05:15,680
图块中的任何一个，我们将解决这个问题，所以我只是去我的笔记

1300
02:05:15,680 --> 02:05:21,192
和 确保我在这里拥有所有信息，

1301
02:05:21,192 --> 02:05:26,320
所以我们现在需要的只是确保用户可以点击 um

1302
02:05:26,320 --> 02:05:31,600
on those uh on the on tap 好吧，很抱歉，用户可以点击这些

1303
02:05:31,600 --> 02:05:37,120
列表图块，然后我们' 然后像节点回调一样调用一个函数，

1304
02:05:37,120 --> 02:05:41,760
并告诉我们的所有者小部件，嘿，用户点击

1305
02:05:41,760 --> 02:05:45,600
其中一个只是做任何你想做的事情，所以让我们继续在这里添加一个字段并

1306
02:05:45,600 --> 02:05:51,040
在点击时说抱歉回调，我们' 我只是调用它

1307
02:05:51,040 --> 02:05:54,480
ontap 构造函数现在不高兴说是的，你有一个 final 字段

1308
02:05:54,480 --> 02:05:58,480
您还没有初始化，所以让我们在取消删除后立即添加它，

1309
02:05:58,480 --> 02:06:03,120
我将在末尾添加这个必需的参数和逗号，以

1310
02:06:03,120 --> 02:06:06,400
确保您获得正确的格式以及

1311
02:06:06,400 --> 02:06:10,720
我们没有在点击时使用 现在，如果您注意到我们在这里也破坏了

1312
02:06:10,720 --> 02:06:14,080
笔记，那没关系，我们会到达那里，我们会尽快修复我们

1313
02:06:14,080 --> 02:06:17,600
破坏 note2 的原因是因为我们没有通过 tap，因为它是必需的

1314
02:06:17,600 --> 02:06:23,040
参数 好的，我们将幸运地解决这个问题，以便处理列表图块上的选项卡，

1315
02:06:23,040 --> 02:06:26,872
我们不必使用手势识别或类似的东西

1316
02:06:26,872 --> 02:06:31,832
，但我们可以做的就是说未点击你看到它已经在那里，所以

1317
02:06:31,832 --> 02:06:36,080
有一个 没有参数的函数

1318
02:06:36,080 --> 02:06:40,320
，我们需要在这里做的只是在这里调用我们自己的 ontap，你可以

1319
02:06:40,320 --> 02:06:45,440
看到我们必须传递一个数据库节点，幸运的是我们已经有了我相信这里有一个注释

1320
02:06:45,440 --> 02:06:48,552
好的，所以我们只是要 说 untap 并

1321
02:06:48,552 --> 02:06:52,960
注意

1322
02:06:52,960 --> 02:06:59,192
没关系，所以我们现在正在这样做，现在我们需要做的是回到

1323
02:06:59,192 --> 02:07:03,192
我们的 笔记查看并处理你看到的情况，

1324
02:07:03,192 --> 02:07:06,960
所以我要回到我们的笔记2并滚动到我们

1325
02:07:06,960 --> 02:07:11,600
遇到错误的部分，我们有删除嗯，

1326
02:07:11,600 --> 02:07:16,400
但我们没有点击所以我 '我现在也要去我的笔记，

1327
02:07:16,400 --> 02:07:20,400
在删除笔记之后，

1328
02:07:20,400 --> 02:07:24,000
让我们在这里添加这个未开发的功能

1329
02:07:24,000 --> 02:07:27,280
，你可以看到帮助我的视觉效果，并说哦，这个功能实际上接受

1330
02:07:27,280 --> 02:07:33,192
一个节点，所以如果我移动我的 将鼠标悬停在它上面它已经告诉我它是一个数据库节点

1331
02:07:33,192 --> 02:07:37,120
，记住这正是节点列表视图给我们的一切

1332
02:07:37,120 --> 02:07:41,832
，然后在这里让这个函数成为一个异步函数，原因

1333
02:07:41,832 --> 02:07:45,360
是因为我们要真正抓住我们的

1334
02:07:45,360 --> 02:07:47,920
um 让我实际看看我们是否必须

1335
02:07:47,920 --> 02:07:50,640
让它异步我认为它不需要首先异步让我们不要让它

1336
02:07:50,640 --> 02:07:54,080
异步我在我的笔记中将它作为异步我认为我们必须这样

1337
02:07:54,080 --> 02:07:56,400
做但也许有一个 背后的原因

1338
02:07:56,400 --> 02:07:59,920
我还不知道，但是呃，让我们继续，不要添加 asynchr

1339
02:07:59,920 --> 02:08:03,440
目前很麻烦所以在这种情况下我们需要做的

1340
02:08:03,440 --> 02:08:07,440
也是做一些与我们在这里所做的非常相似的

1341
02:08:12,720 --> 02:08:18,080
事情 复制该代码实际上可能是有意义的，让我们

1342
02:08:18,080 --> 02:08:21,832
进入选项卡并粘贴我将在

1343
02:08:21,832 --> 02:08:25,192
此处放置一个逗号以便它为我分解它

1344
02:08:25,192 --> 02:08:28,800
，在这里我们要做的只是说出论点 我们要在

1345
02:08:28,800 --> 02:08:31,512
那里传递注释，

1346
02:08:31,512 --> 02:08:34,552
所以我们只是说这是一个注释，然后

1347
02:08:34,552 --> 02:08:38,640
转到该屏幕并将该参数传递给它，然后当我们

1348
02:08:38,640 --> 02:08:42,552
转到 um 创建更新注释视图时，

1349
02:08:42,552 --> 02:08:46,232
此函数被称为 create 或 get 现有节点

1350
02:08:46,232 --> 02:08:49,512
反过来尝试

1351
02:08:49,512 --> 02:08:53,512
使用我们的 get 参数泛型函数从我们的上下文中获取类型数据库节点的参数

1352
02:08:53,512 --> 02:08:57,192
，然后转到该上下文的模态路径，然后

1353
02:08:57,192 --> 02:09:01,360
获取该参数，因此它就像三层提取，但这

1354
02:09:01,360 --> 02:09:04,872
很好 现在至少你有一个通用的函数可以抓取 你的论点

1355
02:09:04,872 --> 02:09:10,000
没问题，所以我要按命令，做一个热重载可能会很好

1356
02:09:10,000 --> 02:09:14,160
抱歉热重启只是因为我们已经做了很多

1357
02:09:14,160 --> 02:09:18,720
改变，所以我要像这样删除这两个节点，然后我

1358
02:09:18,720 --> 02:09:24,872
我要按加号按钮让我们在这里

1359
02:09:31,600 --> 02:09:35,600
第一个和第二个

1360
02:09:35,600 --> 02:09:39,832
，然后我现在要测试一下，看看我们实际上可以去编辑一个

1361
02:09:39,832 --> 02:09:43,512
现有的便笺，所以我要去我的第一个便笺并点击它，

1362
02:09:43,512 --> 02:09:48,960
现在我可以看到我实际上 去了我们的笔记，它说它仍然写着新

1363
02:09:48,960 --> 02:09:52,480
笔记，也许没关系，我们可以

1364
02:09:52,480 --> 02:09:56,400
保持这样，我们可以稍后更新文本，这很好，

1365
02:09:56,400 --> 02:09:59,512
但至少我可以看到文本，所以我现在实际上要改变 这是我的新

1366
02:09:59,512 --> 02:10:04,872
笔记，对不起，我的笔记 1 到我的笔记 3，然后回去，我现在可以看到我有笔记 2

1367
02:10:04,872 --> 02:10:09,192
和 3。所以这是一个非常好的迹象，因为这意味着上升 约会

1368
02:10:09,192 --> 02:10:13,440
现有笔记实际上是有效的，我们不会创建新笔记，因为

1369
02:10:13,440 --> 02:10:16,552
否则该笔记将出现在此列表中，所以我将转到此

1370
02:10:16,552 --> 02:10:21,040
新笔记 3，然后将其更改为一个，所以现在你看到了 它得到了

1371
02:10:21,040 --> 02:10:26,720
更新，很好，完美，我们得到了更新工作，

1372
02:10:26,720 --> 02:10:29,920
如果你问我做得很好，对你说实话是一件轻而易举的事，

1373
02:10:29,920 --> 02:10:33,832
嗯，我们现在需要的是确保我们

1374
02:10:33,832 --> 02:10:38,400
不会丢失我们的代码，所以让我们像往常一样去吧 在每一章的最后做

1375
02:10:38,400 --> 02:10:43,680
，我们要提交并标记我们的代码 好的，我要改变屏幕

1376
02:10:43,680 --> 02:10:49,760
布局，然后我要增加屏幕的大小，这样你就可以

1377
02:10:49,760 --> 02:10:54,720
看到我在做什么了 更好一点，让我们去我们的终端，如果你

1378
02:10:54,720 --> 02:10:58,800
看看 oops，如果你看看

1379
02:10:58,800 --> 02:11:04,872
um，我认为它是命令 k 是的，让我们看看我们的 git log，你会

1380
02:11:04,872 --> 02:11:10,160
看到我们所做的最后一个 uh 提交是第 16 步，还有你的标签 最后一个标签

1381
02:11:10,160 --> 02:11:13,832
也是第 16 步，好吧，让我们现在

1382
02:11:13,832 --> 02:11:16,480
像之前一样提交，让我们看看

1383
02:11:16,480 --> 02:11:19,760
状态，有点改变了修改 m  odified

1384
02:11:19,760 --> 02:11:23,680
deleted 它认为这个文件已被删除，

1385
02:11:23,680 --> 02:11:28,640
虽然它真的不是，它只是被重命名了，

1386
02:11:28,640 --> 02:11:31,832
所以不幸的是它把它标记为

1387
02:11:31,832 --> 02:11:36,720
已删除，虽然没关系，但有点不幸的是，有一些方法可以

1388
02:11:36,720 --> 02:11:40,720
做到这一点，以便 git 真正理解 您重命名文件，但

1389
02:11:40,720 --> 02:11:44,480
我可以看到 Visual Studio 代码实际上无法将其标记为重命名，并且

1390
02:11:44,480 --> 02:11:48,400
它也只是将其标记为基本上被标记为已删除，

1391
02:11:48,400 --> 02:11:52,160
但没关系我们可以忍受，所以让我们说 git add all

1392
02:11:52,160 --> 02:11:56,800
然后我们就说 git commit step 17

1393
02:11:56,800 --> 02:11:59,832
好吧 然后我们就说 git push 所以我们推送我们

1394
02:11:59,832 --> 02:12:03,192
所有的更改，让我们做一个 git status 以确保我们没有留下任何

1395
02:12:03,192 --> 02:12:07,120
文件，我们在这里没有留下任何文件 '然后会说获取

1396
02:12:07,120 --> 02:12:12,872
标签第 17 步，然后推送我们的标签，

1397
02:12:12,872 --> 02:12:16,000
这样这部分就完成了，我们已经

1398
02:12:16,000 --> 02:12:19,280
完成了对

1399
02:12:19,280 --> 02:12:24,480
现有笔记的更新，这太棒了，就像本课程每一章的传统一样，

1400
02:12:24,480 --> 02:12:29,280
我们总是谈论什么 当我们需要在下一章继续工作时

1401
02:12:29,280 --> 02:12:31,920
所以

1402
02:12:31,920 --> 02:12:35,040
目前我们的源代码中存在一些问题，这

1403
02:12:35,040 --> 02:12:39,360
在我们的节点服务中，所以我将在这里摆脱这个底部栏并

1404
02:12:39,360 --> 02:12:42,960
转到节点服务，你可以在我们的节点服务中看到

1405
02:12:42,960 --> 02:12:47,600
我们 '在这里公开一个名为获取所有节点的功能实际上我不

1406
02:12:47,600 --> 02:12:51,040
认为我们正在使用它获取所有笔记我们只是使用

1407
02:12:51,040 --> 02:12:54,640
所有笔记流，嗯

1408
02:12:54,640 --> 02:12:58,000
让我们看看这里所有笔记流在哪里，那只是阅读

1409
02:12:58,000 --> 02:13:01,280
笔记 流控制器流

1410
02:13:01,280 --> 02:13:04,720
和来自这里的，你可以

1411
02:13:04,720 --> 02:13:09,280
从我们的笔记中看到，并且

1412
02:13:09,280 --> 02:13:17,920
里面填充了笔记让我们看看删除我们这里的所有节点，

1413
02:13:17,920 --> 02:13:23,360
所以你看到我们现在正在阅读所有笔记，我们只是暴露 他们

1414
02:13:23,360 --> 02:13:28,960
到外面的世界，但等一下，我们的应用程序有用户的概念，

1415
02:13:28,960 --> 02:13:33,360
所以如果我们现在退出

1416
02:13:33,360 --> 02:13:37,600
应用程序并用另一个用户重新登录，

1417
02:13:37,600 --> 02:13:43,440
那么新用户将看到我的笔记，因为里面没有地方 这个

1418
02:13:43,440 --> 02:13:48,480
节点服务，我们有一个像我们这样的用户的概念 实际上并没有过滤

1419
02:13:48,480 --> 02:13:52,800
掉这些东西，只向用户公开相关数据，好吧，所以

1420
02:13:52,800 --> 02:13:56,720
我们需要修复它非常严重，呃，这不是一个错误，它实际上是

1421
02:13:56,720 --> 02:13:59,920
我故意留下的东西，直到这一点，因为是的，我们不必这样做

1422
02:13:59,920 --> 02:14:03,760
处理应用程序的用户界面更有趣，但我们

1423
02:14:03,760 --> 02:14:06,552
必须非常注意这些我们尚未实现的小东西，

1424
02:14:06,552 --> 02:14:10,400
而这正是我们将在下一章中要做的和修复的，

1425
02:14:10,400 --> 02:14:12,872
所以我'

1426
02:14:12,872 --> 02:14:16,872
大家好，欢迎来到上一章 swati 课程的第 35

1427
02:14:16,872 --> 02:14:20,720
章，正如你所看到的，我们开始讨论如何更新

1428
02:14:20,720 --> 02:14:26,640
节点列表中的现有节点，并且我们重构了新的节点视图，因为它

1429
02:14:26,640 --> 02:14:31,680
之前被称为 成为我相信创建更新节点视图，这个节点视图

1430
02:14:31,680 --> 02:14:35,192
现在能够做两件事，要么创建一个新节点，

1431
02:14:35,192 --> 02:14:40,320
要么更新一个现有节点，所以我们没有创建一个全新的视图，只是为了

1432
02:14:40,320 --> 02:14:44,000
能够更新现有节点，这样就可以了 真的很好

1433
02:14:44,000 --> 02:14:47,040
，但是作为我男人

1434
02:14:47,040 --> 02:14:50,960
在上一章末尾提到我们的

1435
02:14:50,960 --> 02:14:56,552
节点服务有一点问题，因为现在节点服务并没有真正

1436
02:14:56,552 --> 02:15:02,320
考虑哪些用户登录了应用程序，因此它无法

1437
02:15:02,320 --> 02:15:06,320
返回该特定用户的相关节点 所以节点

1438
02:15:06,320 --> 02:15:09,360
服务目前正在做的只是从数据库中获取所有节点并将其

1439
02:15:09,360 --> 02:15:13,680
返回给当前用户，这将导致一个问题，当我们

1440
02:15:13,680 --> 02:15:17,600
使用一个用户登录时，我们将看到所有 系统中的节点，当我们

1441
02:15:17,600 --> 02:15:21,512
以用户注销并以全新用户登录时，我们将再次

1442
02:15:21,512 --> 02:15:24,960
看到存储在笔记服务器中的所有笔记，因此我们必须在本章开始之前修复它

1443
02:15:29,600 --> 02:15:33,360
我们的更新有点问题

1444
02:15:33,360 --> 02:15:36,400
，这是一个在应用程序内部存在一段时间的错误，因为我们

1445
02:15:36,400 --> 02:15:40,480
基本上创建了我们的云服务，我们必须修复它，所以让我们

1446
02:15:40,480 --> 02:15:43,920
看看这个错误实际上是什么 在我能

1447
02:15:43,920 --> 02:15:47,192
之前 o on 所以我要把 scrcpy 放在这里

1448
02:15:47,192 --> 02:15:51,120
，我也要把 Visual Studio 代码放在这里

1449
02:15:51,120 --> 02:15:55,040
，所以我希望你能看到屏幕，所以现在我们有，嗯，

1450
02:15:55,040 --> 02:15:58,160
也许我不必 希望我可以把屏幕

1451
02:15:58,160 --> 02:16:03,440
稍微大一点，所以如果你现在看 scr cpy，我们有两个我的笔记，

1452
02:16:03,440 --> 02:16:08,160
第二个，这正是盒子，所以让我们进去第一个，我'

1453
02:16:08,160 --> 02:16:11,512
我只想说我的第一条笔记，哎呀

1454
02:16:11,512 --> 02:16:15,920
，然后出去，现在一切看起来都很好，这只是因为我们也在

1455
02:16:15,920 --> 02:16:20,552
更新我们的本地缓存，所以事情看起来不错，但是如果

1456
02:16:20,552 --> 02:16:27,120
你热重启应用程序并且我的 scr cpy 刚刚死了 所以没关系，

1457
02:16:27,120 --> 02:16:31,760
我可以忍受它是一个免费软件，就像你的 cpy 一样，我

1458
02:16:31,760 --> 02:16:37,192
现在可以看到我实际上也丢失了 scrcpy 的调试命令，

1459
02:16:37,192 --> 02:16:42,640
所以我要重新启动应用程序，但现在会发生什么 正如

1460
02:16:42,640 --> 02:16:47,120
您很快就会看到的，我们的更新注释功能有一点问题，

1461
02:16:47,120 --> 02:16:51,440
所以您现在可以看到我现在我重新 突然启动了应用程序

1462
02:16:51,440 --> 02:16:56,160
，两个笔记都更改为我的第一条笔记，这

1463
02:16:56,160 --> 02:16:59,832
并不是不正确，因为应用程序内部存在错误，

1464
02:16:59,832 --> 02:17:04,720
因此它的表现形式是，当您在本地更新笔记时

1465
02:17:04,720 --> 02:17:09,440
，它看起来很好，但是如果您 做一个热重启，对不起，它会

1466
02:17:09,440 --> 02:17:13,760
像现在一样跳闸，错误就在这里我不知道

1467
02:17:13,760 --> 02:17:17,360
你是否能注意到，对不起，

1468
02:17:17,360 --> 02:17:20,160
我不知道你是否能注意到，但我们有这个电话

1469
02:17:20,160 --> 02:17:25,760
到更新功能，但是我们实际上并没有告诉，

1470
02:17:25,760 --> 02:17:30,640
这也是在更新节点功能内的节点服务飞镖内部的方式

1471
02:17:30,640 --> 02:17:34,480
在这里您可以看到我们正在向 sqlite 发出查询，我们说的是

1472
02:17:34,480 --> 02:17:39,680
更新节点表 并将文本设置为该文本，这正是

1473
02:17:39,680 --> 02:17:44,232
sqlite 正在做的事情，它遍历 note 表中的所有行并

1474
02:17:44,232 --> 02:17:46,960
使用给定文本更新它们的文本列，

1475
02:17:46,960 --> 02:17:51,600
所以我们错过了一个 where 参数，所以我们不是 告诉 sqlite

1476
02:17:51,600 --> 02:17:55,760
钻机 ht 现在要更新哪一行，所以它正在更新

1477
02:17:55,760 --> 02:18:00,000
所有行，所以我们需要紧急解决这个问题，

1478
02:18:00,000 --> 02:18:03,832
所以让我们进入这里，说我们现在

1479
02:18:03,832 --> 02:18:07,512
看到这是我们的更新

1480
02:18:07,512 --> 02:18:12,320
，在创建这本

1481
02:18:12,320 --> 02:18:17,440
字典之后，我们 重新说一个是，我们要说

1482
02:18:17,440 --> 02:18:21,280
我们要更新的那一列的 id 字段，或者对不起，我们要更新的行的 id 字段，或者

1483
02:18:21,280 --> 02:18:26,160
注意我们要更新的内容将等于某事，并且 args

1484
02:18:26,160 --> 02:18:31,440
在哪里 将等于我们的节点 id，所以我需要你也

1485
02:18:31,440 --> 02:18:35,680
按照我在这里写的方式编写这段代码，所以现在如果你说我的第一个注释，我进入

1486
02:18:35,680 --> 02:18:39,760
这里，我说第二个次要，那么它会做 正确的

1487
02:18:39,760 --> 02:18:42,960
做法是，如果您进行热重启，那么您可以看到注释实际上已

1488
02:18:42,960 --> 02:18:46,400
正确填充，好吧，我不会进行热重启，

1489
02:18:46,400 --> 02:18:50,480
因为我知道 scr cpy 可能会再次崩溃，我必须重新启动整个过程

1490
02:18:50,480 --> 02:18:52,720
所以 我不想浪费你的时间，

1491
02:18:52,720 --> 02:18:55,360
这就是为什么我不会做一个热

1492
02:18:55,360 --> 02:19:02,400
重启，但这应该可以正常工作抱歉 再次

1493
02:19:02,400 --> 02:19:06,960
好吧，嗯，现在回到我们正在做的

1494
02:19:06,960 --> 02:19:10,872
事情，或者回到本章的主要目标，所以

1495
02:19:10,872 --> 02:19:15,280
让我们看看如果你去这里无法解决我们的用户服务器与我们的

1496
02:19:15,280 --> 02:19:20,000
节点服务的问题 返回相关节点，

1497
02:19:20,000 --> 02:19:24,232
除了它返回所有节点，所以我相信它就在节点服务内部

1498
02:19:24,232 --> 02:19:28,800
哦，我们已经在那里对此感到抱歉，所以我们有我们的节点服务

1499
02:19:28,800 --> 02:19:32,800
，当我们说这里时你可以看到，

1500
02:19:32,800 --> 02:19:39,120
注意这发生在呃内部 缓存所有缓存注释，您可以

1501
02:19:39,120 --> 02:19:42,640
看到它正在从数据库中读取所有注释，使用获取所有注释将其

1502
02:19:42,640 --> 02:19:46,960
放入其中，抱歉您看不到缓存注释正在读取所有

1503
02:19:46,960 --> 02:19:51,512
注释，然后将它们放入本地局部变量中 还可以

1504
02:19:51,512 --> 02:19:57,280
填充流控制器，但是我们需要做的是

1505
02:19:57,280 --> 02:20:03,512
我们需要确保当前用户保存在此便笺

1506
02:20:03,512 --> 02:20:07,120
服务中的某个位置，以便便笺服务知道可以，这是当前用户

1507
02:20:07,120 --> 02:20:12,320
使用此处的所有节点功能将我的所有笔记转到呼叫站点

1508
02:20:12,320 --> 02:20:16,640
我需要实际过滤掉

1509
02:20:16,640 --> 02:20:21,360
该列表中的笔记，以确保只有当前用户创建的相关笔记才能

1510
02:20:21,360 --> 02:20:27,600
从该流中返回，

1511
02:20:27,600 --> 02:20:31,120
所以我们需要什么 是

1512
02:20:35,512 --> 02:20:40,872
在这个 uh 节点服务中的我们的服务中保留某种当前用户，所以让我们继续这样做，

1513
02:20:40,872 --> 02:20:46,160
让我们在这里实际定义我们的 um 数据库用户

1514
02:20:46,160 --> 02:20:49,512
，我们说这是可选的，它是平等的 但是对于用户，

1515
02:20:49,512 --> 02:20:54,960
我们总是希望确保在您实际获取笔记列表之前设置该用户

1516
02:20:54,960 --> 02:20:58,080
，所以这是

1517
02:20:58,080 --> 02:21:01,600
该笔记服务器的期望，因此笔记服务器说，如果您希望

1518
02:21:01,600 --> 02:21:05,512
能够阅读所有笔记 你这样做的方式和你做的一样干净

1519
02:21:05,512 --> 02:21:10,552
你还要确保你已经把这个当前用户设置好了，

1520
02:21:10,552 --> 02:21:15,280
所以如果这个期望没有得到满足，我们将抛出一个异常

1521
02:21:15,280 --> 02:21:19,760
，我们将 调用该异常用户应该在读取所有节点之前设置

1522
02:21:19,760 --> 02:21:24,480
正如标题所示，我们将转到我们之前的人群异常

1523
02:21:24,480 --> 02:21:29,120
，所以让我们发现给定文件夹中的人群异常

1524
02:21:29,120 --> 02:21:32,720
是抱歉，在我在屏幕底部提到的给定路径中是的 lib s

1525
02:21:32,720 --> 02:21:35,832
rvices cross 人群异常

1526
02:21:35,832 --> 02:21:39,192
，我们将定义一个名为 user 的新异常，应该

1527
02:21:39,192 --> 02:21:42,552
在阅读所有此类注释之前设置

1528
02:21:42,552 --> 02:21:46,960
好，所以请继续并将其定义为您的应用程序中的异常之一

1529
02:21:46,960 --> 02:21:50,800
以及人群异常下的异常，

1530
02:21:50,800 --> 02:21:53,680
所以

1531
02:21:53,680 --> 02:21:58,080
我们 现在需要是我们能够

1532
02:21:58,080 --> 02:22:01,600
根据当前用户过滤所有给定节点的一种方式，

1533
02:22:01,600 --> 02:22:05,360
所以让我们看看我们现在的所有节点

1534
02:22:05,360 --> 02:22:10,872
在这里你看到我们需要的是确保所有

1535
02:22:10,872 --> 02:22:18,000
节点都可以实际过滤呃 此流中的给定节点

1536
02:22:18,000 --> 02:22:21,440
并使用某种过滤器功能

1537
02:22:21,440 --> 02:22:24,720
所以我们所拥有的你可以在这里看到一个流

1538
02:22:24,720 --> 02:22:30,400
让我们说流一个流有一个名为 where 的函数

1539
02:22:30,400 --> 02:22:32,720
所以它的作用是你可以看到它

1540
02:22:32,720 --> 02:22:38,960
有嗯它允许你 抓住当前的续集 ent 的那个

1541
02:22:38,960 --> 02:22:44,080
流，然后你可以通过一个测试，这样你就可以说这个对象是否

1542
02:22:44,080 --> 02:22:48,160
等于这个然后做那个并返回这个值，否则返回其他的

1543
02:22:48,160 --> 02:22:51,832
东西，所以它有点像一个流值上的字符串的过滤机制

1544
02:22:51,832 --> 02:22:58,640
但是我们的流包含一个列表记住让我们回到

1545
02:22:58,640 --> 02:23:02,800
这里原谅我在这里你可以看到

1546
02:23:02,800 --> 02:23:07,440
我们返回一个数据库节点列表的流

1547
02:23:07,440 --> 02:23:11,280
所以我们想要的是一个两层深的 where 子句

1548
02:23:11,280 --> 02:23:16,400
我们希望能够过滤掉并且

1549
02:23:16,400 --> 02:23:21,360
根据当前用户更改此流的内容，然后我们需要

1550
02:23:21,360 --> 02:23:25,360
根据当前用户的 id 过滤列表，并仅返回与该用户相关的数据库注释，

1551
02:23:25,360 --> 02:23:29,512
因此这是一种特殊情况，

1552
02:23:29,512 --> 02:23:32,960
因此我们 需要在我们的流上创建我们自己的函数

1553
02:23:32,960 --> 02:23:39,920
，这是一个类似于过滤器函数的手动函数，

1554
02:23:39,920 --> 02:23:46,000
所以让我们继续这样做，所以我们需要在这里做

1555
02:23:46,000 --> 02:23:50,640
的是创建一个新文件，如您在 lib 扩展列表过滤器下看到的那样

1556
02:23:50,640 --> 02:23:56,232
所以我要继续这样做 看看我们是否已经有一些扩展，

1557
02:23:56,232 --> 02:24:00,960
所以我现在可以在 lib 下看到我们有常量枚举服务实用程序视图，

1558
02:24:00,960 --> 02:24:06,400
但我们没有任何扩展，所以最好的方法是创建

1559
02:24:06,400 --> 02:24:10,640
过滤器 dart 文件是正确的 单击实时并说新文件

1560
02:24:10,640 --> 02:24:15,080
，然后我要说扩展列表

1561
02:24:15,080 --> 02:24:18,000
过滤器。 好的

1562
02:24:18,000 --> 02:24:23,040
，那么我们在这里要做的是在我们的流上创建一个扩展，

1563
02:24:23,040 --> 02:24:29,920
所以让我们继续说扩展

1564
02:24:29,920 --> 02:24:34,160
过滤器在 t 的流上，

1565
02:24:34,160 --> 02:24:37,680
所以我这样做的原因是

1566
02:24:37,680 --> 02:24:43,832
这样我们可以 在我们的扩展中抓住那个流的内容

1567
02:24:43,832 --> 02:24:48,400
好吧，就像如果你做了这样

1568
02:24:48,400 --> 02:24:53,920
的事情仍然可以工作，但在这里我们要说的是我们正在扩展

1569
02:24:53,920 --> 02:24:59,440
任何具有 t 值并在我们的过滤器中的流 函数，然后我们可以

1570
02:24:59,440 --> 02:25:03,760
访问那个 t，你很快就会看到好的，所以我们会说

1571
02:25:03,760 --> 02:25:08,872
那个对象列表的流

1572
02:25:08,872 --> 02:25:11,680
，我们将调用我们的函数过滤器

1573
02:25:11,680 --> 02:25:16,320
，在我们的过滤器函数中，我们想要获取另一个函数 这

1574
02:25:16,320 --> 02:25:20,872
对项目进行了测试，所以让我们说 bool

1575
02:25:20,872 --> 02:25:27,192
um 函数，它抓取该类型的项目，

1576
02:25:27,192 --> 02:25:32,400
所以你现在可以看到我们基本上已经分解了过滤的要求，

1577
02:25:32,400 --> 02:25:35,280
应该是两层

1578
02:25:35,280 --> 02:25:40,800
深现在是一层 跳跃是因为我们的过滤器函数

1579
02:25:40,800 --> 02:25:45,512
将我们的数据库节点 t 传递给了这个 where 函数 好的，

1580
02:25:45,512 --> 02:25:48,720
所以目前不存在，但我们正在创建它，好的，

1581
02:25:48,720 --> 02:25:51,440
所以在这里我们要说的是

1582
02:25:51,440 --> 02:25:56,080
我们要做的是我们需要映射我们的 um

1583
02:25:56,080 --> 02:25:59,440
流，你可以看到它 给

1584
02:25:59,440 --> 02:26:06,720
我们值所以在这里我们得到项目然后在这里我们说

1585
02:26:06,720 --> 02:26:13,600
我们在这里传递那个词子句的项目我们说像这样列出

1586
02:26:13,600 --> 02:26:17,600
所以我可以在这里看到实际上我们有一个

1587
02:26:17,600 --> 02:26:22,320
过滤器 t 但我们的流 需要有一个 t 的列表，这样就可以

1588
02:26:22,320 --> 02:26:25,440
解决我们的问题，所以在这种情况下，我们实际上是

1589
02:26:25,440 --> 02:26:29,040
在列表的深处向下钻取两层，好吧，这是我们刚刚创建的函数，

1590
02:26:29,040 --> 02:26:34,000
因此它允许我们过滤流 一些东西的列表，然后

1591
02:26:34,000 --> 02:26:38,232
我们的 where 子句将得到那个东西，如果那个东西

1592
02:26:38,232 --> 02:26:42,800
通过测试，那么它将被包含在最终列表中，所以

1593
02:26:42,800 --> 02:26:46,400
看起来我知道这是复杂的东西，但请暂停视频，

1594
02:26:46,400 --> 02:26:51,120
稍微思考一下 我们有一个包含事物列表的

1595
02:26:51,120 --> 02:26:57,680
流，现在我们想要流相同的细列表 g 只要

1596
02:26:57,680 --> 02:27:01,040
这些东西通过了

1597
02:27:01,040 --> 02:27:04,552
使用此工作损失指定的特定测试，好吧，

1598
02:27:04,552 --> 02:27:09,192
这很难，我知道这可能是一些对于某些用户来说可能太难了

1599
02:27:09,192 --> 02:27:12,640
，你会觉得我不明白 任何这些我都不明白，但

1600
02:27:12,640 --> 02:27:17,512
你只需要练习你只需要抓住这段代码就可以

1601
02:27:17,512 --> 02:27:22,000
继续并在其他一些功能上实现它，比如清单，

1602
02:27:22,000 --> 02:27:26,400
如果我有一个清单，看看没关系 我如何过滤掉

1603
02:27:26,400 --> 02:27:30,800
里面的那个东西，它最终会点击好的

1604
02:27:40,400 --> 02:27:44,552
看到现在我们

1605
02:27:44,552 --> 02:27:47,832
在节点服务中有获取或创建用户功能，

1606
02:27:47,832 --> 02:27:53,360
所以让我们回到我们的节点服务并找到该函数获取或创建用户

1607
02:27:53,360 --> 02:27:57,920
，目前它只需要一封电子邮件，因为标题表明我们需要

1608
02:27:57,920 --> 02:28:03,360
在这个函数中添加一个参数 这也说设置为当前用户，所以当你得到

1609
02:28:03,360 --> 02:28:06,800
或 cr 吃掉我们目前正在做的用户我

1610
02:28:06,800 --> 02:28:11,512
相信我们的笔记视图所以让我们进入这里的

1611
02:28:11,512 --> 02:28:17,832
笔记笔记视图在这里你看到获取或创建用户所以

1612
02:28:17,832 --> 02:28:22,640
这就像裸露的骨头这是实际非常重要的部分 在我们的应用程序

1613
02:28:22,640 --> 02:28:26,320
中，用户要么按照他或她原来的方式或创建方式从数据库中检索出来，

1614
02:28:26,320 --> 02:28:31,040
此时让该用户成为当前用户才有意义，

1615
02:28:31,040 --> 02:28:35,920
所以让我们进入我们的节点服务

1616
02:28:35,920 --> 02:28:43,040
并更改该功能，所以我 '我也要调出我的笔记

1617
02:28:43,040 --> 02:28:48,232
，让我们在这里添加一个名为 set as current user 的参数，在那里放一个

1618
02:28:48,232 --> 02:28:52,000
逗号，让我们说这个

1619
02:28:52,000 --> 02:28:57,192
参数是一个布尔集作为当前用户，我们要设置

1620
02:28:57,192 --> 02:29:02,960
默认情况下它为真，所以我需要做同样的事情，

1621
02:29:02,960 --> 02:29:06,400
所以在这样做之后，当我们检索用户时，我们将查看这个

1622
02:29:06,400 --> 02:29:10,640
参数，我们会说如果设置

1623
02:29:10,640 --> 02:29:15,360
为当前用户，然后设置为当前用户 我们将把我们自己的用户设置为我们刚刚

1624
02:29:15,360 --> 02:29:19,920
从 数据库，也不要忘记创建

1625
02:29:19,920 --> 02:29:23,920
此用户时，

1626
02:29:23,920 --> 02:29:27,512
如果该布尔标志为真，您还必须设置当前用户，所以我们

1627
02:29:27,512 --> 02:29:33,760
在这里也设置为当前用户，然后我们会说用户是创建用户

1628
02:29:33,760 --> 02:29:39,280
所以 我们在这里所做的是我们只是说如果我们可以从数据库中检索该用户

1629
02:29:39,280 --> 02:29:44,000
并且这个布尔参数为真，那么我们将我们自己的用户设置为该

1630
02:29:44,000 --> 02:29:47,920
用户，否则如果我们必须创建该用户

1631
02:29:47,920 --> 02:29:52,000
并且该参数为真，那么我们执行 同样，我们将此当前用户

1632
02:29:52,000 --> 02:29:55,040
设置为创建的用户，如果您在这里遇到一些错误，说

1633
02:29:55,040 --> 02:29:58,232
找不到该下划线用户，这可能是因为您错过了将

1634
02:29:58,232 --> 02:30:01,040
这个数据库用户添加到您的节点服务中

1635
02:30:01,040 --> 02:30:03,920
，这是我之前提到的

1636
02:30:03,920 --> 02:30:09,360
在我们创建这个异常之前，我们继续创建过滤器函数好吧或抱歉，

1637
02:30:09,360 --> 02:30:13,360
这部分现在也完成了，嗯，

1638
02:30:13,360 --> 02:30:16,960
现在我们需要做的是进行实际的

1639
02:30:16,960 --> 02:30:22,080
过滤，这就是我们需要做的事情 你可以看到一个

1640
02:30:22,080 --> 02:30:27,120
缓存 e索引更改所有节点流以过滤当前用户

1641
02:30:27,120 --> 02:30:30,960
，这是我们需要在所有节点函数中执行的操作，

1642
02:30:30,960 --> 02:30:35,040
或者对不起getter，所以在这里

1643
02:30:35,040 --> 02:30:41,600
我们要说的是我实际上我想我会 改变它们，

1644
02:30:41,600 --> 02:30:44,720
是的，让我们保持这样，所以我只想说没有流

1645
02:30:44,720 --> 02:30:47,760
控制器和点

1646
02:30:47,760 --> 02:30:51,600
流，在这里我们可以使用我们的过滤器功能，你现在看到的 Visual

1647
02:30:51,600 --> 02:30:55,040
Studio 代码就像混淆一样哦，没有过滤器功能 流，

1648
02:30:55,040 --> 02:30:58,160
但请记住，我们实际上是自己添加的，所以我要从

1649
02:30:58,160 --> 02:31:01,832
Visual Studio 代码中获得帮助，并在 Mac 上说命令点或在 Linux 和

1650
02:31:01,832 --> 02:31:05,832
Windows 和 Visual Studio 代码上说控制点，然后它就会明白哦

1651
02:31:05,832 --> 02:31:09,760
，你有一个过滤器功能 '已经在流中定义了你想让我导入那个，

1652
02:31:09,760 --> 02:31:12,832
我会说是的，所以现在我们有了

1653
02:31:12,832 --> 02:31:18,872
过滤器记住过滤器然后得到一个正确的注释，如果我现在将鼠标移到它上面

1654
02:31:18,872 --> 02:31:23,280
你可以看到它说哦你有 一个数据库注释，但是我们的流

1655
02:31:23,280 --> 02:31:27,360
实际上包含一个 dat 列表 一个基本节点，突然我们的过滤器一次只

1656
02:31:27,360 --> 02:31:31,512
得到一个注释，所以这是创建自己的扩展的美妙之处，

1657
02:31:31,512 --> 02:31:37,440
这样您就可以深入现有对象并在应用程序中获取您需要的

1658
02:31:37,440 --> 02:31:42,872
内容，所以在这里我们需要什么 是创建一个

1659
02:31:42,872 --> 02:31:46,400
函数然后你记得这个函数必须返回一个布尔值我们还

1660
02:31:46,400 --> 02:31:49,360
没有从这里返回任何东西这就是为什么我们得到一个错误

1661
02:31:49,360 --> 02:31:53,360
所以在这个函数结束时我们需要返回一个卷所以让我们说

1662
02:31:53,360 --> 02:31:59,512
final 当前用户是这个用户，如果这个当前

1663
02:31:59,512 --> 02:32:04,000
用户不为空，这就像我们实际期望的条件，那么我们

1664
02:32:04,000 --> 02:32:07,760
将做一些代码，否则我们需要抛出我们的异常

1665
02:32:07,760 --> 02:32:12,080
用户应该在之前说好，所以这是

1666
02:32:12,080 --> 02:32:16,552
我们的期望 调用者如果您正在阅读此

1667
02:32:16,552 --> 02:32:21,440
界面中的所有注释，则需要确保在调用此函数时设置了当前用户，

1668
02:32:21,440 --> 02:32:27,120
因此这必须是正确的，抱歉，您可能没有

1669
02:32:27,120 --> 02:32:30,552
看到代码，但您也可以争辩 哦，等等

1670
02:32:30,552 --> 02:32:34,872
分钟如果这就像这个界面的期望，

1671
02:32:34,872 --> 02:32:37,832
在你阅读所有笔记之前应该总是说当前用户，

1672
02:32:37,832 --> 02:32:41,600
那么你为什么不把它

1673
02:32:41,600 --> 02:32:45,920
设为默认为什么不这样做并删除这个功能并始终设置用户

1674
02:32:45,920 --> 02:32:49,120
默认情况下，其背后的原因

1675
02:32:49,120 --> 02:32:53,920
是只有在您使用所有节点时才必须发送当前用户现在

1676
02:32:53,920 --> 02:32:58,872
这个节点服务应该能够像更新现有节点或删除

1677
02:32:58,872 --> 02:33:03,040
现有节点一样工作它在这些功能中应该

1678
02:33:03,040 --> 02:33:07,832
仍然有效 如果当前用户未正确设置，因为这些功能是

1679
02:33:07,832 --> 02:33:12,552
纯交叉函数，即更新具有此 ID 的节点获取具有此 ID 的用户

1680
02:33:12,552 --> 02:33:18,960
删除具有此 ID 的节点等它们不依赖于当前用户

1681
02:33:18,960 --> 02:33:24,160
但是所有节点都依赖 在当前用户上，

1682
02:33:24,160 --> 02:33:27,192
在这里设置这个功能

1683
02:33:27,192 --> 02:33:32,552
是有意义的

1684
02:33:32,552 --> 02:33:36,320
这是我将其作为

1685
02:33:36,320 --> 02:33:39,832
参数而不是使其成为此类的默认 um

1686
02:33:39,832 --> 02:33:44,960
行为的原因，所以如果当前用户不为

1687
02:33:44,960 --> 02:33:50,720
空，那就像快乐的路径，那么我们说我们返回此注释

1688
02:33:50,720 --> 02:33:57,440
它不只要它的 um 用户 id

1689
02:33:57,440 --> 02:34:01,680
与当前用户 id 相同，所以我们说

1690
02:34:01,680 --> 02:34:05,280
注意用户 id 应该等于当前用户

1691
02:34:05,280 --> 02:34:09,760
点 id

1692
02:34:09,760 --> 02:34:14,080
必须返回

1693
02:34:14,080 --> 02:34:17,680
一个布尔值，所以我们在这里不返回任何节点，我们只是检查

1694
02:34:17,680 --> 02:34:22,640
该节点的使用是否与该节点相同，然后执行此操作，

1695
02:34:22,640 --> 02:34:25,832
这样现在应该很好，所以我们

1696
02:34:25,832 --> 02:34:31,832
可以做什么我知道这可能 实际上，现在就破坏事情，因为我在

1697
02:34:31,832 --> 02:34:35,832
scr cpy 方面遇到了一些问题，但是您必须原谅我，这

1698
02:34:35,832 --> 02:34:40,640
不是我可以控制的，但是由于我们已经更改了很多代码，所以我现在要

1699
02:34:40,640 --> 02:34:45,280
关闭所有这些屏幕 在这些选项卡上，我将进行热重载，

1700
02:34:45,280 --> 02:34:49,192
但这很可能会发生 崩溃 scr cpy

1701
02:34:49,192 --> 02:34:54,000
哦，这不是很好，感谢上帝，所以我们现在有了笔记，我们如何将

1702
02:34:54,000 --> 02:34:58,000
其用于测试我们需要做的是注销并登录

1703
02:34:58,000 --> 02:35:01,440
，所以我要去控制台 firebase

1704
02:35:01,440 --> 02:35:06,000
让我们转到我们的应用程序，这是我的笔记颤动项目

1705
02:35:06,000 --> 02:35:11,832
我们现在有两个经过身份验证的用户这两封电子邮件所以

1706
02:35:11,832 --> 02:35:15,120
现在我用其中一个登录我真的不知道哪一个所以我

1707
02:35:15,120 --> 02:35:19,120
要登录 在这里，然后我将使用

1708
02:35:19,120 --> 02:35:24,552
pixeltab gmail.com foobarbas 登录

1709
02:35:24,552 --> 02:35:29,920
，我可以看到那些电子邮件在像素选项卡下，所以我

1710
02:35:29,920 --> 02:35:34,640
将再次注销，我将登录 其他用户

1711
02:35:34,640 --> 02:35:37,680
喜欢这个工具栏坏了，然后我要

1712
02:35:37,680 --> 02:35:42,552
按下登录按钮，我还没有验证我的电子邮件，所以我必须这样做

1713
02:35:42,552 --> 02:35:47,600
，所以让我看看我现在是否可以处理这个问题

1714
02:35:47,600 --> 02:35:53,440
然后我会带上我的电子邮件

1715
02:35:53,440 --> 02:35:58,872
去看看我能不能找到这封验证邮件，但我找不到，所以我

1716
02:35:58,872 --> 02:36:02,400
只是要发送发送电子邮件验证，它会发送一个新的电子邮件 邮件

1717
02:36:02,400 --> 02:36:08,160
验证给我，我收到了电子邮件验证

1718
02:36:08,160 --> 02:36:12,160
，它看起来像这样，所以我要点击它，我

1719
02:36:12,160 --> 02:36:16,080
现在可以看到它说你的电子邮件已经过验证，

1720
02:36:16,080 --> 02:36:20,000
所以让我重新开始，现在

1721
02:36:20,000 --> 02:36:26,480
我' 已经验证了我的电子邮件我将尝试使用用户登录，

1722
02:36:26,480 --> 02:36:29,920
因为哎呀这是注册我想

1723
02:36:29,920 --> 02:36:32,800
登录所以

1724
02:36:32,800 --> 02:36:35,192
这里 foo barbats

1725
02:36:35,192 --> 02:36:39,280
然后登录现在我可以看到我的用户我没有

1726
02:36:39,280 --> 02:36:42,960
看到任何注释 但只是为了确保我只是要创建一个新用户并

1727
02:36:42,960 --> 02:36:47,192
说不抱歉创建一个新节点我要说这个节点是

1728
02:36:47,192 --> 02:36:52,160
为 van dot 创建的或者只是把我的电子邮件放在这里

1729
02:36:52,160 --> 02:36:54,720
好吧我是 回去，我可以看到

1730
02:36:54,720 --> 02:37:00,640
这里显示了注释然后我要做的就是

1731
02:37:00,640 --> 02:37:05,512
注销这个用户并与另一个用户一起登录

1732
02:37:05,512 --> 02:37:09,680
只是为了确保那个是由另一个创建的哦 用户

1733
02:37:09,680 --> 02:37:13,512
没有显示给这个用户，好吧

1734
02:37:13,512 --> 02:37:19,920
，现在我们可以登录，我只能看到这个用户的笔记，所以

1735
02:37:19,920 --> 02:37:24,480
恭喜我们做了很多工作，t 就像我们所做的那样，嗯，

1736
02:37:24,480 --> 02:37:28,320
应用程序似乎按照我们设计的方式工作，

1737
02:37:28,320 --> 02:37:32,320
所以我们现在需要做的就是

1738
02:37:32,320 --> 02:37:38,232
确保我们不会像传统那样丢失我们的代码，所以我们需要承诺 我们的

1739
02:37:38,232 --> 02:37:42,872
代码，还可以标记我们的代码，所以我要

1740
02:37:42,872 --> 02:37:46,552
在屏幕上做一些 uh shuffle，我要增加 Visual Studio 代码的大小，

1741
02:37:46,552 --> 02:37:51,440
这样你可以更好地看到它让我们做 git status 看看我们的

1742
02:37:51,440 --> 02:37:55,832
状态是什么 '已经修改了两个文件，我们还添加了一个全新的文件夹，所以

1743
02:37:55,832 --> 02:38:00,000
我只想说 git add all 如果您查看我们的日志，上

1744
02:38:00,000 --> 02:38:04,232
一步是第 17 步，现在我们必须提交我们的工作并将其

1745
02:38:04,232 --> 02:38:08,232
标记为步骤 18，如果您也查看我们的标签，那么您应该在

1746
02:38:08,232 --> 02:38:11,440
这里执行第 17 步，让我们说 git commit，我将

1747
02:38:11,440 --> 02:38:16,552
说第 18 步。在这里，我将这些更改推送到

1748
02:38:16,552 --> 02:38:20,640
遥控器，在我的情况下是 github，您可能 在这里也使用 bitbucket 或其他一些

1749
02:38:20,640 --> 02:38:25,120
远程和小于标记作为步骤 18

1750
02:38:25,120 --> 02:38:29,600
并把你的标签放好，

1751
02:38:29,600 --> 02:38:34,160
这样部分就完成了，现在我们已经标记和合作 提交或代码，所以如果你

1752
02:38:34,160 --> 02:38:40,400
说 git status 你应该没有任何处理在这里可以提交

1753
02:38:40,400 --> 02:38:44,552
哇太棒了 所以再次作为传统，我们总是

1754
02:38:44,552 --> 02:38:47,512
谈论我们需要在下一章中提到

1755
02:38:47,512 --> 02:38:50,400
的内容 下一章在每一章的末尾，所以

1756
02:38:50,400 --> 02:38:54,000
到目前为止，我们一直在使用我们的 notes crot 服务，效果

1757
02:38:54,000 --> 02:38:57,120
非常好，一切都保存在设备上，

1758
02:38:57,120 --> 02:39:01,040
但是如果你真的考虑一下，

1759
02:39:01,040 --> 02:39:04,480
你现在已经学会了如何 与人群一起工作，这就是

1760
02:39:04,480 --> 02:39:07,680
我在本课程开始

1761
02:39:07,680 --> 02:39:12,400
时的意图之一

1762
02:39:15,040 --> 02:39:19,280
开发人员必须知道，所以我希望您已经了解到，

1763
02:39:19,280 --> 02:39:23,920
但是现在我们在这里遇到了一个大问题，那就是我们所有的笔记都保存在本地

1764
02:39:23,920 --> 02:39:28,800
的类似 sql 的数据库中，如果出现任何问题，例如

1765
02:39:28,800 --> 02:39:33,120
如果用户发生了什么事 这 用户的电话所有数据

1766
02:39:33,120 --> 02:39:36,720
都会消失，所以用户的笔记可能会消失，

1767
02:39:36,720 --> 02:39:40,320
如果你像我一样，你可能会想，这有什么问题？

1768
02:39:44,960 --> 02:39:50,000
很多所以我

1769
02:39:50,000 --> 02:39:54,872
有时会在我的笔记中存储非常非常重要的信息，你会惊讶

1770
02:39:54,872 --> 02:39:59,120
于这门课程的大纲我实际上管理了这一切我

1771
02:39:59,120 --> 02:40:02,872
在我的 Macintosh 上的笔记应用程序中管理了所有这些所以我写了整个大纲

1772
02:40:02,872 --> 02:40:06,400
花了很多很多 几个小时，

1773
02:40:06,400 --> 02:40:10,872
如果这些笔记由于某种原因消失了，或者如果我的孩子抓住了我的

1774
02:40:10,872 --> 02:40:13,832
电话并且只是移除了笔记并且没有任何理由，那么

1775
02:40:13,832 --> 02:40:17,280
我将无法再次抓住这些笔记，那么我会被摧毁，那又

1776
02:40:17,280 --> 02:40:21,832
怎样 我们现在需要做的只是确保我们可以将这些节点存储在

1777
02:40:21,832 --> 02:40:24,872
某种后端中，以便它位于

1778
02:40:24,872 --> 02:40:28,800
云中，这样我们就不必在本地管理它们，这就是我们将

1779
02:40:28,800 --> 02:40:32,320
使用 firebase 的目的 我们要开始了

1780
02:40:32,320 --> 02:40:36,720
从下一章开始就越来越多地谈论 Firebase 存储，所以我希望

1781
02:40:36,720 --> 02:40:40,872
你喜欢这一章，喝点茶点咖啡或茶或任何

1782
02:40:40,872 --> 02:40:44,720
你想要的巧克力，我会在下一章见到你

1783
02:40:44,720 --> 02:40:49,040
你好，欢迎来到第 36 章 在前面章节中的这个颤振课程中，

1784
02:40:49,040 --> 02:40:52,400
我们一直在使用我们的 quad 服务，并且我们一直在

1785
02:40:52,400 --> 02:40:57,192
使用 firebase 身份验证到目前为止，我们已经将用户生成的

1786
02:40:57,192 --> 02:41:03,040
注释存储在我们用 sqlite 支持的 crtch 存储中 数据库，

1787
02:41:03,040 --> 02:41:06,872
我们还让云服务

1788
02:41:06,872 --> 02:41:10,160
知道当前登录的用户，所以

1789
02:41:10,160 --> 02:41:14,720
当用户登录时，他或她只能看到他们自己的笔记，当该用户注销

1790
02:41:14,720 --> 02:41:19,040
时，另一个用户登录，然后是之前创建的

1791
02:41:19,040 --> 02:41:25,440
数据库中的笔记不会暴露给新用户，所以我们已经处理了所有这些，但

1792
02:41:25,440 --> 02:41:29,192
我们的笔记仍然只存储在本地存储中

1793
02:41:29,192 --> 02:41:33,040
，从本章开始，我们将真正

1794
02:41:33,040 --> 02:41:36,400
远离 存储我们 将数据存储在本地数据库中

1795
02:41:36,400 --> 02:41:41,040
，而不是将其存储在 firebase 中

1796
02:41:51,680 --> 02:41:57,280
事情是crud create read update and delete and um 虽然 firebase

1797
02:41:57,280 --> 02:42:02,800
是一个很好的方法，但是 firebase 删除了很多

1798
02:42:02,800 --> 02:42:07,360
你需要理解的逻辑才能成为更好的开发人员，所以

1799
02:42:07,360 --> 02:42:11,920
firebase 已经抽象出人群的概念 很多，你

1800
02:42:11,920 --> 02:42:14,872
在云中处理数据，你真的不知道这些数据是如何填充的以及在

1801
02:42:14,872 --> 02:42:18,400
哪里填充，所以当我开始设计课程时，我

1802
02:42:18,400 --> 02:42:22,960
想也许可以，我们可以先看看在本地存储数据

1803
02:42:22,960 --> 02:42:27,280
很好地掌握crud，然后我们现在

1804
02:42:27,280 --> 02:42:30,800
了解crop是如何工作的，以及这些操作是如何在数据库级别的低级别执行的，

1805
02:42:30,800 --> 02:42:35,280
然后我们可以离开它并转到am  ore abstract layer

1806
02:42:35,280 --> 02:42:39,832
所以这是我在设计这门课程的早期遇到的一个选择，这

1807
02:42:39,832 --> 02:42:44,160
绝对不是浪费时间你现在知道如何在你的应用程序中使用 sql light

1808
02:42:44,160 --> 02:42:49,040
，你可能会越来越多地使用 sqlite

1809
02:42:49,040 --> 02:42:53,680
在你的 Flutter 开发生涯中，

1810
02:42:53,680 --> 02:42:56,872
我希望你明白，

1811
02:42:56,872 --> 02:43:01,600
我们仍然很好地使用了 uh sqlite，我们已经理解了这一点，但是现在

1812
02:43:01,600 --> 02:43:08,320
是时候离开我们的本地存储并转向使用 um firebase 相反，

1813
02:43:08,320 --> 02:43:11,600
所以我想为本章的下一部分提供标题，

1814
02:43:11,600 --> 02:43:16,640
这就是我们要讨论 Cloud Firestore 所以如果我拿出我的

1815
02:43:16,640 --> 02:43:21,040
笔记并转到我为你提供的那个 URL

1816
02:43:21,040 --> 02:43:25,512
并且 把它带到这里，你可以在这里看到它说

1817
02:43:25,512 --> 02:43:31,040
firestore是一个灵活的可扩展的nosql云数据库，以

1818
02:43:31,040 --> 02:43:34,552
它的工作方式存储和同步数据我的意思是你

1819
02:43:34,552 --> 02:43:38,232
可以实际访问我提供的这个链接 你在这里，它告诉

1820
02:43:38,232 --> 02:43:41,832
你如何实际 y 将 cloud firestore 添加到您的应用程序，但我

1821
02:43:41,832 --> 02:43:45,040
相信我们已经这样做了，所以如果我将我们的 um

1822
02:43:45,040 --> 02:43:49,360
应用程序也带到屏幕上，请增加大小，然后我们进入我们的 pop

1823
02:43:49,360 --> 02:43:52,552
special，我们将查看我们所处的依赖项

1824
02:43:52,552 --> 02:43:57,280
在这里使用 firebase core firebase auth 和 um 的那一刻也告诉

1825
02:43:57,280 --> 02:44:01,120
你必须使用 cloud firestore 所以让我们进入这里，我们可以看到我们

1826
02:44:01,120 --> 02:44:04,872
已经从本课程中绝对最早的章节之一中拖入了 cloud firestore

1827
02:44:04,872 --> 02:44:08,400
已经

1828
02:44:08,400 --> 02:44:12,080
将此依赖项添加到我们的应用程序中，因此您不必这样做，但如果您

1829
02:44:12,080 --> 02:44:17,440
没有将 Cloud Firestore 添加到您的应用程序中，您现在可能需要

1830
02:44:17,440 --> 02:44:21,192
按照此链接中的说明进行操作，如果您有 没有

1831
02:44:21,192 --> 02:44:25,680
它可能是因为你错过了这个 um 课程的早期章节之一，

1832
02:44:25,680 --> 02:44:29,832
所以

1833
02:44:29,832 --> 02:44:34,000
我们将使用 cloud firestore 来存储用户

1834
02:44:34,000 --> 02:44:36,800
生成的数据，在这种情况下，我们的节点

1835
02:44:36,800 --> 02:44:41,600
现在你可能很熟悉 使用 sql 和 nosql

1836
02:44:41,600 --> 02:44:44,720
但我的意思是

1837
02:44:44,720 --> 02:44:50,160
我可以解释 clo  ud fire stories是你将有

1838
02:44:50,160 --> 02:44:55,832
两个你需要理解的概念，它们被称为um collections

1839
02:44:55,832 --> 02:45:01,512
，另一个是文档，所以在传统的sql存储中，你

1840
02:45:01,512 --> 02:45:06,640
将有硬依赖和每个uh表，例如当我们设计我们的

1841
02:45:06,640 --> 02:45:10,960
sqlite时 数据库我们实际上必须在表内设计具有特定

1842
02:45:10,960 --> 02:45:14,720
布局的表，所以我们有不同的字段，我们有

1843
02:45:14,720 --> 02:45:20,000
外键等，这就像一个典型的 sql 关系关系数据库，

1844
02:45:20,000 --> 02:45:24,800
但是当你去 node sql 例如 firestore 时，事情更多是

1845
02:45:24,800 --> 02:45:27,600
基于文档的所以 对于那些正在做后端开发的人来说，你已经知道

1846
02:45:27,600 --> 02:45:30,720
了，例如，

1847
02:45:30,720 --> 02:45:35,120
如果你使用的是 sequel light，那么事情不会像你想的那样基于文档，

1848
02:45:35,120 --> 02:45:38,080
但是当我们去 firestore 时，你

1849
02:45:38,080 --> 02:45:44,232
会拥有很多 基本上为您的表格和文档定义更宽松的数据，

1850
02:45:44,232 --> 02:45:48,800
因此同一集合中的一个文档可以包含

1851
02:45:48,800 --> 02:45:52,552
两个字段，下一个文档可以包含三个字段，

1852
02:45:52,552 --> 02:45:57,192
因此 使用firestar创建它的方式更加开放，

1853
02:45:57,192 --> 02:46:00,872
因此从这一点开始，在整个课程中，我们将

1854
02:46:00,872 --> 02:46:06,080
依赖firestore来使用它来存储用户生成的内容，

1855
02:46:06,080 --> 02:46:11,192
这些内容在我们的例子中是笔记，所以让我们 现在谈谈

1856
02:46:11,192 --> 02:46:16,872
生产模式与测试模式 um firebase 使用 firestore，因为您很快就会看到它

1857
02:46:16,872 --> 02:46:19,920
有不同的

1858
02:46:19,920 --> 02:46:26,160
方式允许您作为开发人员与您的数据库进行交互，

1859
02:46:26,160 --> 02:46:30,080
所以有一种叫做测试模式和另一个调用者的东西 生产模式

1860
02:46:30,080 --> 02:46:34,080
和测试模式，这意味着当您正在开发您的应用程序时

1861
02:46:34,080 --> 02:46:38,960
，例如我们目前正在开发的应用程序，您可能需要例如

1862
02:46:38,960 --> 02:46:43,040
打开您的数据库，以便您可以

1863
02:46:43,040 --> 02:46:46,960
与您的 from 进行实际交互 例如，您的应用程序甚至无需对用户进行身份验证，

1864
02:46:46,960 --> 02:46:50,232
因此即使用户未经过身份验证，您实际上也可以

1865
02:46:50,232 --> 02:46:55,280
向 firestore 发出一些命令以读取数据、删除数据

1866
02:46:55,280 --> 02:46:59,680
并更改数据，这就是您正在开发的

1867
02:46:59,680 --> 02:47:02,720
r 应用程序，而您仍在使用身份验证，但

1868
02:47:02,720 --> 02:47:06,720
请记住，我们已经确定了身份验证，因此如果您忘记了无法结束，您实际上无法

1869
02:47:06,720 --> 02:47:10,872
最终进入便笺视图或嵌入在便笺视图中的便笺列表视图

1870
02:47:13,680 --> 02:47:18,320
如果您尚未进行身份验证并且您尚未

1871
02:47:18,320 --> 02:47:22,720
验证您的电子邮件地址，那么我们知道，在我们的案例中，我们实际上

1872
02:47:22,720 --> 02:47:27,832
并不需要使用我们的数据库的测试模式和 Firestore，我们

1873
02:47:27,832 --> 02:47:32,872
会立即 切换到生产模式以及生产模式是什么，

1874
02:47:32,872 --> 02:47:37,192
例如，当您开发 Firestore 数据库时，您将在本章中很快看到

1875
02:47:39,192 --> 02:47:43,120
您将能够向数据库添加更多规则，

1876
02:47:43,120 --> 02:47:46,400
以便未经身份验证访问

1877
02:47:46,400 --> 02:47:50,800
数据库 将被拒绝，这是我们

1878
02:47:50,800 --> 02:47:55,120
将在本课程的其余部分中使用的类似模型，并且几乎在本课程结束时，

1879
02:47:55,120 --> 02:47:58,640
我们还将向

1880
02:47:58,640 --> 02:48:02,480
我们的 firebase 添加更多规则 抱歉，firestore 数据库 ase 以便我们

1881
02:48:02,480 --> 02:48:07,512
更明确地说明谁可以访问

1882
02:48:07,512 --> 02:48:10,872
只知道有测试模式和生产模式的内容 测试模式

1883
02:48:10,872 --> 02:48:14,800
在安全性方面有点松散，但生产模式

1884
02:48:14,800 --> 02:48:18,720
在这方面更严格一些 如果它只是试图

1885
02:48:18,720 --> 02:48:21,832
确保在经过身份验证的访问

1886
02:48:21,832 --> 02:48:25,440
uh 时，例如一个文档，因此用户无权访问将被

1887
02:48:25,440 --> 02:48:29,120
拒绝，

1888
02:48:29,120 --> 02:48:32,720
好吧，我们已经注意到我刚刚

1889
02:48:32,720 --> 02:48:37,120
提到了一些事情 关于规则，您可能想知道这些

1890
02:48:37,120 --> 02:48:40,080
规则实际上是什么以及它们的实际含义，

1891
02:48:40,080 --> 02:48:44,480
所以我在这里准备了链接，所以我要看看我是否真的可以在

1892
02:48:44,480 --> 02:48:47,440
我的电脑上打开它，这样我就可以把它带到 屏幕

1893
02:48:47,440 --> 02:48:51,832
在这里没关系，所以这些是我正在谈论的规则，

1894
02:48:51,832 --> 02:48:55,192
所以你看看你是否

1895
02:48:55,192 --> 02:48:59,920
像我一样是后端开发人员，你也会非常熟悉部署你的

1896
02:48:59,920 --> 02:49:03,680
应用程序，所以如果你是 django 开发人员或 node.js 与 express

1897
02:49:03,680 --> 02:49:08,960
或任何东西或烧瓶开发人员然后你是公关 习惯于

1898
02:49:08,960 --> 02:49:12,872
将您的应用程序部署到某种云

1899
02:49:12,872 --> 02:49:17,280
服务，然后您还将

1900
02:49:17,280 --> 02:49:23,600
负责指定用户如何与您的后端交互以及

1901
02:49:23,600 --> 02:49:29,280
在什么情况下应用什么规则，因为它不像

1902
02:49:29,280 --> 02:49:33,440
您拥有的传统后端 部署自己，因为它是

1903
02:49:33,440 --> 02:49:37,760
已经存在并且已部署的产品，它需要您的帮助才能

1904
02:49:37,760 --> 02:49:42,552
了解其安全规则，因此您可以看到这是后端的典型 Firebase

1905
02:49:42,552 --> 02:49:46,232
Firestore 配置，您可以在此处看到它说 该

1906
02:49:46,232 --> 02:49:51,600
服务是 firestore 服务，并在这些路径上匹配这些文档，

1907
02:49:51,600 --> 02:49:56,000
并且仅在用户经过身份验证时才允许读取和写入，

1908
02:49:56,000 --> 02:49:59,192
因此，如果您是 django 开发人员，您已经知道类似

1909
02:49:59,192 --> 02:50:04,872
请求，您也会知道您在 django 中所以 请求用户将

1910
02:50:04,872 --> 02:50:08,960
包含当前登录的经过身份验证的用户，因此这与该用户非常相似

1911
02:50:08,960 --> 02:50:11,760
，如果我

1912
02:50:11,760 --> 02:50:14,320
谈论后端开发只是因为我正在尝试，我很抱歉 如果您不是

1913
02:50:14,320 --> 02:50:17,440
后端开发人员，那么喜欢为那些后端开发人员并尝试了解 Firebase Firestore 的人建立这种联系，

1914
02:50:17,440 --> 02:50:21,040
只要

1915
02:50:21,040 --> 02:50:25,360
知道这些安全规则可以帮助

1916
02:50:25,360 --> 02:50:28,800
您，

1917
02:50:28,800 --> 02:50:33,832
他们就可以提供帮助 您保护了您的数据库，因为您看到

1918
02:50:33,832 --> 02:50:37,192
了我们实际生成应用程序的方式让我们转到源代码

1919
02:50:37,192 --> 02:50:41,760
并看一下它，当我们使用 firebase cli 和 firestore cli 设置我们的 uh firebase 时，

1920
02:50:41,760 --> 02:50:46,400
有一些文件 它们是自动为我们生成的

1921
02:50:46,400 --> 02:50:50,480
，它们在这个 firebase 选项中，所以

1922
02:50:50,480 --> 02:50:54,552
我要在这里为我们打开它，你可以在这里看到一些信息，

1923
02:50:54,552 --> 02:50:58,872
正如你可以看到的 android 应用程序有一个 api key app id 消息

1924
02:50:58,872 --> 02:51:05,192
发送者 id 项目 id 和存储桶，如果有人掌握了此信息，

1925
02:51:05,192 --> 02:51:09,360
因为您现在将通过观看本课程来掌握此信息，

1926
02:51:09,360 --> 02:51:13,512
您实际上将能够复制此 firebase 选项。 在您自己的

1927
02:51:13,512 --> 02:51:20,080
应用程序中使用我的 api 密钥应用程序 ID 和发件人 ID 并与

1928
02:51:20,080 --> 02:51:24,160
我控制的数据库进行交互，即使您个人无权访问该

1929
02:51:24,160 --> 02:51:28,160
数据库，因为该数据库存储在我

1930
02:51:28,160 --> 02:51:30,320
在

1931
02:51:30,320 --> 02:51:34,480
firebase 控制台中的配置文件下，因此使用 这个 api 密钥和应用程序 ID，您可以

1932
02:51:34,480 --> 02:51:39,192
与数据库交互，它只是安全信息，它只是

1933
02:51:42,640 --> 02:51:46,400
我在我的 firebase 配置中指定的 um 身份验证信息或身份验证规则，

1934
02:51:46,400 --> 02:51:50,640
然后将决定谁可以访问什么，

1935
02:51:50,640 --> 02:51:55,192
所以不用担心 关于这一点，我

1936
02:51:55,192 --> 02:51:59,280
实际上将在本课程发布时删除这个 firebase 项目，所以我对这些

1937
02:51:59,280 --> 02:52:04,552
信息公开并显示给你感到非常满意

1938
02:52:07,280 --> 02:52:13,120
我们可以在我们的 firebase firestore 项目中定义我们可以指定谁可以访问

1939
02:52:13,120 --> 02:52:17,760
什么以及基于什么规则，例如，如果用户经过身份验证，

1940
02:52:17,760 --> 02:52:23,512
或者该用户 id 是否实际存在于该文档的 id 字段中 例如，这样的

1941
02:52:23,512 --> 02:52:27,120
事情

1942
02:52:27,120 --> 02:52:31,040
好吧，嗯，现在我们要做的实际上是

1943
02:52:31,040 --> 02:52:36,960
开始为我们的项目创建一个 um firestore 数据库，所以

1944
02:52:36,960 --> 02:52:41,360
呃我在这里要做的是我要调出 safari，我要

1945
02:52:41,360 --> 02:52:45,920
去控制台firebase.com，所以我建议你做同样的事情，

1946
02:52:45,920 --> 02:52:49,120
在这里稍微改变一下屏幕布局，

1947
02:52:49,120 --> 02:52:52,720
这样你就能更好地看到我的屏幕，对不起

1948
02:52:52,720 --> 02:52:57,512
，然后我要去我们的减号花项目，所以我建议你

1949
02:52:57,512 --> 02:53:00,552
做 你的应用程序也是一样的，

1950
02:53:00,552 --> 02:53:04,080
所以当我们在这里结束时，在左侧你会看到一个叫做

1951
02:53:04,080 --> 02:53:07,440
firestore 数据库的东西，我希望你点击那里并确保你

1952
02:53:07,440 --> 02:53:11,192
在这里也选择了正确的应用程序 可能有很多

1953
02:53:11,192 --> 02:53:14,800
就像我一样，然后我们需要在这里

1954
02:53:14,800 --> 02:53:20,872
做的，只是说创建数据库没问题，正如你所看到的，现在的

1955
02:53:20,872 --> 02:53:26,000
屏幕可能看起来有点吓人，但它完全没问题

1956
02:53:26,000 --> 02:53:30,080
，你 可以看到这里指定了两种不同的模式，因为我们谈到了

1957
02:53:30,080 --> 02:53:33,832
生产模式 a 然后另一个

1958
02:53:33,832 --> 02:53:40,720
是生产模式下的测试模式，对不起，默认规则非常

1959
02:53:40,720 --> 02:53:46,080
糟糕，正如您在此处看到的那样，它说数据库中的任何文档都

1960
02:53:46,080 --> 02:53:49,832
无法访问，因此或无法访问，无法访问

1961
02:53:49,832 --> 02:53:55,680
它说不允许读取 或者写因为条件只是假

1962
02:53:55,680 --> 02:53:59,920
所以你可以看到它说所有第三方读取和权利都将被拒绝

1963
02:53:59,920 --> 02:54:03,600
但这真的不是嗯

1964
02:54:03,600 --> 02:54:06,552
这不是我们将如何设置我们的

1965
02:54:06,552 --> 02:54:10,800
firestore数据库我们就像我之前提到的我们 将来会加强

1966
02:54:10,800 --> 02:54:16,640
很多，但不仅仅是现在，所以我需要你

1967
02:54:16,640 --> 02:54:21,120
进入测试模式开始，你会收到这个绝对漂亮的

1968
02:54:21,120 --> 02:54:25,600
消息，说测试模式的默认安全规则允许

1969
02:54:25,600 --> 02:54:29,832
任何人 使用您的数据库参考来查看和记住数据库参考

1970
02:54:41,920 --> 02:54:45,120
它说

1971
02:54:45,120 --> 02:54:50,400
在接下来的 30 天内从数据库中的所有数据中编辑和删除所有数据库，所以没关系

1972
02:54:50,400 --> 02:54:54,000
，你可以看到这里设置的规则说如果

1973
02:54:54,000 --> 02:54:58,480
请求时间小于等等等等，则允许读写所以 它基本上会打开您的数据库

1974
02:54:58,480 --> 02:55:02,800
30 天 它实际上非常智能 非常好 所以我

1975
02:55:02,800 --> 02:55:07,440
需要你这样做 记住我们很快就会收紧它

1976
02:55:07,440 --> 02:55:11,760
然后你可以在这里看到它说允许基本上设置一个位置

1977
02:55:11,760 --> 02:55:17,360
您的数据现在将存储在哪里可能存在某种

1978
02:55:17,360 --> 02:55:21,680
利益冲突，例如您的业务的法律部分

1979
02:55:21,680 --> 02:55:25,760
以及您想要存储数据的位置以及您实际

1980
02:55:25,760 --> 02:55:30,552
感觉舒适的位置，但是 gdpr 肯定会让

1981
02:55:30,552 --> 02:55:34,080
如果你住在欧洲，这会更加复杂，所以

1982
02:55:34,080 --> 02:55:38,640
我的意思是，即使你住在国外，gdpr 也会让事情变得复杂

1983
02:55:38,640 --> 02:55:43,040
，一些托管在美国的网站仍然无法被欧盟的用户访问

1984
02:55:43,040 --> 02:55:47,440
，这让事情变得有点复杂 我现在基本上

1985
02:55:47,440 --> 02:55:50,320
在瑞典，所以我更喜欢使用

1986
02:55:53,832 --> 02:55:59,600
可能与欧洲有关的位置，嗯，我可以看到欧洲西部，而瑞典

1987
02:55:59,600 --> 02:56:04,000
有点像在中间，所以我只是 现在要使用欧洲西部，但

1988
02:56:04,000 --> 02:56:08,400
现在这又不是那么重要，它可能

1989
02:56:08,400 --> 02:56:12,160
会对应用程序的速度产生一些影响，具体取决于服务器的实际

1990
02:56:12,160 --> 02:56:16,000
位置，所以 Firebase 让你可以选择你的位置真的很好

1991
02:56:16,000 --> 02:56:21,192
firestore 数据库，因此您可能想阅读更多有关此内容的信息

1992
02:56:21,192 --> 02:56:25,680
，您可以按了解更多信息以阅读有关此内容的更多信息，但我

1993
02:56:25,680 --> 02:56:30,232
只会选择欧洲西部，因为我相信它对我来说更有意义，

1994
02:56:30,232 --> 02:56:34,080
因为我位于 在瑞典所以

1995
02:56:34,080 --> 02:56:38,960
选择一个对你有意义的位置，然后按下启用按钮

1996
02:56:38,960 --> 02:56:45,360
哇，这是一个绝对可怕的加载屏幕

1997
02:56:45,360 --> 02:56:49,512
我的意思是它甚至没有居中所以没关系 firebase

1998
02:56:49,512 --> 02:56:53,680
记住我们使用 firebase 作为免费服务 所以我只想 确保

1999
02:56:53,680 --> 02:56:56,872
每个人都明白我非常感谢拥有 firebase，因为

2000
02:56:56,872 --> 02:57:00,872
它让我的生活变得更轻松，即使我可以创建自己的后端，

2001
02:57:00,872 --> 02:57:04,320
但我有时仍然更喜欢使用 firebase，

2002
02:57:04,320 --> 02:57:10,320
所以嗯，只是因为它很容易使用 所以，非常感谢

2003
02:57:10,320 --> 02:57:15,280
任何在firebase上工作并为我们提供免费

2004
02:57:15,280 --> 02:57:19,600
服务的人，

2005
02:57:19,600 --> 02:57:25,120
所以让我们在这里看看我们的规则，让我

2006
02:57:25,120 --> 02:57:28,960
像这样增加屏幕的大小，也许也

2007
02:57:28,960 --> 02:57:33,440
像这样增加它 所以你看得更清楚，让我看看我是否可以

2008
02:57:33,440 --> 02:57:37,120
稍微关闭左边的部分

2009
02:57:37,120 --> 02:57:39,920
，我实际上可能已经这样做了，

2010
02:57:39,920 --> 02:57:43,832
所以我要回到这里并按下这个按钮来关闭那个部分，

2011
02:57:43,832 --> 02:57:48,320
所以 我们现在需要做的是，正如标题所示，

2012
02:57:48,320 --> 02:57:53,512
我们将更改数据库中的安全规则

2013
02:57:53,512 --> 02:57:57,440
，我对其进行更改，以便

2014
02:57:57,440 --> 02:58:03,680
在用户通过身份验证的情况下允许读取和写入，

2015
02:58:03,680 --> 02:58:09,040
所以我们尽可能确保您可以 看到它说 request off 不是 null 所以让我们

2016
02:58:09,040 --> 02:58:14,400
继续并更改它，因此我将在这样的请求点之后删除所有内容

2017
02:58:14,400 --> 02:58:19,440
，您可以看到它使您可以访问路径资源时间

2018
02:58:19,440 --> 02:58:22,872
方法，所以我只想说 off 不是 null

2019
02:58:22,872 --> 02:58:26,800
好的，所以您实际上可以带来它

2020
02:58:26,800 --> 02:58:30,400
如果您愿意，也可以在同一行完成后，

2021
02:58:30,400 --> 02:58:35,680
如果请求身份验证不是全部，您可以说允许读写，这实际上只是意味着

2022
02:58:35,680 --> 02:58:40,320
通过我们的应用程序进行身份验证的人并且他们拥有

2023
02:58:40,320 --> 02:58:45,280
并且他们拥有有效的 当他们与数据库交互时，firebase 用户被

2024
02:58:45,280 --> 02:58:49,040
允许读取和写入从数据库读取和写入数据库，

2025
02:58:49,040 --> 02:58:53,832
但是请记住，这是数据库范围的，目前它

2026
02:58:53,832 --> 02:58:57,760
说任何文档，我们仍然没有太多谈论文档，但我会

2027
02:58:57,760 --> 02:59:02,400
告诉 你很快就会知道，但是任何人都可以想象，如果用户登录，你的数据库中的任何内容都可以被

2028
02:59:02,400 --> 02:59:07,192
读取和写入，这并不那么安全，

2029
02:59:07,192 --> 02:59:10,640
因为这实际上意味着我作为用户 1

2030
02:59:10,640 --> 02:59:15,192
而你作为用户 2 可以访问彼此的文档 好吧，即使

2031
02:59:15,192 --> 02:59:19,440
应用程序本身就像隔离这两个文件，说哦，

2032
02:59:19,440 --> 02:59:24,552
你是一个用户，我只会给你用户的文件，但在内部作为

2033
02:59:24,552 --> 02:59:29,600
firebase 用户，考虑到我们当前的安全 um

2034
02:59:29,600 --> 02:59:32,872
规则，即使应用程序受到限制，你也可以访问我的文件

2035
02:59:32,872 --> 02:59:36,872
您的访问权限请记住，好的，

2036
02:59:36,872 --> 02:59:40,080
所以在您完成之后，我需要您

2037
02:59:40,080 --> 02:59:44,960
按下发布按钮，这样您就可以看到它说发布

2038
02:59:44,960 --> 02:59:48,000
更改可能需要一分钟才能生效，这没关系，因为

2039
02:59:48,000 --> 02:59:53,120
我们要 在我们开始在我们的应用程序中使用这些新规则之前实际上需要一分钟多的时间，

2040
02:59:53,120 --> 02:59:58,232
所以现在好了