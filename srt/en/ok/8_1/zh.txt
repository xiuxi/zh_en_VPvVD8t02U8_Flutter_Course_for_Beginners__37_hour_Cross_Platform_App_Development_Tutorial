1
00:00:00,720 --> 00:00:02,719
让我们在这里谈谈收藏

2
00:00:02,719 --> 00:00:08,800
，我已经准备了一个文档和一个链接，所以让我看看我

3
00:00:08,800 --> 00:00:12,871
是否也可以在这里找到那个链接，这样你就可以在这里看到，有一个

4
00:00:12,871 --> 00:00:16,000
很好的文档可以讨论一些关于收藏的内容 和

5
00:00:16,000 --> 00:00:20,719
文件，你可以通过这个，但我现在不打算这样做，

6
00:00:20,719 --> 00:00:24,079
但如果你想这样做，你知道这是屏幕底部的链接

7
00:00:24,079 --> 00:00:28,079
，我将亲自谈论收藏，

8
00:00:28,079 --> 00:00:31,600
所以你 用我的话会明白，所以

9
00:00:31,600 --> 00:00:36,832
此时我们需要的只是去我们的firebase数据库

10
00:00:36,832 --> 00:00:42,079
，你会看到一个看起来像这样的屏幕，所以这里有

11
00:00:42,079 --> 00:00:47,119
你的项目名称，然后有一个 名为开始收集的按钮

12
00:00:47,119 --> 00:00:52,079
好吧，想象一下集合，正如它的名字所指示的那样，它是一组相关的对象

13
00:00:52,079 --> 00:00:56,640
对象可能是您可以将它们解释为传统上

14
00:00:56,640 --> 00:01:01,439
在关系数据库（例如 sqlite）中拥有的表

15
00:01:04,480 --> 00:01:10,079
我们的应用程序做我们的吗 应用程序为其所有用户存储节点，

16
00:01:10,079 --> 00:01:15,512
所以用户 a 有节点，用户 b 有节点，但用户 c 可能没有节点，

17
00:01:15,512 --> 00:01:18,719
所以我们的应用程序现在唯一存储

18
00:01:18,719 --> 00:01:25,359
在数据库中的是注释，所以它可以是它自己的集合，所以我们

19
00:01:25,359 --> 00:01:29,920
只需创建 一个名为 notes 的集合，在该集合中，我们将存储

20
00:01:29,920 --> 00:01:33,831
我们所有的便笺，这样每个用户都会有自己的

21
00:01:33,831 --> 00:01:37,599
便笺，这就是我们在本课程中将这样做的方式，

22
00:01:37,599 --> 00:01:40,480
但是作为开发人员的您可能只是

23
00:01:40,480 --> 00:01:43,760
认为我要去 以不同的方式做

24
00:01:43,760 --> 00:01:48,159
我要做的是，我将为每个用户创建一个新的笔记集合，以便

25
00:01:48,159 --> 00:01:51,680
用户 a 将拥有一个名为用户 a 笔记的集合，

26
00:01:51,680 --> 00:01:56,079
用户 b 将拥有用户 b 笔记或你 可能只是

27
00:01:56,079 --> 00:02:01,680
为每个用户 ID 分配创建一个集合，所以你记得我们从 firebase 获得一个用户

28
00:02:01,680 --> 00:02:06,231
标识符你可以决定你

29
00:02:06,231 --> 00:02:10,800
根据他们的用户 ID 为每个用户创建一个集合，这很好，但是如果你跟着

30
00:02:10,800 --> 00:02:13,919
这个课程我 强烈建议实际上按照我正在做的方式做 esp 特别是

31
00:02:13,919 --> 00:02:18,719
如果你如果你是第一次这样做如果你之前已经这样做了

32
00:02:18,719 --> 00:02:21,680
你可能只是对创建

33
00:02:21,680 --> 00:02:25,439
另一种类型的收藏感到满意然后成为我的客人请继续但这

34
00:02:25,439 --> 00:02:30,719
对你来说可能很困难 稍后继续课程

35
00:02:30,719 --> 00:02:34,551
好吧，所以这些是集合，

36
00:02:34,551 --> 00:02:40,639
所以让我们继续，然后点击这里的开始集合按钮，

37
00:02:40,639 --> 00:02:45,759
嗯，正如你在这里看到的，它说好的，这个集合是在

38
00:02:45,759 --> 00:02:50,000
根路径中创建的，只需给我一个 id，这是一组

39
00:02:50,000 --> 00:02:53,759
包含数据的文档，在这里它存储了一组

40
00:02:53,759 --> 00:02:56,400
用户，但请记住，我们不必

41
00:02:56,400 --> 00:03:00,479
将用户实际存储在我们的数据库中，firebase 已经在处理这个问题，我实际上

42
00:03:00,479 --> 00:03:04,319
认为这是一个不好的例子 他们要求人们说出

43
00:03:04,319 --> 00:03:08,960
用户的示例集合，因为这种方式为开发人员提供了 id 想法哦，现在我

44
00:03:08,960 --> 00:03:14,080
必须将我的用户存储在这里，但是这些用户已经存储在 firebase

45
00:03:14,080 --> 00:03:18,159
级别，好吧，所以让我们继续在这里，

46
00:03:18,159 --> 00:03:23,759
只是 s 是的，我们正在存储节点，我们接下来要说

47
00:03:23,759 --> 00:03:27,439
，你可以在这里看到，现在我们得到了一个叫做文档

48
00:03:27,439 --> 00:03:30,551
父路径注释的东西，然后它说一个文档 ID，一个

49
00:03:30,551 --> 00:03:33,919
集合必须包含至少一个文档云 Firestore

50
00:03:33,919 --> 00:03:39,439
存储文档单元将您的数据存储为字段自动生成文档或

51
00:03:39,439 --> 00:03:44,479
id，或者如果需要可以自定义一个

52
00:03:44,479 --> 00:03:47,831
，这样我们就可以知道什么文档是

53
00:03:47,831 --> 00:03:50,319
一个文档，

54
00:03:50,319 --> 00:03:55,512
您可以查看它，就好像您了解呃

55
00:03:55,512 --> 00:03:59,831
sql 从以前开始，如果您

56
00:03:59,831 --> 00:04:04,479
在查看 db browser for sql lite 时遵循我们一直在创建的内容和内容，

57
00:04:04,479 --> 00:04:08,080
那么我们有这些表，如 user 并注意

58
00:04:08,080 --> 00:04:13,439
这些，呃，这些就像文档的架构，

59
00:04:13,439 --> 00:04:17,439
所以你可以看到 这里和这里说每个笔记

60
00:04:17,439 --> 00:04:21,600
都是这样创建的 它有一个 id 它有一个用户 id 它有一个文本 与

61
00:04:21,600 --> 00:04:25,600
云同步 记住所有这些字段并且它有那是

62
00:04:25,600 --> 00:04:31,192
在 firestore 世界中很远的模式那些是文档所以整个笔记

63
00:04:31,192 --> 00:04:36,079
架构是一个文档，每个字段我 然后它可以有一个数据类型，

64
00:04:38,639 --> 00:04:42,480
所以当我们创建自己的表时，

65
00:04:42,480 --> 00:04:47,120
这些字段你

66
00:04:47,120 --> 00:04:50,552
可能会知道它们是列 我们现在不会实际使用它，

67
00:04:50,552 --> 00:04:55,360
您可能有，您甚至可能喜欢将那个数据库扔进垃圾箱

68
00:04:55,360 --> 00:04:58,800
，这完全没问题，我只想告诉你这个，嗯

69
00:04:58,800 --> 00:05:04,232
，当我们创建这个节点表或节点文档时 我们有不同的

70
00:05:04,232 --> 00:05:09,279
字段记住 id 用户 id 文本，这些在此处是完全相同的东西，

71
00:05:09,279 --> 00:05:14,552
所以如果我继续创建一个新的

72
00:05:14,552 --> 00:05:19,439
控制台 firebase 并查看例如我的

73
00:05:19,439 --> 00:05:25,360
其他 uh firebase 项目，我可以看到我有一个 笔记应用程序，你可以在这里看到

74
00:05:25,360 --> 00:05:30,160
，嗯，我在本课程开始时设计这个的方式是我有

75
00:05:30,160 --> 00:05:34,552
一个集合，然后每个集合中都有文档，其中有文本，

76
00:05:34,552 --> 00:05:38,800
然后是用户 ID，这就是我们要 在这里我们只会说一个

77
00:05:38,800 --> 00:05:42,800
文本字段 d 它是键入的字符串，它没有

78
00:05:42,800 --> 00:05:46,800
值，好吧，然后我们要在这里添加一个新字段，只需调用它使用

79
00:05:46,800 --> 00:05:51,120
righty 好吧，然后在这里它也没有

80
00:05:51,120 --> 00:05:56,800
值，然后是我们要自动的文档 ID 生成好，所以我们

81
00:05:56,800 --> 00:06:03,120
几乎只是创建了一个带有随机文档 ID 的新便笺，它有一个

82
00:06:03,120 --> 00:06:07,279
文本字段和另一个名为用户 ID 的字段，

83
00:06:07,279 --> 00:06:11,831
然后我需要你按下保存按钮，现在你会看到我们有

84
00:06:11,831 --> 00:06:16,079
我们的笔记集合，在里面我们有一个包含这两个字段的文档，

85
00:06:16,079 --> 00:06:20,959
所以你也可以做的是

86
00:06:20,959 --> 00:06:25,600
删除一个集合或删除一个文档，所以我只想说删除

87
00:06:25,600 --> 00:06:30,552
文档并开始删除，你可以看到 现在我们有一个名为节点的空集合，

88
00:06:30,552 --> 00:06:34,720
我仍然觉得这有点奇怪

89
00:06:34,720 --> 00:06:38,079
，当我们创建一个集合时，firebase 会

90
00:06:38,079 --> 00:06:42,399
强制我们在其中创建一个文档，就像我说开始集合

91
00:06:42,399 --> 00:06:47,759
然后在这里按下下一个按钮我可以'  t 实际上保存我的空集合

92
00:06:47,759 --> 00:06:51,759
，它说每个让' 在这里看到一个集合必须

93
00:06:51,759 --> 00:06:54,552
至少包含一个文档所以

94
00:06:54,552 --> 00:06:57,600
我不确定这是否真的是因为你现在可以看到我们有一个

95
00:06:57,600 --> 00:07:01,920
没有文档的集合所以我不确定为什么会创建

96
00:07:01,920 --> 00:07:05,040
那个为什么那个规则是在什么时候设置的 您创建了一个新

97
00:07:05,040 --> 00:07:08,552
集合，但只知道它不完全正确，因此您可以拥有一个

98
00:07:08,552 --> 00:07:12,959
没有文档的集合，

99
00:07:12,959 --> 00:07:18,800
所以现在让我们谈谈数据流，如果您还

100
00:07:18,800 --> 00:07:25,279
记得我们的应用程序的话 呃

101
00:07:25,279 --> 00:07:28,552
节点服务在这里

102
00:07:28,552 --> 00:07:33,600
你记得我们有这个数据库节点流作为数据库节点列表的流

103
00:07:33,600 --> 00:07:39,120
，我们将它称为我们应用程序中的所有节点到目前为止，

104
00:07:39,120 --> 00:07:43,680
我们必须手动管理这些流，因为我们必须喜欢 去

105
00:07:43,680 --> 00:07:48,232
创建一个流控制器做这整个舞蹈 um

106
00:07:48,232 --> 00:07:52,079
unlisten 用节点填充流控制器

107
00:07:52,079 --> 00:07:57,512
你真的很高兴听到当我们去firebase和

108
00:07:57,512 --> 00:08:02,232
firestore时我们不必做任何这些因为firestore

109
00:08:02,232 --> 00:08:07,360
已经 拥有这一切 例如，当您阅读

110
00:08:07,360 --> 00:08:13,680
此注释集合中的所有文档时，这些文档实际上将是您的这些

111
00:08:13,680 --> 00:08:16,959
数据点的流，因此

112
00:08:16,959 --> 00:08:20,319
不再需要流控制器，也不再

113
00:08:20,319 --> 00:08:24,552
需要您手动管理的流，好吧，这些将被暴露 你的

114
00:08:24,552 --> 00:08:28,552
应用程序使用了firestore

115
00:08:28,552 --> 00:08:32,320
，所以正如你所看到的，当

116
00:08:32,320 --> 00:08:35,919
我开始创建这个集合时，我用

117
00:08:35,919 --> 00:08:41,440
一个带有文本的便笺文档创建了它，它有一个用户ID字段，所以

118
00:08:41,440 --> 00:08:45,279
我们在本章和接下来的目标是确保 每个节点

119
00:08:45,279 --> 00:08:50,871
都有一个文本，它实际上使用该用户的用户 ID 链接到一个 Firebase 用户，

120
00:08:50,871 --> 00:08:53,360
好吧，所以

121
00:08:53,360 --> 00:08:58,000
如果我们将我们的应用程序转到我们的 auth 服务，那么让

122
00:08:58,000 --> 00:09:02,960
我们关闭，然后在这里进行 auth 服务，记住我们正在使用 firebase auth

123
00:09:02,960 --> 00:09:06,871
provider 所以让我们进去，你可以看到，

124
00:09:06,871 --> 00:09:11,279
当我们说创建用户时使用电子邮件和密码，然后这个函数

125
00:09:11,279 --> 00:09:15,511
返回一个叫做用户凭证的东西给我们，用户凭证

126
00:09:15,511 --> 00:09:19,039
实际上有很多属性，你可以看到它有 ac  redential 并且它里面有一个

127
00:09:19,039 --> 00:09:23,831
user 类型的用户，所以如果你进入那个用户，你可以看到它有

128
00:09:23,831 --> 00:09:28,231
不同的属性，比如显示名称、电子邮件、电子邮件验证元数据电话

129
00:09:28,231 --> 00:09:33,831
号码等，但是这个用户还有一个叫做用户唯一 ID 的东西

130
00:09:33,831 --> 00:09:41,192
，我们实际上需要它 为了将笔记存储到我们的收集笔记集合

131
00:09:41,192 --> 00:09:44,639
中，这就是我的意思是

132
00:09:44,639 --> 00:09:47,759
，我们创建的每个文档都将成为节点，一些

133
00:09:47,759 --> 00:09:51,679
随机 id 或我们尚未决定的东西，其中一个字段让我

134
00:09:51,679 --> 00:09:56,000
真正看到 如果我可以调整 uh 这个 safari 窗口的大小，以便您看得更

135
00:09:56,000 --> 00:09:59,120
清楚，那么它将有一个文本，并且文本将由用户生成，但

136
00:09:59,120 --> 00:10:03,440
它也会有一个名为 user id 的字段，所以在这个用户 id 字段中，我们

137
00:10:03,440 --> 00:10:07,039
实际上需要在其中存储该用户的通用

138
00:10:07,039 --> 00:10:10,799
firebase生成的ID，

139
00:10:10,799 --> 00:10:14,639
现在回到我们对该用户所做的事情你

140
00:10:14,639 --> 00:10:20,720
还记得我们实际上并没有将firebase用户暴露给我们的应用程序，

141
00:10:20,720 --> 00:10:24,159
这是一个很好的抽象级别但是w  e有一点

142
00:10:24,159 --> 00:10:29,831
问题，现在我们的用户有电子邮件并且通过电子邮件验证它

143
00:10:29,831 --> 00:10:34,552
实际上没有唯一的ID，因此我们的应用程序将无法

144
00:10:34,552 --> 00:10:39,679
将新笔记与它不会的auth用户相关

145
00:10:39,679 --> 00:10:44,799
联 能够将新笔记与用户 ID 相关联，好吧，

146
00:10:44,799 --> 00:10:48,720
所以我们需要解决这个问题，所以我将在这里稍微查看一下我的笔记

147
00:10:48,720 --> 00:10:54,399
，我们需要更新我们的 auth 用户，如您在此处看到的

148
00:10:54,399 --> 00:10:58,480
所以在我在这里打开的 auth user.dart 文件中

149
00:10:58,480 --> 00:11:01,759
，我们需要添加一个新字段

150
00:11:01,759 --> 00:11:06,000
，这是一个必填字段，我们需要使

151
00:11:06,000 --> 00:11:10,871
该用户的 id 没问题，

152
00:11:10,871 --> 00:11:14,871
所以让我们继续现在就这样做 我只是继续说最后的

153
00:11:14,871 --> 00:11:20,000
字符串和 id，所以这个字段不是可选的，

154
00:11:20,000 --> 00:11:25,679
在这里你看到进入我们应用程序的每个用户都应该有一个 id，

155
00:11:25,679 --> 00:11:30,480
这就像我们对关闭用户的期望一样，所以我需要 您

156
00:11:30,480 --> 00:11:34,480
继续并在此处添加用户类，

157
00:11:34,480 --> 00:11:40,000
然后让我们进入此处，我将把这个添加到

158
00:11:40,000 --> 00:11:43,919
所需的 我可以看到的字段，Visual Studio 代码实际上无法满足

159
00:11:43,919 --> 00:11:47,759
这个必需的参数

160
00:11:51,279 --> 00:11:55,831
现在我们在这里遇到了一个问题，因为

161
00:11:55,831 --> 00:12:02,720
我们在这里的身份验证用户没有我们从 firebase 用户创建的 id，

162
00:12:02,720 --> 00:12:08,480
让我们去补救一下，让我们说这里的 id 是用户 uid

163
00:12:08,480 --> 00:12:13,120
记住我说的这个 uh 参数 对你来说好吧，

164
00:12:13,120 --> 00:12:18,320
所以现在创建了，让我真正去 scrcpy 我可以看到

165
00:12:18,320 --> 00:12:21,360
Visual Studio 代码现在有一点热重载问题，

166
00:12:21,360 --> 00:12:25,279
这是因为应用程序可能不在前台，所以

167
00:12:25,279 --> 00:12:28,480
现在已经解决了 关于 scr cpy

168
00:12:28,480 --> 00:12:32,480
对我来说，在这里引入 crcpy 可能是个好主意，只是为了确保我们不会

169
00:12:32,480 --> 00:12:37,919
带来和破坏任何东西，

170
00:12:37,919 --> 00:12:41,192
所以这是我们必须对我们的汽车用户做出的一个改变，另一个我们必须做的改变

171
00:12:41,192 --> 00:12:45,360
make是为了确保我们用户的email参数

172
00:12:45,360 --> 00:12:48,399
不是可选的，您会看到我们目前创建的方式是

173
00:12:50,720 --> 00:12:56,320
我们的应用程序是我们已经创建了使用电子邮件和密码身份验证的登录过程，

174
00:12:56,320 --> 00:13:00,080
因此我们没有像 facebook 身份验证或 google

175
00:13:00,080 --> 00:13:03,039
身份验证我们只有用户名和 密码

176
00:13:03,039 --> 00:13:08,231
对不起电子邮件和密码，因此在这种情况下，我们可以确定

177
00:13:08,231 --> 00:13:11,831
我们的应用程序中的每个经过身份验证的用户实际上都有一个电子邮件

178
00:13:11,831 --> 00:13:14,871
地址，所以

179
00:13:14,871 --> 00:13:20,159
让我们继续说电子邮件不再是可选字段，在

180
00:13:20,159 --> 00:13:24,799
这里我们将明确 解开那封电子邮件，这

181
00:13:24,799 --> 00:13:32,639
是我们对应用程序所做的另一项更改，所以现在我们已经完成了，你可以看到

182
00:13:32,639 --> 00:13:36,720
颤振对这些更改不太满意，说好吧，是的，你破坏了

183
00:13:36,720 --> 00:13:41,120
一些东西，这是我们的测试被破坏了

184
00:13:41,120 --> 00:13:45,759
所以 正如你所看到的，我们需要确保 id 实际上也包含在我们的

185
00:13:45,759 --> 00:13:50,000
测试中，因为我们实际上并没有

186
00:13:50,000 --> 00:13:55,120
为该用户 id 创建特定的测试，所以我们可以在这里添加一个随机 id

187
00:13:55,120 --> 00:14:00,000
让我们说 我的 id 没问题，我也

188
00:14:00,000 --> 00:14:05,511
要把它带到这里，所以我们在测试中的 auth 用户的两种情况下都有一个 id 字段

189
00:14:09,360 --> 00:14:12,480
好的，现在我们有另一个问题，你可以

190
00:14:12,480 --> 00:14:15,511
在我们的创建更新的标题中看到 note view

191
00:14:15,511 --> 00:14:20,960
我们正在打开用户的电子邮件，这就是这个橙色的小视图 um

192
00:14:20,960 --> 00:14:25,192
文件夹它不是红色的，这

193
00:14:25,192 --> 00:14:29,919
意味着它不是错误，但它是一个警告，所以让我们转到这个创建

194
00:14:29,919 --> 00:14:33,600
更新便笺视图并看看这个 uh

195
00:14:33,600 --> 00:14:38,159
字段 在这里，您可以看到我们在获取创建或获取现有

196
00:14:38,159 --> 00:14:42,399
注释中，我们正在打开这封电子邮件，但

197
00:14:42,399 --> 00:14:46,399
现在警告是说它在说什么，呃，

198
00:14:46,399 --> 00:14:50,480
星号将无效，因为接收者不能 不要尝试删除

199
00:14:50,480 --> 00:14:54,799
星号运算符，我需要你这样做，

200
00:14:54,799 --> 00:14:58,552
我们还有另一个问题，我们在你的笔记中还有另一个警告

201
00:14:58,552 --> 00:15:01,360
，我相信我们在笔记视图中做了类似的事情，所以让我们

202
00:15:01,360 --> 00:15:05,360
看看你是否能找到一个 警告 [音乐] 我实际上没有

203
00:15:05,360 --> 00:15:08,720
的警告在哪里

204
00:15:08,720 --> 00:15:12,871
哦，这里我们也有用户电子邮件，所以我

205
00:15:12,871 --> 00:15:17,192
将在此之后删除星号，所以我需要你做同样的事情，

206
00:15:17,192 --> 00:15:20,480
请

207
00:15:20,480 --> 00:15:23,360
好的，现在我们将进入

208
00:15:23,360 --> 00:15:28,480
uh 云存储集成的多汁部分 所以我很干净我基本上是

209
00:15:28,480 --> 00:15:32,871
从这里删除所有文件所有飞镖标签我实际上并没有像那个标签一样删除我要删除的文件

210
00:15:32,871 --> 00:15:36,080
所以它是一个干净的石板

211
00:15:36,080 --> 00:15:40,480
然后我们需要的是创建

212
00:15:40,480 --> 00:15:44,960
我们所有的 云存储异常，如果您还记得我们使用quad服务时看到的云存储异常，

213
00:15:44,960 --> 00:15:51,192
那么我们在croth文件夹下还有一个

214
00:15:51,192 --> 00:15:55,360
名为crowd exceptions的文件，在这里我们定义

215
00:15:55,360 --> 00:16:00,080
了当用户使用时可能出错的所有不同事物 现在正在使用我们的节点服务，因为

216
00:16:00,080 --> 00:16:05,679
我们正在远离 crud，我们需要在某个地方定义我们的新异常

217
00:16:05,679 --> 00:16:09,192
，并且

218
00:16:09,192 --> 00:16:11,679
正如您在缓存中看到的那样，就像我们有人群异常一样，我们也

219
00:16:11,679 --> 00:16:15,120
将抛出一些异常 通过

220
00:16:15,120 --> 00:16:19,440
我们尚未开发的新的 fire 存储服务 但是，我们至少需要定义

221
00:16:19,440 --> 00:16:24,159
这些异常，所以

222
00:16:24,159 --> 00:16:28,159
我们现在需要去创建那个文件，所以我需要你

223
00:16:28,159 --> 00:16:34,080
在 lib services cloud 下创建一个文件，然后将该文件创建为云

224
00:16:34,080 --> 00:16:38,080
存储异常，所以我要去 也这样做，所以让我们

225
00:16:38,080 --> 00:16:41,600
看看我要在这里折叠所有文件夹，

226
00:16:41,600 --> 00:16:46,399
这样我们就有 lib 服务，然后是云，你可以看到我们目前没有云，

227
00:16:46,399 --> 00:16:51,120
所以我们有服务，我们在那里有 和人群，所以我要

228
00:16:51,120 --> 00:16:55,600
右键单击服务并说新文件，然后在这里我只想说

229
00:16:55,600 --> 00:16:59,600
云，然后删除云存储

230
00:16:59,600 --> 00:17:04,079
异常。dart 好的，

231
00:17:04,079 --> 00:17:08,551
所以在创建该文件后，

232
00:17:08,551 --> 00:17:13,039
我将删除该项目 explorer 还有我们需要的是

233
00:17:13,039 --> 00:17:17,920
为我们所有的 cl 云异常定义一个超类，

234
00:17:17,920 --> 00:17:20,551
如果你还记得

235
00:17:20,551 --> 00:17:24,551
我们在这里创建的人群异常，所有这些异常实际上都是

236
00:17:24,551 --> 00:17:28,480
异常类型，这是一种方法但是

237
00:17:28,480 --> 00:17:32,079
如果你 想要将您的例外归为一个

238
00:17:32,079 --> 00:17:34,319
超级例外，

239
00:17:34,319 --> 00:17:39,039
并且您 然后会非常顺利或更好地处理它们，

240
00:17:39,039 --> 00:17:41,759
实际上我会

241
00:17:41,759 --> 00:17:46,720
在调用站点上说，所以基本上将使用继承，然后你

242
00:17:46,720 --> 00:17:50,799
和我们将创建一个新的异常，正如你

243
00:17:50,799 --> 00:17:55,680
在这里看到的，称为云存储异常和我们所有的 云异常将

244
00:17:55,680 --> 00:18:00,160
属于这种类型，因此将来分组和捕获这些异常会

245
00:18:00,160 --> 00:18:05,920
容易得多

246
00:18:11,192 --> 00:18:14,079
和

247
00:18:14,079 --> 00:18:21,039
类云存储异常并实现异常

248
00:18:21,039 --> 00:18:24,640
好吧，我们还将为它创建一个

249
00:18:24,640 --> 00:18:29,680
常量构造函数，这样它可以更容易地创建这个实例

250
00:18:29,680 --> 00:18:35,192
，你也可以基本上说这是一个

251
00:18:35,192 --> 00:18:39,359
不可变的类，意味着这个类和 它的所有子类都需要是

252
00:18:39,359 --> 00:18:43,832
不可变的，你可以这样做，这也很好，但通常

253
00:18:43,832 --> 00:18:47,511
异常不会用这个标记它通常是数据类，

254
00:18:47,511 --> 00:18:53,039
用不可变标记所以我不去 nna 现在就这样做好吧

255
00:18:53,039 --> 00:18:57,511
，事情已经完成

256
00:18:57,511 --> 00:19:01,511
了，所以这是父异常，我们应该尽量不要抛出该异常

257
00:19:01,511 --> 00:19:06,231
，因为我们必须抛出该异常的子类子类，好的，

258
00:19:06,231 --> 00:19:09,279
现在我们要定义的第一个异常

259
00:19:09,279 --> 00:19:13,359
是 无法创建节点异常，我相信它被称为是，

260
00:19:13,359 --> 00:19:20,640
我们将把它扔到我们的课程中，很快就会写一个类

261
00:19:25,279 --> 00:19:28,160
可以抛出这个错误，

262
00:19:28,160 --> 00:19:34,400
所以我要定义那个异常，然后你需要输入这个，然后嗯，我

263
00:19:34,400 --> 00:19:38,799
刚刚从我的笔记中带来了它，

264
00:19:38,799 --> 00:19:44,160
现在也在这个屏幕上，我们为给定用户显示了所有笔记，

265
00:19:44,160 --> 00:19:47,920
我们也可能不会 能够检索该用户的所有注释，例如，如果

266
00:19:47,920 --> 00:19:51,832
存在网络连接问题或可能出现的任何其他问题，

267
00:19:51,832 --> 00:19:54,231
因此我们也需要为此设置

268
00:19:54,231 --> 00:19:58,400
异常并且调用该异常无法获取所有节点异常正常

269
00:19:58,400 --> 00:20:03,511
所以让我们定义 那也一样，它的写法就像无法获取

270
00:20:03,511 --> 00:20:07,759
所有注释异常

271
00:20:07,759 --> 00:20:12,480
异常我们必须定义的下一个异常称为无法更新

272
00:20:12,480 --> 00:20:17,359
节点，因此我们创建了节点异常获取节点异常，现在我们在

273
00:20:17,359 --> 00:20:23,119
crot 的 u 部分 所以你看到

274
00:20:23,119 --> 00:20:31,039
创建部分是 crud 中的 ac，gets 是 r，现在我们正在看着你

275
00:20:31,039 --> 00:20:36,640
，那是 uh 无法更新节点异常，

276
00:20:36,640 --> 00:20:40,231
所以我们可以说这是

277
00:20:40,231 --> 00:20:44,640
你在 crud 中，get

278
00:20:44,640 --> 00:20:51,680
是 r 在crop 中 在 crud 中创建 ac 好，所以我们

279
00:20:51,680 --> 00:20:55,359
有 cru，然后我们必须定义 d

280
00:20:55,359 --> 00:21:00,400
，它用于删除红外线，这正是我们现在要做的，

281
00:21:00,400 --> 00:21:05,680
所以让我们去定义无法删除节点异常，

282
00:21:05,680 --> 00:21:10,960
然后让我们说在 好的，所以现在我们

283
00:21:10,960 --> 00:21:16,551
定义了三个四个呃异常，所有这些异常都是

284
00:21:16,551 --> 00:21:22,872
从云存储异常继承的，

285
00:21:22,872 --> 00:21:26,400
好吧，现在我们已经讨论了

286
00:21:26,400 --> 00:21:30,551
异常，我们还必须讨论你看到的实际云存储服务

287
00:21:30,551 --> 00:21:34,640
我们目前的四轮车服务 工作量

288
00:21:34,640 --> 00:21:38,960
很大，我们对此感到非常自豪实际上它在我的实现中有很多代码

289
00:21:38,960 --> 00:21:45,599
至少在这里我们有大约 360 行代码

290
00:21:45,599 --> 00:21:49,759
我的意思是不是所有的代码那里还有空格就像

291
00:21:49,759 --> 00:21:53,680
我认为有一些 诸如不可变等注释，但是有很多

292
00:21:53,680 --> 00:21:56,960
代码可以，这里有一个打印语句，我实际上必须删除它，

293
00:21:56,960 --> 00:21:59,511
所以

294
00:21:59,511 --> 00:22:03,440
有很多代码，这可以与 sql lite 一起使用，但我们还需要

295
00:22:03,440 --> 00:22:07,119
一个可以与 firebase 一起使用的服务 firestore，

296
00:22:07,119 --> 00:22:12,319
所以我们需要尽快创建该服务，所以只要知道我们将

297
00:22:12,319 --> 00:22:15,920
在这里有 crud，它将与 sqlite 对话，

298
00:22:15,920 --> 00:22:19,511
但我们实际上正在远离它，所以

299
00:22:19,511 --> 00:22:23,359
让我们修复那个，

300
00:22:23,359 --> 00:22:27,599
所以让我们进入这里并拥有 看看我们的常量

301
00:22:27,599 --> 00:22:31,511
，如果你在这里查看我们的节点服务

302
00:22:31,511 --> 00:22:36,640
，我们在这里有我们的常量，我们有路由，

303
00:22:36,640 --> 00:22:42,319
在节点服务结束时，我们在这个类

304
00:22:42,319 --> 00:22:46,720
或这个 dart 文件中定义了一些常量，有些人可能 像这样，但我

305
00:22:46,720 --> 00:22:51,359
个人 p 指将我的常量定义在单独的文件中，即使

306
00:22:51,359 --> 00:22:56,319
这些常量仅与该文件非常相关，但只是

307
00:22:56,319 --> 00:23:00,400
将它们放在单独的位置只会更容易查看，

308
00:23:00,400 --> 00:23:04,160
因为这些常量目前就像隐藏在底部的底部

309
00:23:04,160 --> 00:23:07,832
这个文件让我们继续定义我们的

310
00:23:07,832 --> 00:23:11,440
常量，让我们看看它将在服务云中的路径

311
00:23:11,440 --> 00:23:17,192
，然后是服务上的云存储常量现在我们有云

312
00:23:17,192 --> 00:23:22,551
，在云下我们有云存储异常我认为异常是的现在 我们

313
00:23:22,551 --> 00:23:28,160
必须定义云存储常量，所以新文件云存储

314
00:23:28,160 --> 00:23:32,551
常量飞镖，

315
00:23:32,551 --> 00:23:35,119
我现在要去我的笔记[音乐]

316
00:23:35,119 --> 00:23:39,680
常量如果你记得从我们的笔记系列

317
00:23:39,680 --> 00:23:44,400
我们定义像表格，对不起

318
00:23:44,400 --> 00:23:50,319
，我们定义了 表格列，甚至创建新表格的格式

319
00:23:50,319 --> 00:23:54,872
我们并不真正需要这些我们需要的是这两个字段，因为您

320
00:23:54,872 --> 00:24:00,231
记住了文本，而且我们需要一个这样的用户ID字段，

321
00:24:03,192 --> 00:24:08,480
所以让我们定义 这些我们只是说所有者用户 ID 所以让我们在这里

322
00:24:08,480 --> 00:24:15,279
说 const 增加大小所有者

323
00:24:15,279 --> 00:24:23,192
用户 ID 就是这样的用户 ID 然后我们要说 const text field name

324
00:24:23,192 --> 00:24:28,079
对不起所以我需要你将这两个字段定义为 对你的应用程序

325
00:24:28,079 --> 00:24:32,160
很好，所以让我们回到原来的字体

326
00:24:32,160 --> 00:24:36,000
大小，

327
00:24:36,000 --> 00:24:39,359
现在我们已经定义了，如果你记得从我们的笔记服务中，我们

328
00:24:39,359 --> 00:24:43,759
在这里有这些漂亮的类，一个称为数据库节点的调用和一个数据库

329
00:24:43,759 --> 00:24:47,599
用户现在给出 我们正在远离

330
00:24:47,599 --> 00:24:51,039
在 sqlite 数据库中存储东西和笔记

331
00:24:51,039 --> 00:24:54,960
，我们正在转向 firestore um

332
00:24:54,960 --> 00:24:58,640
数据库，我们实际上不再需要数据库用户

333
00:24:58,640 --> 00:25:02,000
，但我们确实需要某种

334
00:25:02,000 --> 00:25:07,279
代表这些文档的类 我们将在这里创建好的，

335
00:25:07,279 --> 00:25:11,511
我们将称之为云节点

336
00:25:11,511 --> 00:25:15,599
所以让我们继续你看到这里被称为数据库节点所以你

337
00:25:15,599 --> 00:25:19,832
知道它是一个本地数据库也许你可以重命名 这个本地数据库节点，如果

338
00:25:19,832 --> 00:25:23,119
你想 b 但是我不会这样做，因为我们要远离

339
00:25:23,119 --> 00:25:27,039
它，所以重构它的意义何在，

340
00:25:27,039 --> 00:25:31,359
所以我要关闭节点服务，然后让我们继续

341
00:25:31,359 --> 00:25:36,799
在服务下创建一个名为 cloud note dart 的新文件 lib services cloud

342
00:25:36,799 --> 00:25:41,599
，我将把它称为cloud underscore node.dark

343
00:25:41,599 --> 00:25:47,599
，现在我们需要做的是实际实现云节点，

344
00:25:47,599 --> 00:25:50,640
对不起，

345
00:25:50,640 --> 00:25:55,039
云节点实际上将包含什么云节点具有三个属性

346
00:25:55,039 --> 00:25:59,920
包含，它们

347
00:25:59,920 --> 00:26:04,640
是该节点的实际标识符，我很抱歉，我实际上必须让自己

348
00:26:04,640 --> 00:26:10,640
进入请勿打扰，

349
00:26:10,640 --> 00:26:14,231
所以云节点必须包含三件事

350
00:26:14,231 --> 00:26:19,511
数据库

351
00:26:19,511 --> 00:26:24,799
如果您来自类似后端开发的数据库，则由 firebase 生成的每个文档都将具有唯一的 id，

352
00:26:24,799 --> 00:26:27,832
那么您已经对此很熟悉，

353
00:26:27,832 --> 00:26:32,160
例如 django 有一个 pk 的想法，它是主键，您也可以

354
00:26:32,160 --> 00:26:35,680
阅读它 作为 id 所以一切都结束了 数据库中的红色有

355
00:26:35,680 --> 00:26:40,079
某种主键 firestore 没有什么不同，所以

356
00:26:40,079 --> 00:26:43,832
在 firestore 数据库中创建的每个文档也将有

357
00:26:43,832 --> 00:26:47,511
一个主键，这是我们的

358
00:26:47,511 --> 00:26:52,960
云节点将包含其他两个的第一个属性 非常熟悉，因为

359
00:26:52,960 --> 00:26:57,511
您在文档中看到这里我们将有一个文本字段，

360
00:26:57,511 --> 00:27:01,279
另一个就像所有者用户 ID，所以我们必须将三个字段添加到

361
00:27:01,279 --> 00:27:05,759
我们的类中，所以让我们继续这样做，让我们只是 说，

362
00:27:05,759 --> 00:27:11,832
嗯，如果我可以在这里打字，那么上课对不起，我的面前有一个麦克风

363
00:27:11,832 --> 00:27:16,000
，就像它挡住了我的键盘，所以有时这就是

364
00:27:16,000 --> 00:27:20,000
为什么我必须看起来像这样才能找到我的键盘

365
00:27:20,000 --> 00:27:23,039
所以让我们说云节点嗯

366
00:27:23,039 --> 00:27:26,960
和里面 我们的云节点让我们定义这三个属性，所以我们只说

367
00:27:26,960 --> 00:27:31,832
最终字符串文档 id 好

368
00:27:31,832 --> 00:27:36,551
，我将在这里复制字符串并说所有者用户 id，然后

369
00:27:36,551 --> 00:27:41,511
我们将说文本好，来自 Visual Studio 代码的帮助

370
00:27:41,511 --> 00:27:45,680
实现构造函数 d um in here 那么我要说

371
00:27:45,680 --> 00:27:50,000
这是一个常量构造函数，好吧，就像我说的那样，您实际上可以将其

372
00:27:50,000 --> 00:27:53,039
定义为不可变的，在这种情况下，我实际上更喜欢对您说实话

373
00:27:53,039 --> 00:27:56,160
，我没有，我没有计划 为了使这个不可变，但我认为

374
00:27:56,160 --> 00:28:02,160
如果它是一个云节点实际上是有意义的，那么我们就说它是不可变

375
00:28:02,160 --> 00:28:07,440
的，这就是第一部分，我也知道我们需要制作这些

376
00:28:07,440 --> 00:28:11,511
必需的参数，所以让我们继续做吧让我们说

377
00:28:11,511 --> 00:28:16,400
在所有这些参数之前都需要，所以它们实际上是必需的，命名

378
00:28:16,400 --> 00:28:20,400
参数不是可选的，基本上

379
00:28:20,400 --> 00:28:25,440
没关系，如果你看看我们的数据库节点如何

380
00:28:25,440 --> 00:28:32,319
让我们看看我们是否可以在节点服务中找到数据库节点，

381
00:28:32,319 --> 00:28:36,640
那么让我们看看数据库 节点你还记得我们有这些字段

382
00:28:36,640 --> 00:28:41,680
但是我们几乎从不调用这个数据库节点一个构造函数我们

383
00:28:41,680 --> 00:28:44,960
总是从行中使用这个东西数据库节点

384
00:28:44,960 --> 00:28:49,192
这基本上就是你刚刚看到的对象这张地图是

385
00:28:49,192 --> 00:28:53,599
我们的对象 重新 从我们的 sqlite 数据库和工作人员中读取，然后我们在内部

386
00:28:53,599 --> 00:28:59,279
从该对象创建数据库节点的实例，好吧，

387
00:28:59,279 --> 00:29:02,960
所以这种映射也是您

388
00:29:02,960 --> 00:29:07,359
将从 firestore 收到的，

389
00:29:07,359 --> 00:29:11,279
但是它将被包装在称为查询文档快照的东西中，

390
00:29:11,279 --> 00:29:17,359
所以 它只是你的数据的一个包装器，所以

391
00:29:17,359 --> 00:29:22,000
让我们继续在这里，我们要说的是，如果你只是输入

392
00:29:22,000 --> 00:29:27,440
查询文档快照，那么 Visual Studio 代码会

393
00:29:27,440 --> 00:29:33,039
自动为你导入它，那么它应该被导入 这里

394
00:29:33,039 --> 00:29:37,599
太好了，而且我们需要我们的

395
00:29:37,599 --> 00:29:41,920
云存储常量，所以让我们去导入它们，所以我们只说

396
00:29:41,920 --> 00:29:47,279
包和我的节点，我们有什么，我们

397
00:29:47,279 --> 00:29:51,832
有什么存储在服务云中，所以服务云

398
00:29:51,832 --> 00:29:56,231
常量或抱歉 云存储常量，所以

399
00:29:56,231 --> 00:30:01,511
你需要 cloud firestore dart 然后你的常量

400
00:30:01,511 --> 00:30:05,920
让我们继续创建一个类似于构造函数的东西，我们

401
00:30:05,920 --> 00:30:11,680
将从快照中调用，这个构造函数将用于所有 ow firestore 给我们

402
00:30:11,680 --> 00:30:15,920
它和云节点的快照，然后我们将从那个好的创建我们的云节点的实例，

403
00:30:15,920 --> 00:30:21,599
所以我们只说

404
00:30:21,599 --> 00:30:26,400
来自快照的云节点和参数将是查询

405
00:30:26,400 --> 00:30:32,000
文档快照 我们实际上需要

406
00:30:32,000 --> 00:30:36,480
这样的映射，我们将把它称为快照，好吧，

407
00:30:36,480 --> 00:30:39,279
所以现在你可以看到我们

408
00:30:39,279 --> 00:30:43,440
从 um 从 dart 中得到了一些错误，说所有最终变量都

409
00:30:43,440 --> 00:30:46,079
需要初始化，并且必须提供函数体 好的，我们

410
00:30:46,079 --> 00:30:52,079
很快就会修复它，所以这是你函数的 um 签名，然后在这里

411
00:30:52,079 --> 00:30:56,960
你现在的工作是确保你的所有字段都已初始化，所以

412
00:30:56,960 --> 00:31:01,039
让我们说如果我可以再次输入

413
00:31:01,039 --> 00:31:06,872
它来的文档 id 从我们的快照 id 中，这是一个存储在快照级别的属性，

414
00:31:06,872 --> 00:31:10,400
所以你可以得到那个 id

415
00:31:14,480 --> 00:31:18,551
快照

416
00:31:18,551 --> 00:31:21,599
呃快照

417
00:31:21,599 --> 00:31:24,799
数据，然后我们必须 说

418
00:31:24,799 --> 00:31:29,832
所有者用户 id 字段名称让我们在用户

419
00:31:29,832 --> 00:31:32,400
id

420
00:31:32,400 --> 00:31:36,551
下查看所有者用户 id 让我们称这个字段名称为抱歉，让我们回到

421
00:31:36,551 --> 00:31:40,872
云存储常量并修复这个问题，说所有者用户 id 字段名称实际上

422
00:31:40,872 --> 00:31:43,359
没问题，

423
00:31:43,359 --> 00:31:47,680
所以我们错过了，但那是 好吧，这只是一个命名更改，

424
00:31:47,680 --> 00:31:50,720
所以我们要说所有者用户 ID 字段

425
00:31:50,720 --> 00:31:55,599
名称，这是所有者用户 ID，我们将获取

426
00:31:55,599 --> 00:32:00,079
等于快照点数据的

427
00:32:00,079 --> 00:32:05,119
文本和作为字符串的文本字段名称

428
00:32:05,119 --> 00:32:09,511
我们有一个漂亮的云节点不可变类，带有一个

429
00:32:09,511 --> 00:32:15,359
常量构造函数，我们很快就会从 firestore 获得这个快照 um 查询文档快照

430
00:32:15,359 --> 00:32:20,319
，我们可以创建我们的云节点的实例，正如你

431
00:32:20,319 --> 00:32:23,832
很快就会看到的

432
00:32:23,832 --> 00:32:29,920
那样，我们需要的是 创建我们新的云存储

433
00:32:29,920 --> 00:32:35,359
服务，这就像

434
00:32:35,359 --> 00:32:41,920
从云存储迁移到存储存储的开始，所以这实际上非常令人兴奋，而且一开始

435
00:32:41,920 --> 00:32:45,599
可能有点令人生畏，

436
00:32:45,599 --> 00:32:49,511
因为我们不得不非常喜欢重做 的 工作，

437
00:32:49,511 --> 00:32:54,231
但考虑到 Firestore 为您提供了几乎所有您需要的工具，

438
00:32:54,231 --> 00:32:57,599
因为您很快就会看到我们将要做的功能的实现

439
00:32:57,599 --> 00:33:02,799
是如此之少，因为

440
00:33:02,799 --> 00:33:06,640
已经提供了 Fire Store 的基础 我们只需要连接它并获取数据

441
00:33:06,640 --> 00:33:11,119
写入数据等的基础，所以让我们关闭我们目前拥有的所有这些选项卡，

442
00:33:11,119 --> 00:33:16,231
对不起，让我们去这个 um

443
00:33:16,231 --> 00:33:20,799
服务云并创建我们新的 firebase 云存储 dart 文件

444
00:33:20,799 --> 00:33:26,799
firebase 云存储飞镖

445
00:33:26,799 --> 00:33:30,960
好吧，所以我实际上也会这样做，所以

446
00:33:34,799 --> 00:33:39,680
我的笔记中的firebase云存储好吧，所以让我们继续说我们有一个新的

447
00:33:39,680 --> 00:33:45,192
类，叫做firebase云存储，

448
00:33:45,192 --> 00:33:49,511
就像现在它不一样 除了我们需要做的事情之外，我们需要做的是

449
00:33:49,511 --> 00:33:52,799
让 uh 使它成为一个共享实例

450
00:33:52,799 --> 00:33:56,400
，我将为此带来标题，

451
00:33:56,400 --> 00:34:00,480
如果你还记得我们已经将节点服务

452
00:34:03,119 --> 00:34:06,480
设为单例，那么让我们回到我们的节点服务

453
00:34:06,480 --> 00:34:10,480
macintosh 和 visual studi 上的命令 p  o 在 Windows 和 linux 中编写代码或控制 p 以

454
00:34:10,480 --> 00:34:15,119
按名称字段显示此搜索文件，

455
00:34:15,119 --> 00:34:19,512
如果您还记得在便笺服务中，我只想说便笺服务我

456
00:34:19,512 --> 00:34:23,440
认为在顶部我们有这种

457
00:34:23,440 --> 00:34:26,960
创建单例的模式您还记得吗 这是

458
00:34:26,960 --> 00:34:32,400
正确的，所以我们有点需要或抱歉这部分

459
00:34:32,400 --> 00:34:36,400
我们需要相同的东西实际上

460
00:34:36,400 --> 00:34:40,552
几乎完全相同的东西除了这部分因为它与流

461
00:34:40,552 --> 00:34:45,920
控制器对话所以我发现这种在 dart 中创建单例的模式仍然

462
00:34:45,920 --> 00:34:49,920
我想我之前在创建节点服务时已经提到过这一点，

463
00:34:49,920 --> 00:34:53,920
但这是我们必须做的事情，以确保我们的 Firebase 云存储

464
00:34:53,920 --> 00:34:58,800
实际上是一个单例，所以我将从我的笔记中带上该代码，因为我

465
00:34:58,800 --> 00:35:02,800
没有 '认为它实际上不值得写这个，不值得你或我的

466
00:35:02,800 --> 00:35:06,480
时间，但这是你需要创建的，

467
00:35:06,480 --> 00:35:10,719
所以这里发生的是我们有一个私有构造函数，

468
00:35:10,719 --> 00:35:13,760
然后我们将创建一个工厂构造函数 默认

469
00:35:13,760 --> 00:35:18,159
c 我们的类 firebase 云存储的 onstructor 就在这里

470
00:35:18,159 --> 00:35:23,360
，这将与静态 final 字段进行对话，该字段又调用此

471
00:35:23,360 --> 00:35:26,400
私有初始化程序，因此

472
00:35:26,400 --> 00:35:33,512
在其他语言中，例如 swift 和 rust，创建

473
00:35:33,512 --> 00:35:36,552
单例要容易得多，但这 是一种模式，你必须这样做

474
00:35:36,552 --> 00:35:40,960
首先创建一个私有构造函数，然后创建一个工厂构造函数，它

475
00:35:40,960 --> 00:35:48,400
与一个静态 final 对话，后者又与私有构造函数对话

476
00:35:54,079 --> 00:35:58,320
我们云存储中的所有笔记都可以，

477
00:35:58,320 --> 00:36:03,760
所以让我们在这个工厂构造函数之后继续我们将

478
00:36:03,760 --> 00:36:07,192
在案例调用笔记中将一个字段作为笔记公开为屏幕底部的标题，

479
00:36:07,192 --> 00:36:11,280
所以我只想说笔记 等于

480
00:36:11,280 --> 00:36:15,679
我们只会说firebase和firestore，它会自动

481
00:36:15,679 --> 00:36:19,512
为我导入它，所以这对你来说也不再是一件奇怪的事情

482
00:36:19,512 --> 00:36:22,719
，然后我只想说我们自己的例子，然后

483
00:36:22,719 --> 00:36:27,440
原谅我 集合称为注释报价为

484
00:36:27,440 --> 00:36:33,192
好吧，这就是您实际与 Firestore 交谈的方式，

485
00:36:33,192 --> 00:36:37,440
因此您可以看到该集合的签名实际上正在

486
00:36:37,440 --> 00:36:40,871
返回，使用称为集合引用的东西

487
00:36:40,871 --> 00:36:45,440
，您很快就会看到我们如何从该集合中提取我们的实际注释。

488
00:36:45,440 --> 00:36:48,400
请记住，

489
00:36:48,400 --> 00:36:51,920
如果您还没有真正创建您的笔记集，那么这将不起作用

490
00:36:51,920 --> 00:36:55,679
所以如果您还没有这样做，如果您忘记这样做，请继续，请

491
00:36:55,679 --> 00:37:00,159
原谅我现在就这样做，

492
00:37:00,159 --> 00:37:05,039
所以我们需要的第一件事 要做的是创建一个用于创建新节点的函数，

493
00:37:05,039 --> 00:37:08,400
好吧，对不起

494
00:37:08,400 --> 00:37:14,960
，让我们继续进入我们的项目并创建一个函数，因为

495
00:37:14,960 --> 00:37:19,760
标题表明我要说 void create new nodes in here

496
00:37:19,760 --> 00:37:25,192
然后我们要 说我们需要一个所有者 id

497
00:37:25,192 --> 00:37:30,480
所以需要字符串所有者用户 id 我相信我们称之为它，然后它是一个

498
00:37:30,480 --> 00:37:35,760
异步函数，好吧，然后在这里，因为你有

499
00:37:35,760 --> 00:37:41,831
你所有笔记的流或读写流，这就是这个

500
00:37:41,831 --> 00:37:45,512
uh 收藏参考意味着它就是它

501
00:37:45,512 --> 00:37:48,719
不仅是一个你可以读取的流，而且它也是一个你可以写入的流，

502
00:37:48,719 --> 00:37:51,920
这就是为什么它不被称为流的

503
00:37:51,920 --> 00:37:55,831
原因，因为流就像你试图只从它读取一样

504
00:37:55,831 --> 00:37:59,192
，在这里我们要做什么 会说注释添加

505
00:37:59,192 --> 00:38:03,512
，你可以看到它字面上说给我一张地图或一本字典，或者你

506
00:38:03,512 --> 00:38:07,599
想称它为一个有键和值的对象

507
00:38:07,599 --> 00:38:11,192
你想让我在数据库中存储什么，这就是 nosql 的类型

508
00:38:11,192 --> 00:38:16,639
意味着这里是基于文档的，它没有您

509
00:38:16,639 --> 00:38:21,360
添加的内容的真实结构，您在此处添加的所有内容都将被打包到一个文档中，该文档

510
00:38:21,360 --> 00:38:25,192
将与您指定的字段和值一起存储在此处

511
00:38:25,192 --> 00:38:29,920
好的，所以让我们继续说我们

512
00:38:29,920 --> 00:38:34,000
在这里为您提供了一个文档，第一个

513
00:38:34,000 --> 00:38:38,871
字段是所有者用户 ID 字段名称，这将自动从我们之前的常量中导入它，

514
00:38:38,871 --> 00:38:42,639
记住这里的值将

515
00:38:42,639 --> 00:38:45,512
是 是所有者用户 ID

516
00:38:45,512 --> 00:38:48,320
，文本字段文本

517
00:38:48,320 --> 00:38:52,400
字段名称是 现在只是一个空

518
00:38:52,400 --> 00:38:57,119
便条，记住这是一个异步异步函数，它

519
00:38:57,119 --> 00:39:00,639
返回文档引用的未来，就像我们在这里有我们的集合

520
00:39:00,639 --> 00:39:04,552
引用一样，但我们实际上至少现在不想要它的结果，所以

521
00:39:04,552 --> 00:39:08,079
我们 “再等待它，所以不要忘记那个重量，因为没有

522
00:39:08,079 --> 00:39:13,679
做重量这个功能实际上并不是要被调用

523
00:39:13,679 --> 00:39:19,512
哇哇哇我们现在需要做的事情然后

524
00:39:19,512 --> 00:39:24,000
去下一个项目来找我的下一个项目

525
00:39:24,000 --> 00:39:27,440
用户 ID 的注释，所以签名将

526
00:39:27,440 --> 00:39:30,719
返回一个 i

527
00:39:30,719 --> 00:39:34,871
的云注释，你给了一个用户 ID，所以

528
00:39:34,871 --> 00:39:39,280
正如我们所说的，我们存储在数据库中的每个节点，

529
00:39:39,280 --> 00:39:42,960
呃，都会有这两个字段，一个所有者和一个文本字段 所以现在我们想要的是

530
00:39:42,960 --> 00:39:46,871
为特定用户获取所有节点，好吧

531
00:39:46,871 --> 00:39:50,480
，让我们继续这样做，所以它被称为

532
00:39:50,480 --> 00:39:56,480
um get notes，这是一个非常丰富的功能，实际上我可以在这里看到，

533
00:39:56,480 --> 00:40:04,400
所以让我们现在就开始吧 假设云节点的可迭代 um 的未来

534
00:40:04,400 --> 00:40:07,599
，我认为我们 还必须导入云节点，因此

535
00:40:07,599 --> 00:40:10,231
如果您遇到一些错误，请按此按钮为我导入此节点，这可能是

536
00:40:10,231 --> 00:40:14,400
因为您的编辑器无法找到云节点

537
00:40:14,400 --> 00:40:19,039
，所以我们会说获取注释和必需的 参数在

538
00:40:19,039 --> 00:40:26,159
这里用户 id 好的，它是一个异步函数，

539
00:40:26,159 --> 00:40:31,440
所以我们要做的就是

540
00:40:31,440 --> 00:40:35,920
在我们的笔记上 um 一个权重 uh 在这里你看到我们

541
00:40:35,920 --> 00:40:41,440
实际上可以从我们的笔记集合中检索笔记在这里 通过说 notes where

542
00:40:41,440 --> 00:40:45,360
所以我们要在 notes uh

543
00:40:45,360 --> 00:40:50,480
collection reference 中进行搜索，然后你可以使用 where 子句进行搜索

544
00:40:54,719 --> 00:40:59,512
就是这个，

545
00:40:59,512 --> 00:41:03,039
它没有在这里记录，但我相信它实际上可以创建一个

546
00:41:03,039 --> 00:41:06,480
异常，所以让我们继续并抓住这个，所以

547
00:41:06,480 --> 00:41:11,192
我们只是说尝试我们会尝试，然后如果这里发生任何事情，

548
00:41:11,192 --> 00:41:14,960
呃，我们只是要抛出 并且

549
00:41:14,960 --> 00:41:20,159
不能 t 得到所有节点异常，这将从我们

550
00:41:20,159 --> 00:41:24,320
之前的代码中自动导入，所以我不应该一遍又一遍地解释这个你

551
00:41:24,320 --> 00:41:29,679
已经知道它是如何工作的，所以现在我们有一个 try

552
00:41:29,679 --> 00:41:35,831
and catch 语句在那里 所以假设我们在笔记上等待

553
00:41:35,831 --> 00:41:40,480
，我们说 uh where 子句和 word 子句

554
00:41:40,480 --> 00:41:45,360
会说好的，你想要在哪个字段上进行

555
00:41:45,360 --> 00:41:50,552
工作搜索，我们想要搜索所有属于该

556
00:41:50,552 --> 00:41:56,000
所有者的笔记 用户 id 所以让我们说所有者用户 id 字段名称

557
00:41:56,000 --> 00:42:00,552
应该等于你看到的参数等于所有者用户 id

558
00:42:07,679 --> 00:42:11,512
执行此查询，然后使用它的 get 函数执行此操作，您会

559
00:42:11,512 --> 00:42:14,639
看到它返回，

560
00:42:14,639 --> 00:42:19,440
如果我将鼠标移到上方，您会看到它返回查询快照的未来，其中

561
00:42:19,440 --> 00:42:22,639
包含 firestore 可以从数据库中检索的所有对象

562
00:42:22,639 --> 00:42:27,512
我们必须得到嗯

563
00:42:27,512 --> 00:42:31,039
我们所做的就是做 那么

564
00:42:31,039 --> 00:42:35,679
这就是我们使用future的方式，所以future的event子句允许你

565
00:42:35,679 --> 00:42:40,871
返回它它所做的是它返回那个future的值给你，它

566
00:42:40,871 --> 00:42:44,960
允许你在then函数中返回一个同步值，

567
00:42:44,960 --> 00:42:48,320
或者你实际上可以 返回另一个future

568
00:42:48,320 --> 00:42:52,719
那些熟悉node.js 或者只是一般的javascript

569
00:42:52,719 --> 00:42:57,920
甚至是swift 他们熟悉promise 和futures 是如何工作的，所以这是

570
00:42:57,920 --> 00:43:02,639
你实际返回一个值的机会，因为这个

571
00:43:02,639 --> 00:43:07,760
future 会返回给你，好吧 我们现在将把它称为基本

572
00:43:07,760 --> 00:43:11,192
值，如果我将鼠标移到它上面，你可以看到它显示

573
00:43:11,192 --> 00:43:15,512
了这些可能写的红色文档的查询快照，

574
00:43:15,512 --> 00:43:19,679
所以在这里我们要做的是说

575
00:43:19,679 --> 00:43:24,400
docs 这是 所有可以读取的文档

576
00:43:24,400 --> 00:43:27,920
，我们将映射所有这些

577
00:43:27,920 --> 00:43:31,760
文档，如果我调用这个文档，如果我将鼠标移到它上面，它会创建

578
00:43:31,760 --> 00:43:36,079
文档快照，而这个是查询快照，这个是查询快照 查询

579
00:43:36,079 --> 00:43:41,192
文档快照 se 字段好，所以让我们进入这里，我们

580
00:43:41,192 --> 00:43:47,192
要做的是说我们在这个内部返回一个云节点

581
00:43:47,192 --> 00:43:51,760
，我们有这三个字段好的，我们有文档 ID 所有者用户 ID

582
00:43:51,760 --> 00:43:55,920
和文本，所以这基本上是我们的机会 现在要创建

583
00:43:55,920 --> 00:44:00,960
我们的云节点的实例，我将把

584
00:44:00,960 --> 00:44:04,800
列放在这里，这样我们的格式会更好一些

585
00:44:04,800 --> 00:44:08,400
，我们需要做的是获取文档 ID，这样做的方法是

586
00:44:08,400 --> 00:44:12,639
这个 Dock 有一个 id在这里你可以看到它是一个字符串

587
00:44:12,639 --> 00:44:19,039
，另一个是停靠然后我们有数据

588
00:44:19,039 --> 00:44:23,280
，让我们说所有者用户id字段名称

589
00:44:23,280 --> 00:44:26,320
，这是一个字符串

590
00:44:26,320 --> 00:44:32,552
，在这里我们要说一个文档数据

591
00:44:32,552 --> 00:44:38,639
，我们 说文本字段名称作为字符串现在记住这看起来很

592
00:44:38,639 --> 00:44:43,280
熟悉我们之前在哪里做过这个是的我们已经在快照中的云笔记中做过这个

593
00:44:43,280 --> 00:44:46,871
不用担心我们实际上会

594
00:44:46,871 --> 00:44:50,000
在我们要删除的时候使用那个函数 这个返回语句是它的

595
00:44:50,000 --> 00:44:53,440
写法，但让我们现在就这样写吧，这样更容易

596
00:44:53,440 --> 00:44:56,552
明白

597
00:44:56,552 --> 00:45:03,039
哇，好吧，嗯，我想我认为应该是这样

598
00:45:03,039 --> 00:45:07,920
，所以我们有这个对不起

599
00:45:07,920 --> 00:45:11,512
，嗯，

600
00:45:11,512 --> 00:45:15,512
是的，我相信我相信这会为我们现在覆盖它，所以没有

601
00:45:15,512 --> 00:45:19,280
更多的解释这个老实说所以

602
00:45:19,280 --> 00:45:23,360
我们 也可以在此处放置一个逗号以

603
00:45:23,360 --> 00:45:27,440
使代码更具可读性，然后我们将值

604
00:45:27,440 --> 00:45:30,719
返回，在这里我们不必对您诚实的

605
00:45:30,719 --> 00:45:34,400
是这里的返回语句，

606
00:45:34,400 --> 00:45:38,719
或者实际上我们是这样创建的，所以是的 它是一个箭头函数，

607
00:45:38,719 --> 00:45:42,800
所以我们不必有一个特殊的 return 语句，但是如果你不喜欢

608
00:45:42,800 --> 00:45:47,192
这种箭头函数，你可以像这样获取你已经编写的代码

609
00:45:47,192 --> 00:45:50,800
并在其中创建

610
00:45:50,800 --> 00:45:56,320
大括号 在这里，而不是使用这种语法来表示返回，

611
00:45:56,320 --> 00:46:02,231
而不是好的，所以这有点取决于你喜欢什么，嗯，

612
00:46:02,231 --> 00:46:05,831
我没有偏好，我可以按原样使用错误函数，所以

613
00:46:05,831 --> 00:46:09,039
我就这样离开它 好的

614
00:46:09,039 --> 00:46:12,871
，记住我们现在正在等待这个，但我们不会退还

615
00:46:12,871 --> 00:46:18,320
它，所以让我们 t返回所以这基本上只是我们的一种奇特方式，请

616
00:46:18,320 --> 00:46:23,192
原谅我与firebase firestore进行交流并阅读文档，

617
00:46:23,192 --> 00:46:27,360
有太多要解释的内容，我无法完成所有这些，但我真的

618
00:46:27,360 --> 00:46:30,159
建议您自己阅读这些功能

619
00:46:30,159 --> 00:46:35,280
文档，看看为什么我在使用 where 然后变得

620
00:46:35,280 --> 00:46:39,192
如此 uh 因为您需要阅读

621
00:46:39,192 --> 00:46:44,719
这些功能附带的所有文档，以便您更好地理解它们，

622
00:46:44,719 --> 00:46:51,440
好吧嗯，现在我们需要通过用户 ID 获取注释

623
00:46:51,440 --> 00:46:54,570
也是 um

624
00:46:54,570 --> 00:46:58,159
[音乐] 我们需要的

625
00:46:58,159 --> 00:47:02,800
是能够在这里为我们的笔记列表

626
00:47:02,800 --> 00:47:08,552
提供该特定用户的笔记流的能力

627
00:47:08,552 --> 00:47:13,920
是我们

628
00:47:13,920 --> 00:47:18,320
公开了这个数据库节点列表流，这就是我们还

629
00:47:18,320 --> 00:47:21,599
需要对我们的 firebase 云存储做的事情，比如有一个功能，我们的

630
00:47:21,599 --> 00:47:25,119
节点列表对不起，我不能订阅并读取

631
00:47:25,119 --> 00:47:28,480
所有可用的节点 给定用户，我们走吧 阅读并做到这一点，让

632
00:47:28,480 --> 00:47:33,679
我们称它为流可迭代，我有那个函数签名，所以我

633
00:47:33,679 --> 00:47:38,159
认为我不应该手动编写它，但你可能需要编写它，

634
00:47:38,159 --> 00:47:42,800
所以这是一个函数签名好的，在这里我们是 要说的是

635
00:47:42,800 --> 00:47:47,039
，我们将去我们这里的笔记集合并获取所有

636
00:47:47,039 --> 00:47:52,159
可用的快照让我们看看我们有我们的笔记，然后我们

637
00:47:52,159 --> 00:47:57,280
有我们的快照，我们将映射它，

638
00:47:57,280 --> 00:48:01,599
让我们说是的，会得到我们的 文档在该

639
00:48:01,599 --> 00:48:05,440
快照中，然后我们

640
00:48:05,440 --> 00:48:11,039
将像这样映射它，让我们称之为 doc

641
00:48:11,039 --> 00:48:15,831
，在这里我们将

642
00:48:15,831 --> 00:48:21,440
根据该文档的快照创建一个云笔记，然后在这里

643
00:48:21,440 --> 00:48:24,871
我们要说它在

644
00:48:24,871 --> 00:48:28,480
哪里 我们的笔记，然后我们要说笔记

645
00:48:28,480 --> 00:48:31,920
所有者用户ID我要写这个然后我要告诉你

646
00:48:31,920 --> 00:48:34,800
我基本上在做什么，因为这里有很多代码，喜欢

647
00:48:34,800 --> 00:48:39,119
停下来描述 这段代码的每一点实际上都可能使它看起来

648
00:48:39,119 --> 00:48:43,512
比实际更复杂，我' 然后我会说所有者用户

649
00:48:43,512 --> 00:48:45,760
id 好，

650
00:48:45,760 --> 00:48:50,400
但是那里有一个分号，等一下，

651
00:48:50,400 --> 00:48:54,960
那里结束，然后那里有一个分号，是的，所以让我们看看

652
00:48:54,960 --> 00:48:59,760
这里发生了什么，所以这看起来实际上很吓人，但它是

653
00:48:59,760 --> 00:49:04,960
一段非常简单的代码 所以我们在这里所做的是，如果您

654
00:49:04,960 --> 00:49:09,760
想在数据流不断发展时获取数据流，您希望能够

655
00:49:09,760 --> 00:49:12,871
订阅发生在它身上的所有更改，那么您需要使用

656
00:49:12,871 --> 00:49:17,512
称为快照的东西，如您所见 是一个查询快照流，而

657
00:49:17,512 --> 00:49:21,280
where 查询本身可以，然后 get

658
00:49:21,280 --> 00:49:26,800
是一个未来，所以它只是 get 一个在那个时间点拍摄快照

659
00:49:26,800 --> 00:49:31,440
并将其返回给你，但如果你想保持

660
00:49:31,440 --> 00:49:35,760
喜欢 if 您希望实时更新所有更改，因为它们正在发生

661
00:49:35,760 --> 00:49:40,552
在您的笔记集合中的数据上，然后您需要订阅

662
00:49:40,552 --> 00:49:44,480
我们正在做的快照，所以这是快照的第一部分，所以我们

663
00:49:44,480 --> 00:49:47,512
实际上是在说 我们希望看到所有的变化 他们正在现场发生，

664
00:49:47,512 --> 00:49:51,280
好吧，然后它说好吧，我会给你所有

665
00:49:51,280 --> 00:49:54,800
正在发生的变化，这些变化都在查询快照中

666
00:49:54,800 --> 00:49:59,280
记住从这里的查询快照记住这里的查询

667
00:49:59,280 --> 00:50:02,552
在获取中的哎呀，所以

668
00:50:02,552 --> 00:50:07,192
在这一点之后，这就是我们所做的 在获取注释中说

669
00:50:07,192 --> 00:50:11,599
好的，这里是一个查询快照，然后我们说好的，那里有文档

670
00:50:11,599 --> 00:50:15,360
，这正是我们正在做的，这里有

671
00:50:15,360 --> 00:50:20,480
查询快照中的文档，然后我们将每个文档映射到 云笔记好吧

672
00:50:20,480 --> 00:50:24,000
，然后我们在最后加上 where 子句

673
00:50:24,000 --> 00:50:29,192
，说我们只对你的所有者用户 id 是这里提供的所有者用户 id 的笔记感兴趣，

674
00:50:29,192 --> 00:50:34,552
所以如果没有这个词子句，我们实际上是在暴露所有 系统中

675
00:50:34,552 --> 00:50:38,800
所有用户的当前用户的注释，

676
00:50:47,599 --> 00:50:53,512
因此 word 子句非常重要 函数

677
00:50:53,512 --> 00:50:57,920
f  irestore 为我们提供了好的

678
00:50:57,920 --> 00:51:03,831
哇那是很多信息

679
00:51:03,831 --> 00:51:08,000
好的让我们继续讨论更新你的笔记抱歉更新

680
00:51:08,000 --> 00:51:12,719
现有的笔记所以我们之前讨论过它如果你有一个笔记并且你点击

681
00:51:12,719 --> 00:51:16,079
它的工作方式 现在在我们的应用程序中，我可以点击这个节点

682
00:51:16,079 --> 00:51:22,000
，然后将其文本更改为 22 并返回，现在它已更改为 22 好吧，

683
00:51:22,000 --> 00:51:25,360
所以我们还需要

684
00:51:25,360 --> 00:51:30,552
在我们的 firebase 云存储

685
00:51:30,552 --> 00:51:34,320
中公开此功能 所以这个函数将是更新节点，它需要两个

686
00:51:34,320 --> 00:51:38,000
参数文档ID和一个文本所以我们只是说

687
00:51:38,000 --> 00:51:41,280
它将是void的未来，我们将在这里调用它更新节点

688
00:51:41,280 --> 00:51:44,719
两个参数这是必需的 我会说必需的

689
00:51:44,719 --> 00:51:48,159
字符串和文档 ID

690
00:51:48,159 --> 00:51:52,719
，然后是必需的字符串文本

691
00:51:52,719 --> 00:51:56,871
，让我们把它变成一个异步函数，

692
00:51:56,871 --> 00:52:00,231
然后我们要做的是，我们将在这里尝试并捕获

693
00:52:00,231 --> 00:52:05,360
，以防万一 't update the notes 然后在这里我们只想

694
00:52:05,360 --> 00:52:10,480
说 throw 无法更新注释异常，好吧，如果你愿意，你实际上可以

695
00:52:10,480 --> 00:52:14,400
忽略这个 e，所以你可以这样做，

696
00:52:14,400 --> 00:52:18,552
或者你可以是的，我认为实际上我们不能做一个空缓存捕获，所以你

697
00:52:18,552 --> 00:52:23,192
可以这样做 如果您愿意，但我更喜欢这样

698
00:52:34,079 --> 00:52:39,039
做 要做的就是在这里再次访问我们的集合，

699
00:52:39,039 --> 00:52:44,400
假设我们得到了一个文档，你可以看到它说好的，那个文档的路径是什么

700
00:52:44,400 --> 00:52:47,831
，我们会说文档 ID

701
00:52:47,831 --> 00:52:52,831
是一个路径，然后让我们开始吧 前面说

702
00:52:52,831 --> 00:52:57,119
um dot update 它说好的实际

703
00:52:57,119 --> 00:53:00,719
更新是什么，在更新内部我们要做的是说

704
00:53:00,719 --> 00:53:05,360
文本字段名称是这个文本，

705
00:53:05,360 --> 00:53:09,039
所以现在看起来有点隐蔽，我们也必须等待 在它上面可能看起来

706
00:53:09,039 --> 00:53:12,800
有点神秘，什么是 doc Dock id

707
00:53:12,800 --> 00:53:16,800
记住在这个函数中在这里它说给我拍拍 h 你看到这个

708
00:53:16,800 --> 00:53:20,871
参数路径，我们说的是在

709
00:53:20,871 --> 00:53:26,960
notes 集合中每个文档都有一个标识符，所以我们实际上

710
00:53:26,960 --> 00:53:30,800
将使用我们在这里实例化的文档 id 你还记得

711
00:53:30,800 --> 00:53:36,159
doc id 将进入 我们的云节点文档ID，所以路径是

712
00:53:36,159 --> 00:53:42,000
注释斜线文档ID，所以这就是它调用的firebase firestore的距离，

713
00:53:42,000 --> 00:53:47,192
基本上保持它的路径它是路径在这种情况下，如果我创建

714
00:53:47,192 --> 00:53:50,000
一个集合，你会看到它说哦集合 正在根

715
00:53:50,000 --> 00:53:54,719
文件夹中创建，它有一个集合 id，在我们的例子中称为 notes，我们

716
00:53:54,719 --> 00:53:58,871
在这里引用它，所以我们已经构建了 notes 路径，其中的每个文档

717
00:53:58,871 --> 00:54:03,760
都有自己的 id，所以它将是斜线 notes slash document id 没问题，

718
00:54:03,760 --> 00:54:08,871
所以我希望我会为你解释一下，

719
00:54:08,871 --> 00:54:13,599
现在让我们谈谈删除笔记，嗯，所以

720
00:54:13,599 --> 00:54:17,440
删除笔记实际上也很容易，所以我们不必对删除节点做太多事情，

721
00:54:17,440 --> 00:54:21,599
所以它非常类似于 更新节点，

722
00:54:21,599 --> 00:54:26,159
我们正在 继续使用文档 ID 删除注释，

723
00:54:26,159 --> 00:54:30,400
因为标题表明在这里创建一个新的 void 功能，我们

724
00:54:30,400 --> 00:54:34,231
要说删除节点，我们将继续使用一个名为 document 的必需字符串

725
00:54:34,231 --> 00:54:39,280
参数 id

726
00:54:39,280 --> 00:54:44,000
它同步，让我们在这里做一个尝试缓存，以防我们无法删除

727
00:54:44,000 --> 00:54:46,480
文档，然后我们会说 throw

728
00:54:46,480 --> 00:54:49,440
不能

729
00:54:49,440 --> 00:54:53,192
没有注释异常我相信它

730
00:54:56,231 --> 00:55:00,400
在这里的 try 语句中被称为是，我们将要 说

731
00:55:00,400 --> 00:55:03,440
带有该文档 ID 的 notes doc

732
00:55:03,440 --> 00:55:06,480
好吧，然后我们只会说 delete

733
00:55:06,480 --> 00:55:10,960
我记得我相信这实际上是未来的 void 所以让我们等着

734
00:55:10,960 --> 00:55:14,159
吧，这就是你必须为 delete 做的所有事情，

735
00:55:14,159 --> 00:55:18,639
所以没有魔法 因为它与更新说明非常相似，只是

736
00:55:18,639 --> 00:55:24,639
它不处理任何类似的字段或类似的

737
00:55:35,360 --> 00:55:38,960
内容 贯穿本章，但如果你重新 我的意思是，如果你看看

738
00:55:38,960 --> 00:55:43,599
我们所做的不是那么多代码，它对我来说是 68 行代码，

739
00:55:43,599 --> 00:55:47,192
如果你没有在这里完成所有这些额外的逗号，那么对你来说可能会更少，所以

740
00:55:47,192 --> 00:55:52,400
可能像 60 但有很多 的新概念，所以

741
00:55:52,400 --> 00:55:57,192
我认为我必须这样做，甚至可能过度

742
00:55:57,192 --> 00:55:59,760
解释事情，但我认为一开始

743
00:55:59,760 --> 00:56:02,159
，了解一切如何运作非常重要

744
00:56:04,079 --> 00:56:08,480
本章我们已经实际

745
00:56:08,480 --> 00:56:11,831
测试以确保这是有效的，我们将在下一章中执行此操作，

746
00:56:11,831 --> 00:56:15,920
但按照传统，我们将确保我们的工作

747
00:56:15,920 --> 00:56:20,960
提交到我们的 github 存储库或 bitbucket，无论您在哪里

748
00:56:20,960 --> 00:56:25,039
重新使用你的 uh 或者你托管 git 项目的任何地方，所以让我们

749
00:56:25,039 --> 00:56:30,320
继续做吧，我想稍微改变一下屏幕

750
00:56:30,320 --> 00:56:34,639
布局，我要摆脱 scrcpy

751
00:56:34,639 --> 00:56:38,480
oops，我要关闭屏幕

752
00:56:38,480 --> 00:56:43,360
在这个呃视图中把它变大然后我

753
00:56:43,360 --> 00:56:48,079
要去航站楼好吧对不起让我们来 看看我们的

754
00:56:48,079 --> 00:56:53,360
状态，这里有很多修改，而且我们添加了一个全新的

755
00:56:53,360 --> 00:56:56,231
文件夹，所以我只想说 git add all

756
00:56:56,231 --> 00:56:59,920
，让我们看看我们的日志，之前的提交是第 18 步，让我们

757
00:56:59,920 --> 00:57:04,719
有一个 看看我们的标签，我在这里也可以看到第 18 步，

758
00:57:04,719 --> 00:57:09,360
现在让我们说第 19 步

759
00:57:09,360 --> 00:57:13,599
对不起，然后我们有

760
00:57:13,599 --> 00:57:17,039
提交，我们已经提交，让我们推送这些

761
00:57:17,039 --> 00:57:22,079
更改让我们也在这里标记并说第 19 步，

762
00:57:22,079 --> 00:57:28,871
好吧 让我们也推上我们的标签

763
00:57:28,871 --> 00:57:32,320
，这就是每章末尾的传统，

764
00:57:32,320 --> 00:57:35,679
我们将在下一章讨论我们必须讨论的内容

765
00:57:35,679 --> 00:57:39,360
，正如你所看到的那样，我们需要开始使用我们的新服务 而不是

766
00:57:39,360 --> 00:57:41,760
sqlite 数据库，所以这有点

767
00:57:41,760 --> 00:57:48,400
像我们整个 uh 课程的转折点，因为我们要放弃我们的

768
00:57:48,400 --> 00:57:54,159
本地存储并离开它并开始使用我们的 firebase 云存储

769
00:57:54,159 --> 00:57:58,079
，所以嗯，它就是我 认为下一章

770
00:57:58,079 --> 00:58:00,960
实际上是最激动人心的章节之一，请

771
00:58:00,960 --> 00:58:04,960
原谅我 整个课程，所以

772
00:58:04,960 --> 00:58:08,639
如果你愿意，请享用一些茶点，我会在那里见到你，

773
00:58:08,639 --> 00:58:12,639
大家好，欢迎来到这个颤振课程的第 37 章，正如你在

774
00:58:12,639 --> 00:58:17,280
前面的章节中看到的那样，我们已经开始远离我们的本地数据库存储，

775
00:58:17,280 --> 00:58:21,760
并且 在 sqlite 上，我们开始越来越多地使用

776
00:58:21,760 --> 00:58:27,512
由 firebase 托管的 firestore 数据库，所以这对我们来说是一个非常令人兴奋的点

777
00:58:32,000 --> 00:58:36,320
而不是使用本地

778
00:58:36,320 --> 00:58:40,552
uh 存储，你看到我们使用了 crud，正如我在上一章中提到的，我

779
00:58:40,552 --> 00:58:43,440
真的很想向你介绍 Crowd，因为它

780
00:58:43,440 --> 00:58:46,719
是软件开发的一个重要部分，你

781
00:58:46,719 --> 00:58:52,552
迟早需要在本地使用 Crowd Storage 你的计算机在你的应用程序上，

782
00:58:52,552 --> 00:58:55,440
嗯，这基本上是故意完成的

783
00:58:55,440 --> 00:58:59,119
，所以我们首先讨论了本地存储，然后我们离开了

784
00:58:59,119 --> 00:59:03,192
它，仅仅是因为呃，甚至

785
00:59:03,192 --> 00:59:08,400
firebase 本身也是某种杂乱无章的存储，而不是 有些是粗制滥造的，但它

786
00:59:08,400 --> 00:59:12,400
存储在云中，

787
00:59:12,400 --> 00:59:16,960
如果我没有首先在本地实现它们，那么我向您解释作物的概念会更加困难，

788
00:59:16,960 --> 00:59:19,512
所以

789
00:59:19,512 --> 00:59:25,599
在上一章中我们准备了我们的服务 我们将代码带到

790
00:59:25,599 --> 00:59:29,512
这里，这样我们就可以看看我们实际上称之为它让我们看看

791
00:59:29,512 --> 00:59:34,159
它在我们的服务云中我们称之为firebase云存储

792
00:59:34,159 --> 00:59:38,480
就在这里，我们还谈到了我们如何

793
00:59:38,480 --> 00:59:42,400
基本上开始集成到这个firebase云搜索中 在我们的

794
00:59:42,400 --> 00:59:44,871
应用程序中，这是我们

795
00:59:44,871 --> 00:59:49,831
要让这些计划具体化

796
00:59:57,920 --> 01:00:01,119
的章节 源头上的东西，我的意思是现在我们想要摆脱

797
01:00:01,119 --> 01:00:06,320
我们的本地 crud 存储，我喜欢做的策略是去

798
01:00:06,320 --> 01:00:10,320
呃应用程序，或者注释掉

799
01:00:10,320 --> 01:00:13,599
必须做的整段代码 与我们不 服务和人群异常

800
01:00:13,599 --> 01:00:16,480
，或者我们完全删除它，或者我们

801
01:00:16,480 --> 01:00:21,360
注释掉了，所以让我们继续处理这个问题，

802
01:00:21,360 --> 01:00:26,000
所以我要在这里稍微改变一下屏幕布局，然后我会

803
01:00:26,000 --> 01:00:30,960
进入我们的笔记 服务，所以请转到注释服务并选择此处的整个

804
01:00:30,960 --> 01:00:37,440
代码并将其注释掉，以便用于注释服务，然后

805
01:00:37,440 --> 01:00:40,800
我们还将转到我们的我要保存此文件，然后我们

806
01:00:40,800 --> 01:00:46,079
要 去人群例外选择整个内容并评论它

807
01:00:46,079 --> 01:00:49,360
，这就是我们需要注意的另一件事

808
01:00:49,360 --> 01:00:56,719
是在我们新的firebase云存储里面呃得到的笔记

809
01:00:56,719 --> 01:01:00,800
我们忘记做的是我实际上没有做的地方 忘记做我故意把

810
01:01:00,800 --> 01:01:05,920
它留成这样，这样我们就可以得到基本的想法，就像你在这里看到的那样，

811
01:01:05,920 --> 01:01:10,231
我们在这个 uh get notes 函数中，因为标题在

812
01:01:10,231 --> 01:01:14,400
屏幕底部表明我们正在返回我们的云实例 节点使用它的

813
01:01:14,400 --> 01:01:18,719
构造函数但是它的默认构造函数 如果你还记得这个云

814
01:01:18,719 --> 01:01:23,280
节点快照，我们有一个方便的构造函数，它可以

815
01:01:23,280 --> 01:01:28,480
使用文档快照创建我们的云节点的实例，这

816
01:01:28,480 --> 01:01:32,320
正是我们在这里得到的，你会看到查询文档快照，但我们没有使用

817
01:01:32,320 --> 01:01:36,480
那个方便的构造函数 这正是我们现在要解决的问题，

818
01:01:36,480 --> 01:01:40,079
所以对不起，

819
01:01:40,079 --> 01:01:46,639
让我们进入我们有扩展坞的地方，我将把这段代码

820
01:01:46,639 --> 01:01:51,512
从正常功能更改为错误功能，然后在这里我 会说

821
01:01:51,512 --> 01:01:58,552
我们从那个码头的快照返回一个云节点好吧就像

822
01:01:58,552 --> 01:02:03,039
我按 s 保存这个文件命令抱歉，你也可以在最后删除那个逗号

823
01:02:03,039 --> 01:02:06,719
所以你可以像这样在最后留下一个逗号所以它

824
01:02:06,719 --> 01:02:10,231
变成多行，或者你像我在这里做的那样删除逗号，它就

825
01:02:10,231 --> 01:02:16,480
变成一行好了

826
01:02:16,480 --> 01:02:19,599
，这部分已经完成了，

827
01:02:19,599 --> 01:02:26,159
现在我们需要做的是进入这个

828
01:02:26,159 --> 01:02:29,280
Firebase 云存储，你可以在

829
01:02:29,280 --> 01:02:33,119
里面看到 功能呃抱歉里面的创建新节点 当我们

830
01:02:33,119 --> 01:02:37,831
说 void 所以我们没有返回我们实际创建的节点并且我们

831
01:02:37,831 --> 01:02:42,079
需要修复这个问题所以我们需要实际创建新的新

832
01:02:42,079 --> 01:02:46,159
节点并返回它所以让我们进入这里，我只是 要说最终

833
01:02:46,159 --> 01:02:49,440
使代码更大一点最终

834
01:02:49,440 --> 01:02:54,159
文档等于对此的权重

835
01:02:54,159 --> 01:02:59,280
，如果您现在查看文档，您可以看到它实际上是一个文档，您现在可能看不到它，

836
01:02:59,280 --> 01:03:02,320
您可能可以看到它 它是一个文档

837
01:03:02,320 --> 01:03:06,871
引用，好吧，所以它是一个引用，因为它的名称表明它不是

838
01:03:06,871 --> 01:03:12,871
快照为了获取快照我们需要在其上发出 get 函数

839
01:03:12,871 --> 01:03:18,000
所以我们只是说最终获取的注释是

840
01:03:18,000 --> 01:03:23,192
等待这个文档获取并且你 '现在会看到 fetch note 是

841
01:03:23,192 --> 01:03:28,159
包含该文档数据的实际快照，

842
01:03:28,159 --> 01:03:32,079
所以在这里我们将只返回一个

843
01:03:32,079 --> 01:03:35,192
像这样

844
01:03:35,192 --> 01:03:39,440
的云节点，或者让我们看看带有这些参数的云节点，

845
01:03:39,440 --> 01:03:43,039
文档 id 将是获取的注释

846
01:03:43,039 --> 01:03:46,719
id 所有者用户用户 id 已经提供给

847
01:03:46,719 --> 01:03:51,192
我们的函数并且 t  ext 将像这样为空，

848
01:03:51,192 --> 01:03:57,192
并确保 uh 在这里我们不会返回 void，除非我们返回云节点的未来，

849
01:03:57,192 --> 01:04:00,159
好吧，然后

850
01:04:00,159 --> 01:04:06,480
保存你的文件，这部分也完成了，

851
01:04:06,480 --> 01:04:08,639
嗯，

852
01:04:08,639 --> 01:04:11,920
现在我们需要制作 当然，我只是

853
01:04:11,920 --> 01:04:16,800
要关闭所有这些选项卡，正如标题所示，我们将进入我们的

854
01:04:16,800 --> 01:04:20,871
创建更新注释视图并修复它，以便它可以

855
01:04:20,871 --> 01:04:26,000
与我们的新服务对话，我认为我们称之为云 Firebase 存储

856
01:04:26,000 --> 01:04:28,960
它firebase云存储对此感到抱歉，

857
01:04:28,960 --> 01:04:32,871
所以我将在mac上的visual studio代码中按命令p或控制p

858
01:04:32,871 --> 01:04:38,719
和linux和windows，然后只说创建它所谓的

859
01:04:38,719 --> 01:04:44,320
创建更新节点视图好的，这里的标题表明我们

860
01:04:44,320 --> 01:04:49,039
需要 导入我们的云节点 dart

861
01:04:49,039 --> 01:04:53,039
文件云存储异常暗文件和 firebase 云存储 dart

862
01:04:53,039 --> 01:04:56,719
文件的三个东西，所以这些文件目前在 um 中，

863
01:04:56,719 --> 01:05:01,039
让我们看看它们在服务云文件夹中，

864
01:05:01,039 --> 01:05:05,039
所以我要进去 '我只想说导入包我的节点和

865
01:05:05,039 --> 01:05:09,440
然后服务云，

866
01:05:09,440 --> 01:05:12,800
所以我们有第一个云节点，所以让我们导入，

867
01:05:12,800 --> 01:05:17,512
我将复制此路径，然后再次使用它来导入云存储

868
01:05:17,512 --> 01:05:22,159
异常，然后我们还需要云

869
01:05:22,159 --> 01:05:26,800
，它叫什么 firebase 云存储，就是

870
01:05:26,800 --> 01:05:30,552
这样 如果您还没有将应用程序称为我的笔记，则还需要执行这三个导入，

871
01:05:30,552 --> 01:05:33,760
那么这个包将有所不同，它将被打

872
01:05:33,760 --> 01:05:41,920
包您的应用程序的名称，然后是服务等等等，好吧好吧

873
01:05:41,920 --> 01:05:44,552
，我

874
01:05:44,552 --> 01:05:48,800
们拥有的下一件事 正如您在此处的标题中看到的那样，

875
01:05:48,800 --> 01:05:53,440
我们需要确保我们的创建更新节点视图状态就

876
01:05:53,440 --> 01:05:57,760
在此处，该状态目前包含我们的节点服务作为其节点服务，它必须

877
01:05:57,760 --> 01:06:01,920
转向使用 Firebase 云存储，

878
01:06:01,920 --> 01:06:04,871
所以我 '我也会在这里查看我的笔记，以确保我给你

879
01:06:04,871 --> 01:06:09,280
提供了你需要的所有信息，所以让我们在这里更改我们的节点服务

880
01:06:09,280 --> 01:06:15,039
，现在将其称为 firebase 云存储，这就是服务还可以

881
01:06:15,039 --> 01:06:20,871
，在你的 初始化函数 然后，您还需要确保我们

882
01:06:20,871 --> 01:06:25,679
在 init 状态函数中获得了我们的 firebase 云存储的单例实例，

883
01:06:25,679 --> 01:06:29,360
还记得这个注释现在不再是

884
01:06:29,360 --> 01:06:33,679
数据库注释，但它实际上是一个云节点，所以我们称该云

885
01:06:33,679 --> 01:06:38,400
节点为 好吧，现在我们可以看到这里有一个未使用的

886
01:06:38,400 --> 01:06:42,320
导入，所以我将删除它，因为我们不需要那个

887
01:06:42,320 --> 01:06:46,960
未使用的导入，那么接下来我们需要做的就是

888
01:06:46,960 --> 01:06:50,552
作为标题，以防我们 必须去创建或获取现有节点，我们

889
01:06:50,552 --> 01:06:55,760
必须确保它与云存储一起工作，所以让我们在这里

890
01:06:55,760 --> 01:06:58,552
完美，所以在这里